From c3f809792187a0d74abcf416912bca84ee99eff3 Mon Sep 17 00:00:00 2001
From: Rex Lin <rex_lin@htc.com>
Date: Fri, 5 Mar 2010 00:10:37 +0800
Subject: [PATCH] Symptom:[HeroC] remove other project board/config files.

Bug ID:
Root Cause:
Solution:
Note:

Signed-off-by: Rex Lin <rex_lin@htc.com>
---
 arch/arm/configs/bravo_defconfig                   | 1683 ----------------
 arch/arm/configs/desirec_defconfig                 | 1596 ----------------
 arch/arm/configs/hero_defconfig                    | 1557 ---------------
 arch/arm/configs/incrediblec_defconfig             | 1629 ----------------
 arch/arm/configs/msm7225_defconfig                 | 1596 ----------------
 arch/arm/configs/msm7227_defconfig                 | 1673 ----------------
 arch/arm/configs/paradise_defconfig                | 1545 ---------------
 arch/arm/configs/passionc_defconfig                | 1644 ----------------
 arch/arm/configs/supersonic_defconfig              | 1637 ----------------
 arch/arm/mach-msm/Makefile                         |  106 -
 arch/arm/mach-msm/board-bahamas-keypad.c           |  140 --
 arch/arm/mach-msm/board-bahamas-mmc.c              |  473 -----
 arch/arm/mach-msm/board-bahamas-rfkill.c           |  109 --
 arch/arm/mach-msm/board-bahamas.c                  | 1115 -----------
 arch/arm/mach-msm/board-bahamas.h                  |   99 -
 arch/arm/mach-msm/board-bee-keypad.c               |  141 --
 arch/arm/mach-msm/board-bee-microp.c               |   92 -
 arch/arm/mach-msm/board-bee-mmc.c                  |  293 ---
 arch/arm/mach-msm/board-bee-panel.c                |  304 ---
 arch/arm/mach-msm/board-bee-rfkill.c               |  341 ----
 arch/arm/mach-msm/board-bee-wifi.c                 |  140 --
 arch/arm/mach-msm/board-bee.c                      | 1133 -----------
 arch/arm/mach-msm/board-bee.h                      |  121 --
 arch/arm/mach-msm/board-bravo-audio.c              |  230 ---
 arch/arm/mach-msm/board-bravo-keypad.c             |  151 --
 arch/arm/mach-msm/board-bravo-microp.c             |  224 ---
 arch/arm/mach-msm/board-bravo-mmc.c                |  346 ----
 arch/arm/mach-msm/board-bravo-rfkill.c             |  334 ----
 arch/arm/mach-msm/board-bravo-wifi.c               |  140 --
 arch/arm/mach-msm/board-bravo.c                    | 1273 -------------
 arch/arm/mach-msm/board-bravo.h                    |  162 --
 arch/arm/mach-msm/board-bravoc-audio.c             |  212 ---
 arch/arm/mach-msm/board-bravoc-keypad.c            |  168 --
 arch/arm/mach-msm/board-bravoc-microp.c            |  253 ---
 arch/arm/mach-msm/board-bravoc-mmc.c               |  303 ---
 arch/arm/mach-msm/board-bravoc-rfkill.c            |  343 ----
 arch/arm/mach-msm/board-bravoc-wifi.c              |  140 --
 arch/arm/mach-msm/board-bravoc.c                   | 1196 ------------
 arch/arm/mach-msm/board-bravoc.h                   |  154 --
 arch/arm/mach-msm/board-buzz-keypad.c              |  269 ---
 arch/arm/mach-msm/board-buzz-microp.c              |   81 -
 arch/arm/mach-msm/board-buzz-mmc.c                 |  293 ---
 arch/arm/mach-msm/board-buzz-panel.c               |  339 ----
 arch/arm/mach-msm/board-buzz-rfkill.c              |  341 ----
 arch/arm/mach-msm/board-buzz-wifi.c                |  140 --
 arch/arm/mach-msm/board-buzz.c                     |  993 ----------
 arch/arm/mach-msm/board-buzz.h                     |  117 --
 arch/arm/mach-msm/board-buzzc-keypad.c             |  259 ---
 arch/arm/mach-msm/board-buzzc-microp.c             |   81 -
 arch/arm/mach-msm/board-buzzc-mmc.c                |  293 ---
 arch/arm/mach-msm/board-buzzc-panel.c              |  344 ----
 arch/arm/mach-msm/board-buzzc-rfkill.c             |  341 ----
 arch/arm/mach-msm/board-buzzc-wifi.c               |  140 --
 arch/arm/mach-msm/board-buzzc.c                    |  882 ---------
 arch/arm/mach-msm/board-buzzc.h                    |  114 --
 arch/arm/mach-msm/board-click-panel.c              |  686 -------
 arch/arm/mach-msm/board-desirec-camsensor.c        | 1871 ------------------
 arch/arm/mach-msm/board-desirec-camsensor.h        |   40 -
 arch/arm/mach-msm/board-desirec-keypad.c           |  322 ----
 arch/arm/mach-msm/board-desirec-mmc.c              |  351 ----
 arch/arm/mach-msm/board-desirec-panel.c            |  266 ---
 arch/arm/mach-msm/board-desirec-rfkill.c           |  219 ---
 arch/arm/mach-msm/board-desirec-wifi.c             |  104 -
 arch/arm/mach-msm/board-desirec.c                  | 1222 ------------
 arch/arm/mach-msm/board-desirec.h                  |  136 --
 arch/arm/mach-msm/board-firestone-keypad.c         |   97 -
 arch/arm/mach-msm/board-firestone-mmc.c            |  412 ----
 arch/arm/mach-msm/board-firestone-panel.c          |  304 ---
 arch/arm/mach-msm/board-firestone-rfkill.c         |  108 --
 arch/arm/mach-msm/board-firestone.c                |  364 ----
 arch/arm/mach-msm/board-firestone.h                |   65 -
 arch/arm/mach-msm/board-hero-keypad.c              |  321 ----
 arch/arm/mach-msm/board-hero-mmc.c                 |  359 ----
 arch/arm/mach-msm/board-hero-panel.c               |  745 --------
 arch/arm/mach-msm/board-hero-rfkill.c              |  219 ---
 arch/arm/mach-msm/board-hero-wifi.c                |  104 -
 arch/arm/mach-msm/board-hero.c                     | 1257 ------------
 arch/arm/mach-msm/board-hero.h                     |  117 --
 arch/arm/mach-msm/board-incredible-audio.c         |  194 --
 arch/arm/mach-msm/board-incredible-keypad.c        |   79 -
 arch/arm/mach-msm/board-incredible-mmc.c           |  288 ---
 arch/arm/mach-msm/board-incredible-panel.c         |  671 -------
 arch/arm/mach-msm/board-incredible-rfkill.c        |  343 ----
 arch/arm/mach-msm/board-incredible.c               |  942 ---------
 arch/arm/mach-msm/board-incredible.h               |  102 -
 arch/arm/mach-msm/board-incrediblec-audio.c        |  294 ---
 arch/arm/mach-msm/board-incrediblec-keypad.c       |  136 --
 arch/arm/mach-msm/board-incrediblec-microp.c       |  633 ------
 arch/arm/mach-msm/board-incrediblec-mmc.c          |  315 ---
 arch/arm/mach-msm/board-incrediblec-rfkill.c       |  333 ----
 arch/arm/mach-msm/board-incrediblec-tv.c           |  125 --
 arch/arm/mach-msm/board-incrediblec-wifi.c         |  140 --
 arch/arm/mach-msm/board-incrediblec.c              | 1606 ----------------
 arch/arm/mach-msm/board-incrediblec.h              |  191 --
 arch/arm/mach-msm/board-latte-keypad.c             |  354 ----
 arch/arm/mach-msm/board-latte-microp.c             |  172 --
 arch/arm/mach-msm/board-latte-mmc.c                |  401 ----
 arch/arm/mach-msm/board-latte-panel.c              |  297 ---
 arch/arm/mach-msm/board-latte-rfkill.c             |  316 ---
 arch/arm/mach-msm/board-latte-wifi.c               |   60 -
 arch/arm/mach-msm/board-latte.c                    | 1005 ----------
 arch/arm/mach-msm/board-latte.h                    |  138 --
 arch/arm/mach-msm/board-legend-keypad.c            |  174 --
 arch/arm/mach-msm/board-legend-microp.c            |  183 --
 arch/arm/mach-msm/board-legend-mmc.c               |  388 ----
 arch/arm/mach-msm/board-legend-panel.c             | 1153 -----------
 arch/arm/mach-msm/board-legend-rfkill.c            |  316 ---
 arch/arm/mach-msm/board-legend-wifi.c              |   60 -
 arch/arm/mach-msm/board-legend.c                   | 1064 -----------
 arch/arm/mach-msm/board-legend.h                   |  142 --
 arch/arm/mach-msm/board-liberty-keypad.c           |  177 --
 arch/arm/mach-msm/board-liberty-microp.c           |  173 --
 arch/arm/mach-msm/board-liberty-mmc.c              |  315 ---
 arch/arm/mach-msm/board-liberty-panel.c            |  266 ---
 arch/arm/mach-msm/board-liberty-rfkill.c           |  339 ----
 arch/arm/mach-msm/board-liberty-wifi.c             |  140 --
 arch/arm/mach-msm/board-liberty.c                  | 1131 -----------
 arch/arm/mach-msm/board-liberty.h                  |  151 --
 arch/arm/mach-msm/board-mahimahi-audio.c           |  193 --
 arch/arm/mach-msm/board-mahimahi-flashlight.c      |  278 ---
 arch/arm/mach-msm/board-mahimahi-keypad.c          |  224 ---
 arch/arm/mach-msm/board-mahimahi-microp.c          | 1824 ------------------
 arch/arm/mach-msm/board-mahimahi-mmc.c             |  407 ----
 arch/arm/mach-msm/board-mahimahi-panel.c           |  584 ------
 arch/arm/mach-msm/board-mahimahi-rfkill.c          |  117 --
 arch/arm/mach-msm/board-mahimahi-wifi.c            |  140 --
 arch/arm/mach-msm/board-mahimahi.c                 |  811 --------
 arch/arm/mach-msm/board-mahimahi.h                 |  114 --
 arch/arm/mach-msm/board-orca-audio.c               |  211 --
 arch/arm/mach-msm/board-orca-keypad.c              |  117 --
 arch/arm/mach-msm/board-orca-microp.c              |  250 ---
 arch/arm/mach-msm/board-orca-mmc.c                 |  288 ---
 arch/arm/mach-msm/board-orca-panel.c               |  692 -------
 arch/arm/mach-msm/board-orca-rfkill.c              |  343 ----
 arch/arm/mach-msm/board-orca-wifi.c                |  140 --
 arch/arm/mach-msm/board-orca.c                     | 1239 ------------
 arch/arm/mach-msm/board-orca.h                     |  135 --
 arch/arm/mach-msm/board-paradise-keypad.c          |  234 ---
 arch/arm/mach-msm/board-paradise-microp.c          |  165 --
 arch/arm/mach-msm/board-paradise-mmc.c             |  293 ---
 arch/arm/mach-msm/board-paradise-panel.c           |  317 ---
 arch/arm/mach-msm/board-paradise-rfkill.c          |  339 ----
 arch/arm/mach-msm/board-paradise-wifi.c            |  140 --
 arch/arm/mach-msm/board-paradise.c                 | 1018 ----------
 arch/arm/mach-msm/board-paradise.h                 |  120 --
 arch/arm/mach-msm/board-passionc-audio.c           |  258 ---
 arch/arm/mach-msm/board-passionc-keypad.c          |  278 ---
 arch/arm/mach-msm/board-passionc-microp.c          |  242 ---
 arch/arm/mach-msm/board-passionc-mmc.c             |  303 ---
 arch/arm/mach-msm/board-passionc-rfkill.c          |  343 ----
 arch/arm/mach-msm/board-passionc-wifi.c            |  140 --
 arch/arm/mach-msm/board-passionc.c                 | 1283 -------------
 arch/arm/mach-msm/board-passionc.h                 |  173 --
 arch/arm/mach-msm/board-sapphire-gpio.c            |  381 ----
 arch/arm/mach-msm/board-sapphire-h2w.c             |  545 ------
 arch/arm/mach-msm/board-sapphire-keypad.c          |  130 --
 arch/arm/mach-msm/board-sapphire-mmc.c             |  469 -----
 arch/arm/mach-msm/board-sapphire-panel.c           | 1376 --------------
 arch/arm/mach-msm/board-sapphire-rfkill.c          |  111 --
 arch/arm/mach-msm/board-sapphire-wifi.c            |   74 -
 arch/arm/mach-msm/board-sapphire.c                 | 1259 ------------
 arch/arm/mach-msm/board-sapphire.h                 |  266 ---
 arch/arm/mach-msm/board-supersonic-audio.c         |  320 ----
 arch/arm/mach-msm/board-supersonic-keypad.c        |   96 -
 arch/arm/mach-msm/board-supersonic-microp.c        |  446 -----
 arch/arm/mach-msm/board-supersonic-mmc.c           |  455 -----
 arch/arm/mach-msm/board-supersonic-panel.c         |  488 -----
 arch/arm/mach-msm/board-supersonic-rfkill.c        |  218 ---
 arch/arm/mach-msm/board-supersonic-wifi.c          |  140 --
 arch/arm/mach-msm/board-supersonic.c               | 1540 ---------------
 arch/arm/mach-msm/board-supersonic.h               |  195 --
 arch/arm/mach-msm/board-swordfish-keypad.c         |  177 --
 arch/arm/mach-msm/board-swordfish-mmc.c            |  265 ---
 arch/arm/mach-msm/board-swordfish-panel.c          |  116 --
 arch/arm/mach-msm/board-swordfish.c                |  337 ----
 arch/arm/mach-msm/board-swordfish.h                |   48 -
 arch/arm/mach-msm/board-trout-gpio.c               |  305 ---
 arch/arm/mach-msm/board-trout-keypad.c             |  345 ----
 arch/arm/mach-msm/board-trout-mmc.c                |  440 -----
 arch/arm/mach-msm/board-trout-panel.c              |  642 -------
 arch/arm/mach-msm/board-trout-rfkill.c             |  106 -
 arch/arm/mach-msm/board-trout-wifi.c               |   74 -
 arch/arm/mach-msm/board-trout.c                    |  870 ---------
 arch/arm/mach-msm/board-trout.h                    |  162 --
 arch/arm/mach-msm/qdsp6/Makefile                   |   11 -
 arch/arm/mach-msm/qdsp6/aac_in.c                   |  217 ---
 arch/arm/mach-msm/qdsp6/analog_audio.c             |   67 -
 arch/arm/mach-msm/qdsp6/audio_ctl.c                |  242 ---
 arch/arm/mach-msm/qdsp6/dal.c                      |  599 ------
 arch/arm/mach-msm/qdsp6/dal.h                      |   65 -
 arch/arm/mach-msm/qdsp6/dal_acdb.h                 |   84 -
 arch/arm/mach-msm/qdsp6/dal_adie.h                 |  108 --
 arch/arm/mach-msm/qdsp6/dal_audio.h                |  606 ------
 arch/arm/mach-msm/qdsp6/dal_audio_format.h         |  285 ---
 arch/arm/mach-msm/qdsp6/mp3.c                      |  229 ---
 arch/arm/mach-msm/qdsp6/msm8k_aac.c                |  579 ------
 arch/arm/mach-msm/qdsp6/msm8k_aac_in.c             |  306 ---
 arch/arm/mach-msm/qdsp6/msm8k_amrnb.c              |  326 ----
 arch/arm/mach-msm/qdsp6/msm8k_amrnb_in.c           |  299 ---
 arch/arm/mach-msm/qdsp6/msm8k_ard.c                | 1505 ---------------
 arch/arm/mach-msm/qdsp6/msm8k_ard_acdb.c           |  342 ----
 arch/arm/mach-msm/qdsp6/msm8k_ard_adie.c           |  697 -------
 arch/arm/mach-msm/qdsp6/msm8k_ard_clk.c            |  360 ----
 arch/arm/mach-msm/qdsp6/msm8k_ard_helper.c         |  237 ---
 arch/arm/mach-msm/qdsp6/msm8k_ard_q6.c             |  521 -----
 arch/arm/mach-msm/qdsp6/msm8k_audio_dev_ctrl.c     |  551 ------
 arch/arm/mach-msm/qdsp6/msm8k_cad.c                |  572 ------
 arch/arm/mach-msm/qdsp6/msm8k_cad_q6dec_drv.c      |  245 ---
 arch/arm/mach-msm/qdsp6/msm8k_cad_q6dec_session.c  |  611 ------
 arch/arm/mach-msm/qdsp6/msm8k_cad_q6dtmf_drv.c     |  237 ---
 arch/arm/mach-msm/qdsp6/msm8k_cad_q6dtmf_session.c |  128 --
 arch/arm/mach-msm/qdsp6/msm8k_cad_q6enc_drv.c      |  242 ---
 arch/arm/mach-msm/qdsp6/msm8k_cad_q6enc_session.c  |  562 ------
 arch/arm/mach-msm/qdsp6/msm8k_cad_q6equalizer.c    |  268 ---
 arch/arm/mach-msm/qdsp6/msm8k_cad_rpc.c            |  487 -----
 arch/arm/mach-msm/qdsp6/msm8k_cad_volume.c         |  977 ----------
 arch/arm/mach-msm/qdsp6/msm8k_dtmf.c               |  267 ---
 arch/arm/mach-msm/qdsp6/msm8k_htc_fm.c             |  220 ---
 arch/arm/mach-msm/qdsp6/msm8k_mp3.c                |  425 -----
 arch/arm/mach-msm/qdsp6/msm8k_pcm.c                |  427 -----
 arch/arm/mach-msm/qdsp6/msm8k_pcm_in.c             |  383 ----
 arch/arm/mach-msm/qdsp6/msm8k_q6_api_flip_utils.c  | 1342 -------------
 arch/arm/mach-msm/qdsp6/msm8k_voice.c              |  353 ----
 arch/arm/mach-msm/qdsp6/msm_q6vdec.c               |  940 ---------
 arch/arm/mach-msm/qdsp6/msm_q6venc.c               |  637 -------
 arch/arm/mach-msm/qdsp6/pcm_in.c                   |  205 --
 arch/arm/mach-msm/qdsp6/pcm_out.c                  |  228 ---
 arch/arm/mach-msm/qdsp6/q6audio.c                  | 2003 --------------------
 arch/arm/mach-msm/qdsp6/q6audio_devices.h          |  265 ---
 arch/arm/mach-msm/qdsp6/qcelp_in.c                 |  212 ---
 arch/arm/mach-msm/qdsp6/routing.c                  |   71 -
 231 files changed, 0 insertions(+), 101511 deletions(-)
 delete mode 100755 arch/arm/configs/bravo_defconfig
 delete mode 100644 arch/arm/configs/desirec_defconfig
 delete mode 100644 arch/arm/configs/hero_defconfig
 mode change 100755 => 100644 arch/arm/configs/heroc_defconfig
 delete mode 100755 arch/arm/configs/incrediblec_defconfig
 delete mode 100644 arch/arm/configs/msm7225_defconfig
 delete mode 100644 arch/arm/configs/msm7227_defconfig
 delete mode 100644 arch/arm/configs/paradise_defconfig
 delete mode 100755 arch/arm/configs/passionc_defconfig
 delete mode 100644 arch/arm/configs/supersonic_defconfig
 delete mode 100644 arch/arm/mach-msm/board-bahamas-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-bahamas-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-bahamas-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-bahamas.c
 delete mode 100644 arch/arm/mach-msm/board-bahamas.h
 delete mode 100644 arch/arm/mach-msm/board-bee-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-bee-microp.c
 delete mode 100644 arch/arm/mach-msm/board-bee-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-bee-panel.c
 delete mode 100644 arch/arm/mach-msm/board-bee-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-bee-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-bee.c
 delete mode 100644 arch/arm/mach-msm/board-bee.h
 delete mode 100644 arch/arm/mach-msm/board-bravo-audio.c
 delete mode 100644 arch/arm/mach-msm/board-bravo-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-bravo-microp.c
 delete mode 100644 arch/arm/mach-msm/board-bravo-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-bravo-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-bravo-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-bravo.c
 delete mode 100644 arch/arm/mach-msm/board-bravo.h
 delete mode 100644 arch/arm/mach-msm/board-bravoc-audio.c
 delete mode 100644 arch/arm/mach-msm/board-bravoc-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-bravoc-microp.c
 delete mode 100644 arch/arm/mach-msm/board-bravoc-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-bravoc-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-bravoc-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-bravoc.c
 delete mode 100644 arch/arm/mach-msm/board-bravoc.h
 delete mode 100644 arch/arm/mach-msm/board-buzz-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-buzz-microp.c
 delete mode 100644 arch/arm/mach-msm/board-buzz-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-buzz-panel.c
 delete mode 100644 arch/arm/mach-msm/board-buzz-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-buzz-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-buzz.c
 delete mode 100644 arch/arm/mach-msm/board-buzz.h
 delete mode 100644 arch/arm/mach-msm/board-buzzc-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-buzzc-microp.c
 delete mode 100644 arch/arm/mach-msm/board-buzzc-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-buzzc-panel.c
 delete mode 100644 arch/arm/mach-msm/board-buzzc-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-buzzc-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-buzzc.c
 delete mode 100644 arch/arm/mach-msm/board-buzzc.h
 delete mode 100644 arch/arm/mach-msm/board-click-panel.c
 delete mode 100644 arch/arm/mach-msm/board-desirec-camsensor.c
 delete mode 100644 arch/arm/mach-msm/board-desirec-camsensor.h
 delete mode 100644 arch/arm/mach-msm/board-desirec-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-desirec-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-desirec-panel.c
 delete mode 100644 arch/arm/mach-msm/board-desirec-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-desirec-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-desirec.c
 delete mode 100644 arch/arm/mach-msm/board-desirec.h
 delete mode 100644 arch/arm/mach-msm/board-firestone-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-firestone-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-firestone-panel.c
 delete mode 100644 arch/arm/mach-msm/board-firestone-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-firestone.c
 delete mode 100644 arch/arm/mach-msm/board-firestone.h
 delete mode 100644 arch/arm/mach-msm/board-hero-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-hero-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-hero-panel.c
 delete mode 100644 arch/arm/mach-msm/board-hero-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-hero-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-hero.c
 delete mode 100644 arch/arm/mach-msm/board-hero.h
 delete mode 100644 arch/arm/mach-msm/board-incredible-audio.c
 delete mode 100644 arch/arm/mach-msm/board-incredible-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-incredible-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-incredible-panel.c
 delete mode 100644 arch/arm/mach-msm/board-incredible-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-incredible.c
 delete mode 100644 arch/arm/mach-msm/board-incredible.h
 delete mode 100644 arch/arm/mach-msm/board-incrediblec-audio.c
 delete mode 100644 arch/arm/mach-msm/board-incrediblec-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-incrediblec-microp.c
 delete mode 100644 arch/arm/mach-msm/board-incrediblec-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-incrediblec-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-incrediblec-tv.c
 delete mode 100644 arch/arm/mach-msm/board-incrediblec-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-incrediblec.c
 delete mode 100644 arch/arm/mach-msm/board-incrediblec.h
 delete mode 100644 arch/arm/mach-msm/board-latte-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-latte-microp.c
 delete mode 100755 arch/arm/mach-msm/board-latte-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-latte-panel.c
 delete mode 100644 arch/arm/mach-msm/board-latte-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-latte-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-latte.c
 delete mode 100644 arch/arm/mach-msm/board-latte.h
 delete mode 100644 arch/arm/mach-msm/board-legend-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-legend-microp.c
 delete mode 100755 arch/arm/mach-msm/board-legend-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-legend-panel.c
 delete mode 100644 arch/arm/mach-msm/board-legend-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-legend-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-legend.c
 delete mode 100644 arch/arm/mach-msm/board-legend.h
 delete mode 100644 arch/arm/mach-msm/board-liberty-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-liberty-microp.c
 delete mode 100644 arch/arm/mach-msm/board-liberty-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-liberty-panel.c
 delete mode 100644 arch/arm/mach-msm/board-liberty-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-liberty-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-liberty.c
 delete mode 100644 arch/arm/mach-msm/board-liberty.h
 delete mode 100644 arch/arm/mach-msm/board-mahimahi-audio.c
 delete mode 100644 arch/arm/mach-msm/board-mahimahi-flashlight.c
 delete mode 100644 arch/arm/mach-msm/board-mahimahi-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-mahimahi-microp.c
 delete mode 100644 arch/arm/mach-msm/board-mahimahi-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-mahimahi-panel.c
 delete mode 100644 arch/arm/mach-msm/board-mahimahi-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-mahimahi-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-mahimahi.c
 delete mode 100644 arch/arm/mach-msm/board-mahimahi.h
 delete mode 100644 arch/arm/mach-msm/board-orca-audio.c
 delete mode 100644 arch/arm/mach-msm/board-orca-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-orca-microp.c
 delete mode 100644 arch/arm/mach-msm/board-orca-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-orca-panel.c
 delete mode 100644 arch/arm/mach-msm/board-orca-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-orca-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-orca.c
 delete mode 100644 arch/arm/mach-msm/board-orca.h
 delete mode 100644 arch/arm/mach-msm/board-paradise-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-paradise-microp.c
 delete mode 100644 arch/arm/mach-msm/board-paradise-mmc.c
 delete mode 100755 arch/arm/mach-msm/board-paradise-panel.c
 delete mode 100755 arch/arm/mach-msm/board-paradise-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-paradise-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-paradise.c
 delete mode 100644 arch/arm/mach-msm/board-paradise.h
 delete mode 100644 arch/arm/mach-msm/board-passionc-audio.c
 delete mode 100644 arch/arm/mach-msm/board-passionc-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-passionc-microp.c
 delete mode 100644 arch/arm/mach-msm/board-passionc-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-passionc-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-passionc-wifi.c
 delete mode 100755 arch/arm/mach-msm/board-passionc.c
 delete mode 100755 arch/arm/mach-msm/board-passionc.h
 delete mode 100644 arch/arm/mach-msm/board-sapphire-gpio.c
 delete mode 100644 arch/arm/mach-msm/board-sapphire-h2w.c
 delete mode 100644 arch/arm/mach-msm/board-sapphire-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-sapphire-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-sapphire-panel.c
 delete mode 100644 arch/arm/mach-msm/board-sapphire-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-sapphire-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-sapphire.c
 delete mode 100644 arch/arm/mach-msm/board-sapphire.h
 delete mode 100644 arch/arm/mach-msm/board-supersonic-audio.c
 delete mode 100644 arch/arm/mach-msm/board-supersonic-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-supersonic-microp.c
 delete mode 100644 arch/arm/mach-msm/board-supersonic-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-supersonic-panel.c
 delete mode 100644 arch/arm/mach-msm/board-supersonic-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-supersonic-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-supersonic.c
 delete mode 100644 arch/arm/mach-msm/board-supersonic.h
 delete mode 100644 arch/arm/mach-msm/board-swordfish-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-swordfish-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-swordfish-panel.c
 delete mode 100644 arch/arm/mach-msm/board-swordfish.c
 delete mode 100644 arch/arm/mach-msm/board-swordfish.h
 delete mode 100644 arch/arm/mach-msm/board-trout-gpio.c
 delete mode 100644 arch/arm/mach-msm/board-trout-keypad.c
 delete mode 100644 arch/arm/mach-msm/board-trout-mmc.c
 delete mode 100644 arch/arm/mach-msm/board-trout-panel.c
 delete mode 100644 arch/arm/mach-msm/board-trout-rfkill.c
 delete mode 100644 arch/arm/mach-msm/board-trout-wifi.c
 delete mode 100644 arch/arm/mach-msm/board-trout.c
 delete mode 100644 arch/arm/mach-msm/board-trout.h
 delete mode 100644 arch/arm/mach-msm/qdsp6/Makefile
 delete mode 100644 arch/arm/mach-msm/qdsp6/aac_in.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/analog_audio.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/audio_ctl.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/dal.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/dal.h
 delete mode 100644 arch/arm/mach-msm/qdsp6/dal_acdb.h
 delete mode 100644 arch/arm/mach-msm/qdsp6/dal_adie.h
 delete mode 100644 arch/arm/mach-msm/qdsp6/dal_audio.h
 delete mode 100644 arch/arm/mach-msm/qdsp6/dal_audio_format.h
 delete mode 100644 arch/arm/mach-msm/qdsp6/mp3.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_aac.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_aac_in.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_amrnb.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_amrnb_in.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_ard.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_ard_acdb.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_ard_adie.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_ard_clk.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_ard_helper.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_ard_q6.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_audio_dev_ctrl.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_cad.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_cad_q6dec_drv.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_cad_q6dec_session.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_cad_q6dtmf_drv.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_cad_q6dtmf_session.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_cad_q6enc_drv.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_cad_q6enc_session.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_cad_q6equalizer.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_cad_rpc.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_cad_volume.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_dtmf.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_htc_fm.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_mp3.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_pcm.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_pcm_in.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_q6_api_flip_utils.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm8k_voice.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm_q6vdec.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/msm_q6venc.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/pcm_in.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/pcm_out.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/q6audio.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/q6audio_devices.h
 delete mode 100644 arch/arm/mach-msm/qdsp6/qcelp_in.c
 delete mode 100644 arch/arm/mach-msm/qdsp6/routing.c

diff --git a/arch/arm/configs/bravo_defconfig b/arch/arm/configs/bravo_defconfig
deleted file mode 100755
index 29e5dee..0000000
--- a/arch/arm/configs/bravo_defconfig
+++ /dev/null
@@ -1,1683 +0,0 @@
-
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29
-# Thu Oct  8 01:00:04 2009
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_CLASSIC_RCU=y
-# CONFIG_TREE_RCU is not set
-# CONFIG_PREEMPT_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_PREEMPT_RCU_TRACE is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_GROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-# CONFIG_USER_SCHED is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-# CONFIG_CGROUP_NS is not set
-CONFIG_CGROUP_FREEZER=y
-# CONFIG_CGROUP_DEVICE is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_CGROUP_MEM_RES_CTLR is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-# CONFIG_ELF_CORE is not set
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_ASHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_COMPAT_BRK=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-# CONFIG_PROFILING is not set
-CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-# CONFIG_IOSCHED_CFQ is not set
-# CONFIG_DEFAULT_AS is not set
-CONFIG_DEFAULT_DEADLINE=y
-# CONFIG_DEFAULT_CFQ is not set
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="deadline"
-CONFIG_FREEZER=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KIRKWOOD is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-# CONFIG_ARCH_LOKI is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-CONFIG_ARCH_MSM=y
-# CONFIG_ARCH_W90X900 is not set
-# CONFIG_ARCH_MSM7X00A is not set
-CONFIG_ARCH_QSD8X50=y
-CONFIG_ARCH_MSM_SCORPION=y
-CONFIG_MSM_MDP31=y
-CONFIG_MSM_AMSS_VERSION=3200
-CONFIG_MSM_AMSS_VERSION_3200=y
-# CONFIG_MSM_DEBUG_UART is not set
-CONFIG_MSM_DEBUG_UART_NONE=y
-# CONFIG_MSM_DEBUG_UART1 is not set
-# CONFIG_MSM_DEBUG_UART2 is not set
-# CONFIG_MSM_DEBUG_UART3 is not set
-
-#
-# MSM Board Type
-#
-# CONFIG_MACH_SWORDFISH is not set
-# CONFIG_MACH_FIRESTONE is not set
-# CONFIG_MACH_ORCA is not set
-CONFIG_MACH_BRAVO=y
-# CONFIG_MACH_MAHIMAHI is not set
-# CONFIG_MACH_INCREDIBLE is not set
-# CONFIG_MACH_INCREDIBLEC is not set
-CONFIG_MACH_BRAVOC=y
-# CONFIG_MACH_PASSIONC is not set
-# CONFIG_MACH_SUPERSONIC is not set
-CONFIG_HTC_HEADSET=y
-# CONFIG_HTC_AUDIOJACK is not set
-CONFIG_MICROP_COMMON=y
-CONFIG_LIGHTSENSOR_MICROP=y
-# CONFIG_TROUT_BATTCHG is not set
-CONFIG_HTC_BATTCHG=y
-CONFIG_HTC_BATTCHG_SMEM=n
-# CONFIG_HTC_PWRSINK is not set
-CONFIG_CACHE_FLUSH_RANGE_LIMIT=0x40000
-CONFIG_MSM7X00A_USE_GP_TIMER=y
-# CONFIG_MSM7X00A_USE_DG_TIMER is not set
-CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
-# CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_SLEEP_MODE=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE=1
-CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
-CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
-CONFIG_MSM7X00A_SLEEP_NO_LIMIT=y
-# CONFIG_MSM7X00A_SLEEP_LIMITED_SLEEP is not set
-# CONFIG_MSM7X00A_SLEEP_NEGATE_SLEEP is not set
-CONFIG_MSM7X00A_SLEEP_LIMIT=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_NO_LIMIT is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_LIMITED_SLEEP is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_NEGATE_SLEEP=y
-CONFIG_MSM7X00A_IDLE_SLEEP_LIMIT=2
-CONFIG_MSM_IDLE_STATS=y
-CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
-CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
-CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
-CONFIG_MSM_FIQ_SUPPORT=y
-CONFIG_MSM_SERIAL_DEBUGGER=y
-CONFIG_MSM_SMD=y
-CONFIG_MSM_N_WAY_SMD=y
-CONFIG_MSM_ONCRPCROUTER=y
-CONFIG_MSM_RPCSERVERS=y
-# CONFIG_MSM_CPU_FREQ_SCREEN is not set
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX=998400
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN=245000
-# CONFIG_MSM_HW3D is not set
-# CONFIG_MSM_ADSP is not set
-# CONFIG_HTC_ACOUSTIC is not set
-CONFIG_HTC_ACOUSTIC_QSD=y
-CONFIG_MSM_DALRPC=y
-# CONFIG_MSM_DALRPC_TEST is not set
-CONFIG_QSD_AUDIO=y
-CONFIG_QSD_HTC_FM=y
-CONFIG_ARCH_MSM_FLASHLIGHT=y
-CONFIG_WIFI_NVS_PROC_CREATE=y
-CONFIG_WIFI_CONTROL_FUNC=y
-CONFIG_WIFI_MEM_PREALLOC=n
-CONFIG_BUILD_OMA_DM=y
-CONFIG_SMD_OFFSET_TCXO_STAT=0xFC2A0
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_32v6K=y
-CONFIG_CPU_V7=y
-CONFIG_CPU_32v7=y
-CONFIG_CPU_ABRT_EV7=y
-CONFIG_CPU_PABRT_IFAR=y
-CONFIG_CPU_CACHE_V7=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V7=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-CONFIG_ARM_THUMBEE=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-CONFIG_HAS_TLS_REG=y
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_1G is not set
-CONFIG_PAGE_OFFSET=0xC0000000
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-CONFIG_ARCH_FLATMEM_HAS_HOLES=y
-# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
-# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=0
-CONFIG_VIRT_TO_BUS=y
-CONFIG_UNEVICTABLE_LRU=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="mem=64M console=ttyMSM,115200n8"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# CPU Power Management
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-# CONFIG_CPU_FREQ_DEBUG is not set
-CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_STAT_DETAILS=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_MIN_TICKS=2
-CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
-# CONFIG_CPU_IDLE is not set
-CONFIG_PERFLOCK=y
-CONFIG_PERFLOCK_BOOT_LOCK=y
-# CONFIG_PERFLOCK_SCREEN_POLICY is not set
-# CONFIG_PERFLOCK_SCREEN_ON_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_ON_MAX is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MAX is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-CONFIG_VFP=y
-CONFIG_VFPv3=y
-CONFIG_NEON=y
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_HAVE_AOUT=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-CONFIG_HAS_WAKELOCK=y
-CONFIG_HAS_EARLYSUSPEND=y
-CONFIG_WAKELOCK=y
-CONFIG_WAKELOCK_STAT=y
-CONFIG_USER_WAKELOCK=y
-CONFIG_EARLYSUSPEND=y
-# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
-# CONFIG_CONSOLE_EARLYSUSPEND is not set
-CONFIG_FB_EARLYSUSPEND=y
-# CONFIG_APM_EMULATION is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_COMPAT_NET_DEV_OPS=y
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-CONFIG_NET_KEY=y
-# CONFIG_NET_KEY_MIGRATE is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_ASK_IP_FIB_HASH=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_VERBOSE=y
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-CONFIG_INET_ESP=y
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-CONFIG_XFRM_IPCOMP=y
-CONFIG_IPV6=y
-CONFIG_IPV6_PRIVACY=y
-CONFIG_IPV6_ROUTER_PREF=y
-CONFIG_IPV6_ROUTE_INFO=y
-CONFIG_IPV6_OPTIMISTIC_DAD=y
-CONFIG_INET6_AH=y
-CONFIG_INET6_ESP=y
-CONFIG_INET6_IPCOMP=y
-CONFIG_IPV6_MIP6=y
-CONFIG_INET6_XFRM_TUNNEL=y
-CONFIG_INET6_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_TRANSPORT=y
-CONFIG_INET6_XFRM_MODE_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_BEET=y
-CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=y
-CONFIG_IPV6_SIT=y
-CONFIG_IPV6_NDISC_NODETYPE=y
-CONFIG_IPV6_TUNNEL=y
-CONFIG_IPV6_MULTIPLE_TABLES=y
-CONFIG_IPV6_SUBTREES=y
-CONFIG_IPV6_MROUTE=y
-CONFIG_IPV6_PIMSM_V2=y
-CONFIG_NETFILTER_XT_TARGET_DSCP=y
-CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=y
-CONFIG_NF_CONNTRACK_IPV6=y
-CONFIG_IP6_NF_QUEUE=y
-CONFIG_IP6_NF_IPTABLES=y
-CONFIG_IP6_NF_MATCH_AH=y
-CONFIG_IP6_NF_MATCH_EUI64=y
-CONFIG_IP6_NF_MATCH_FRAG=y
-CONFIG_IP6_NF_MATCH_OPTS=y
-CONFIG_IP6_NF_MATCH_HL=y
-CONFIG_IP6_NF_MATCH_IPV6HEADER=y
-CONFIG_IP6_NF_MATCH_MH=y
-CONFIG_IP6_NF_MATCH_RT=y
-CONFIG_IP6_NF_TARGET_LOG=y
-CONFIG_IP6_NF_FILTER=y
-CONFIG_IP6_NF_TARGET_REJECT=y
-CONFIG_IP6_NF_MANGLE=y
-CONFIG_IP6_NF_TARGET_HL=y
-CONFIG_IP6_NF_RAW=y
-CONFIG_ANDROID_PARANOID_NETWORK=y
-# CONFIG_NETWORK_SECMARK is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_NETFILTER_ADVANCED=y
-
-#
-# Core Netfilter Configuration
-#
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_NETLINK_LOG is not set
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CT_ACCT=y
-CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-CONFIG_NF_CONNTRACK_FTP=y
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_PPTP is not set
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CT_NETLINK is not set
-CONFIG_NETFILTER_XTABLES=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_DCCP=y
-CONFIG_NETFILTER_XT_MATCH_DSCP=y
-CONFIG_NETFILTER_XT_MATCH_ESP=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-CONFIG_NETFILTER_XT_MATCH_REALM=y
-CONFIG_NETFILTER_XT_MATCH_SCTP=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_NF_CONNTRACK_PROC_COMPAT=y
-# CONFIG_IP_NF_QUEUE is not set
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_RECENT=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_MATCH_ADDRTYPE=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_LOG=y
-# CONFIG_IP_NF_TARGET_ULOG is not set
-CONFIG_NF_NAT=y
-CONFIG_NF_NAT_NEEDED=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-CONFIG_NF_NAT_FTP=y
-# CONFIG_NF_NAT_IRC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_NAT_AMANDA is not set
-# CONFIG_NF_NAT_PPTP is not set
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_IP_NF_MANGLE is not set
-CONFIG_IP_NF_RAW=y
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-# CONFIG_DCB is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-CONFIG_BT=y
-CONFIG_BT_L2CAP=y
-CONFIG_BT_SCO=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-# CONFIG_BT_BNEP_MC_FILTER is not set
-# CONFIG_BT_BNEP_PROTO_FILTER is not set
-CONFIG_BT_HIDP=y
-
-#
-# Bluetooth device drivers
-#
-# CONFIG_BT_HCIBTSDIO is not set
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_BCSP is not set
-CONFIG_BT_HCIUART_LL=y
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_PHONET is not set
-CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
-CONFIG_WIRELESS_OLD_REGULATORY=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WIRELESS_EXT_SYSFS=y
-# CONFIG_LIB80211 is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_WIMAX is not set
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_PM is not set
-# CONFIG_RFKILL_INPUT is not set
-CONFIG_RFKILL_LEDS=y
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH=""
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_EXTRA_FIRMWARE=""
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-CONFIG_MTD_MSM_NAND=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-CONFIG_MISC_DEVICES=y
-CONFIG_ANDROID_PMEM=y
-# CONFIG_ICS932S401 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-CONFIG_KERNEL_DEBUGGER_CORE=y
-CONFIG_UID_STAT=y
-CONFIG_SENSORS_BMA150_SPI=y
-# CONFIG_WL127X_RFKILL is not set
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_93CX6 is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_DEBUG=y
-CONFIG_DM_CRYPT=y
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_DELAY is not set
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-CONFIG_SMC91X=y
-# CONFIG_DM9000 is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_DNET is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_B44 is not set
-CONFIG_NETDEV_1000=y
-CONFIG_NETDEV_10000=y
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-CONFIG_BCM4329=m
-CONFIG_BCM4329_FW_PATH="/system/etc/firmware/fw_bcm4329.bin"
-CONFIG_BCM4329_NVRAM_PATH="/proc/calibration"
-
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-# CONFIG_WIMAX_SQN is not set
-#
-# CONFIG_WAN is not set
-CONFIG_PPP=y
-# CONFIG_PPP_MULTILINK is not set
-# CONFIG_PPP_FILTER is not set
-CONFIG_PPP_ASYNC=y
-# CONFIG_PPP_SYNC_TTY is not set
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_MPPE=y
-# CONFIG_PPPOE is not set
-# CONFIG_PPPOL2TP is not set
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-# CONFIG_SLIP is not set
-CONFIG_SLHC=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_MSM_RMNET=y
-# CONFIG_MSM_RMNET_DEBUG is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-CONFIG_INPUT_CAPELLA_CM3602=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-CONFIG_INPUT_KEYRESET=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-# CONFIG_TOUCHSCREEN_ATMEL is not set
-# CONFIG_TOUCHSCREEN_CYPRESS_TMG is not set
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELAN_I2C_8232 is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-CONFIG_TOUCHSCREEN_MSM=y
-CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI=y
-# CONFIG_TOUCHSCREEN_SYNAPTICS_T1007 is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_ATI_REMOTE is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INPUT_CM109 is not set
-CONFIG_INPUT_UINPUT=y
-CONFIG_INPUT_GPIO=y
-CONFIG_INPUT_KEYCHORD=y
-CONFIG_INPUT_OPTICALJOYSTICK=y
-CONFIG_OPTICALJOYSTICK_CRUCIAL=y
-CONFIG_FLASHLIGHT=y
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_DEVMEM is not set
-# CONFIG_DEVKMEM is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_CORE=y
-# CONFIG_SERIAL_CORE_CONSOLE is not set
-CONFIG_SERIAL_MSM=y
-# CONFIG_SERIAL_MSM_CONSOLE is not set
-# CONFIG_SERIAL_MSM_CLOCK_CONTROL is not set
-CONFIG_SERIAL_MSM_HS=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_DCC_TTY is not set
-CONFIG_Q6_VENC=y
-CONFIG_MSM_Q6VDEC=y
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_CHARDEV is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_GPIO is not set
-CONFIG_I2C_MSM=y
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_SIMTEC is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_STUB is not set
-
-#
-# Miscellaneous I2C Chip support
-#
-# CONFIG_DS1682 is not set
-# CONFIG_SENSORS_PCF8574 is not set
-# CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_AKM8976 is not set
-CONFIG_SENSORS_AKM8973=y
-# CONFIG_SENSORS_PCA963X is not set
-# CONFIG_SENSORS_MT9T013 is not set
-CONFIG_AMP_TPA2018D1=y
-CONFIG_AMP_TPA6130A=y
-CONFIG_VP_A1026=y
-CONFIG_SMB329=y
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CHIP is not set
-CONFIG_SPI=y
-CONFIG_SPI_MASTER=y
-CONFIG_SPI_QSD=y
-CONFIG_W1=y
-
-#
-# 1-wire Bus Masters
-#
-CONFIG_W1_MASTER_DS2482=y
-# CONFIG_W1_MASTER_GPIO is not set
-
-#
-# 1-wire Slaves
-#
-# CONFIG_W1_SLAVE_THERM is not set
-# CONFIG_W1_SLAVE_SMEM is not set
-# CONFIG_W1_SLAVE_DS2433 is not set
-# CONFIG_W1_SLAVE_DS2760 is not set
-CONFIG_W1_SLAVE_DS2784=y
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_BATTERY_DS2760 is not set
-CONFIG_BATTERY_DS2784=y
-CONFIG_HTC_GUAGE_BATTCHG=y
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_HWMON is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_WATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_PCF50633 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_VIDEO_V4L2_COMMON=y
-# CONFIG_VIDEO_ALLOW_V4L1 is not set
-CONFIG_VIDEO_V4L1_COMPAT=y
-# CONFIG_DVB_CORE is not set
-CONFIG_VIDEO_MEDIA=y
-
-#
-# Multimedia drivers
-#
-# CONFIG_MEDIA_ATTACH is not set
-CONFIG_MEDIA_TUNER=y
-# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
-CONFIG_MEDIA_TUNER_SIMPLE=y
-CONFIG_MEDIA_TUNER_TDA8290=y
-CONFIG_MEDIA_TUNER_TDA9887=y
-CONFIG_MEDIA_TUNER_TEA5761=y
-CONFIG_MEDIA_TUNER_TEA5767=y
-CONFIG_MEDIA_TUNER_MT20XX=y
-CONFIG_MEDIA_TUNER_XC2028=y
-CONFIG_MEDIA_TUNER_XC5000=y
-CONFIG_VIDEO_V4L2=y
-CONFIG_VIDEO_CAPTURE_DRIVERS=y
-# CONFIG_VIDEO_ADV_DEBUG is not set
-# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
-CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
-# CONFIG_VIDEO_VIVI is not set
-# CONFIG_VIDEO_SAA5246A is not set
-# CONFIG_VIDEO_SAA5249 is not set
-# CONFIG_SOC_CAMERA is not set
-
-#
-# Qualcomm MSM Camera And Video
-#
-CONFIG_MSM_CAMERA=y
-# CONFIG_MSM_CAMERA_DEBUG is not set
-
-#
-# Camera Sensor Selection
-#
-CONFIG_MSM_CAMERA_FLASH=y
-# CONFIG_MT9T013 is not set
-# CONFIG_MT9D112 is not set
-# CONFIG_MT9P012 is not set
-# CONFIG_MSM_CAMERA_AF_FOXCONN is not set
-# CONFIG_MSM_CAMERA_AF_BAM is not set
-CONFIG_S5K3E2FX=y
-# CONFIG_VB6801 is not set
-# CONFIG_OV8810 is not set
-
-#
-# Camera Sensor Selection
-#
-CONFIG_RADIO_ADAPTERS=y
-# CONFIG_RADIO_TEA5764 is not set
-# CONFIG_DAB is not set
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-CONFIG_VIDEO_OUTPUT_CONTROL=y
-CONFIG_FB=y
-# CONFIG_FB_MSM_TVOUT is not set
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MB862XX is not set
-CONFIG_FB_MSM=y
-CONFIG_FB_MSM_LCDC=y
-CONFIG_GPU_MSM_KGSL=y
-CONFIG_MSM_KGSL_MMU=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-# CONFIG_LOGO is not set
-# CONFIG_SOUND is not set
-CONFIG_HID_SUPPORT=y
-CONFIG_HID=y
-# CONFIG_HID_DEBUG is not set
-# CONFIG_HIDRAW is not set
-# CONFIG_HID_PID is not set
-
-#
-# Special HID drivers
-#
-CONFIG_HID_COMPAT=y
-# CONFIG_HID_APPLE is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-
-#
-# Enable Host or Gadget support to see Inventra options
-#
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# OTG and related infrastructure
-#
-
-#
-# USB Function Support
-#
-CONFIG_USB_FUNCTION=y
-CONFIG_USB_FUNCTION_MSM_HSUSB=y
-# CONFIG_USB_FUNCTION_NULL is not set
-# CONFIG_USB_FUNCTION_ZERO is not set
-# CONFIG_USB_FUNCTION_LOOPBACK is not set
-CONFIG_USB_FUNCTION_ADB=y
-# CONFIG_USB_FUNCTION_UMS is not set
-CONFIG_USB_FUNCTION_MASS_STORAGE=y
-CONFIG_USB_FUNCTION_DIAG=y
-CONFIG_USB_FUNCTION_ETHER=y
-CONFIG_USB_FUNCTION_RNDIS=y
-CONFIG_USB_FUNCTION_MODEM=y
-CONFIG_USB_FUNCTION_PROJECTOR=y
-CONFIG_USB_FUNCTION_CAT_KIT=y
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_MMC_UNSAFE_RESUME=y
-CONFIG_MMC_EMBEDDED_SDIO=y
-CONFIG_MMC_PARANOID_SD_INIT=y
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-# CONFIG_MMC_BLOCK_BOUNCE is not set
-CONFIG_MMC_BLOCK_PARANOID_RESUME=y
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-CONFIG_MMC_BUSCLK_PWRSAVE=y
-CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-# CONFIG_MMC_SDHCI is not set
-CONFIG_MMC_MSM7X00A=y
-# CONFIG_MMC_MSM7X00A_RESUME_IN_WQ is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_ACCESSIBILITY is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-CONFIG_MMC_BLOCK_PROG_ENA=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_PCA9532 is not set
-CONFIG_LEDS_GPIO=y
-CONFIG_LEDS_CPLD=y
-# CONFIG_LEDS_PCA955X is not set
-CONFIG_FLASHLIGHT=y
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-CONFIG_LEDS_TRIGGER_SLEEP=y
-CONFIG_SWITCH=y
-CONFIG_SWITCH_GPIO=y
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-# CONFIG_RTC_INTF_SYSFS is not set
-# CONFIG_RTC_INTF_PROC is not set
-# CONFIG_RTC_INTF_DEV is not set
-CONFIG_RTC_INTF_ALARM=y
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-
-#
-# SPI RTC drivers
-#
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_CMOS is not set
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-
-#
-# on-CPU RTC drivers
-#
-CONFIG_RTC_DRV_MSM7X00A=y
-# CONFIG_DMADEVICES is not set
-CONFIG_REGULATOR=y
-CONFIG_REGULATOR_DEBUG=y
-# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
-# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
-# CONFIG_REGULATOR_BQ24022 is not set
-CONFIG_REGULATOR_TPS65023=y
-# CONFIG_UIO is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_EXCLUDE_BUILD is not set
-# CONFIG_MEILHAUS is not set
-# CONFIG_ECHO is not set
-# CONFIG_COMEDI is not set
-
-#
-# Android
-#
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_RAM_CONSOLE=y
-CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
-# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
-CONFIG_ANDROID_TIMED_OUTPUT=y
-CONFIG_ANDROID_TIMED_GPIO=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-# CONFIG_BTPORT is not set
-# CONFIG_BTPORT_DRV is not set
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-# CONFIG_EXT2_FS_XIP is not set
-CONFIG_EXT3_FS=y
-CONFIG_EXT3_FS_XATTR=y
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-# CONFIG_EXT4_FS is not set
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-# CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_YAFFS_FS=y
-CONFIG_YAFFS_YAFFS1=y
-# CONFIG_YAFFS_9BYTE_TAGS is not set
-# CONFIG_YAFFS_DOES_ECC is not set
-CONFIG_YAFFS_YAFFS2=y
-CONFIG_YAFFS_AUTO_YAFFS2=y
-# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
-# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
-# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
-CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
-# CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFSD is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_UNUSED_SYMBOLS is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-CONFIG_DETECT_SOFTLOCKUP=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
-CONFIG_SCHEDSTATS=y
-CONFIG_TIMER_STATS=y
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SLAB_LEAK is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-CONFIG_DEBUG_MUTEXES=y
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO=y
-CONFIG_DEBUG_VM=y
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_LIST is not set
-CONFIG_DEBUG_SG=y
-# CONFIG_DEBUG_NOTIFIERS is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-# CONFIG_RCU_CPU_STALL_DETECTOR is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_LATENCYTOP is not set
-CONFIG_HAVE_FUNCTION_TRACER=y
-
-#
-# Tracers
-#
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_BOOT_TRACER is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-# CONFIG_STACK_TRACER is not set
-# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-# CONFIG_DEBUG_USER is not set
-# CONFIG_DEBUG_ERRORS is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_LL is not set
-# CONFIG_DEBUG_ICEDCC is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_FIPS is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-CONFIG_CRYPTO_AUTHENC=y
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-CONFIG_CRYPTO_ECB=y
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_MD4 is not set
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
-CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_TWOFISH_COMMON=y
-
-#
-# Compression
-#
-CONFIG_CRYPTO_DEFLATE=y
-# CONFIG_CRYPTO_LZO is not set
-
-#
-# Random Number Generation
-#
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRYPTO_HW=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_FIND_LAST_BIT=y
-CONFIG_CRC_CCITT=y
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_ALLOCATOR=y
-CONFIG_REED_SOLOMON=y
-CONFIG_REED_SOLOMON_ENC8=y
-CONFIG_REED_SOLOMON_DEC8=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/desirec_defconfig b/arch/arm/configs/desirec_defconfig
deleted file mode 100644
index 81e5246..0000000
--- a/arch/arm/configs/desirec_defconfig
+++ /dev/null
@@ -1,1596 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29
-# Mon Apr 20 10:57:11 2009
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_CLASSIC_RCU=y
-# CONFIG_TREE_RCU is not set
-# CONFIG_PREEMPT_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_PREEMPT_RCU_TRACE is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_GROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-# CONFIG_USER_SCHED is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-# CONFIG_CGROUP_NS is not set
-CONFIG_CGROUP_FREEZER=y
-# CONFIG_CGROUP_DEVICE is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_CGROUP_MEM_RES_CTLR is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-# CONFIG_ELF_CORE is not set
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_ASHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_COMPAT_BRK=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-CONFIG_PROFILING=y
-CONFIG_OPROFILE=y
-CONFIG_HAVE_OPROFILE=y
-CONFIG_OPROFILE_ARMV6=y
-CONFIG_OPROFILE_ARM11_CORE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-# CONFIG_IOSCHED_CFQ is not set
-# CONFIG_DEFAULT_AS is not set
-CONFIG_DEFAULT_DEADLINE=y
-# CONFIG_DEFAULT_CFQ is not set
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="deadline"
-CONFIG_FREEZER=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KIRKWOOD is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-# CONFIG_ARCH_LOKI is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-CONFIG_ARCH_MSM=y
-# CONFIG_ARCH_W90X900 is not set
-CONFIG_ARCH_MSM7X00A=y
-CONFIG_ARCH_MSM_ARM11=y
-CONFIG_MSM_AMSS_VERSION_4410=y
-CONFIG_RADIO_IS_ENDOF_EBI1=y
-# CONFIG_MSM_DEBUG_UART_NONE is not set
-# CONFIG_MSM_DEBUG_UART1 is not set
-# CONFIG_MSM_DEBUG_UART2 is not set
-CONFIG_MSM_DEBUG_UART3=y
-
-#
-# MSM Board Type
-#
-CONFIG_MACH_DESIREC=y
-CONFIG_HTC_HEADSET_V1=y
-CONFIG_HTC_35MM_REMOTE_V1=y
-CONFIG_HTC_AUDIOJACK_V1=y
-CONFIG_HTC_BATTCHG=y
-CONFIG_HTC_BATTCHG_SMEM=y
-CONFIG_HTC_PWRSINK=y
-CONFIG_MSM7X00A_USE_GP_TIMER=y
-# CONFIG_MSM7X00A_USE_DG_TIMER is not set
-CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
-# CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_SLEEP_MODE=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE=1
-CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
-CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
-CONFIG_MSM_IDLE_STATS=y
-CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
-CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
-CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
-CONFIG_MSM_FIQ_SUPPORT=y
-CONFIG_MSM_SERIAL_DEBUGGER=y
-CONFIG_MSM_SERIAL_DEBUGGER_NO_SLEEP=y
-# CONFIG_MSM_SERIAL_DEBUGGER_WAKEUP_IRQ_ALWAYS_ON is not set
-# CONFIG_MSM_SERIAL_DEBUGGER_CONSOLE is not set
-CONFIG_MSM_SMD=y
-CONFIG_MSM_ONCRPCROUTER=y
-CONFIG_MSM_RPCSERVERS=y
-# CONFIG_MSM_CPU_FREQ_SCREEN is not set
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX=528000
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN=245760
-CONFIG_MSM_HW3D=y
-CONFIG_MSM_HW3D_EARLYSUSPEND_ENABLED=n
-# CONFIG_MSM_ADSP is not set
-CONFIG_MSM_ADSP_REPORT_EVENTS=y
-CONFIG_WIFI_CONTROL_FUNC=y
-CONFIG_WIFI_MEM_PREALLOC=y
-CONFIG_BUILD_OMA_DM=y
-CONFIG_SMD_OFFSET_TCXO_STAT=0xFC2A0
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_V6=y
-# CONFIG_CPU_32v6K is not set
-CONFIG_CPU_32v6=y
-CONFIG_CPU_ABRT_EV6=y
-CONFIG_CPU_PABRT_NOIFAR=y
-CONFIG_CPU_CACHE_V6=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V6=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_1G is not set
-CONFIG_PAGE_OFFSET=0xC0000000
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-CONFIG_ARCH_FLATMEM_HAS_HOLES=y
-# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
-# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=0
-CONFIG_VIRT_TO_BUS=y
-CONFIG_UNEVICTABLE_LRU=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="mem=64M console=ttyMSM,115200n8"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# Power management
-#
-CONFIG_TURBO_MODE=y
-
-#
-# CPU Power Management
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-# CONFIG_CPU_FREQ_DEBUG is not set
-CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_STAT_DETAILS=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_MIN_TICKS=1
-CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
-# CONFIG_CPU_IDLE is not set
-CONFIG_PERFLOCK=y
-CONFIG_PERFLOCK_BOOT_LOCK=y
-CONFIG_PERFLOCK_SCREEN_POLICY=y
-CONFIG_PERFLOCK_SCREEN_ON_MIN=480000
-# CONFIG_PERFLOCK_SCREEN_ON_MAX is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MAX is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-# CONFIG_VFP is not set
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_HAVE_AOUT=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-CONFIG_HAS_WAKELOCK=y
-CONFIG_HAS_EARLYSUSPEND=y
-CONFIG_WAKELOCK=y
-CONFIG_WAKELOCK_STAT=y
-CONFIG_USER_WAKELOCK=y
-CONFIG_EARLYSUSPEND=y
-# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
-# CONFIG_CONSOLE_EARLYSUSPEND is not set
-CONFIG_FB_EARLYSUSPEND=y
-# CONFIG_APM_EMULATION is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_COMPAT_NET_DEV_OPS=y
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-CONFIG_NET_KEY=y
-# CONFIG_NET_KEY_MIGRATE is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-CONFIG_INET_ESP=y
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-CONFIG_XFRM_IPCOMP=y
-CONFIG_IPV6=y
-CONFIG_IPV6_PRIVACY=y
-CONFIG_IPV6_ROUTER_PREF=y
-CONFIG_IPV6_ROUTE_INFO=y
-CONFIG_IPV6_OPTIMISTIC_DAD=y
-CONFIG_INET6_AH=y
-CONFIG_INET6_ESP=y
-CONFIG_INET6_IPCOMP=y
-CONFIG_IPV6_MIP6=y
-CONFIG_INET6_XFRM_TUNNEL=y
-CONFIG_INET6_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_TRANSPORT=y
-CONFIG_INET6_XFRM_MODE_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_BEET=y
-CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=y
-CONFIG_IPV6_SIT=y
-CONFIG_IPV6_NDISC_NODETYPE=y
-CONFIG_IPV6_TUNNEL=y
-CONFIG_IPV6_MULTIPLE_TABLES=y
-CONFIG_IPV6_SUBTREES=y
-CONFIG_IPV6_MROUTE=y
-CONFIG_IPV6_PIMSM_V2=y
-CONFIG_NETFILTER_XT_TARGET_DSCP=y
-CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=y
-CONFIG_NF_CONNTRACK_IPV6=y
-CONFIG_IP6_NF_QUEUE=y
-CONFIG_IP6_NF_IPTABLES=y
-CONFIG_IP6_NF_MATCH_AH=y
-CONFIG_IP6_NF_MATCH_EUI64=y
-CONFIG_IP6_NF_MATCH_FRAG=y
-CONFIG_IP6_NF_MATCH_OPTS=y
-CONFIG_IP6_NF_MATCH_HL=y
-CONFIG_IP6_NF_MATCH_IPV6HEADER=y
-CONFIG_IP6_NF_MATCH_MH=y
-CONFIG_IP6_NF_MATCH_RT=y
-CONFIG_IP6_NF_TARGET_LOG=y
-CONFIG_IP6_NF_FILTER=y
-CONFIG_IP6_NF_TARGET_REJECT=y
-CONFIG_IP6_NF_MANGLE=y
-CONFIG_IP6_NF_TARGET_HL=y
-CONFIG_IP6_NF_RAW=y
-CONFIG_ANDROID_PARANOID_NETWORK=y
-# CONFIG_NETWORK_SECMARK is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_NETFILTER_ADVANCED=y
-
-#
-# Core Netfilter Configuration
-#
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_NETLINK_LOG is not set
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CT_ACCT=y
-CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-CONFIG_NF_CONNTRACK_FTP=y
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_PPTP is not set
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CT_NETLINK is not set
-CONFIG_NETFILTER_XTABLES=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_DCCP=y
-CONFIG_NETFILTER_XT_MATCH_DSCP=y
-CONFIG_NETFILTER_XT_MATCH_ESP=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-CONFIG_NETFILTER_XT_MATCH_REALM=y
-CONFIG_NETFILTER_XT_MATCH_SCTP=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_NF_CONNTRACK_PROC_COMPAT=y
-# CONFIG_IP_NF_QUEUE is not set
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_RECENT=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_MATCH_ADDRTYPE=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_LOG=y
-# CONFIG_IP_NF_TARGET_ULOG is not set
-CONFIG_NF_NAT=y
-CONFIG_NF_NAT_NEEDED=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-CONFIG_NF_NAT_FTP=y
-# CONFIG_NF_NAT_IRC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_NAT_AMANDA is not set
-# CONFIG_NF_NAT_PPTP is not set
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_IP_NF_MANGLE is not set
-CONFIG_IP_NF_RAW=y
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-# CONFIG_DCB is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-CONFIG_BT=y
-CONFIG_BT_L2CAP=y
-CONFIG_BT_SCO=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-# CONFIG_BT_BNEP_MC_FILTER is not set
-# CONFIG_BT_BNEP_PROTO_FILTER is not set
-CONFIG_BT_HIDP=y
-
-#
-# Bluetooth device drivers
-#
-# CONFIG_BT_HCIBTSDIO is not set
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_BCSP is not set
-CONFIG_BT_HCIUART_LL=y
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_PHONET is not set
-CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
-CONFIG_WIRELESS_OLD_REGULATORY=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WIRELESS_EXT_SYSFS=y
-# CONFIG_LIB80211 is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_WIMAX is not set
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_PM is not set
-# CONFIG_RFKILL_INPUT is not set
-CONFIG_RFKILL_LEDS=y
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH=""
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_EXTRA_FIRMWARE=""
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-CONFIG_MTD_MSM_NAND=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-CONFIG_MISC_DEVICES=y
-CONFIG_ANDROID_PMEM=y
-# CONFIG_ICS932S401 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-CONFIG_KERNEL_DEBUGGER_CORE=y
-CONFIG_UID_STAT=y
-CONFIG_SENSORS_BMA150_SPI=n
-CONFIG_PROXIMITYSENSOR=n
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_93CX6 is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_DEBUG=y
-CONFIG_DM_CRYPT=y
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_DELAY is not set
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-CONFIG_SMC91X=y
-# CONFIG_DM9000 is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_DNET is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_B44 is not set
-CONFIG_NETDEV_1000=y
-CONFIG_NETDEV_10000=y
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-#
-# CONFIG_WAN is not set
-CONFIG_PPP=y
-# CONFIG_PPP_MULTILINK is not set
-# CONFIG_PPP_FILTER is not set
-CONFIG_PPP_ASYNC=y
-# CONFIG_PPP_SYNC_TTY is not set
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_MPPE=y
-# CONFIG_PPPOE is not set
-# CONFIG_PPPOL2TP is not set
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-# CONFIG_SLIP is not set
-CONFIG_SLHC=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_MSM_RMNET=y
-CONFIG_MSM_RMNET_DEBUG=y
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-CONFIG_INPUT_CAPELLA_CM3602=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-CONFIG_INPUT_KEYRESET=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI=y
-# CONFIG_TOUCHSCREEN_SYNAPTICS_T1007 is not set
-CONFIG_TOUCHSCREEN_MELFAS_I2C=y
-CONFIG_TOUCHSCREEN_CONCATENATE_REPORT=y
-CONFIG_TOUCHSCREEN_DUPLICATED_FILTER=y
-# CONFIG_TOUCHSCREEN_COMPATIBLE_REPORT is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_ATI_REMOTE is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INPUT_CM109 is not set
-CONFIG_INPUT_UINPUT=y
-CONFIG_INPUT_GPIO=y
-CONFIG_INPUT_KEYCHORD=y
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_DEVMEM is not set
-# CONFIG_DEVKMEM is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_CORE=y
-# CONFIG_SERIAL_CORE_CONSOLE is not set
-CONFIG_SERIAL_MSM=y
-# CONFIG_SERIAL_MSM_CONSOLE is not set
-# CONFIG_SERIAL_MSM_CLOCK_CONTROL is not set
-CONFIG_SERIAL_MSM_HS=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_DCC_TTY is not set
-CONFIG_Q6_VENC=y
-CONFIG_MSM_Q6VDEC=y
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_CHARDEV is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_GPIO is not set
-CONFIG_I2C_MSM=y
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_SIMTEC is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_STUB is not set
-
-#
-# Miscellaneous I2C Chip support
-#
-# CONFIG_DS1682 is not set
-# CONFIG_SENSORS_PCF8574 is not set
-# CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_AKM8976 is not set
-CONFIG_SENSORS_AKM8973=y
-CONFIG_SENSORS_BMA150=y
-CONFIG_SENSORS_PCA963X=y
-CONFIG_AMP_TPA6130A=y
-# CONFIG_SENSORS_MT9T013 is not set
-CONFIG_MICROP_I2C=y
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CHIP is not set
-# CONFIG_SPI is not set
-# CONFIG_W1 is not set
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_BATTERY_DS2760 is not set
-# CONFIG_BATTERY_DS2784 is not set
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_HWMON is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_WATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Qualcomm camera driver
-#
-
-CONFIG_MSM_CAMERA=y
-# CONFIG_MSM_CAMERA_DEBUG is not set
-# CONFIG_MSM_CAMERA_FLASH is not set
-# CONFIG_MT9P012 is not set
-# CONFIG_MT9T013 is not set
-# CONFIG_MT9D112 is not set
-CONFIG_S5K3E2FX=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_PCF50633 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_VIDEO_V4L2_COMMON=y
-# CONFIG_VIDEO_ALLOW_V4L1 is not set
-CONFIG_VIDEO_V4L1_COMPAT=y
-# CONFIG_DVB_CORE is not set
-# CONFIG_VIDEO_MEDIA is not set
-
-# Multimedia drivers
-#
-# CONFIG_MEDIA_ATTACH is not set
-# CONFIG_MEDIA_TUNER is not set
-CONFIG_VIDEO_V4L2=y
-# CONFIG_VIDEO_V4L1 is not set
-CONFIG_VIDEO_CAPTURE_DRIVERS=y
-
-#
-# Multimedia drivers
-#
-CONFIG_DAB=y
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-CONFIG_VIDEO_OUTPUT_CONTROL=y
-CONFIG_FB=y
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MB862XX is not set
-CONFIG_FB_MSM=y
-CONFIG_FB_565=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-# CONFIG_LOGO is not set
-# CONFIG_SOUND is not set
-CONFIG_HID_SUPPORT=y
-CONFIG_HID=y
-# CONFIG_HID_DEBUG is not set
-# CONFIG_HIDRAW is not set
-# CONFIG_HID_PID is not set
-
-#
-# Special HID drivers
-#
-CONFIG_HID_COMPAT=y
-# CONFIG_HID_APPLE is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-
-#
-# Enable Host or Gadget support to see Inventra options
-#
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# OTG and related infrastructure
-#
-
-#
-# USB Function Support
-#
-CONFIG_USB_FUNCTION=y
-CONFIG_USB_FUNCTION_MSM_HSUSB=y
-# CONFIG_USB_FUNCTION_NULL is not set
-# CONFIG_USB_FUNCTION_ZERO is not set
-# CONFIG_USB_FUNCTION_LOOPBACK is not set
-CONFIG_USB_FUNCTION_ADB=y
-# CONFIG_USB_FUNCTION_UMS is not set
-CONFIG_USB_FUNCTION_MASS_STORAGE=y
-CONFIG_USB_FUNCTION_DIAG=y
-CONFIG_USB_FUNCTION_ETHER=y
-CONFIG_USB_FUNCTION_RNDIS=y
-CONFIG_USB_FUNCTION_MODEM=y
-CONFIG_USB_FUNCTION_PROJECTOR=y
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_MMC_UNSAFE_RESUME=y
-CONFIG_MMC_EMBEDDED_SDIO=y
-CONFIG_MMC_PARANOID_SD_INIT=y
-CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-# CONFIG_MMC_BLOCK_BOUNCE is not set
-CONFIG_MMC_BLOCK_PARANOID_RESUME=y
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-CONFIG_MMC_SDIO_EMAPI=y
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-# CONFIG_MMC_SDHCI is not set
-CONFIG_MMC_MSM7X00A=y
-# CONFIG_MMC_MSM7X00A_RESUME_IN_WQ is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_ACCESSIBILITY is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_PCA9532 is not set
-CONFIG_LEDS_GPIO=y
-CONFIG_LEDS_CPLD=y
-# CONFIG_LEDS_PCA955X is not set
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-CONFIG_LEDS_TRIGGER_SLEEP=y
-CONFIG_SWITCH=y
-CONFIG_SWITCH_GPIO=y
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-# CONFIG_RTC_INTF_SYSFS is not set
-# CONFIG_RTC_INTF_PROC is not set
-# CONFIG_RTC_INTF_DEV is not set
-CONFIG_RTC_INTF_ALARM=y
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-
-#
-# SPI RTC drivers
-#
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_CMOS is not set
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-
-#
-# on-CPU RTC drivers
-#
-CONFIG_RTC_DRV_MSM7X00A=y
-# CONFIG_DMADEVICES is not set
-# CONFIG_REGULATOR is not set
-# CONFIG_UIO is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_EXCLUDE_BUILD is not set
-# CONFIG_MEILHAUS is not set
-# CONFIG_ECHO is not set
-# CONFIG_COMEDI is not set
-
-#
-# Android
-#
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_RAM_CONSOLE=y
-CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
-# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
-CONFIG_ANDROID_TIMED_OUTPUT=y
-CONFIG_ANDROID_TIMED_GPIO=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-# CONFIG_BTPORT is not set
-# CONFIG_BTPORT_DRV is not set
-
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-# CONFIG_EXT2_FS_XIP is not set
-CONFIG_EXT3_FS=y
-CONFIG_EXT3_FS_XATTR=y
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-# CONFIG_EXT4_FS is not set
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-# CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_YAFFS_FS=y
-CONFIG_YAFFS_YAFFS1=y
-# CONFIG_YAFFS_9BYTE_TAGS is not set
-# CONFIG_YAFFS_DOES_ECC is not set
-CONFIG_YAFFS_YAFFS2=y
-CONFIG_YAFFS_AUTO_YAFFS2=y
-# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
-# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
-# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
-CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
-# CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFSD is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_UNUSED_SYMBOLS is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-CONFIG_DETECT_SOFTLOCKUP=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
-CONFIG_SCHEDSTATS=y
-CONFIG_TIMER_STATS=y
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SLAB_LEAK is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-CONFIG_DEBUG_MUTEXES=y
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO=y
-CONFIG_DEBUG_VM=y
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_LIST is not set
-CONFIG_DEBUG_SG=y
-# CONFIG_DEBUG_NOTIFIERS is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-# CONFIG_RCU_CPU_STALL_DETECTOR is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_LATENCYTOP is not set
-CONFIG_HAVE_FUNCTION_TRACER=y
-
-#
-# Tracers
-#
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_BOOT_TRACER is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-# CONFIG_STACK_TRACER is not set
-# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-# CONFIG_DEBUG_USER is not set
-# CONFIG_DEBUG_ERRORS is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_LL is not set
-# CONFIG_DEBUG_ICEDCC is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_FIPS is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-CONFIG_CRYPTO_AUTHENC=y
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-CONFIG_CRYPTO_ECB=y
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_MD4 is not set
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_ARC4 is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_TWOFISH_COMMON=y
-
-#
-# Compression
-#
-CONFIG_CRYPTO_DEFLATE=y
-# CONFIG_CRYPTO_LZO is not set
-
-#
-# Random Number Generation
-#
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRYPTO_HW=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_FIND_LAST_BIT=y
-CONFIG_CRC_CCITT=y
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_ALLOCATOR=y
-CONFIG_REED_SOLOMON=y
-CONFIG_REED_SOLOMON_ENC8=y
-CONFIG_REED_SOLOMON_DEC8=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/hero_defconfig b/arch/arm/configs/hero_defconfig
deleted file mode 100644
index a089d02..0000000
--- a/arch/arm/configs/hero_defconfig
+++ /dev/null
@@ -1,1557 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29
-# Mon Apr 20 10:57:11 2009
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_CLASSIC_RCU=y
-# CONFIG_TREE_RCU is not set
-# CONFIG_PREEMPT_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_PREEMPT_RCU_TRACE is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_GROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-# CONFIG_USER_SCHED is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-# CONFIG_CGROUP_NS is not set
-CONFIG_CGROUP_FREEZER=y
-# CONFIG_CGROUP_DEVICE is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_CGROUP_MEM_RES_CTLR is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-# CONFIG_ELF_CORE is not set
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_ASHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_COMPAT_BRK=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-CONFIG_PROFILING=y
-CONFIG_OPROFILE=y
-CONFIG_HAVE_OPROFILE=y
-CONFIG_OPROFILE_ARMV6=y
-CONFIG_OPROFILE_ARM11_CORE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-# CONFIG_IOSCHED_CFQ is not set
-# CONFIG_DEFAULT_AS is not set
-CONFIG_DEFAULT_DEADLINE=y
-# CONFIG_DEFAULT_CFQ is not set
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="deadline"
-CONFIG_FREEZER=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KIRKWOOD is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-# CONFIG_ARCH_LOKI is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-CONFIG_ARCH_MSM=y
-# CONFIG_ARCH_W90X900 is not set
-CONFIG_ARCH_MSM7X00A=y
-CONFIG_ARCH_MSM_ARM11=y
-# CONFIG_MSM_AMSS_VERSION_6210 is not set
-# CONFIG_MSM_AMSS_VERSION_6220 is not set
-# CONFIG_MSM_AMSS_VERSION_6225 is not set
-CONFIG_MSM_AMSS_VERSION_6355=y
-CONFIG_RADIO_IS_ENDOF_EBI1=y
-# CONFIG_MSM_DEBUG_UART_NONE is not set
-# CONFIG_MSM_DEBUG_UART1 is not set
-# CONFIG_MSM_DEBUG_UART2 is not set
-CONFIG_MSM_DEBUG_UART3=y
-
-#
-# MSM Board Type
-#
-CONFIG_MACH_HALIBUT=n
-CONFIG_MACH_TROUT=n
-# CONFIG_MACH_SAPPHIRE is not set
-CONFIG_MACH_HERO=y
-CONFIG_HTC_HEADSET_V1=y
-# CONFIG_HTC_35MM_REMOTE_V1 is not set
-# CONFIG_HTC_AUDIOJACK_V1 is not set
-CONFIG_HTC_BATTCHG=y
-CONFIG_HTC_BATTCHG_SMEM=y
-CONFIG_HTC_PWRSINK=y
-CONFIG_MSM7X00A_USE_GP_TIMER=y
-# CONFIG_MSM7X00A_USE_DG_TIMER is not set
-CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
-# CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_SLEEP_MODE=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE=1
-CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
-CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
-CONFIG_MSM_IDLE_STATS=y
-CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
-CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
-CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
-CONFIG_MSM_FIQ_SUPPORT=y
-CONFIG_MSM_SERIAL_DEBUGGER=y
-CONFIG_MSM_SERIAL_DEBUGGER_NO_SLEEP=y
-# CONFIG_MSM_SERIAL_DEBUGGER_WAKEUP_IRQ_ALWAYS_ON is not set
-# CONFIG_MSM_SERIAL_DEBUGGER_CONSOLE is not set
-CONFIG_MSM_SMD=y
-CONFIG_MSM_ONCRPCROUTER=y
-CONFIG_MSM_RPCSERVERS=y
-# CONFIG_MSM_CPU_FREQ_SCREEN is not set
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX=528000
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN=245760
-CONFIG_MSM_HW3D=y
-CONFIG_MSM_HW3D_EARLYSUSPEND_ENABLED=n
-# CONFIG_MSM_ADSP is not set
-CONFIG_MSM_ADSP_REPORT_EVENTS=y
-CONFIG_WIFI_CONTROL_FUNC=y
-CONFIG_WIFI_MEM_PREALLOC=y
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_V6=y
-# CONFIG_CPU_32v6K is not set
-CONFIG_CPU_32v6=y
-CONFIG_CPU_ABRT_EV6=y
-CONFIG_CPU_PABRT_NOIFAR=y
-CONFIG_CPU_CACHE_V6=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V6=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_1G is not set
-CONFIG_PAGE_OFFSET=0xC0000000
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-CONFIG_ARCH_FLATMEM_HAS_HOLES=y
-# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
-# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=0
-CONFIG_VIRT_TO_BUS=y
-CONFIG_UNEVICTABLE_LRU=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="mem=64M console=ttyMSM,115200n8"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# Power management
-#
-CONFIG_TURBO_MODE=y
-
-#
-# CPU Power Management
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-# CONFIG_CPU_FREQ_DEBUG is not set
-CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_STAT_DETAILS=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_MIN_TICKS=1
-CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
-# CONFIG_CPU_IDLE is not set
-CONFIG_PERFLOCK=y
-CONFIG_PERFLOCK_BOOT_LOCK=y
-CONFIG_PERFLOCK_SCREEN_POLICY=y
-CONFIG_PERFLOCK_SCREEN_ON_MIN=480000
-# CONFIG_PERFLOCK_SCREEN_ON_MAX is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MAX is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-# CONFIG_VFP is not set
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_HAVE_AOUT=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-CONFIG_HAS_WAKELOCK=y
-CONFIG_HAS_EARLYSUSPEND=y
-CONFIG_WAKELOCK=y
-CONFIG_WAKELOCK_STAT=y
-CONFIG_USER_WAKELOCK=y
-CONFIG_EARLYSUSPEND=y
-# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
-# CONFIG_CONSOLE_EARLYSUSPEND is not set
-CONFIG_FB_EARLYSUSPEND=y
-# CONFIG_APM_EMULATION is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_COMPAT_NET_DEV_OPS=y
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-CONFIG_NET_KEY=y
-# CONFIG_NET_KEY_MIGRATE is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_ASK_IP_FIB_HASH=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_VERBOSE=y
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-CONFIG_INET_ESP=y
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-CONFIG_ANDROID_PARANOID_NETWORK=y
-# CONFIG_NETWORK_SECMARK is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_NETFILTER_ADVANCED=y
-
-#
-# Core Netfilter Configuration
-#
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_NETLINK_LOG is not set
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CT_ACCT=y
-CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-CONFIG_NF_CONNTRACK_FTP=y
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_PPTP is not set
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CT_NETLINK is not set
-CONFIG_NETFILTER_XTABLES=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_DCCP=y
-CONFIG_NETFILTER_XT_MATCH_DSCP=y
-CONFIG_NETFILTER_XT_MATCH_ESP=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-CONFIG_NETFILTER_XT_MATCH_REALM=y
-CONFIG_NETFILTER_XT_MATCH_SCTP=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_NF_CONNTRACK_PROC_COMPAT=y
-# CONFIG_IP_NF_QUEUE is not set
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_RECENT=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_MATCH_ADDRTYPE=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_LOG=y
-# CONFIG_IP_NF_TARGET_ULOG is not set
-CONFIG_NF_NAT=y
-CONFIG_NF_NAT_NEEDED=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-CONFIG_NF_NAT_FTP=y
-# CONFIG_NF_NAT_IRC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_NAT_AMANDA is not set
-# CONFIG_NF_NAT_PPTP is not set
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_IP_NF_MANGLE is not set
-CONFIG_IP_NF_RAW=y
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-# CONFIG_DCB is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-CONFIG_BT=y
-CONFIG_BT_L2CAP=y
-CONFIG_BT_SCO=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-# CONFIG_BT_BNEP_MC_FILTER is not set
-# CONFIG_BT_BNEP_PROTO_FILTER is not set
-CONFIG_BT_HIDP=y
-
-#
-# Bluetooth device drivers
-#
-# CONFIG_BT_HCIBTSDIO is not set
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_BCSP is not set
-CONFIG_BT_HCIUART_LL=y
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_PHONET is not set
-CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
-CONFIG_WIRELESS_OLD_REGULATORY=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WIRELESS_EXT_SYSFS=y
-# CONFIG_LIB80211 is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_WIMAX is not set
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_PM is not set
-# CONFIG_RFKILL_INPUT is not set
-CONFIG_RFKILL_LEDS=y
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH=""
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_EXTRA_FIRMWARE=""
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-CONFIG_MTD_MSM_NAND=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-CONFIG_MISC_DEVICES=y
-CONFIG_ANDROID_PMEM=y
-# CONFIG_ICS932S401 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-CONFIG_KERNEL_DEBUGGER_CORE=y
-CONFIG_UID_STAT=y
-CONFIG_SENSORS_BMA150_SPI=n
-CONFIG_PROXIMITYSENSOR=n
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_93CX6 is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_DEBUG=y
-CONFIG_DM_CRYPT=y
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_DELAY is not set
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-CONFIG_SMC91X=y
-# CONFIG_DM9000 is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_DNET is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_B44 is not set
-CONFIG_NETDEV_1000=y
-CONFIG_NETDEV_10000=y
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-#
-# CONFIG_WAN is not set
-CONFIG_PPP=y
-# CONFIG_PPP_MULTILINK is not set
-# CONFIG_PPP_FILTER is not set
-CONFIG_PPP_ASYNC=y
-# CONFIG_PPP_SYNC_TTY is not set
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_MPPE=y
-# CONFIG_PPPOE is not set
-# CONFIG_PPPOL2TP is not set
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-# CONFIG_SLIP is not set
-CONFIG_SLHC=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_MSM_RMNET=y
-CONFIG_MSM_RMNET_DEBUG=y
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-CONFIG_INPUT_KEYRESET=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI=y
-CONFIG_TOUCHSCREEN_CONCATENATE_REPORT=y
-CONFIG_TOUCHSCREEN_DUPLICATED_FILTER=y
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_ATI_REMOTE is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INPUT_CM109 is not set
-CONFIG_INPUT_UINPUT=y
-CONFIG_INPUT_GPIO=y
-CONFIG_INPUT_KEYCHORD=y
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_DEVMEM is not set
-# CONFIG_DEVKMEM is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_CORE=y
-# CONFIG_SERIAL_CORE_CONSOLE is not set
-CONFIG_SERIAL_MSM=y
-# CONFIG_SERIAL_MSM_CONSOLE is not set
-# CONFIG_SERIAL_MSM_CLOCK_CONTROL is not set
-CONFIG_SERIAL_MSM_HS=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_DCC_TTY is not set
-CONFIG_Q6_VENC=y
-CONFIG_MSM_Q6VDEC=y
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_CHARDEV is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_GPIO is not set
-CONFIG_I2C_MSM=y
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_SIMTEC is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_STUB is not set
-
-#
-# Miscellaneous I2C Chip support
-#
-# CONFIG_DS1682 is not set
-# CONFIG_SENSORS_PCF8574 is not set
-# CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_AKM8976 is not set
-CONFIG_SENSORS_AKM8973=y
-CONFIG_SENSORS_BMA150=y
-CONFIG_SENSORS_PCA963X=y
-# CONFIG_SENSORS_MT9T013 is not set
-CONFIG_MICROP_I2C=y
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CHIP is not set
-# CONFIG_SPI is not set
-# CONFIG_W1 is not set
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_BATTERY_DS2760 is not set
-# CONFIG_BATTERY_DS2784 is not set
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_HWMON is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_WATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Qualcomm camera driver
-#
-
-CONFIG_MSM_CAMERA=y
-# CONFIG_MSM_CAMERA_DEBUG is not set
-# CONFIG_MSM_CAMERA_FLASH is not set
-CONFIG_MT9P012=y
-# CONFIG_MT9T013 is not set
-# CONFIG_MT9D112 is not set
-# CONFIG_S5K3E2FX is not set
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_PCF50633 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_VIDEO_V4L2_COMMON=y
-# CONFIG_VIDEO_ALLOW_V4L1 is not set
-CONFIG_VIDEO_V4L1_COMPAT=y
-# CONFIG_DVB_CORE is not set
-# CONFIG_VIDEO_MEDIA is not set
-
-# Multimedia drivers
-#
-# CONFIG_MEDIA_ATTACH is not set
-# CONFIG_MEDIA_TUNER is not set
-CONFIG_VIDEO_V4L2=y
-# CONFIG_VIDEO_V4L1 is not set
-CONFIG_VIDEO_CAPTURE_DRIVERS=y
-
-#
-# Multimedia drivers
-#
-CONFIG_DAB=y
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-CONFIG_VIDEO_OUTPUT_CONTROL=y
-CONFIG_FB=y
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MB862XX is not set
-CONFIG_FB_MSM=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-# CONFIG_LOGO is not set
-# CONFIG_SOUND is not set
-CONFIG_HID_SUPPORT=y
-CONFIG_HID=y
-# CONFIG_HID_DEBUG is not set
-# CONFIG_HIDRAW is not set
-# CONFIG_HID_PID is not set
-
-#
-# Special HID drivers
-#
-CONFIG_HID_COMPAT=y
-# CONFIG_HID_APPLE is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-
-#
-# Enable Host or Gadget support to see Inventra options
-#
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# OTG and related infrastructure
-#
-
-#
-# USB Function Support
-#
-CONFIG_USB_FUNCTION=y
-CONFIG_USB_FUNCTION_MSM_HSUSB=y
-# CONFIG_USB_FUNCTION_NULL is not set
-# CONFIG_USB_FUNCTION_ZERO is not set
-# CONFIG_USB_FUNCTION_LOOPBACK is not set
-CONFIG_USB_FUNCTION_ADB=y
-# CONFIG_USB_FUNCTION_UMS is not set
-CONFIG_USB_FUNCTION_MASS_STORAGE=y
-#CONFIG_USB_FUNCTION_DIAG=y
-CONFIG_USB_FUNCTION_ETHER=y
-CONFIG_USB_FUNCTION_RNDIS=y
-CONFIG_USB_FUNCTION_MODEM=y
-CONFIG_USB_FUNCTION_PROJECTOR=n
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_MMC_UNSAFE_RESUME=y
-CONFIG_MMC_EMBEDDED_SDIO=y
-CONFIG_MMC_PARANOID_SD_INIT=y
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-# CONFIG_MMC_BLOCK_BOUNCE is not set
-CONFIG_MMC_BLOCK_PARANOID_RESUME=y
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-CONFIG_MMC_SDIO_EMAPI=y
-CONFIG_MMC_BUSCLK_PWRSAVE=y
-CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-# CONFIG_MMC_SDHCI is not set
-CONFIG_MMC_MSM7X00A=y
-# CONFIG_MMC_MSM7X00A_RESUME_IN_WQ is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_ACCESSIBILITY is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_PCA9532 is not set
-CONFIG_LEDS_GPIO=y
-CONFIG_LEDS_CPLD=y
-# CONFIG_LEDS_PCA955X is not set
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-CONFIG_LEDS_TRIGGER_SLEEP=y
-CONFIG_SWITCH=y
-CONFIG_SWITCH_GPIO=y
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-# CONFIG_RTC_INTF_SYSFS is not set
-# CONFIG_RTC_INTF_PROC is not set
-# CONFIG_RTC_INTF_DEV is not set
-CONFIG_RTC_INTF_ALARM=y
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-
-#
-# SPI RTC drivers
-#
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_CMOS is not set
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-
-#
-# on-CPU RTC drivers
-#
-CONFIG_RTC_DRV_MSM7X00A=y
-# CONFIG_DMADEVICES is not set
-# CONFIG_REGULATOR is not set
-# CONFIG_UIO is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_EXCLUDE_BUILD is not set
-# CONFIG_MEILHAUS is not set
-# CONFIG_ECHO is not set
-# CONFIG_COMEDI is not set
-
-#
-# Android
-#
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_RAM_CONSOLE=y
-CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
-# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
-CONFIG_ANDROID_TIMED_OUTPUT=y
-CONFIG_ANDROID_TIMED_GPIO=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-# CONFIG_BTPORT is not set
-# CONFIG_BTPORT_DRV is not set
-
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-# CONFIG_EXT2_FS_XIP is not set
-CONFIG_EXT3_FS=y
-CONFIG_EXT3_FS_XATTR=y
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-# CONFIG_EXT4_FS is not set
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-# CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_YAFFS_FS=y
-CONFIG_YAFFS_YAFFS1=y
-# CONFIG_YAFFS_9BYTE_TAGS is not set
-# CONFIG_YAFFS_DOES_ECC is not set
-CONFIG_YAFFS_YAFFS2=y
-CONFIG_YAFFS_AUTO_YAFFS2=y
-# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
-# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
-# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
-CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
-# CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFSD is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_UNUSED_SYMBOLS is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-CONFIG_DETECT_SOFTLOCKUP=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
-CONFIG_SCHEDSTATS=y
-CONFIG_TIMER_STATS=y
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SLAB_LEAK is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-CONFIG_DEBUG_MUTEXES=y
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO=y
-CONFIG_DEBUG_VM=y
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_LIST is not set
-CONFIG_DEBUG_SG=y
-# CONFIG_DEBUG_NOTIFIERS is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-# CONFIG_RCU_CPU_STALL_DETECTOR is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_LATENCYTOP is not set
-CONFIG_HAVE_FUNCTION_TRACER=y
-
-#
-# Tracers
-#
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_BOOT_TRACER is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-# CONFIG_STACK_TRACER is not set
-# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-# CONFIG_DEBUG_USER is not set
-# CONFIG_DEBUG_ERRORS is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_LL is not set
-# CONFIG_DEBUG_ICEDCC is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_FIPS is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-CONFIG_CRYPTO_AUTHENC=y
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-CONFIG_CRYPTO_ECB=y
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_MD4 is not set
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_ARC4 is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_TWOFISH_COMMON=y
-
-#
-# Compression
-#
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_LZO is not set
-
-#
-# Random Number Generation
-#
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRYPTO_HW=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_FIND_LAST_BIT=y
-CONFIG_CRC_CCITT=y
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_ALLOCATOR=y
-CONFIG_REED_SOLOMON=y
-CONFIG_REED_SOLOMON_ENC8=y
-CONFIG_REED_SOLOMON_DEC8=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/heroc_defconfig b/arch/arm/configs/heroc_defconfig
old mode 100755
new mode 100644
diff --git a/arch/arm/configs/incrediblec_defconfig b/arch/arm/configs/incrediblec_defconfig
deleted file mode 100755
index 69436e7..0000000
--- a/arch/arm/configs/incrediblec_defconfig
+++ /dev/null
@@ -1,1629 +0,0 @@
-
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29
-# Thu Oct  8 01:00:04 2009
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_CLASSIC_RCU=y
-# CONFIG_TREE_RCU is not set
-# CONFIG_PREEMPT_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_PREEMPT_RCU_TRACE is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_GROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-# CONFIG_USER_SCHED is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-# CONFIG_CGROUP_NS is not set
-CONFIG_CGROUP_FREEZER=y
-# CONFIG_CGROUP_DEVICE is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_CGROUP_MEM_RES_CTLR is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-# CONFIG_ELF_CORE is not set
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_ASHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_COMPAT_BRK=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-# CONFIG_PROFILING is not set
-CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-# CONFIG_IOSCHED_DEADLINE is not set
-# CONFIG_IOSCHED_CFQ is not set
-CONFIG_DEFAULT_AS=y
-# CONFIG_DEFAULT_DEADLINE is not set
-# CONFIG_DEFAULT_CFQ is not set
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="anticipatory"
-CONFIG_FREEZER=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KIRKWOOD is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-# CONFIG_ARCH_LOKI is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-CONFIG_ARCH_MSM=y
-# CONFIG_ARCH_W90X900 is not set
-# CONFIG_ARCH_MSM7X00A is not set
-CONFIG_ARCH_QSD8X50=y
-CONFIG_ARCH_MSM_SCORPION=y
-CONFIG_MSM_MDP31=y
-CONFIG_MSM_AMSS_VERSION=3200
-CONFIG_MSM_AMSS_VERSION_3200=y
-CONFIG_MSM_DEBUG_UART=1
-# CONFIG_MSM_DEBUG_UART_NONE is not set
-CONFIG_MSM_DEBUG_UART1=y
-# CONFIG_MSM_DEBUG_UART2 is not set
-# CONFIG_MSM_DEBUG_UART3 is not set
-
-#
-# MSM Board Type
-#
-# CONFIG_MACH_SWORDFISH is not set
-# CONFIG_MACH_FIRESTONE is not set
-# CONFIG_MACH_ORCA is not set
-# CONFIG_MACH_BRAVO is not set
-# CONFIG_MACH_MAHIMAHI is not set
-# CONFIG_MACH_INCREDIBLE is not set
-CONFIG_MACH_INCREDIBLEC=y
-# CONFIG_MACH_PASSIONC is not set
-# CONFIG_MACH_SUPERSONIC is not set
-CONFIG_HTC_HEADSET=y
-CONFIG_HTC_35MM_REMOTE=y
-CONFIG_HTC_AUDIOJACK=y
-CONFIG_MICROP_COMMON=y
-CONFIG_LIGHTSENSOR_MICROP=y
-# CONFIG_TROUT_BATTCHG is not set
-CONFIG_HTC_BATTCHG=y
-CONFIG_HTC_BATTCHG_SMEM=y
-# CONFIG_HTC_PWRSINK is not set
-CONFIG_CACHE_FLUSH_RANGE_LIMIT=0x40000
-CONFIG_MSM7X00A_USE_GP_TIMER=y
-# CONFIG_MSM7X00A_USE_DG_TIMER is not set
-CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
-# CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_SLEEP_MODE=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE_APPS_SLEEP=y
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE=2
-CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
-CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
-CONFIG_MSM7X00A_SLEEP_NO_LIMIT=y
-# CONFIG_MSM7X00A_SLEEP_LIMITED_SLEEP is not set
-# CONFIG_MSM7X00A_SLEEP_NEGATE_SLEEP is not set
-CONFIG_MSM7X00A_SLEEP_LIMIT=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_NO_LIMIT is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_LIMITED_SLEEP is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_NEGATE_SLEEP=y
-CONFIG_MSM7X00A_IDLE_SLEEP_LIMIT=2
-CONFIG_MSM_IDLE_STATS=y
-CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
-CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
-CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
-CONFIG_MSM_FIQ_SUPPORT=y
-CONFIG_MSM_SERIAL_DEBUGGER=y
-CONFIG_MSM_SERIAL_DEBUGGER_NO_SLEEP=y
-# CONFIG_MSM_SERIAL_DEBUGGER_WAKEUP_IRQ_ALWAYS_ON is not set
-# CONFIG_MSM_SERIAL_DEBUGGER_CONSOLE is not set
-CONFIG_MSM_SMD=y
-CONFIG_MSM_N_WAY_SMD=y
-CONFIG_MSM_ONCRPCROUTER=y
-CONFIG_MSM_RPCSERVERS=y
-# CONFIG_MSM_CPU_FREQ_SCREEN is not set
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX=998400
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN=245000
-# CONFIG_MSM_HW3D is not set
-# CONFIG_MSM_ADSP is not set
-# CONFIG_HTC_ACOUSTIC is not set
-CONFIG_HTC_ACOUSTIC_QSD=y
-CONFIG_MSM_DALRPC=y
-# CONFIG_MSM_DALRPC_TEST is not set
-CONFIG_QSD_AUDIO=y
-CONFIG_QSD_HTC_FM=y
-CONFIG_ARCH_MSM_FLASHLIGHT=y
-CONFIG_WIFI_NVS_PROC_CREATE=y
-CONFIG_WIFI_CONTROL_FUNC=y
-CONFIG_WIFI_MEM_PREALLOC=n
-CONFIG_BUILD_OMA_DM=y
-CONFIG_SMD_OFFSET_TCXO_STAT=0xFC2A0
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_32v6K=y
-CONFIG_CPU_V7=y
-CONFIG_CPU_32v7=y
-CONFIG_CPU_ABRT_EV7=y
-CONFIG_CPU_PABRT_IFAR=y
-CONFIG_CPU_CACHE_V7=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V7=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-CONFIG_ARM_THUMBEE=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-CONFIG_HAS_TLS_REG=y
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_1G is not set
-CONFIG_PAGE_OFFSET=0xC0000000
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-CONFIG_ARCH_FLATMEM_HAS_HOLES=y
-# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
-# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=0
-CONFIG_VIRT_TO_BUS=y
-CONFIG_UNEVICTABLE_LRU=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="mem=64M console=ttyMSM,115200n8"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# CPU Power Management
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-# CONFIG_CPU_FREQ_DEBUG is not set
-CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_STAT_DETAILS=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_MIN_TICKS=2
-CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
-# CONFIG_CPU_IDLE is not set
-CONFIG_PERFLOCK=y
-CONFIG_PERFLOCK_BOOT_LOCK=y
-# CONFIG_PERFLOCK_SCREEN_POLICY is not set
-# CONFIG_PERFLOCK_SCREEN_ON_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_ON_MAX is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MAX is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-CONFIG_VFP=y
-CONFIG_VFPv3=y
-CONFIG_NEON=y
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_HAVE_AOUT=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-CONFIG_HAS_WAKELOCK=y
-CONFIG_HAS_EARLYSUSPEND=y
-CONFIG_WAKELOCK=y
-CONFIG_WAKELOCK_STAT=y
-CONFIG_USER_WAKELOCK=y
-CONFIG_EARLYSUSPEND=y
-# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
-# CONFIG_CONSOLE_EARLYSUSPEND is not set
-CONFIG_FB_EARLYSUSPEND=y
-# CONFIG_APM_EMULATION is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_COMPAT_NET_DEV_OPS=y
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-CONFIG_NET_KEY=y
-# CONFIG_NET_KEY_MIGRATE is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-CONFIG_INET_ESP=y
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-CONFIG_ANDROID_PARANOID_NETWORK=y
-# CONFIG_NETWORK_SECMARK is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_NETFILTER_ADVANCED=y
-
-#
-# Core Netfilter Configuration
-#
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_NETLINK_LOG is not set
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CT_ACCT=y
-CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-CONFIG_NF_CONNTRACK_FTP=y
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_PPTP is not set
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CT_NETLINK is not set
-CONFIG_NETFILTER_XTABLES=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_DCCP=y
-CONFIG_NETFILTER_XT_MATCH_DSCP=y
-CONFIG_NETFILTER_XT_MATCH_ESP=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-CONFIG_NETFILTER_XT_MATCH_REALM=y
-CONFIG_NETFILTER_XT_MATCH_SCTP=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_NF_CONNTRACK_PROC_COMPAT=y
-# CONFIG_IP_NF_QUEUE is not set
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_RECENT=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_MATCH_ADDRTYPE=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_LOG=y
-# CONFIG_IP_NF_TARGET_ULOG is not set
-CONFIG_NF_NAT=y
-CONFIG_NF_NAT_NEEDED=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-CONFIG_NF_NAT_FTP=y
-# CONFIG_NF_NAT_IRC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_NAT_AMANDA is not set
-# CONFIG_NF_NAT_PPTP is not set
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_IP_NF_MANGLE is not set
-CONFIG_IP_NF_RAW=y
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-# CONFIG_DCB is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-CONFIG_BT=y
-CONFIG_BT_L2CAP=y
-CONFIG_BT_SCO=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-# CONFIG_BT_BNEP_MC_FILTER is not set
-# CONFIG_BT_BNEP_PROTO_FILTER is not set
-CONFIG_BT_HIDP=y
-
-#
-# Bluetooth device drivers
-#
-# CONFIG_BT_HCIBTSDIO is not set
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_BCSP is not set
-CONFIG_BT_HCIUART_LL=y
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_PHONET is not set
-CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
-CONFIG_WIRELESS_OLD_REGULATORY=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WIRELESS_EXT_SYSFS=y
-# CONFIG_LIB80211 is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_WIMAX is not set
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_PM is not set
-# CONFIG_RFKILL_INPUT is not set
-CONFIG_RFKILL_LEDS=y
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH=""
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_EXTRA_FIRMWARE=""
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-CONFIG_MTD_MSM_NAND=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-CONFIG_MISC_DEVICES=y
-CONFIG_ANDROID_PMEM=y
-# CONFIG_ICS932S401 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-CONFIG_KERNEL_DEBUGGER_CORE=y
-CONFIG_UID_STAT=y
-CONFIG_SENSORS_BMA150_SPI=y
-# CONFIG_WL127X_RFKILL is not set
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_93CX6 is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_DEBUG=y
-CONFIG_DM_CRYPT=y
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_DELAY is not set
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-CONFIG_SMC91X=y
-# CONFIG_DM9000 is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_DNET is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_B44 is not set
-CONFIG_NETDEV_1000=y
-CONFIG_NETDEV_10000=y
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-CONFIG_BCM4329=m
-CONFIG_BCM4329_FW_PATH="/system/etc/firmware/fw_bcm4329.bin"
-CONFIG_BCM4329_NVRAM_PATH="/proc/calibration"
-
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-CONFIG_WIMAX_SQN=m
-#
-# CONFIG_WAN is not set
-CONFIG_PPP=y
-# CONFIG_PPP_MULTILINK is not set
-# CONFIG_PPP_FILTER is not set
-CONFIG_PPP_ASYNC=y
-# CONFIG_PPP_SYNC_TTY is not set
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_MPPE=y
-# CONFIG_PPPOE is not set
-# CONFIG_PPPOL2TP is not set
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-# CONFIG_SLIP is not set
-CONFIG_SLHC=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_MSM_RMNET=y
-# CONFIG_MSM_RMNET_DEBUG is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-CONFIG_INPUT_KEYRESET=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_ATMEL=y
-# CONFIG_TOUCHSCREEN_CYPRESS_TMG is not set
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELAN_I2C_8232 is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_MSM is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_T1007 is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_ATI_REMOTE is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INPUT_CM109 is not set
-CONFIG_INPUT_UINPUT=y
-CONFIG_INPUT_GPIO=y
-CONFIG_INPUT_KEYCHORD=y
-CONFIG_INPUT_OPTICALJOYSTICK=y
-CONFIG_OPTICALJOYSTICK_CRUCIAL=y
-CONFIG_INPUT_DUMMY_KEYPAD=y
-# CONFIG_PROXIMITYSENSOR is not set
-CONFIG_FLASHLIGHT=y
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_DEVMEM is not set
-# CONFIG_DEVKMEM is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_CORE=y
-# CONFIG_SERIAL_CORE_CONSOLE is not set
-CONFIG_SERIAL_MSM=y
-# CONFIG_SERIAL_MSM_CONSOLE is not set
-# CONFIG_SERIAL_MSM_CLOCK_CONTROL is not set
-CONFIG_SERIAL_MSM_HS=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_DCC_TTY is not set
-CONFIG_Q6_VENC=y
-CONFIG_MSM_Q6VDEC=y
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_CHARDEV is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_GPIO is not set
-CONFIG_I2C_MSM=y
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_SIMTEC is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_STUB is not set
-
-#
-# Miscellaneous I2C Chip support
-#
-# CONFIG_DS1682 is not set
-# CONFIG_SENSORS_PCF8574 is not set
-# CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_AKM8976 is not set
-CONFIG_SENSORS_AKM8973=y
-# CONFIG_SENSORS_PCA963X is not set
-# CONFIG_SENSORS_MT9T013 is not set
-CONFIG_AMP_TPA2018D1=y
-CONFIG_AMP_TPA6130A=y
-CONFIG_VP_A1026=y
-CONFIG_SMB329=y
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CHIP is not set
-CONFIG_SPI=y
-CONFIG_SPI_MASTER=y
-CONFIG_SPI_QSD=y
-
-
-# CONFIG_W1 is not set
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_BATTERY_DS2760 is not set
-# CONFIG_BATTERY_DS2784 is not set
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_HWMON is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_WATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_PCF50633 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_VIDEO_V4L2_COMMON=y
-# CONFIG_VIDEO_ALLOW_V4L1 is not set
-CONFIG_VIDEO_V4L1_COMPAT=y
-# CONFIG_DVB_CORE is not set
-CONFIG_VIDEO_MEDIA=y
-
-#
-# Multimedia drivers
-#
-# CONFIG_MEDIA_ATTACH is not set
-CONFIG_MEDIA_TUNER=y
-# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
-CONFIG_MEDIA_TUNER_SIMPLE=y
-CONFIG_MEDIA_TUNER_TDA8290=y
-CONFIG_MEDIA_TUNER_TDA9887=y
-CONFIG_MEDIA_TUNER_TEA5761=y
-CONFIG_MEDIA_TUNER_TEA5767=y
-CONFIG_MEDIA_TUNER_MT20XX=y
-CONFIG_MEDIA_TUNER_XC2028=y
-CONFIG_MEDIA_TUNER_XC5000=y
-CONFIG_VIDEO_V4L2=y
-CONFIG_VIDEO_CAPTURE_DRIVERS=y
-# CONFIG_VIDEO_ADV_DEBUG is not set
-# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
-CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
-# CONFIG_VIDEO_VIVI is not set
-# CONFIG_VIDEO_SAA5246A is not set
-# CONFIG_VIDEO_SAA5249 is not set
-# CONFIG_SOC_CAMERA is not set
-
-#
-# Qualcomm MSM Camera And Video
-#
-CONFIG_MSM_CAMERA=y
-# CONFIG_MSM_CAMERA_DEBUG is not set
-
-#
-# Camera Sensor Selection
-#
-CONFIG_MSM_CAMERA_FLASH=y
-# CONFIG_MT9T013 is not set
-# CONFIG_MT9D112 is not set
-# CONFIG_MT9P012 is not set
-# CONFIG_MSM_CAMERA_AF_FOXCONN is not set
-# CONFIG_MSM_CAMERA_AF_BAM is not set
-# CONFIG_S5K3E2FX is not set
-# CONFIG_VB6801 is not set
-CONFIG_OV9665=y
-CONFIG_OV8810=y
-
-#
-# Camera Sensor Selection
-#
-CONFIG_RADIO_ADAPTERS=y
-# CONFIG_RADIO_TEA5764 is not set
-# CONFIG_DAB is not set
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-CONFIG_VIDEO_OUTPUT_CONTROL=y
-CONFIG_FB=y
-CONFIG_FB_MSM_TVOUT=y
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MB862XX is not set
-CONFIG_FB_MSM=y
-CONFIG_FB_MSM_LCDC=y
-CONFIG_GPU_MSM_KGSL=y
-CONFIG_MSM_KGSL_MMU=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-# CONFIG_LOGO is not set
-# CONFIG_SOUND is not set
-CONFIG_HID_SUPPORT=y
-CONFIG_HID=y
-# CONFIG_HID_DEBUG is not set
-# CONFIG_HIDRAW is not set
-# CONFIG_HID_PID is not set
-
-#
-# Special HID drivers
-#
-CONFIG_HID_COMPAT=y
-# CONFIG_HID_APPLE is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-
-#
-# Enable Host or Gadget support to see Inventra options
-#
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# OTG and related infrastructure
-#
-
-#
-# USB Function Support
-#
-CONFIG_USB_FUNCTION=y
-CONFIG_USB_FUNCTION_MSM_HSUSB=y
-# CONFIG_USB_FUNCTION_NULL is not set
-# CONFIG_USB_FUNCTION_ZERO is not set
-# CONFIG_USB_FUNCTION_LOOPBACK is not set
-CONFIG_USB_FUNCTION_ADB=y
-# CONFIG_USB_FUNCTION_UMS is not set
-CONFIG_USB_FUNCTION_MASS_STORAGE=y
-CONFIG_USB_FUNCTION_DIAG=y
-CONFIG_USB_FUNCTION_ETHER=y
-CONFIG_USB_FUNCTION_RNDIS=y
-CONFIG_USB_FUNCTION_MODEM=y
-CONFIG_USB_FUNCTION_PROJECTOR=y
-CONFIG_USB_FUNCTION_MTP_TUNNEL=y
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_MMC_UNSAFE_RESUME=y
-CONFIG_MMC_EMBEDDED_SDIO=y
-CONFIG_MMC_PARANOID_SD_INIT=y
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-# CONFIG_MMC_BLOCK_BOUNCE is not set
-CONFIG_MMC_BLOCK_PARANOID_RESUME=y
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-CONFIG_MMC_BUSCLK_PWRSAVE=y
-CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-# CONFIG_MMC_SDHCI is not set
-CONFIG_MMC_MSM7X00A=y
-# CONFIG_MMC_MSM7X00A_RESUME_IN_WQ is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_ACCESSIBILITY is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_PCA9532 is not set
-CONFIG_LEDS_GPIO=y
-CONFIG_LEDS_CPLD=y
-# CONFIG_LEDS_PCA955X is not set
-CONFIG_FLASHLIGHT=y
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-CONFIG_LEDS_TRIGGER_SLEEP=y
-CONFIG_SWITCH=y
-CONFIG_SWITCH_GPIO=y
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-# CONFIG_RTC_INTF_SYSFS is not set
-# CONFIG_RTC_INTF_PROC is not set
-# CONFIG_RTC_INTF_DEV is not set
-CONFIG_RTC_INTF_ALARM=y
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-
-#
-# SPI RTC drivers
-#
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_CMOS is not set
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-
-#
-# on-CPU RTC drivers
-#
-CONFIG_RTC_DRV_MSM7X00A=y
-# CONFIG_DMADEVICES is not set
-CONFIG_REGULATOR=y
-CONFIG_REGULATOR_DEBUG=y
-# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
-# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
-# CONFIG_REGULATOR_BQ24022 is not set
-CONFIG_REGULATOR_TPS65023=y
-# CONFIG_UIO is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_EXCLUDE_BUILD is not set
-# CONFIG_MEILHAUS is not set
-# CONFIG_ECHO is not set
-# CONFIG_COMEDI is not set
-
-#
-# Android
-#
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_RAM_CONSOLE=y
-CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
-# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
-CONFIG_ANDROID_TIMED_OUTPUT=y
-CONFIG_ANDROID_TIMED_GPIO=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-CONFIG_BTPORT=y
-CONFIG_BTPORT_DRV=y
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-# CONFIG_EXT2_FS_XIP is not set
-CONFIG_EXT3_FS=y
-CONFIG_EXT3_FS_XATTR=y
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-# CONFIG_EXT4_FS is not set
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-# CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_YAFFS_FS=y
-CONFIG_YAFFS_YAFFS1=y
-# CONFIG_YAFFS_9BYTE_TAGS is not set
-# CONFIG_YAFFS_DOES_ECC is not set
-CONFIG_YAFFS_YAFFS2=y
-CONFIG_YAFFS_AUTO_YAFFS2=y
-# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
-# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
-# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
-CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
-# CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFSD is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_UNUSED_SYMBOLS is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-CONFIG_DETECT_SOFTLOCKUP=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
-CONFIG_SCHEDSTATS=y
-CONFIG_TIMER_STATS=y
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SLAB_LEAK is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-CONFIG_DEBUG_MUTEXES=y
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO=y
-CONFIG_DEBUG_VM=y
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_LIST is not set
-CONFIG_DEBUG_SG=y
-# CONFIG_DEBUG_NOTIFIERS is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-# CONFIG_RCU_CPU_STALL_DETECTOR is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_LATENCYTOP is not set
-CONFIG_HAVE_FUNCTION_TRACER=y
-
-#
-# Tracers
-#
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_BOOT_TRACER is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-# CONFIG_STACK_TRACER is not set
-# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-# CONFIG_DEBUG_USER is not set
-# CONFIG_DEBUG_ERRORS is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_LL is not set
-# CONFIG_DEBUG_ICEDCC is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_FIPS is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-CONFIG_CRYPTO_AUTHENC=y
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-CONFIG_CRYPTO_ECB=y
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_MD4 is not set
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
-CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_TWOFISH_COMMON=y
-
-#
-# Compression
-#
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_LZO is not set
-
-#
-# Random Number Generation
-#
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRYPTO_HW=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_FIND_LAST_BIT=y
-CONFIG_CRC_CCITT=y
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_ALLOCATOR=y
-CONFIG_REED_SOLOMON=y
-CONFIG_REED_SOLOMON_ENC8=y
-CONFIG_REED_SOLOMON_DEC8=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/msm7225_defconfig b/arch/arm/configs/msm7225_defconfig
deleted file mode 100644
index dbf307a..0000000
--- a/arch/arm/configs/msm7225_defconfig
+++ /dev/null
@@ -1,1596 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29
-# Mon Apr 20 10:57:11 2009
-#
-
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ARCH_SUPPORTS_AOUT=y
-CONFIG_ZONE_DMA=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
-CONFIG_OPROFILE_ARMV6=y
-CONFIG_OPROFILE_ARM11_CORE=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_CLASSIC_RCU=y
-# CONFIG_TREE_RCU is not set
-# CONFIG_PREEMPT_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_PREEMPT_RCU_TRACE is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_GROUP_SCHED=y
-CONFIG_CGROUPS=y
-CONFIG_FAIR_GROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-# CONFIG_USER_SCHED is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_CGROUP_DEBUG=y
-# CONFIG_CGROUP_NS is not set
-CONFIG_CGROUP_FREEZER=y
-# CONFIG_CGROUP_DEVICE is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_CGROUP_MEM_RES_CTLR is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-# CONFIG_ELF_CORE is not set
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_ASHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_COMPAT_BRK=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-# CONFIG_PROFILING is not set
-CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-# CONFIG_IOSCHED_CFQ is not set
-# CONFIG_DEFAULT_AS is not set
-CONFIG_DEFAULT_DEADLINE=y
-# CONFIG_DEFAULT_CFQ is not set
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="deadline"
-CONFIG_FREEZER=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KIRKWOOD is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-# CONFIG_ARCH_LOKI is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-CONFIG_ARCH_MSM=y
-# CONFIG_ARCH_W90X900 is not set
-
-#
-# Boot options
-#
-
-#
-# Qualcomm MSM7K Implementations
-#
-# CONFIG_ARCH_MSM7201A is not set
-CONFIG_ARCH_MSM7225=y
-# CONFIG_ARCH_MSM7501A is not set
-CONFIG_MSM_MDP22=y
-
-CONFIG_MSM_AMSS_VERSION_1355=y
-CONFIG_MSM_DEBUG_UART_NONE=y
-# CONFIG_MSM_DEBUG_UART1 is not set
-# CONFIG_MSM_DEBUG_UART2 is not set
-# CONFIG_MSM_DEBUG_UART3 is not set
-
-#
-# Power management
-#
-CONFIG_TURBO_MODE=y
-#
-# MSM Board Type
-#
-# CONFIG_MACH_HTCJADE is not set
-# CONFIG_MACH_MEMPHIS is not set
-CONFIG_MACH_BAHAMAS=y
-CONFIG_MACH_PARADISE=y
-CONFIG_MACH_BUZZ=y
-CONFIG_MACH_BEE=y
-CONFIG_MACH_BUZZC=y
-CONFIG_HTC_BATTCHG=y
-CONFIG_HTC_BATTCHG_SMEM=y
-CONFIG_HTC_HEADSET=y
-CONFIG_MICROP_COMMON=y
-CONFIG_LIGHTSENSOR_MICROP=y
-CONFIG_HTC_PWRSINK=y
-CONFIG_HTC_SLEEP_MODE_GPIO_DUMP=y
-
-CONFIG_MSM7XXX_USE_GP_TIMER=y
-# CONFIG_MSM7XXX_USE_DG_TIMER is not set
-CONFIG_MSM7XXX_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
-# CONFIG_MSM7XXX_SLEEP_MODE_POWER_COLLAPSE is not set
-# CONFIG_MSM7XXX_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7XXX_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7XXX_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7XXX_SLEEP_MODE=0
-# CONFIG_MSM7XXX_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
-CONFIG_MSM7XXX_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
-# CONFIG_MSM7XXX_IDLE_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7XXX_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7XXX_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7XXX_IDLE_SLEEP_MODE=1
-CONFIG_MSM7XXX_IDLE_SLEEP_MIN_TIME=20000000
-CONFIG_MSM7XXX_IDLE_SPIN_TIME=80000
-CONFIG_MSM_IDLE_STATS=y
-CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
-CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
-CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
-CONFIG_MSM_FIQ_SUPPORT=y
-CONFIG_MSM_SERIAL_DEBUGGER=y
-# CONFIG_MSM_SERIAL_DEBUGGER_CONSOLE is not set
-CONFIG_MSM_SMD=y
-CONFIG_MSM_ONCRPCROUTER=y
-CONFIG_MSM_RPCSERVERS=y
-# CONFIG_MSM_CPU_FREQ_MSM7K is not set
-# CONFIG_MSM_CPU_FREQ_SCREEN is not set
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX=528000
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN=245760
-# CONFIG_MSM_HW3D is not set
-CONFIG_HTC_AUDIOJACK=y
-CONFIG_WIFI_NVS_PROC_CREATE=y
-CONFIG_WIFI_CONTROL_FUNC=y
-CONFIG_WIFI_MEM_PREALLOC=y
-CONFIG_ARCH_MSM_FLASHLIGHT=y
-CONFIG_BUILD_OMA_DM=y
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_V6=y
-# CONFIG_CPU_32v6K is not set
-CONFIG_CPU_32v6=y
-CONFIG_CPU_ABRT_EV6=y
-CONFIG_CPU_PABRT_NOIFAR=y
-CONFIG_CPU_CACHE_V6=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V6=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_1G is not set
-CONFIG_PAGE_OFFSET=0xC0000000
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-CONFIG_ARCH_FLATMEM_HAS_HOLES=y
-CONFIG_HOLES_IN_ZONE=y
-# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
-# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=0
-CONFIG_VIRT_TO_BUS=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
-CONFIG_UNEVICTABLE_LRU=y
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="mem=75M console=ttyMSM2,115200n8"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# CPU Frequency scaling
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-# CONFIG_CPU_FREQ_DEBUG is not set
-CONFIG_CPU_FREQ_STAT=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_MSM7K is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-CONFIG_CPU_FREQ_GOV_MSM7K=y
-CONFIG_CPU_FREQ_MIN_TICKS=1
-CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
-CONFIG_PERFLOCK=y
-CONFIG_PERFLOCK_BOOT_LOCK=y
-CONFIG_PERFLOCK_SCREEN_POLICY=y
-CONFIG_PERFLOCK_SCREEN_ON_MIN=480000
-# CONFIG_PERFLOCK_SCREEN_ON_MAX is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MAX is not set
-
-#
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-# CONFIG_VFP is not set
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_HAVE_AOUT=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-CONFIG_HAS_WAKELOCK=y
-CONFIG_HAS_EARLYSUSPEND=y
-CONFIG_WAKELOCK=y
-CONFIG_WAKELOCK_STAT=y
-CONFIG_USER_WAKELOCK=y
-CONFIG_EARLYSUSPEND=y
-# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
-# CONFIG_CONSOLE_EARLYSUSPEND is not set
-CONFIG_FB_EARLYSUSPEND=y
-# CONFIG_APM_EMULATION is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_COMPAT_NET_DEV_OPS=y
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_ASK_IP_FIB_HASH=y
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_VERBOSE=y
-CONFIG_FIB_RULES=y
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-CONFIG_INET_AH=y
-CONFIG_INET_ESP=y
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-CONFIG_INET_XFRM_MODE_TUNNEL=y
-CONFIG_INET_XFRM_MODE_BEET=y
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-CONFIG_XFRM_IPCOMP=y
-CONFIG_IPV6=y
-CONFIG_IPV6_PRIVACY=y
-CONFIG_IPV6_ROUTER_PREF=y
-CONFIG_IPV6_ROUTE_INFO=y
-CONFIG_IPV6_OPTIMISTIC_DAD=y
-CONFIG_INET6_AH=y
-CONFIG_INET6_ESP=y
-CONFIG_INET6_IPCOMP=y
-CONFIG_IPV6_MIP6=y
-CONFIG_INET6_XFRM_TUNNEL=y
-CONFIG_INET6_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_TRANSPORT=y
-CONFIG_INET6_XFRM_MODE_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_BEET=y
-CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=y
-CONFIG_IPV6_SIT=y
-CONFIG_IPV6_NDISC_NODETYPE=y
-CONFIG_IPV6_TUNNEL=y
-CONFIG_IPV6_MULTIPLE_TABLES=y
-CONFIG_IPV6_SUBTREES=y
-CONFIG_IPV6_MROUTE=y
-CONFIG_IPV6_PIMSM_V2=y
-CONFIG_NETFILTER_XT_TARGET_DSCP=y
-CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=y
-CONFIG_NF_CONNTRACK_IPV6=y
-CONFIG_IP6_NF_QUEUE=y
-CONFIG_IP6_NF_IPTABLES=y
-CONFIG_IP6_NF_MATCH_AH=y
-CONFIG_IP6_NF_MATCH_EUI64=y
-CONFIG_IP6_NF_MATCH_FRAG=y
-CONFIG_IP6_NF_MATCH_OPTS=y
-CONFIG_IP6_NF_MATCH_HL=y
-CONFIG_IP6_NF_MATCH_IPV6HEADER=y
-CONFIG_IP6_NF_MATCH_MH=y
-CONFIG_IP6_NF_MATCH_RT=y
-CONFIG_IP6_NF_TARGET_LOG=y
-CONFIG_IP6_NF_FILTER=y
-CONFIG_IP6_NF_TARGET_REJECT=y
-CONFIG_IP6_NF_MANGLE=y
-CONFIG_IP6_NF_TARGET_HL=y
-CONFIG_IP6_NF_RAW=y
-CONFIG_ANDROID_PARANOID_NETWORK=y
-# CONFIG_NETWORK_SECMARK is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_NETFILTER_ADVANCED=y
-
-#
-# Core Netfilter Configuration
-#
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_NETLINK_LOG is not set
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CT_ACCT=y
-CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-CONFIG_NF_CONNTRACK_FTP=y
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-CONFIG_NF_CONNTRACK_PPTP=y
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CT_NETLINK is not set
-CONFIG_NETFILTER_XTABLES=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_DCCP=y
-CONFIG_NETFILTER_XT_MATCH_DSCP=y
-CONFIG_NETFILTER_XT_MATCH_ESP=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-CONFIG_NETFILTER_XT_MATCH_REALM=y
-CONFIG_NETFILTER_XT_MATCH_SCTP=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_NF_CONNTRACK_PROC_COMPAT=y
-# CONFIG_IP_NF_QUEUE is not set
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_ADDRTYPE=y
-CONFIG_IP_NF_MATCH_RECENT=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_LOG=y
-# CONFIG_IP_NF_TARGET_ULOG is not set
-CONFIG_NF_NAT=y
-CONFIG_NF_NAT_NEEDED=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-CONFIG_NF_NAT_FTP=y
-# CONFIG_NF_NAT_IRC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_NAT_AMANDA is not set
-CONFIG_NF_NAT_PPTP=y
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_IP_NF_MANGLE is not set
-CONFIG_IP_NF_RAW=y
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-# CONFIG_DCB is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-CONFIG_BT=y
-CONFIG_BT_L2CAP=y
-CONFIG_BT_SCO=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-# CONFIG_BT_BNEP_MC_FILTER is not set
-# CONFIG_BT_BNEP_PROTO_FILTER is not set
-CONFIG_BT_HIDP=y
-
-#
-# Bluetooth device drivers
-#
-# CONFIG_BT_HCIBTSDIO is not set
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_BCSP is not set
-CONFIG_BT_HCIUART_LL=y
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_PHONET is not set
-CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
-CONFIG_WIRELESS_OLD_REGULATORY=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WIRELESS_EXT_SYSFS=y
-# CONFIG_LIB80211 is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_WIMAX is not set
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_PM is not set
-# CONFIG_RFKILL_INPUT is not set
-CONFIG_RFKILL_LEDS=y
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH=""
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_EXTRA_FIRMWARE=""
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-CONFIG_MTD_MSM_NAND=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=y
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-CONFIG_MISC_DEVICES=y
-CONFIG_ANDROID_PMEM=y
-# CONFIG_ICS932S401 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-CONFIG_KERNEL_DEBUGGER_CORE=y
-CONFIG_UID_STAT=y
-CONFIG_APANIC=y
-CONFIG_APANIC_PLABEL="crashdata"
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_93CX6 is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_DEBUG=y
-CONFIG_DM_CRYPT=y
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_DELAY is not set
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-CONFIG_TUN=y
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-CONFIG_SMC91X=y
-# CONFIG_DM9000 is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_DNET is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_B44 is not set
-CONFIG_NETDEV_1000=y
-CONFIG_NETDEV_10000=y
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-
-CONFIG_BCM4329=m
-CONFIG_BCM4329_FW_PATH="/system/etc/firmware/fw_bcm4329.bin"
-CONFIG_BCM4329_NVRAM_PATH="/proc/calibration"
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-#
-# CONFIG_WAN is not set
-CONFIG_PPP=y
-CONFIG_PPP_MULTILINK=y
-CONFIG_PPP_FILTER=y
-CONFIG_PPP_ASYNC=y
-# CONFIG_PPP_SYNC_TTY is not set
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_MPPE=y
-CONFIG_PPPOE=y
-CONFIG_PPPOL2TP=y
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-# CONFIG_SLIP is not set
-CONFIG_SLHC=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_MSM_RMNET=y
-CONFIG_MSM_RMNET_DEBUG=y
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-CONFIG_INPUT_CAPELLA_CM3602=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-CONFIG_INPUT_KEYRESET=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELAN_I2C_8232 is not set
-CONFIG_TOUCHSCREEN_TSSC_MANAGER=y
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI=y
-CONFIG_TOUCHSCREEN_MELFAS_I2C=y
-CONFIG_TOUCHSCREEN_ATMEL=y
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_ATI_REMOTE is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INPUT_CM109 is not set
-CONFIG_INPUT_UINPUT=y
-CONFIG_INPUT_GPIO=y
-CONFIG_INPUT_KEYCHORD=y
-CONFIG_INPUT_OPTICALJOYSTICK=y
-CONFIG_OPTICALJOYSTICK_CRUCIAL=y
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_DEVMEM is not set
-# CONFIG_DEVKMEM is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_MSM=y
-# CONFIG_SERIAL_MSM_CONSOLE is not set
-CONFIG_SERIAL_MSM_CLOCK_CONTROL=y
-CONFIG_SERIAL_MSM_RX_WAKEUP=y
-CONFIG_SERIAL_MSM_HS=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_DCC_TTY is not set
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_CHARDEV is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_GPIO is not set
-CONFIG_I2C_MSM=y
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_SIMTEC is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_STUB is not set
-
-#
-# Miscellaneous I2C Chip support
-#
-# CONFIG_DS1682 is not set
-# CONFIG_AT24 is not set
-# CONFIG_SENSORS_EEPROM is not set
-# CONFIG_SENSORS_PCF8574 is not set
-# CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_AKM8976 is not set
-CONFIG_SENSORS_AKM8973=y
-CONFIG_SENSORS_AKM8975=y
-CONFIG_SENSORS_BMA150_SPI=y
-# CONFIG_SENSORS_PCA963X is not set
-# CONFIG_SENSORS_MT9T013 is not set
-# CONFIG_SENSORS_MT9P012 is not set
-CONFIG_TPS65200=y
-CONFIG_MICROP_I2C=y
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CHIP is not set
-# CONFIG_SPI is not set
-# CONFIG_W1 is not set
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_BATTERY_DS2760 is not set
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_HWMON is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_WATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_PCF50633 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_MSM_CAMERA=y
-# Temp remove camera driver
-CONFIG_MT9T013=y
-#CONFIG_MT9P012=y
-#CONFIG_MT9D112=y
-#CONFIG_S5K4B2FX=y
-#CONFIG_S5K3E2FX=y
-CONFIG_S5K4E1GX=y
-# CONFIG_DVB_CORE is not set
-# CONFIG_VIDEO_MEDIA is not set
-
-#
-# Multimedia drivers
-#
-#CONFIG_MSM_CAMERA_FLASH is not set
-CONFIG_DAB=y
-
-#
-# Qualcomm MSM Camera And Video
-#
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-CONFIG_VIDEO_OUTPUT_CONTROL=y
-CONFIG_FB=y
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MB862XX is not set
-CONFIG_FB_MSM=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-# CONFIG_LOGO is not set
-# CONFIG_SOUND is not set
-CONFIG_HID_SUPPORT=y
-CONFIG_HID=y
-# CONFIG_HID_DEBUG is not set
-# CONFIG_HIDRAW is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-
-#
-# Enable Host or Gadget support to see Inventra options
-#
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# OTG and related infrastructure
-#
-
-#
-# USB Function Support
-#
-CONFIG_USB_FUNCTION=y
-CONFIG_USB_FUNCTION_MSM_HSUSB=y
-# CONFIG_USB_FUNCTION_NULL is not set
-# CONFIG_USB_FUNCTION_ZERO is not set
-# CONFIG_USB_FUNCTION_LOOPBACK is not set
-CONFIG_USB_FUNCTION_ADB=y
-# CONFIG_USB_FUNCTION_UMS is not set
-CONFIG_USB_FUNCTION_MASS_STORAGE=y
-CONFIG_USB_FUNCTION_DIAG=y
-CONFIG_USB_FUNCTION_ETHER=y
-CONFIG_USB_FUNCTION_MODEM=y
-CONFIG_USB_FUNCTION_PROJECTOR=y
-CONFIG_USB_FUNCTION_MTP_TUNNEL=y
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_MMC_UNSAFE_RESUME=y
-CONFIG_MMC_EMBEDDED_SDIO=y
-CONFIG_MMC_PARANOID_SD_INIT=y
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-# CONFIG_MMC_BLOCK_BOUNCE is not set
-CONFIG_MMC_BLOCK_PARANOID_RESUME=y
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-CONFIG_MMC_BUSCLK_PWRSAVE=y
-CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-# CONFIG_MMC_SDHCI is not set
-CONFIG_MMC_MSM7X00A=y
-# CONFIG_MMC_MSM7X00A_RESUME_IN_WQ is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_ACCESSIBILITY is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_PCA9532 is not set
-CONFIG_LEDS_GPIO=y
-# CONFIG_LEDS_CPLD is not set
-# CONFIG_LEDS_PCA955X is not set
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-CONFIG_LEDS_TRIGGER_SLEEP=y
-CONFIG_SWITCH=y
-CONFIG_SWITCH_GPIO=y
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-# CONFIG_RTC_INTF_SYSFS is not set
-# CONFIG_RTC_INTF_PROC is not set
-# CONFIG_RTC_INTF_DEV is not set
-CONFIG_RTC_INTF_ALARM=y
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-
-#
-# SPI RTC drivers
-#
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_CMOS is not set
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-
-#
-# on-CPU RTC drivers
-#
-CONFIG_RTC_DRV_MSM7XXX=y
-# CONFIG_DMADEVICES is not set
-# CONFIG_REGULATOR is not set
-# CONFIG_UIO is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_EXCLUDE_BUILD is not set
-# CONFIG_MEILHAUS is not set
-# CONFIG_ECHO is not set
-# CONFIG_COMEDI is not set
-
-#
-# Android
-#
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_RAM_CONSOLE=y
-CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
-# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
-CONFIG_ANDROID_TIMED_OUTPUT=y
-CONFIG_ANDROID_TIMED_GPIO=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-# CONFIG_BTPORT is not set
-# CONFIG_BTPORT_DRV is not set
-
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-# CONFIG_EXT2_FS_XIP is not set
-CONFIG_EXT3_FS=y
-CONFIG_EXT3_FS_XATTR=y
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-# CONFIG_EXT4_FS is not set
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-# CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_YAFFS_FS=y
-CONFIG_YAFFS_YAFFS1=y
-# CONFIG_YAFFS_9BYTE_TAGS is not set
-# CONFIG_YAFFS_DOES_ECC is not set
-CONFIG_YAFFS_YAFFS2=y
-CONFIG_YAFFS_AUTO_YAFFS2=y
-# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
-# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
-# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
-CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
-# CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFSD is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_UNUSED_SYMBOLS is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-CONFIG_DETECT_SOFTLOCKUP=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
-CONFIG_SCHEDSTATS=y
-CONFIG_TIMER_STATS=y
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SLAB_LEAK is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-CONFIG_DEBUG_MUTEXES=y
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO=y
-CONFIG_DEBUG_VM=y
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_LIST is not set
-CONFIG_DEBUG_SG=y
-# CONFIG_DEBUG_NOTIFIERS is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-# CONFIG_RCU_CPU_STALL_DETECTOR is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_LATENCYTOP is not set
-CONFIG_HAVE_FUNCTION_TRACER=y
-
-#
-# Tracers
-#
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_BOOT_TRACER is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-# CONFIG_STACK_TRACER is not set
-# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-# CONFIG_DEBUG_USER is not set
-# CONFIG_DEBUG_ERRORS is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_LL is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_FIPS is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_GF128MUL is not set
-CONFIG_CRYPTO_NULL=y
-# CONFIG_CRYPTO_CRYPTD is not set
-# CONFIG_CRYPTO_AUTHENC is not set
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-# CONFIG_CRYPTO_ECB is not set
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_MD4 is not set
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_ARC4 is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_TWOFISH_COMMON=y
-
-#
-# Compression
-#
-CONFIG_CRYPTO_DEFLATE=y
-# CONFIG_CRYPTO_LZO is not set
-
-#
-# Random Number Generation
-#
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRYPTO_HW=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_FIND_LAST_BIT=y
-CONFIG_CRC_CCITT=y
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_REED_SOLOMON=y
-CONFIG_REED_SOLOMON_ENC8=y
-CONFIG_REED_SOLOMON_DEC8=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/msm7227_defconfig b/arch/arm/configs/msm7227_defconfig
deleted file mode 100644
index 23fa8f4..0000000
--- a/arch/arm/configs/msm7227_defconfig
+++ /dev/null
@@ -1,1673 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29
-# Tue Aug 11 18:48:25 2009
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
-CONFIG_OPROFILE_ARMV6=y
-CONFIG_OPROFILE_ARM11_CORE=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_CLASSIC_RCU=y
-# CONFIG_TREE_RCU is not set
-# CONFIG_PREEMPT_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_PREEMPT_RCU_TRACE is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_GROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-# CONFIG_USER_SCHED is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-# CONFIG_CGROUP_NS is not set
-CONFIG_CGROUP_FREEZER=y
-# CONFIG_CGROUP_DEVICE is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_CGROUP_MEM_RES_CTLR is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-# CONFIG_ELF_CORE is not set
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_ASHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_COMPAT_BRK=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-CONFIG_PROFILING=y
-# CONFIG_TRACEPOINTS is not set
-# CONFIG_MARKERS is not set
-CONFIG_OPROFILE=y
-CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-# CONFIG_IOSCHED_CFQ is not set
-# CONFIG_DEFAULT_AS is not set
-CONFIG_DEFAULT_DEADLINE=y
-# CONFIG_DEFAULT_CFQ is not set
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="deadline"
-CONFIG_FREEZER=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KIRKWOOD is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-# CONFIG_ARCH_LOKI is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-CONFIG_ARCH_MSM=y
-# CONFIG_ARCH_W90X900 is not set
-# CONFIG_ARCH_MSM7200A is not set
-# CONFIG_ARCH_MSM7201A is not set
-# CONFIG_ARCH_MSM7225 is not set
-CONFIG_ARCH_MSM7227=y
-# CONFIG_ARCH_MSM7501A is not set
-CONFIG_ARCH_MSM_ARM11=y
-CONFIG_MSM_MDP31=y
-# CONFIG_MSM_AMSS_VERSION_4725 is not set
-CONFIG_MSM_AMSS_VERSION_4735=y
-CONFIG_MSM_DEBUG_UART_NONE=y
-# CONFIG_MSM_DEBUG_UART1 is not set
-# CONFIG_MSM_DEBUG_UART2 is not set
-# CONFIG_MSM_DEBUG_UART3 is not set
-
-#
-# MSM Board Type
-#
-CONFIG_MACH_LEGEND=y
-CONFIG_MACH_LATTE=y
-CONFIG_MACH_LIBERTY=y
-CONFIG_HTC_BATTCHG=y
-CONFIG_HTC_BATTCHG_SMEM=y
-CONFIG_HTC_HEADSET=y
-CONFIG_MICROP_COMMON=y
-CONFIG_LIGHTSENSOR_MICROP=y
-# CONFIG_TROUT_BATTCHG is not set
-CONFIG_HTC_PWRSINK=y
-CONFIG_HTC_SLEEP_MODE_GPIO_DUMP=y
-CONFIG_HTC_POWER_COLLAPSE_MAGIC=y
-CONFIG_SMEM_RPC_SERVER_STATE=y
-CONFIG_CACHE_FLUSH_RANGE_LIMIT=0x40000
-CONFIG_MSM7X00A_USE_GP_TIMER=y
-# CONFIG_MSM7X00A_USE_DG_TIMER is not set
-CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
-# CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_SLEEP_MODE=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE=1
-CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
-CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
-CONFIG_MSM_SWFI_LATENCY=5000
-CONFIG_MSM_APPS_SLEEP_LATENCY=50000
-CONFIG_MSM_POWER_COLLAPSE_LATENCY=100000
-CONFIG_MSM_TCXO_SHUTDOWN_LATENCY=150000
-CONFIG_MSM_IDLE_STATS=y
-CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
-CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
-CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
-CONFIG_MSM_SUSPEND_STATS_FIRST_BUCKET=1000000000
-CONFIG_MSM_FIQ_SUPPORT=y
-CONFIG_MSM_SERIAL_DEBUGGER=y
-# CONFIG_MSM_SERIAL_DEBUGGER_CONSOLE is not set
-CONFIG_MSM_SMD=y
-# CONFIG_MSM_SMD_PKG3 is not set
-CONFIG_MSM_SMD_PKG4=y
-CONFIG_MSM_N_WAY_SMD=y
-CONFIG_MSM_RESET_MODEM=m
-CONFIG_MSM_ONCRPCROUTER=y
-CONFIG_MSM_ONCRPCROUTER_DEBUG=y
-# CONFIG_MSM_RPCSERVERS is not set
-# CONFIG_MSM_CPU_FREQ_USERSPACE is not set
-# CONFIG_MSM_CPU_FREQ_MSM7K is not set
-# CONFIG_MSM_CPU_FREQ_SCREEN is not set
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX=600000
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN=245760
-# CONFIG_MSM_HW3D is not set
-# CONFIG_TROUT_H2W is not set
-CONFIG_HTC_35MM_REMOTE=y
-CONFIG_HTC_AUDIOJACK=y
-CONFIG_HTC_ACOUSTIC=y
-# CONFIG_OLD_HTC_ACOUSTIC is not set
-CONFIG_WIFI_NVS_PROC_CREATE=y
-CONFIG_WIFI_CONTROL_FUNC=y
-CONFIG_WIFI_MEM_PREALLOC=y
-CONFIG_WIFI_TI_1271=y
-CONFIG_MMC_SUPPORT_EXTERNEL_DRIVER=y
-CONFIG_ARCH_MSM_FLASHLIGHT=y
-CONFIG_SMD_OFFSET_TCXO_STAT=0xFC2A0
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_V6=y
-# CONFIG_CPU_32v6K is not set
-CONFIG_CPU_32v6=y
-CONFIG_CPU_ABRT_EV6=y
-CONFIG_CPU_PABRT_NOIFAR=y
-CONFIG_CPU_CACHE_V6=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V6=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-CONFIG_OUTER_CACHE=y
-CONFIG_CACHE_L2X0=y
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_1G is not set
-CONFIG_PAGE_OFFSET=0xC0000000
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-CONFIG_ARCH_FLATMEM_HAS_HOLES=y
-# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
-# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=0
-CONFIG_VIRT_TO_BUS=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
-CONFIG_UNEVICTABLE_LRU=y
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="mem=75M console=ttyMSM2,115200n8"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# CPU Power Management
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-# CONFIG_CPU_FREQ_DEBUG is not set
-CONFIG_CPU_FREQ_STAT=y
-# CONFIG_CPU_FREQ_STAT_DETAILS is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_MIN_TICKS=1
-CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
-CONFIG_PERFLOCK=y
-CONFIG_PERFLOCK_BOOT_LOCK=y
-CONFIG_PERFLOCK_SCREEN_POLICY=y
-CONFIG_PERFLOCK_SCREEN_ON_MIN=480000
-# CONFIG_PERFLOCK_SCREEN_ON_MAX is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MAX is not set
-# CONFIG_CPU_IDLE is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-CONFIG_VFP=y
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_HAVE_AOUT=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-CONFIG_HAS_WAKELOCK=y
-CONFIG_HAS_EARLYSUSPEND=y
-CONFIG_WAKELOCK=y
-CONFIG_WAKELOCK_STAT=y
-CONFIG_USER_WAKELOCK=y
-CONFIG_EARLYSUSPEND=y
-# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
-# CONFIG_CONSOLE_EARLYSUSPEND is not set
-CONFIG_FB_EARLYSUSPEND=y
-# CONFIG_APM_EMULATION is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_COMPAT_NET_DEV_OPS=y
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_ASK_IP_FIB_HASH=y
-# CONFIG_IP_FIB_TRIE is not set
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_MULTIPLE_TABLES=y
-# CONFIG_IP_ROUTE_MULTIPATH is not set
-CONFIG_IP_ROUTE_VERBOSE=y
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-CONFIG_INET_ESP=y
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-CONFIG_XFRM_IPCOMP=y
-CONFIG_IPV6=y
-CONFIG_IPV6_PRIVACY=y
-CONFIG_IPV6_ROUTER_PREF=y
-CONFIG_IPV6_ROUTE_INFO=y
-CONFIG_IPV6_OPTIMISTIC_DAD=y
-CONFIG_INET6_AH=y
-CONFIG_INET6_ESP=y
-CONFIG_INET6_IPCOMP=y
-CONFIG_IPV6_MIP6=y
-CONFIG_INET6_XFRM_TUNNEL=y
-CONFIG_INET6_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_TRANSPORT=y
-CONFIG_INET6_XFRM_MODE_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_BEET=y
-CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=y
-CONFIG_IPV6_SIT=y
-CONFIG_IPV6_NDISC_NODETYPE=y
-CONFIG_IPV6_TUNNEL=y
-CONFIG_IPV6_MULTIPLE_TABLES=y
-CONFIG_IPV6_SUBTREES=y
-CONFIG_IPV6_MROUTE=y
-CONFIG_IPV6_PIMSM_V2=y
-CONFIG_NETFILTER_XT_TARGET_DSCP=y
-CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=y
-CONFIG_NF_CONNTRACK_IPV6=y
-CONFIG_IP6_NF_QUEUE=y
-CONFIG_IP6_NF_IPTABLES=y
-CONFIG_IP6_NF_MATCH_AH=y
-CONFIG_IP6_NF_MATCH_EUI64=y
-CONFIG_IP6_NF_MATCH_FRAG=y
-CONFIG_IP6_NF_MATCH_OPTS=y
-CONFIG_IP6_NF_MATCH_HL=y
-CONFIG_IP6_NF_MATCH_IPV6HEADER=y
-CONFIG_IP6_NF_MATCH_MH=y
-CONFIG_IP6_NF_MATCH_RT=y
-CONFIG_IP6_NF_TARGET_LOG=y
-CONFIG_IP6_NF_FILTER=y
-CONFIG_IP6_NF_TARGET_REJECT=y
-CONFIG_IP6_NF_MANGLE=y
-CONFIG_IP6_NF_TARGET_HL=y
-CONFIG_IP6_NF_RAW=y
-CONFIG_ANDROID_PARANOID_NETWORK=y
-# CONFIG_NETWORK_SECMARK is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_NETFILTER_ADVANCED=y
-
-#
-# Core Netfilter Configuration
-#
-CONFIG_NETFILTER_NETLINK=y
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-CONFIG_NETFILTER_NETLINK_LOG=y
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CT_ACCT=y
-CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-CONFIG_NF_CONNTRACK_FTP=y
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_PPTP is not set
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CT_NETLINK is not set
-CONFIG_NETFILTER_XTABLES=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_DCCP=y
-CONFIG_NETFILTER_XT_MATCH_DSCP=y
-CONFIG_NETFILTER_XT_MATCH_ESP=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-CONFIG_NETFILTER_XT_MATCH_REALM=y
-# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
-CONFIG_NETFILTER_XT_MATCH_SCTP=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-# CONFIG_IP_VS is not set
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_NF_DEFRAG_IPV4=y
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_NF_CONNTRACK_PROC_COMPAT=y
-# CONFIG_IP_NF_QUEUE is not set
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_ADDRTYPE=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_LOG=y
-# CONFIG_IP_NF_TARGET_ULOG is not set
-CONFIG_NF_NAT=y
-CONFIG_NF_NAT_NEEDED=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-CONFIG_NF_NAT_FTP=y
-# CONFIG_NF_NAT_IRC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_NAT_AMANDA is not set
-# CONFIG_NF_NAT_PPTP is not set
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_IP_NF_MANGLE is not set
-CONFIG_IP_NF_RAW=y
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-CONFIG_NET_CLS_ROUTE=y
-# CONFIG_DCB is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-CONFIG_BT=y
-CONFIG_BT_L2CAP=y
-CONFIG_BT_SCO=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-# CONFIG_BT_BNEP_MC_FILTER is not set
-# CONFIG_BT_BNEP_PROTO_FILTER is not set
-CONFIG_BT_HIDP=y
-
-#
-# Bluetooth device drivers
-#
-# CONFIG_BT_HCIBTSDIO is not set
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_BCSP is not set
-CONFIG_BT_HCIUART_LL=y
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_PHONET is not set
-CONFIG_FIB_RULES=y
-CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
-CONFIG_WIRELESS_OLD_REGULATORY=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WIRELESS_EXT_SYSFS=y
-# CONFIG_LIB80211 is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_WIMAX is not set
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_PM is not set
-# CONFIG_RFKILL_INPUT is not set
-CONFIG_RFKILL_LEDS=y
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH=""
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_EXTRA_FIRMWARE=""
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-CONFIG_MTD_MSM_NAND=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=y
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-CONFIG_MISC_DEVICES=y
-CONFIG_ANDROID_PMEM=y
-# CONFIG_ICS932S401 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-CONFIG_KERNEL_DEBUGGER_CORE=y
-CONFIG_UID_STAT=y
-# CONFIG_WL127X_RFKILL is not set
-CONFIG_APANIC=y
-CONFIG_APANIC_PLABEL="crashdata"
-CONFIG_SENSORS_BMA150_SPI=y
-# CONFIG_PROXIMITYSENSOR is not set
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_93CX6 is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_DEBUG=y
-CONFIG_DM_CRYPT=y
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_DELAY is not set
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-CONFIG_SMC91X=y
-# CONFIG_DM9000 is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_DNET is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_B44 is not set
-CONFIG_NETDEV_1000=y
-CONFIG_NETDEV_10000=y
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-CONFIG_BCM4329=m
-CONFIG_BCM4329_FW_PATH="/system/etc/firmware/fw_bcm4329.bin"
-CONFIG_BCM4329_NVRAM_PATH="/proc/calibration"
-
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-#
-# CONFIG_WAN is not set
-CONFIG_PPP=y
-# CONFIG_PPP_MULTILINK is not set
-# CONFIG_PPP_FILTER is not set
-CONFIG_PPP_ASYNC=y
-# CONFIG_PPP_SYNC_TTY is not set
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_MPPE=y
-# CONFIG_PPPOE is not set
-# CONFIG_PPPOL2TP is not set
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-# CONFIG_SLIP is not set
-CONFIG_SLHC=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_MSM_RMNET=y
-CONFIG_MSM_RMNET_DEBUG=y
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-CONFIG_INPUT_CAPELLA_CM3602=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-CONFIG_INPUT_KEYRESET=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_ATMEL=y
-# CONFIG_TOUCHSCREEN_CYPRESS_TMG is not set
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELAN_I2C_8232 is not set
-# CONFIG_TOUCHSCREEN_TSSC_MANAGER is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_MSM is not set
-CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI=y
-# CONFIG_TOUCHSCREEN_SYNAPTICS_T1007 is not set
-CONFIG_TOUCHSCREEN_SYNAPTICS_T1021=y
-# CONFIG_TOUCHSCREEN_COMPATIBLE_REPORT is not set
-CONFIG_TOUCHSCREEN_CONCATENATE_REPORT=y
-CONFIG_TOUCHSCREEN_DUPLICATED_FILTER=y
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_ATI_REMOTE is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INPUT_CM109 is not set
-CONFIG_INPUT_UINPUT=y
-CONFIG_INPUT_GPIO=y
-CONFIG_INPUT_KEYCHORD=y
-CONFIG_INPUT_OPTICALJOYSTICK=y
-CONFIG_OPTICALJOYSTICK_CRUCIAL=y
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_DEVMEM is not set
-# CONFIG_DEVKMEM is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_MSM=y
-# CONFIG_SERIAL_MSM_CONSOLE is not set
-CONFIG_SERIAL_MSM_CLOCK_CONTROL=y
-CONFIG_SERIAL_MSM_RX_WAKEUP=y
-CONFIG_SERIAL_MSM_HS=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_DCC_TTY is not set
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_CHARDEV is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_GPIO is not set
-CONFIG_I2C_MSM=y
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_SIMTEC is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_STUB is not set
-
-#
-# Miscellaneous I2C Chip support
-#
-# CONFIG_DS1682 is not set
-# CONFIG_SENSORS_PCF8574 is not set
-# CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_AKM8976 is not set
-CONFIG_SENSORS_AKM8973=y
-# CONFIG_SENSORS_BMA150 is not set
-# CONFIG_SENSORS_PCA963X is not set
-# CONFIG_SENSORS_MT9T013 is not set
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CHIP is not set
-# CONFIG_SPI is not set
-# CONFIG_W1 is not set
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_BATTERY_DS2760 is not set
-# CONFIG_BATTERY_DS2784 is not set
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_HWMON is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_WATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_PCF50633 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_VIDEO_V4L2_COMMON=y
-CONFIG_VIDEO_ALLOW_V4L1=y
-CONFIG_VIDEO_V4L1_COMPAT=y
-# CONFIG_DVB_CORE is not set
-CONFIG_VIDEO_MEDIA=y
-
-#
-# Multimedia drivers
-#
-# CONFIG_MEDIA_ATTACH is not set
-CONFIG_MEDIA_TUNER=y
-# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
-CONFIG_MEDIA_TUNER_SIMPLE=y
-CONFIG_MEDIA_TUNER_TDA8290=y
-CONFIG_MEDIA_TUNER_TDA9887=y
-CONFIG_MEDIA_TUNER_TEA5761=y
-CONFIG_MEDIA_TUNER_TEA5767=y
-CONFIG_MEDIA_TUNER_MT20XX=y
-CONFIG_MEDIA_TUNER_XC2028=y
-CONFIG_MEDIA_TUNER_XC5000=y
-CONFIG_VIDEO_V4L2=y
-CONFIG_VIDEO_V4L1=y
-CONFIG_VIDEO_CAPTURE_DRIVERS=y
-# CONFIG_VIDEO_ADV_DEBUG is not set
-# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
-CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
-# CONFIG_VIDEO_VIVI is not set
-# CONFIG_VIDEO_CPIA is not set
-# CONFIG_VIDEO_SAA5246A is not set
-# CONFIG_VIDEO_SAA5249 is not set
-# CONFIG_SOC_CAMERA is not set
-
-#
-# Qualcomm MSM Camera And Video
-#
-CONFIG_MSM_CAMERA=y
-# CONFIG_MSM_CAMERA_DEBUG is not set
-CONFIG_MSM_CAMERA_FLASH=y
-
-#
-# Camera Sensor Selection
-#
-# CONFIG_MT9T013 is not set
-# CONFIG_MT9D112 is not set
-# CONFIG_MT9P012 is not set
-# CONFIG_S5K3E2FX is not set
-CONFIG_S5K4E1GX=y
-
-#
-# Qualcomm MSM Camera And Video-QCT
-#
-
-#
-# Camera Sensor Selection
-#
-CONFIG_RADIO_ADAPTERS=y
-# CONFIG_RADIO_TEA5764 is not set
-CONFIG_DAB=y
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-CONFIG_VIDEO_OUTPUT_CONTROL=y
-CONFIG_FB=y
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MB862XX is not set
-CONFIG_FB_MSM=y
-CONFIG_FB_MSM_LCDC=y
-CONFIG_GPU_MSM_KGSL=y
-CONFIG_MSM_KGSL_MMU=y
-CONFIG_FB_565=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-# CONFIG_LOGO is not set
-# CONFIG_SOUND is not set
-CONFIG_HID_SUPPORT=y
-CONFIG_HID=y
-# CONFIG_HID_DEBUG is not set
-# CONFIG_HIDRAW is not set
-# CONFIG_HID_PID is not set
-
-#
-# Special HID drivers
-#
-CONFIG_HID_COMPAT=y
-# CONFIG_HID_APPLE is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-
-#
-# Enable Host or Gadget support to see Inventra options
-#
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# OTG and related infrastructure
-#
-
-#
-# USB Function Support
-#
-CONFIG_USB_FUNCTION=y
-CONFIG_USB_FUNCTION_MSM_HSUSB=y
-# CONFIG_USB_FUNCTION_NULL is not set
-# CONFIG_USB_FUNCTION_ZERO is not set
-# CONFIG_USB_FUNCTION_LOOPBACK is not set
-CONFIG_USB_FUNCTION_ADB=y
-# CONFIG_USB_FUNCTION_UMS is not set
-CONFIG_USB_FUNCTION_MASS_STORAGE=y
-CONFIG_USB_FUNCTION_DIAG=y
-CONFIG_USB_FUNCTION_ETHER=y
-CONFIG_USB_FUNCTION_RNDIS=y
-# CONFIG_USB_FUNCTION_FSYNC is not set
-# CONFIG_USB_FUNCTION_SERIAL is not set
-CONFIG_USB_FUNCTION_PROJECTOR=y
-CONFIG_USB_FUNCTION_MODEM=y
-CONFIG_USB_FUNCTION_MTP_TUNNEL=y
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_MMC_UNSAFE_RESUME=y
-CONFIG_MMC_EMBEDDED_SDIO=y
-CONFIG_MMC_PARANOID_SD_INIT=y
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-# CONFIG_MMC_BLOCK_BOUNCE is not set
-CONFIG_MMC_BLOCK_PARANOID_RESUME=y
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-CONFIG_MMC_TI_SDIO_ADAPT=y
-CONFIG_MMC_BUSCLK_PWRSAVE=y
-CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-# CONFIG_MMC_SDHCI is not set
-CONFIG_MMC_MSM7X00A=y
-# CONFIG_MEMSTICK is not set
-# CONFIG_ACCESSIBILITY is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_PCA9532 is not set
-CONFIG_LEDS_GPIO=y
-# CONFIG_LEDS_CPLD is not set
-# CONFIG_LEDS_PCA955X is not set
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-CONFIG_LEDS_TRIGGER_SLEEP=y
-CONFIG_SWITCH=y
-CONFIG_SWITCH_GPIO=y
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-# CONFIG_RTC_INTF_SYSFS is not set
-# CONFIG_RTC_INTF_PROC is not set
-# CONFIG_RTC_INTF_DEV is not set
-CONFIG_RTC_INTF_ALARM=y
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-
-#
-# SPI RTC drivers
-#
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_CMOS is not set
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-
-#
-# on-CPU RTC drivers
-#
-CONFIG_RTC_DRV_MSM7X00A=y
-# CONFIG_DMADEVICES is not set
-# CONFIG_REGULATOR is not set
-# CONFIG_UIO is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_EXCLUDE_BUILD is not set
-# CONFIG_MEILHAUS is not set
-# CONFIG_ECHO is not set
-# CONFIG_COMEDI is not set
-
-#
-# Android
-#
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_RAM_CONSOLE=y
-CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
-# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
-CONFIG_ANDROID_TIMED_OUTPUT=y
-CONFIG_ANDROID_TIMED_GPIO=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-# CONFIG_BTPORT is not set
-# CONFIG_BTPORT_DRV is not set
-
-CONFIG_LS_ALG=y
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-# CONFIG_EXT2_FS_XIP is not set
-CONFIG_EXT3_FS=y
-CONFIG_EXT3_FS_XATTR=y
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-# CONFIG_EXT4_FS is not set
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-CONFIG_FUSE_FS=y
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-# CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_YAFFS_FS=y
-CONFIG_YAFFS_YAFFS1=y
-# CONFIG_YAFFS_9BYTE_TAGS is not set
-# CONFIG_YAFFS_DOES_ECC is not set
-CONFIG_YAFFS_YAFFS2=y
-CONFIG_YAFFS_AUTO_YAFFS2=y
-# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
-# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
-# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
-CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
-# CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFSD is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_UNUSED_SYMBOLS is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-CONFIG_DETECT_SOFTLOCKUP=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
-CONFIG_SCHEDSTATS=y
-CONFIG_TIMER_STATS=y
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SLAB_LEAK is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-CONFIG_DEBUG_MUTEXES=y
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_STACKTRACE is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO=y
-CONFIG_DEBUG_VM=y
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_LIST is not set
-CONFIG_DEBUG_SG=y
-# CONFIG_DEBUG_NOTIFIERS is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-# CONFIG_RCU_CPU_STALL_DETECTOR is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_LATENCYTOP is not set
-CONFIG_HAVE_FUNCTION_TRACER=y
-
-#
-# Tracers
-#
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_BOOT_TRACER is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-# CONFIG_STACK_TRACER is not set
-# CONFIG_FTRACE_STARTUP_TEST is not set
-# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-# CONFIG_DEBUG_USER is not set
-# CONFIG_DEBUG_ERRORS is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_LL is not set
-# CONFIG_DEBUG_ICEDCC is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_FIPS is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-# CONFIG_CRYPTO_AUTHENC is not set
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-# CONFIG_CRYPTO_ECB is not set
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_MD4 is not set
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_ARC4 is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_TWOFISH_COMMON=y
-
-#
-# Compression
-#
-CONFIG_CRYPTO_DEFLATE=y
-# CONFIG_CRYPTO_LZO is not set
-
-#
-# Random Number Generation
-#
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRYPTO_HW=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_FIND_LAST_BIT=y
-CONFIG_CRC_CCITT=y
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_REED_SOLOMON=y
-CONFIG_REED_SOLOMON_ENC8=y
-CONFIG_REED_SOLOMON_DEC8=y
-CONFIG_TEXTSEARCH=y
-CONFIG_TEXTSEARCH_KMP=y
-CONFIG_TEXTSEARCH_BM=y
-CONFIG_TEXTSEARCH_FSM=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/paradise_defconfig b/arch/arm/configs/paradise_defconfig
deleted file mode 100644
index a8f1d07..0000000
--- a/arch/arm/configs/paradise_defconfig
+++ /dev/null
@@ -1,1545 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29
-# Mon Apr 20 10:57:11 2009
-#
-
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ARCH_SUPPORTS_AOUT=y
-CONFIG_ZONE_DMA=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
-CONFIG_OPROFILE_ARMV6=y
-CONFIG_OPROFILE_ARM11_CORE=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_CLASSIC_RCU=y
-# CONFIG_TREE_RCU is not set
-# CONFIG_PREEMPT_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_PREEMPT_RCU_TRACE is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_GROUP_SCHED=y
-CONFIG_CGROUPS=y
-CONFIG_FAIR_GROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-# CONFIG_USER_SCHED is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_CGROUP_DEBUG=y
-# CONFIG_CGROUP_NS is not set
-CONFIG_CGROUP_FREEZER=y
-# CONFIG_CGROUP_DEVICE is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_CGROUP_MEM_RES_CTLR is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-# CONFIG_ELF_CORE is not set
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_ASHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_COMPAT_BRK=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-# CONFIG_PROFILING is not set
-CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-# CONFIG_IOSCHED_CFQ is not set
-# CONFIG_DEFAULT_AS is not set
-CONFIG_DEFAULT_DEADLINE=y
-# CONFIG_DEFAULT_CFQ is not set
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="deadline"
-CONFIG_FREEZER=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KIRKWOOD is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-# CONFIG_ARCH_LOKI is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-CONFIG_ARCH_MSM=y
-# CONFIG_ARCH_W90X900 is not set
-
-#
-# Boot options
-#
-
-#
-# Qualcomm MSM7K Implementations
-#
-# CONFIG_ARCH_MSM7201A is not set
-CONFIG_ARCH_MSM7225=y
-# CONFIG_ARCH_MSM7501A is not set
-CONFIG_MSM_MDP22=y
-
-CONFIG_MSM_AMSS_VERSION_1355=y
-CONFIG_MSM_DEBUG_UART_NONE=y
-# CONFIG_MSM_DEBUG_UART1 is not set
-# CONFIG_MSM_DEBUG_UART2 is not set
-# CONFIG_MSM_DEBUG_UART3 is not set
-
-#
-# Power management
-#
-CONFIG_TURBO_MODE=y
-#
-# MSM Board Type
-#
-# CONFIG_MACH_HTCJADE is not set
-# CONFIG_MACH_MEMPHIS is not set
-CONFIG_MACH_PARADISE=y
-CONFIG_HTC_BATTCHG=y
-CONFIG_HTC_BATTCHG_SMEM=y
-CONFIG_HTC_HEADSET=y
-CONFIG_MICROP_COMMON=y
-CONFIG_LIGHTSENSOR_MICROP=y
-CONFIG_HTC_PWRSINK=y
-CONFIG_HTC_SLEEP_MODE_GPIO_DUMP=y
-
-CONFIG_MSM7XXX_USE_GP_TIMER=y
-# CONFIG_MSM7XXX_USE_DG_TIMER is not set
-CONFIG_MSM7XXX_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
-# CONFIG_MSM7XXX_SLEEP_MODE_POWER_COLLAPSE is not set
-# CONFIG_MSM7XXX_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7XXX_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7XXX_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7XXX_SLEEP_MODE=0
-# CONFIG_MSM7XXX_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
-CONFIG_MSM7XXX_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
-# CONFIG_MSM7XXX_IDLE_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7XXX_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7XXX_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7XXX_IDLE_SLEEP_MODE=1
-CONFIG_MSM7XXX_IDLE_SLEEP_MIN_TIME=20000000
-CONFIG_MSM7XXX_IDLE_SPIN_TIME=80000
-CONFIG_MSM_IDLE_STATS=y
-CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
-CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
-CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
-CONFIG_MSM_FIQ_SUPPORT=y
-CONFIG_MSM_SERIAL_DEBUGGER=y
-# CONFIG_MSM_SERIAL_DEBUGGER_CONSOLE is not set
-CONFIG_MSM_SMD=y
-CONFIG_MSM_ONCRPCROUTER=y
-CONFIG_MSM_RPCSERVERS=y
-# CONFIG_MSM_CPU_FREQ_MSM7K is not set
-# CONFIG_MSM_CPU_FREQ_SCREEN is not set
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX=528000
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN=245760
-# CONFIG_MSM_HW3D is not set
-CONFIG_HTC_AUDIOJACK=y
-CONFIG_WIFI_NVS_PROC_CREATE=y
-CONFIG_WIFI_CONTROL_FUNC=y
-CONFIG_WIFI_MEM_PREALLOC=y
-CONFIG_ARCH_MSM_FLASHLIGHT=y
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_V6=y
-# CONFIG_CPU_32v6K is not set
-CONFIG_CPU_32v6=y
-CONFIG_CPU_ABRT_EV6=y
-CONFIG_CPU_PABRT_NOIFAR=y
-CONFIG_CPU_CACHE_V6=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V6=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_1G is not set
-CONFIG_PAGE_OFFSET=0xC0000000
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-CONFIG_ARCH_FLATMEM_HAS_HOLES=y
-CONFIG_HOLES_IN_ZONE=y
-# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
-# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=0
-CONFIG_VIRT_TO_BUS=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
-CONFIG_UNEVICTABLE_LRU=y
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="mem=75M console=ttyMSM2,115200n8"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# CPU Frequency scaling
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-# CONFIG_CPU_FREQ_DEBUG is not set
-CONFIG_CPU_FREQ_STAT=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_MSM7K is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-CONFIG_CPU_FREQ_GOV_MSM7K=y
-CONFIG_CPU_FREQ_MIN_TICKS=1
-CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
-CONFIG_PERFLOCK=y
-CONFIG_PERFLOCK_BOOT_LOCK=y
-CONFIG_PERFLOCK_SCREEN_POLICY=y
-CONFIG_PERFLOCK_SCREEN_ON_MIN=528000
-# CONFIG_PERFLOCK_SCREEN_ON_MAX is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MAX is not set
-
-#
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-# CONFIG_VFP is not set
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_HAVE_AOUT=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-CONFIG_HAS_WAKELOCK=y
-CONFIG_HAS_EARLYSUSPEND=y
-CONFIG_WAKELOCK=y
-CONFIG_WAKELOCK_STAT=y
-CONFIG_USER_WAKELOCK=y
-CONFIG_EARLYSUSPEND=y
-# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
-# CONFIG_CONSOLE_EARLYSUSPEND is not set
-CONFIG_FB_EARLYSUSPEND=y
-# CONFIG_APM_EMULATION is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_COMPAT_NET_DEV_OPS=y
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_ASK_IP_FIB_HASH=y
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_VERBOSE=y
-CONFIG_FIB_RULES=y
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-CONFIG_INET_AH=y
-CONFIG_INET_ESP=y
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-CONFIG_INET_XFRM_MODE_TUNNEL=y
-CONFIG_INET_XFRM_MODE_BEET=y
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-CONFIG_ANDROID_PARANOID_NETWORK=y
-# CONFIG_NETWORK_SECMARK is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_NETFILTER_ADVANCED=y
-
-#
-# Core Netfilter Configuration
-#
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_NETLINK_LOG is not set
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CT_ACCT=y
-CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-CONFIG_NF_CONNTRACK_FTP=y
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-CONFIG_NF_CONNTRACK_PPTP=y
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CT_NETLINK is not set
-CONFIG_NETFILTER_XTABLES=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_DCCP=y
-CONFIG_NETFILTER_XT_MATCH_DSCP=y
-CONFIG_NETFILTER_XT_MATCH_ESP=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-CONFIG_NETFILTER_XT_MATCH_REALM=y
-CONFIG_NETFILTER_XT_MATCH_SCTP=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_NF_CONNTRACK_PROC_COMPAT=y
-# CONFIG_IP_NF_QUEUE is not set
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_ADDRTYPE=y
-CONFIG_IP_NF_MATCH_RECENT=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_LOG=y
-# CONFIG_IP_NF_TARGET_ULOG is not set
-CONFIG_NF_NAT=y
-CONFIG_NF_NAT_NEEDED=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-CONFIG_NF_NAT_FTP=y
-# CONFIG_NF_NAT_IRC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_NAT_AMANDA is not set
-CONFIG_NF_NAT_PPTP=y
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_IP_NF_MANGLE is not set
-CONFIG_IP_NF_RAW=y
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-# CONFIG_DCB is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-CONFIG_BT=y
-CONFIG_BT_L2CAP=y
-CONFIG_BT_SCO=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-# CONFIG_BT_BNEP_MC_FILTER is not set
-# CONFIG_BT_BNEP_PROTO_FILTER is not set
-CONFIG_BT_HIDP=y
-
-#
-# Bluetooth device drivers
-#
-# CONFIG_BT_HCIBTSDIO is not set
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_BCSP is not set
-CONFIG_BT_HCIUART_LL=y
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_PHONET is not set
-CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
-CONFIG_WIRELESS_OLD_REGULATORY=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WIRELESS_EXT_SYSFS=y
-# CONFIG_LIB80211 is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_WIMAX is not set
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_PM is not set
-# CONFIG_RFKILL_INPUT is not set
-CONFIG_RFKILL_LEDS=y
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH=""
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_EXTRA_FIRMWARE=""
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-CONFIG_MTD_MSM_NAND=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=y
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-CONFIG_MISC_DEVICES=y
-CONFIG_ANDROID_PMEM=y
-# CONFIG_ICS932S401 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-CONFIG_KERNEL_DEBUGGER_CORE=y
-CONFIG_UID_STAT=y
-CONFIG_APANIC=y
-CONFIG_APANIC_PLABEL="crashdata"
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_93CX6 is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_DEBUG=y
-CONFIG_DM_CRYPT=y
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_DELAY is not set
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-CONFIG_TUN=y
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-CONFIG_SMC91X=y
-# CONFIG_DM9000 is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_DNET is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_B44 is not set
-CONFIG_NETDEV_1000=y
-CONFIG_NETDEV_10000=y
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-
-CONFIG_BCM4329=m
-CONFIG_BCM4329_FW_PATH="/system/etc/firmware/fw_bcm4329.bin"
-CONFIG_BCM4329_NVRAM_PATH="/proc/calibration"
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-#
-# CONFIG_WAN is not set
-CONFIG_PPP=y
-CONFIG_PPP_MULTILINK=y
-CONFIG_PPP_FILTER=y
-CONFIG_PPP_ASYNC=y
-# CONFIG_PPP_SYNC_TTY is not set
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_MPPE=y
-CONFIG_PPPOE=y
-CONFIG_PPPOL2TP=y
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-# CONFIG_SLIP is not set
-CONFIG_SLHC=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_MSM_RMNET=y
-CONFIG_MSM_RMNET_DEBUG=y
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-CONFIG_INPUT_CAPELLA_CM3602=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-CONFIG_INPUT_KEYRESET=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELAN_I2C_8232 is not set
-CONFIG_TOUCHSCREEN_TSSC_MANAGER=y
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI=y
-CONFIG_TOUCHSCREEN_ATMEL=y
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_ATI_REMOTE is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INPUT_CM109 is not set
-CONFIG_INPUT_UINPUT=y
-CONFIG_INPUT_GPIO=y
-CONFIG_INPUT_KEYCHORD=y
-CONFIG_INPUT_OPTICALJOYSTICK=y
-CONFIG_OPTICALJOYSTICK_CRUCIAL=y
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_DEVMEM is not set
-# CONFIG_DEVKMEM is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_MSM=y
-# CONFIG_SERIAL_MSM_CONSOLE is not set
-CONFIG_SERIAL_MSM_CLOCK_CONTROL=y
-CONFIG_SERIAL_MSM_RX_WAKEUP=y
-CONFIG_SERIAL_MSM_HS=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_DCC_TTY is not set
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_CHARDEV is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_GPIO is not set
-CONFIG_I2C_MSM=y
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_SIMTEC is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_STUB is not set
-
-#
-# Miscellaneous I2C Chip support
-#
-# CONFIG_DS1682 is not set
-# CONFIG_AT24 is not set
-# CONFIG_SENSORS_EEPROM is not set
-# CONFIG_SENSORS_PCF8574 is not set
-# CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_AKM8976 is not set
-CONFIG_SENSORS_AKM8973=y
-CONFIG_SENSORS_BMA150=y
-# CONFIG_SENSORS_PCA963X is not set
-# CONFIG_SENSORS_MT9T013 is not set
-# CONFIG_SENSORS_MT9P012 is not set
-CONFIG_MICROP_I2C=y
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CHIP is not set
-# CONFIG_SPI is not set
-# CONFIG_W1 is not set
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_BATTERY_DS2760 is not set
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_HWMON is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_WATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_PCF50633 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_MSM_CAMERA=y
-# Temp remove camera driver
-CONFIG_MT9T013=y
-#CONFIG_MT9P012=y
-#CONFIG_MT9D112=y
-#CONFIG_S5K4B2FX=y
-#CONFIG_S5K3E2FX=y
-# CONFIG_DVB_CORE is not set
-# CONFIG_VIDEO_MEDIA is not set
-
-#
-# Multimedia drivers
-#
-#CONFIG_MSM_CAMERA_FLASH is not set
-CONFIG_DAB=y
-
-#
-# Qualcomm MSM Camera And Video
-#
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-CONFIG_VIDEO_OUTPUT_CONTROL=y
-CONFIG_FB=y
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MB862XX is not set
-CONFIG_FB_MSM=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-# CONFIG_LOGO is not set
-# CONFIG_SOUND is not set
-CONFIG_HID_SUPPORT=y
-CONFIG_HID=y
-# CONFIG_HID_DEBUG is not set
-# CONFIG_HIDRAW is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-
-#
-# Enable Host or Gadget support to see Inventra options
-#
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# OTG and related infrastructure
-#
-
-#
-# USB Function Support
-#
-CONFIG_USB_FUNCTION=y
-CONFIG_USB_FUNCTION_MSM_HSUSB=y
-# CONFIG_USB_FUNCTION_NULL is not set
-# CONFIG_USB_FUNCTION_ZERO is not set
-# CONFIG_USB_FUNCTION_LOOPBACK is not set
-CONFIG_USB_FUNCTION_ADB=y
-# CONFIG_USB_FUNCTION_UMS is not set
-CONFIG_USB_FUNCTION_MASS_STORAGE=y
-CONFIG_USB_FUNCTION_DIAG=y
-CONFIG_USB_FUNCTION_ETHER=y
-CONFIG_USB_FUNCTION_MODEM=y
-CONFIG_USB_FUNCTION_PROJECTOR=y
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_MMC_UNSAFE_RESUME=y
-CONFIG_MMC_EMBEDDED_SDIO=y
-CONFIG_MMC_PARANOID_SD_INIT=y
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-# CONFIG_MMC_BLOCK_BOUNCE is not set
-CONFIG_MMC_BLOCK_PARANOID_RESUME=y
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-CONFIG_MMC_BUSCLK_PWRSAVE=y
-CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-# CONFIG_MMC_SDHCI is not set
-CONFIG_MMC_MSM7X00A=y
-# CONFIG_MMC_MSM7X00A_RESUME_IN_WQ is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_ACCESSIBILITY is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_PCA9532 is not set
-CONFIG_LEDS_GPIO=y
-# CONFIG_LEDS_CPLD is not set
-# CONFIG_LEDS_PCA955X is not set
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-CONFIG_LEDS_TRIGGER_SLEEP=y
-CONFIG_SWITCH=y
-CONFIG_SWITCH_GPIO=y
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-# CONFIG_RTC_INTF_SYSFS is not set
-# CONFIG_RTC_INTF_PROC is not set
-# CONFIG_RTC_INTF_DEV is not set
-CONFIG_RTC_INTF_ALARM=y
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-
-#
-# SPI RTC drivers
-#
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_CMOS is not set
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-
-#
-# on-CPU RTC drivers
-#
-CONFIG_RTC_DRV_MSM7XXX=y
-# CONFIG_DMADEVICES is not set
-# CONFIG_REGULATOR is not set
-# CONFIG_UIO is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_EXCLUDE_BUILD is not set
-# CONFIG_MEILHAUS is not set
-# CONFIG_ECHO is not set
-# CONFIG_COMEDI is not set
-
-#
-# Android
-#
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_RAM_CONSOLE=y
-CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
-# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
-CONFIG_ANDROID_TIMED_OUTPUT=y
-CONFIG_ANDROID_TIMED_GPIO=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-# CONFIG_BTPORT is not set
-# CONFIG_BTPORT_DRV is not set
-
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-# CONFIG_EXT2_FS_XIP is not set
-CONFIG_EXT3_FS=y
-CONFIG_EXT3_FS_XATTR=y
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-# CONFIG_EXT4_FS is not set
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-# CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_YAFFS_FS=y
-CONFIG_YAFFS_YAFFS1=y
-# CONFIG_YAFFS_9BYTE_TAGS is not set
-# CONFIG_YAFFS_DOES_ECC is not set
-CONFIG_YAFFS_YAFFS2=y
-CONFIG_YAFFS_AUTO_YAFFS2=y
-# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
-# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
-# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
-CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
-# CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFSD is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_UNUSED_SYMBOLS is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-CONFIG_DETECT_SOFTLOCKUP=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
-CONFIG_SCHEDSTATS=y
-CONFIG_TIMER_STATS=y
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SLAB_LEAK is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-CONFIG_DEBUG_MUTEXES=y
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO=y
-CONFIG_DEBUG_VM=y
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_LIST is not set
-CONFIG_DEBUG_SG=y
-# CONFIG_DEBUG_NOTIFIERS is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-# CONFIG_RCU_CPU_STALL_DETECTOR is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_LATENCYTOP is not set
-CONFIG_HAVE_FUNCTION_TRACER=y
-
-#
-# Tracers
-#
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_BOOT_TRACER is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-# CONFIG_STACK_TRACER is not set
-# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-# CONFIG_DEBUG_USER is not set
-# CONFIG_DEBUG_ERRORS is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_LL is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_FIPS is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_GF128MUL is not set
-CONFIG_CRYPTO_NULL=y
-# CONFIG_CRYPTO_CRYPTD is not set
-# CONFIG_CRYPTO_AUTHENC is not set
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-# CONFIG_CRYPTO_ECB is not set
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_MD4 is not set
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_ARC4 is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_TWOFISH_COMMON=y
-
-#
-# Compression
-#
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_LZO is not set
-
-#
-# Random Number Generation
-#
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRYPTO_HW=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_FIND_LAST_BIT=y
-CONFIG_CRC_CCITT=y
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_REED_SOLOMON=y
-CONFIG_REED_SOLOMON_ENC8=y
-CONFIG_REED_SOLOMON_DEC8=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/passionc_defconfig b/arch/arm/configs/passionc_defconfig
deleted file mode 100755
index 10fa248..0000000
--- a/arch/arm/configs/passionc_defconfig
+++ /dev/null
@@ -1,1644 +0,0 @@
-
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29
-# Thu Oct  8 01:00:04 2009
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_CLASSIC_RCU=y
-# CONFIG_TREE_RCU is not set
-# CONFIG_PREEMPT_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_PREEMPT_RCU_TRACE is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_GROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-# CONFIG_USER_SCHED is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-# CONFIG_CGROUP_NS is not set
-CONFIG_CGROUP_FREEZER=y
-# CONFIG_CGROUP_DEVICE is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_CGROUP_MEM_RES_CTLR is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-# CONFIG_ELF_CORE is not set
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_ASHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_COMPAT_BRK=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-# CONFIG_PROFILING is not set
-CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-# CONFIG_IOSCHED_DEADLINE is not set
-# CONFIG_IOSCHED_CFQ is not set
-CONFIG_DEFAULT_AS=y
-# CONFIG_DEFAULT_DEADLINE is not set
-# CONFIG_DEFAULT_CFQ is not set
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="anticipatory"
-CONFIG_FREEZER=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KIRKWOOD is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-# CONFIG_ARCH_LOKI is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-CONFIG_ARCH_MSM=y
-# CONFIG_ARCH_W90X900 is not set
-# CONFIG_ARCH_MSM7X00A is not set
-CONFIG_ARCH_QSD8X50=y
-CONFIG_ARCH_MSM_SCORPION=y
-CONFIG_MSM_MDP31=y
-CONFIG_MSM_AMSS_VERSION=3200
-CONFIG_MSM_AMSS_VERSION_3200=y
-# CONFIG_MSM_DEBUG_UART is not set
-CONFIG_MSM_DEBUG_UART_NONE=y
-# CONFIG_MSM_DEBUG_UART1 is not set
-# CONFIG_MSM_DEBUG_UART2 is not set
-# CONFIG_MSM_DEBUG_UART3 is not set
-
-#
-# MSM Board Type
-#
-# CONFIG_MACH_SWORDFISH is not set
-# CONFIG_MACH_FIRESTONE is not set
-# CONFIG_MACH_ORCA is not set
-# CONFIG_MACH_BRAVO is not set
-# CONFIG_MACH_MAHIMAHI is not set
-# CONFIG_MACH_INCREDIBLE is not set
-# CONFIG_MACH_INCREDIBLEC is not set
-CONFIG_MACH_PASSIONC=y
-# CONFIG_MACH_SUPERSONIC is not set
-CONFIG_HTC_HEADSET=y
-CONFIG_HTC_35MM_REMOTE=y
-CONFIG_HTC_AUDIOJACK=y
-CONFIG_MICROP_COMMON=y
-CONFIG_LIGHTSENSOR_MICROP=y
-# CONFIG_TROUT_BATTCHG is not set
-CONFIG_TROUT_BATTCHG_DOCK=y
-CONFIG_HTC_BATTCHG=y
-CONFIG_HTC_BATTCHG_SMEM=n
-# CONFIG_HTC_PWRSINK is not set
-CONFIG_CACHE_FLUSH_RANGE_LIMIT=0x40000
-CONFIG_MSM7X00A_USE_GP_TIMER=y
-# CONFIG_MSM7X00A_USE_DG_TIMER is not set
-CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
-# CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_SLEEP_MODE=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE=1
-CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
-CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
-CONFIG_MSM7X00A_SLEEP_NO_LIMIT=y
-# CONFIG_MSM7X00A_SLEEP_LIMITED_SLEEP is not set
-# CONFIG_MSM7X00A_SLEEP_NEGATE_SLEEP is not set
-CONFIG_MSM7X00A_SLEEP_LIMIT=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_NO_LIMIT is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_LIMITED_SLEEP is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_NEGATE_SLEEP=y
-CONFIG_MSM7X00A_IDLE_SLEEP_LIMIT=2
-CONFIG_MSM_IDLE_STATS=y
-CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
-CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
-CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
-CONFIG_MSM_FIQ_SUPPORT=y
-CONFIG_MSM_SERIAL_DEBUGGER=y
-CONFIG_MSM_SERIAL_DEBUGGER_NO_SLEEP=y
-# CONFIG_MSM_SERIAL_DEBUGGER_WAKEUP_IRQ_ALWAYS_ON is not set
-# CONFIG_MSM_SERIAL_DEBUGGER_CONSOLE is not set
-CONFIG_MSM_SMD=y
-CONFIG_MSM_N_WAY_SMD=y
-CONFIG_MSM_ONCRPCROUTER=y
-CONFIG_MSM_RPCSERVERS=y
-# CONFIG_MSM_CPU_FREQ_SCREEN is not set
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX=998400
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN=245000
-# CONFIG_MSM_HW3D is not set
-# CONFIG_MSM_ADSP is not set
-# CONFIG_HTC_ACOUSTIC is not set
-CONFIG_HTC_ACOUSTIC_QSD=y
-CONFIG_MSM_DALRPC=y
-# CONFIG_MSM_DALRPC_TEST is not set
-CONFIG_QSD_AUDIO=y
-CONFIG_QSD_HTC_FM=y
-CONFIG_ARCH_MSM_FLASHLIGHT=y
-CONFIG_WIFI_NVS_PROC_CREATE=y
-CONFIG_WIFI_CONTROL_FUNC=y
-CONFIG_WIFI_MEM_PREALLOC=n
-CONFIG_BUILD_OMA_DM=y
-CONFIG_SMD_OFFSET_TCXO_STAT=0xFC280
-CONFIG_AXI_SCREEN_POLICY=y
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_32v6K=y
-CONFIG_CPU_V7=y
-CONFIG_CPU_32v7=y
-CONFIG_CPU_ABRT_EV7=y
-CONFIG_CPU_PABRT_IFAR=y
-CONFIG_CPU_CACHE_V7=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V7=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-CONFIG_ARM_THUMBEE=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-CONFIG_HAS_TLS_REG=y
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_1G is not set
-CONFIG_PAGE_OFFSET=0xC0000000
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-CONFIG_ARCH_FLATMEM_HAS_HOLES=y
-# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
-# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=0
-CONFIG_VIRT_TO_BUS=y
-CONFIG_UNEVICTABLE_LRU=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="mem=64M console=ttyMSM,115200n8"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# CPU Power Management
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-# CONFIG_CPU_FREQ_DEBUG is not set
-CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_STAT_DETAILS=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_MIN_TICKS=2
-CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
-# CONFIG_CPU_IDLE is not set
-CONFIG_PERFLOCK=y
-CONFIG_PERFLOCK_BOOT_LOCK=y
-# CONFIG_PERFLOCK_SCREEN_POLICY is not set
-# CONFIG_PERFLOCK_SCREEN_ON_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_ON_MAX is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MAX is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-CONFIG_VFP=y
-CONFIG_VFPv3=y
-CONFIG_NEON=y
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_HAVE_AOUT=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-CONFIG_HAS_WAKELOCK=y
-CONFIG_HAS_EARLYSUSPEND=y
-CONFIG_WAKELOCK=y
-CONFIG_WAKELOCK_STAT=y
-CONFIG_USER_WAKELOCK=y
-CONFIG_EARLYSUSPEND=y
-# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
-# CONFIG_CONSOLE_EARLYSUSPEND is not set
-CONFIG_FB_EARLYSUSPEND=y
-# CONFIG_APM_EMULATION is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_COMPAT_NET_DEV_OPS=y
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-CONFIG_NET_KEY=y
-# CONFIG_NET_KEY_MIGRATE is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-CONFIG_INET_ESP=y
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-CONFIG_ANDROID_PARANOID_NETWORK=y
-# CONFIG_NETWORK_SECMARK is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_NETFILTER_ADVANCED=y
-
-#
-# Core Netfilter Configuration
-#
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_NETLINK_LOG is not set
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CT_ACCT=y
-CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-CONFIG_NF_CONNTRACK_FTP=y
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_PPTP is not set
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CT_NETLINK is not set
-CONFIG_NETFILTER_XTABLES=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_DCCP=y
-CONFIG_NETFILTER_XT_MATCH_DSCP=y
-CONFIG_NETFILTER_XT_MATCH_ESP=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-CONFIG_NETFILTER_XT_MATCH_REALM=y
-CONFIG_NETFILTER_XT_MATCH_SCTP=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_NF_CONNTRACK_PROC_COMPAT=y
-# CONFIG_IP_NF_QUEUE is not set
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_RECENT=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_MATCH_ADDRTYPE=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_LOG=y
-# CONFIG_IP_NF_TARGET_ULOG is not set
-CONFIG_NF_NAT=y
-CONFIG_NF_NAT_NEEDED=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-CONFIG_NF_NAT_FTP=y
-# CONFIG_NF_NAT_IRC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_NAT_AMANDA is not set
-# CONFIG_NF_NAT_PPTP is not set
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_IP_NF_MANGLE is not set
-CONFIG_IP_NF_RAW=y
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-# CONFIG_DCB is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-CONFIG_BT=y
-CONFIG_BT_L2CAP=y
-CONFIG_BT_SCO=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-# CONFIG_BT_BNEP_MC_FILTER is not set
-# CONFIG_BT_BNEP_PROTO_FILTER is not set
-CONFIG_BT_HIDP=y
-
-#
-# Bluetooth device drivers
-#
-# CONFIG_BT_HCIBTSDIO is not set
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_BCSP is not set
-CONFIG_BT_HCIUART_LL=y
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_PHONET is not set
-CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
-CONFIG_WIRELESS_OLD_REGULATORY=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WIRELESS_EXT_SYSFS=y
-# CONFIG_LIB80211 is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_WIMAX is not set
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_PM is not set
-# CONFIG_RFKILL_INPUT is not set
-CONFIG_RFKILL_LEDS=y
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH=""
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_EXTRA_FIRMWARE=""
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-CONFIG_MTD_MSM_NAND=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-CONFIG_MISC_DEVICES=y
-CONFIG_ANDROID_PMEM=y
-# CONFIG_ICS932S401 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-CONFIG_KERNEL_DEBUGGER_CORE=y
-CONFIG_UID_STAT=y
-CONFIG_SENSORS_BMA150_SPI=y
-# CONFIG_WL127X_RFKILL is not set
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_93CX6 is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_DEBUG=y
-CONFIG_DM_CRYPT=y
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_DELAY is not set
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-CONFIG_SMC91X=y
-# CONFIG_DM9000 is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_DNET is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_B44 is not set
-CONFIG_NETDEV_1000=y
-CONFIG_NETDEV_10000=y
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-CONFIG_BCM4329=m
-CONFIG_BCM4329_FW_PATH="/system/etc/firmware/fw_bcm4329.bin"
-CONFIG_BCM4329_NVRAM_PATH="/proc/calibration"
-
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-# CONFIG_WIMAX_SQN is not set
-#
-# CONFIG_WAN is not set
-CONFIG_PPP=y
-# CONFIG_PPP_MULTILINK is not set
-# CONFIG_PPP_FILTER is not set
-CONFIG_PPP_ASYNC=y
-# CONFIG_PPP_SYNC_TTY is not set
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_MPPE=y
-# CONFIG_PPPOE is not set
-# CONFIG_PPPOL2TP is not set
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-# CONFIG_SLIP is not set
-CONFIG_SLHC=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_MSM_RMNET=y
-# CONFIG_MSM_RMNET_DEBUG is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-CONFIG_INPUT_CAPELLA_CM3602=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-CONFIG_INPUT_KEYRESET=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_ATMEL=y
-# CONFIG_TOUCHSCREEN_CYPRESS_TMG is not set
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELAN_I2C_8232 is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_MSM is not set
-CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI=y
-# CONFIG_TOUCHSCREEN_SYNAPTICS_T1007 is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_ATI_REMOTE is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INPUT_CM109 is not set
-CONFIG_INPUT_UINPUT=y
-CONFIG_INPUT_GPIO=y
-CONFIG_INPUT_KEYCHORD=y
-CONFIG_INPUT_OPTICALJOYSTICK=y
-CONFIG_OPTICALJOYSTICK_CRUCIAL=y
-# CONFIG_PROXIMITYSENSOR is not set
-CONFIG_FLASHLIGHT=y
-CONFIG_INPUT_DUMMY_KEYPAD=y
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_DEVMEM is not set
-# CONFIG_DEVKMEM is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_CORE=y
-# CONFIG_SERIAL_CORE_CONSOLE is not set
-CONFIG_SERIAL_MSM=y
-# CONFIG_SERIAL_MSM_CONSOLE is not set
-# CONFIG_SERIAL_MSM_CLOCK_CONTROL is not set
-CONFIG_SERIAL_MSM_HS=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_DCC_TTY is not set
-CONFIG_Q6_VENC=y
-CONFIG_MSM_Q6VDEC=y
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_CHARDEV is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_GPIO is not set
-CONFIG_I2C_MSM=y
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_SIMTEC is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_STUB is not set
-
-#
-# Miscellaneous I2C Chip support
-#
-# CONFIG_DS1682 is not set
-# CONFIG_SENSORS_PCF8574 is not set
-# CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_AKM8976 is not set
-CONFIG_SENSORS_AKM8973=y
-# CONFIG_SENSORS_PCA963X is not set
-# CONFIG_SENSORS_MT9T013 is not set
-CONFIG_AMP_TPA2018D1=y
-CONFIG_AMP_TPA6130A=y
-CONFIG_VP_A1026=y
-CONFIG_SMB329=y
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CHIP is not set
-CONFIG_SPI=y
-CONFIG_SPI_MASTER=y
-CONFIG_SPI_QSD=y
-CONFIG_W1=y
-
-#
-# 1-wire Bus Masters
-#
-CONFIG_W1_MASTER_DS2482=y
-# CONFIG_W1_MASTER_GPIO is not set
-
-#
-# 1-wire Slaves
-#
-# CONFIG_W1_SLAVE_THERM is not set
-# CONFIG_W1_SLAVE_SMEM is not set
-# CONFIG_W1_SLAVE_DS2433 is not set
-# CONFIG_W1_SLAVE_DS2760 is not set
-CONFIG_W1_SLAVE_DS2784=y
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_BATTERY_DS2760 is not set
-CONFIG_BATTERY_DS2784=y
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_HWMON is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_WATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_PCF50633 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_VIDEO_V4L2_COMMON=y
-# CONFIG_VIDEO_ALLOW_V4L1 is not set
-CONFIG_VIDEO_V4L1_COMPAT=y
-# CONFIG_DVB_CORE is not set
-CONFIG_VIDEO_MEDIA=y
-
-#
-# Multimedia drivers
-#
-# CONFIG_MEDIA_ATTACH is not set
-CONFIG_MEDIA_TUNER=y
-# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
-CONFIG_MEDIA_TUNER_SIMPLE=y
-CONFIG_MEDIA_TUNER_TDA8290=y
-CONFIG_MEDIA_TUNER_TDA9887=y
-CONFIG_MEDIA_TUNER_TEA5761=y
-CONFIG_MEDIA_TUNER_TEA5767=y
-CONFIG_MEDIA_TUNER_MT20XX=y
-CONFIG_MEDIA_TUNER_XC2028=y
-CONFIG_MEDIA_TUNER_XC5000=y
-CONFIG_VIDEO_V4L2=y
-CONFIG_VIDEO_CAPTURE_DRIVERS=y
-# CONFIG_VIDEO_ADV_DEBUG is not set
-# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
-CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
-# CONFIG_VIDEO_VIVI is not set
-# CONFIG_VIDEO_SAA5246A is not set
-# CONFIG_VIDEO_SAA5249 is not set
-# CONFIG_SOC_CAMERA is not set
-
-#
-# Qualcomm MSM Camera And Video
-#
-CONFIG_MSM_CAMERA=y
-# CONFIG_MSM_CAMERA_DEBUG is not set
-
-#
-# Camera Sensor Selection
-#
-CONFIG_MSM_CAMERA_FLASH=y
-# CONFIG_MT9T013 is not set
-# CONFIG_MT9D112 is not set
-# CONFIG_MT9P012 is not set
-# CONFIG_MSM_CAMERA_AF_FOXCONN is not set
-# CONFIG_MSM_CAMERA_AF_BAM is not set
-CONFIG_S5K3E2FX=y
-# CONFIG_VB6801 is not set
-CONFIG_OV8810=y
-
-#
-# Camera Sensor Selection
-#
-CONFIG_RADIO_ADAPTERS=y
-# CONFIG_RADIO_TEA5764 is not set
-# CONFIG_DAB is not set
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-CONFIG_VIDEO_OUTPUT_CONTROL=y
-CONFIG_FB=y
-CONFIG_FB_MSM_TVOUT=n
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MB862XX is not set
-CONFIG_FB_MSM=y
-CONFIG_FB_MSM_LCDC=y
-CONFIG_GPU_MSM_KGSL=n
-CONFIG_MSM_KGSL_MMU=n
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-# CONFIG_LOGO is not set
-# CONFIG_SOUND is not set
-CONFIG_HID_SUPPORT=y
-CONFIG_HID=y
-# CONFIG_HID_DEBUG is not set
-# CONFIG_HIDRAW is not set
-# CONFIG_HID_PID is not set
-
-#
-# Special HID drivers
-#
-CONFIG_HID_COMPAT=y
-# CONFIG_HID_APPLE is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-
-#
-# Enable Host or Gadget support to see Inventra options
-#
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# OTG and related infrastructure
-#
-
-#
-# USB Function Support
-#
-CONFIG_USB_FUNCTION=y
-CONFIG_USB_FUNCTION_MSM_HSUSB=y
-# CONFIG_USB_FUNCTION_NULL is not set
-# CONFIG_USB_FUNCTION_ZERO is not set
-# CONFIG_USB_FUNCTION_LOOPBACK is not set
-CONFIG_USB_FUNCTION_ADB=y
-# CONFIG_USB_FUNCTION_UMS is not set
-CONFIG_USB_FUNCTION_MASS_STORAGE=y
-CONFIG_USB_FUNCTION_DIAG=y
-CONFIG_USB_FUNCTION_ETHER=y
-CONFIG_USB_FUNCTION_RNDIS=y
-CONFIG_USB_FUNCTION_MODEM=y
-CONFIG_USB_FUNCTION_PROJECTOR=y
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_MMC_UNSAFE_RESUME=y
-CONFIG_MMC_EMBEDDED_SDIO=y
-CONFIG_MMC_PARANOID_SD_INIT=y
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-# CONFIG_MMC_BLOCK_BOUNCE is not set
-CONFIG_MMC_BLOCK_PARANOID_RESUME=y
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-CONFIG_MMC_BUSCLK_PWRSAVE=y
-CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-# CONFIG_MMC_SDHCI is not set
-CONFIG_MMC_MSM7X00A=y
-# CONFIG_MMC_MSM7X00A_RESUME_IN_WQ is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_ACCESSIBILITY is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_PCA9532 is not set
-CONFIG_LEDS_GPIO=y
-CONFIG_LEDS_CPLD=y
-# CONFIG_LEDS_PCA955X is not set
-CONFIG_FLASHLIGHT=y
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-CONFIG_LEDS_TRIGGER_SLEEP=y
-CONFIG_SWITCH=y
-CONFIG_SWITCH_GPIO=y
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-# CONFIG_RTC_INTF_SYSFS is not set
-# CONFIG_RTC_INTF_PROC is not set
-# CONFIG_RTC_INTF_DEV is not set
-CONFIG_RTC_INTF_ALARM=y
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-
-#
-# SPI RTC drivers
-#
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_CMOS is not set
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-
-#
-# on-CPU RTC drivers
-#
-CONFIG_RTC_DRV_MSM7X00A=y
-# CONFIG_DMADEVICES is not set
-CONFIG_REGULATOR=y
-CONFIG_REGULATOR_DEBUG=y
-# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
-# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
-# CONFIG_REGULATOR_BQ24022 is not set
-CONFIG_REGULATOR_TPS65023=y
-# CONFIG_UIO is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_EXCLUDE_BUILD is not set
-# CONFIG_MEILHAUS is not set
-# CONFIG_ECHO is not set
-# CONFIG_COMEDI is not set
-
-#
-# Android
-#
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_RAM_CONSOLE=y
-CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
-# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
-CONFIG_ANDROID_TIMED_OUTPUT=y
-CONFIG_ANDROID_TIMED_GPIO=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-# CONFIG_BTPORT is not set
-# CONFIG_BTPORT_DRV is not set
-
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-# CONFIG_EXT2_FS_XIP is not set
-CONFIG_EXT3_FS=y
-CONFIG_EXT3_FS_XATTR=y
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-# CONFIG_EXT4_FS is not set
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-# CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_YAFFS_FS=y
-CONFIG_YAFFS_YAFFS1=y
-# CONFIG_YAFFS_9BYTE_TAGS is not set
-# CONFIG_YAFFS_DOES_ECC is not set
-CONFIG_YAFFS_YAFFS2=y
-CONFIG_YAFFS_AUTO_YAFFS2=y
-# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
-# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
-# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
-CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
-# CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFSD is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_UNUSED_SYMBOLS is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-CONFIG_DETECT_SOFTLOCKUP=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
-CONFIG_SCHEDSTATS=y
-CONFIG_TIMER_STATS=y
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SLAB_LEAK is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-CONFIG_DEBUG_MUTEXES=y
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO=y
-CONFIG_DEBUG_VM=y
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_LIST is not set
-CONFIG_DEBUG_SG=y
-# CONFIG_DEBUG_NOTIFIERS is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-# CONFIG_RCU_CPU_STALL_DETECTOR is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_LATENCYTOP is not set
-CONFIG_HAVE_FUNCTION_TRACER=y
-
-#
-# Tracers
-#
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_BOOT_TRACER is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-# CONFIG_STACK_TRACER is not set
-# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-# CONFIG_DEBUG_USER is not set
-# CONFIG_DEBUG_ERRORS is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_LL is not set
-# CONFIG_DEBUG_ICEDCC is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_FIPS is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-CONFIG_CRYPTO_AUTHENC=y
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-CONFIG_CRYPTO_ECB=y
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_MD4 is not set
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
-CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_TWOFISH_COMMON=y
-
-#
-# Compression
-#
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_LZO is not set
-
-#
-# Random Number Generation
-#
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRYPTO_HW=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_FIND_LAST_BIT=y
-CONFIG_CRC_CCITT=y
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_ALLOCATOR=y
-CONFIG_REED_SOLOMON=y
-CONFIG_REED_SOLOMON_ENC8=y
-CONFIG_REED_SOLOMON_DEC8=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/supersonic_defconfig b/arch/arm/configs/supersonic_defconfig
deleted file mode 100644
index 6f429c1..0000000
--- a/arch/arm/configs/supersonic_defconfig
+++ /dev/null
@@ -1,1637 +0,0 @@
-
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29
-# Thu Oct  8 01:00:04 2009
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_CLASSIC_RCU=y
-# CONFIG_TREE_RCU is not set
-# CONFIG_PREEMPT_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_PREEMPT_RCU_TRACE is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_GROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-# CONFIG_USER_SCHED is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-# CONFIG_CGROUP_NS is not set
-CONFIG_CGROUP_FREEZER=y
-# CONFIG_CGROUP_DEVICE is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_CGROUP_MEM_RES_CTLR is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-# CONFIG_ELF_CORE is not set
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_ASHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_COMPAT_BRK=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-# CONFIG_PROFILING is not set
-CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-# CONFIG_IOSCHED_CFQ is not set
-# CONFIG_DEFAULT_AS is not set
-CONFIG_DEFAULT_DEADLINE=y
-# CONFIG_DEFAULT_CFQ is not set
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="deadline"
-CONFIG_FREEZER=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KIRKWOOD is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-# CONFIG_ARCH_LOKI is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-CONFIG_ARCH_MSM=y
-# CONFIG_ARCH_W90X900 is not set
-# CONFIG_ARCH_MSM7X00A is not set
-CONFIG_ARCH_QSD8X50=y
-CONFIG_ARCH_MSM_SCORPION=y
-CONFIG_MSM_MDP31=y
-CONFIG_MSM_AMSS_VERSION=3200
-CONFIG_MSM_AMSS_VERSION_3200=y
-# CONFIG_MSM_DEBUG_UART is not set
-CONFIG_MSM_DEBUG_UART_NONE=y
-# CONFIG_MSM_DEBUG_UART1 is not set
-# CONFIG_MSM_DEBUG_UART2 is not set
-# CONFIG_MSM_DEBUG_UART3 is not set
-
-#
-# MSM Board Type
-#
-# CONFIG_MACH_SWORDFISH is not set
-# CONFIG_MACH_FIRESTONE is not set
-# CONFIG_MACH_ORCA is not set
-# CONFIG_MACH_BRAVO is not set
-# CONFIG_MACH_MAHIMAHI is not set
-# CONFIG_MACH_INCREDIBLE is not set
-# CONFIG_MACH_INCREDIBLEC is not set
-# CONFIG_MACH_PASSIONC is not set
-CONFIG_MACH_SUPERSONIC=y
-CONFIG_HTC_HEADSET=y
-CONFIG_HTC_35MM_REMOTE=y
-CONFIG_HTC_AUDIOJACK=y
-CONFIG_MICROP_COMMON=y
-CONFIG_LIGHTSENSOR_MICROP=y
-# CONFIG_TROUT_BATTCHG is not set
-CONFIG_HTC_BATTCHG=y
-CONFIG_HTC_BATTCHG_SMEM=y
-# CONFIG_HTC_PWRSINK is not set
-CONFIG_CACHE_FLUSH_RANGE_LIMIT=0x40000
-CONFIG_MSM7X00A_USE_GP_TIMER=y
-# CONFIG_MSM7X00A_USE_DG_TIMER is not set
-CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
-# CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_SLEEP_MODE=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_APPS_SLEEP is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE=1
-CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
-CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
-CONFIG_MSM7X00A_SLEEP_NO_LIMIT=y
-# CONFIG_MSM7X00A_SLEEP_LIMITED_SLEEP is not set
-# CONFIG_MSM7X00A_SLEEP_NEGATE_SLEEP is not set
-CONFIG_MSM7X00A_SLEEP_LIMIT=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_NO_LIMIT is not set
-# CONFIG_MSM7X00A_IDLE_SLEEP_LIMITED_SLEEP is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_NEGATE_SLEEP=y
-CONFIG_MSM7X00A_IDLE_SLEEP_LIMIT=2
-CONFIG_MSM_IDLE_STATS=y
-CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
-CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
-CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
-CONFIG_MSM_FIQ_SUPPORT=y
-CONFIG_MSM_SERIAL_DEBUGGER=y
-CONFIG_MSM_SERIAL_DEBUGGER_NO_SLEEP=y
-# CONFIG_MSM_SERIAL_DEBUGGER_WAKEUP_IRQ_ALWAYS_ON is not set
-# CONFIG_MSM_SERIAL_DEBUGGER_CONSOLE is not set
-CONFIG_MSM_SMD=y
-CONFIG_MSM_N_WAY_SMD=y
-CONFIG_MSM_ONCRPCROUTER=y
-CONFIG_MSM_RPCSERVERS=y
-# CONFIG_MSM_CPU_FREQ_SCREEN is not set
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX=998400
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN=245000
-# CONFIG_MSM_HW3D is not set
-# CONFIG_MSM_ADSP is not set
-# CONFIG_HTC_ACOUSTIC is not set
-CONFIG_HTC_ACOUSTIC_QSD=y
-CONFIG_MSM_DALRPC=y
-# CONFIG_MSM_DALRPC_TEST is not set
-CONFIG_QSD_AUDIO=y
-CONFIG_QSD_HTC_FM=y
-CONFIG_ARCH_MSM_FLASHLIGHT=y
-CONFIG_WIFI_NVS_PROC_CREATE=y
-CONFIG_WIFI_CONTROL_FUNC=y
-CONFIG_WIFI_MEM_PREALLOC=n
-CONFIG_BUILD_CIQ=y
-CONFIG_BUILD_OMA_DM=y
-CONFIG_SMD_OFFSET_TCXO_STAT=0xFC2A0
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_32v6K=y
-CONFIG_CPU_V7=y
-CONFIG_CPU_32v7=y
-CONFIG_CPU_ABRT_EV7=y
-CONFIG_CPU_PABRT_IFAR=y
-CONFIG_CPU_CACHE_V7=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V7=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-CONFIG_ARM_THUMBEE=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-CONFIG_HAS_TLS_REG=y
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_1G is not set
-CONFIG_PAGE_OFFSET=0xC0000000
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-CONFIG_ARCH_FLATMEM_HAS_HOLES=y
-# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
-# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=0
-CONFIG_VIRT_TO_BUS=y
-CONFIG_UNEVICTABLE_LRU=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="mem=64M console=ttyMSM,115200n8"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# CPU Power Management
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-# CONFIG_CPU_FREQ_DEBUG is not set
-CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_STAT_DETAILS=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_MIN_TICKS=2
-CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
-# CONFIG_CPU_IDLE is not set
-CONFIG_PERFLOCK=y
-CONFIG_PERFLOCK_BOOT_LOCK=y
-# CONFIG_PERFLOCK_SCREEN_POLICY is not set
-# CONFIG_PERFLOCK_SCREEN_ON_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_ON_MAX is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MIN is not set
-# CONFIG_PERFLOCK_SCREEN_OFF_MAX is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-CONFIG_VFP=y
-CONFIG_VFPv3=y
-CONFIG_NEON=y
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_HAVE_AOUT=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-CONFIG_HAS_WAKELOCK=y
-CONFIG_HAS_EARLYSUSPEND=y
-CONFIG_WAKELOCK=y
-CONFIG_WAKELOCK_STAT=y
-CONFIG_USER_WAKELOCK=y
-CONFIG_EARLYSUSPEND=y
-# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
-# CONFIG_CONSOLE_EARLYSUSPEND is not set
-CONFIG_FB_EARLYSUSPEND=y
-# CONFIG_APM_EMULATION is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_COMPAT_NET_DEV_OPS=y
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-CONFIG_NET_KEY=y
-# CONFIG_NET_KEY_MIGRATE is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-CONFIG_INET_ESP=y
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-CONFIG_ANDROID_PARANOID_NETWORK=y
-# CONFIG_NETWORK_SECMARK is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_NETFILTER_ADVANCED=y
-
-#
-# Core Netfilter Configuration
-#
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_NETLINK_LOG is not set
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CT_ACCT=y
-CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-CONFIG_NF_CONNTRACK_FTP=y
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_PPTP is not set
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CT_NETLINK is not set
-CONFIG_NETFILTER_XTABLES=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_DCCP=y
-CONFIG_NETFILTER_XT_MATCH_DSCP=y
-CONFIG_NETFILTER_XT_MATCH_ESP=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-CONFIG_NETFILTER_XT_MATCH_REALM=y
-CONFIG_NETFILTER_XT_MATCH_SCTP=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_NF_CONNTRACK_PROC_COMPAT=y
-# CONFIG_IP_NF_QUEUE is not set
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_RECENT=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_MATCH_ADDRTYPE=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_LOG=y
-# CONFIG_IP_NF_TARGET_ULOG is not set
-CONFIG_NF_NAT=y
-CONFIG_NF_NAT_NEEDED=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-CONFIG_NF_NAT_FTP=y
-# CONFIG_NF_NAT_IRC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_NAT_AMANDA is not set
-# CONFIG_NF_NAT_PPTP is not set
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_IP_NF_MANGLE is not set
-CONFIG_IP_NF_RAW=y
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-# CONFIG_DCB is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-CONFIG_BT=y
-CONFIG_BT_L2CAP=y
-CONFIG_BT_SCO=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-# CONFIG_BT_BNEP_MC_FILTER is not set
-# CONFIG_BT_BNEP_PROTO_FILTER is not set
-CONFIG_BT_HIDP=y
-
-#
-# Bluetooth device drivers
-#
-# CONFIG_BT_HCIBTSDIO is not set
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_BCSP is not set
-CONFIG_BT_HCIUART_LL=y
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_PHONET is not set
-CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
-CONFIG_WIRELESS_OLD_REGULATORY=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WIRELESS_EXT_SYSFS=y
-# CONFIG_LIB80211 is not set
-# CONFIG_MAC80211 is not set
-CONFIG_WIMAX=y
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_PM is not set
-# CONFIG_RFKILL_INPUT is not set
-CONFIG_RFKILL_LEDS=y
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH=""
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_EXTRA_FIRMWARE=""
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-CONFIG_MTD_MSM_NAND=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-CONFIG_MISC_DEVICES=y
-CONFIG_ANDROID_PMEM=y
-# CONFIG_ICS932S401 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-CONFIG_KERNEL_DEBUGGER_CORE=y
-CONFIG_UID_STAT=y
-CONFIG_SENSORS_BMA150_SPI=y
-# CONFIG_WL127X_RFKILL is not set
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_93CX6 is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_DEBUG=y
-CONFIG_DM_CRYPT=y
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_DELAY is not set
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-CONFIG_SMC91X=y
-# CONFIG_DM9000 is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_DNET is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_B44 is not set
-CONFIG_NETDEV_1000=y
-CONFIG_NETDEV_10000=y
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-CONFIG_BCM4329=m
-CONFIG_BCM4329_SOFTAP=y
-CONFIG_BCM4329_FW_PATH="/system/etc/firmware/fw_bcm4329.bin"
-CONFIG_BCM4329_NVRAM_PATH="/proc/calibration"
-
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-CONFIG_WIMAX_SQN=m
-#
-# CONFIG_WAN is not set
-CONFIG_PPP=y
-# CONFIG_PPP_MULTILINK is not set
-# CONFIG_PPP_FILTER is not set
-CONFIG_PPP_ASYNC=y
-# CONFIG_PPP_SYNC_TTY is not set
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_MPPE=y
-# CONFIG_PPPOE is not set
-# CONFIG_PPPOL2TP is not set
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-# CONFIG_SLIP is not set
-CONFIG_SLHC=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_MSM_RMNET=y
-# CONFIG_MSM_RMNET_DEBUG is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-CONFIG_INPUT_KEYRESET=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_ATMEL=y
-# CONFIG_TOUCHSCREEN_CYPRESS_TMG is not set
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELAN_I2C_8232 is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_MSM is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_T1007 is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_ATI_REMOTE is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INPUT_CM109 is not set
-CONFIG_INPUT_UINPUT=y
-CONFIG_INPUT_GPIO=y
-CONFIG_INPUT_KEYCHORD=y
-#CONFIG_INPUT_OPTICALJOYSTICK is not set
-#CONFIG_OPTICALJOYSTICK_CRUCIAL is not set
-# CONFIG_PROXIMITYSENSOR is not set
-CONFIG_INPUT_DUMMY_KEYPAD=y
-CONFIG_FLASHLIGHT=y
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_DEVMEM is not set
-# CONFIG_DEVKMEM is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_CORE=y
-# CONFIG_SERIAL_CORE_CONSOLE is not set
-CONFIG_SERIAL_MSM=y
-# CONFIG_SERIAL_MSM_CONSOLE is not set
-# CONFIG_SERIAL_MSM_CLOCK_CONTROL is not set
-CONFIG_SERIAL_MSM_HS=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_DCC_TTY is not set
-CONFIG_Q6_VENC=y
-CONFIG_MSM_Q6VDEC=y
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_CHARDEV is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_GPIO is not set
-CONFIG_I2C_MSM=y
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_SIMTEC is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_STUB is not set
-
-#
-# Miscellaneous I2C Chip support
-#
-# CONFIG_DS1682 is not set
-# CONFIG_SENSORS_PCF8574 is not set
-# CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_AKM8976 is not set
-CONFIG_SENSORS_AKM8973=y
-# CONFIG_SENSORS_PCA963X is not set
-# CONFIG_SENSORS_MT9T013 is not set
-CONFIG_AMP_TPA2018D1=y
-CONFIG_AMP_TPA6130A=y
-CONFIG_VP_A1026=y
-CONFIG_SMB329=y
-CONFIG_TPS65200=y
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CHIP is not set
-CONFIG_SPI=y
-CONFIG_SPI_MASTER=y
-#CONFIG_SPI_QSD=y
-
-
-# CONFIG_W1 is not set
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_BATTERY_DS2760 is not set
-# CONFIG_BATTERY_DS2784 is not set
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_HWMON is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_WATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_PCF50633 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_VIDEO_V4L2_COMMON=y
-# CONFIG_VIDEO_ALLOW_V4L1 is not set
-CONFIG_VIDEO_V4L1_COMPAT=y
-# CONFIG_DVB_CORE is not set
-CONFIG_VIDEO_MEDIA=y
-
-#
-# Multimedia drivers
-#
-# CONFIG_MEDIA_ATTACH is not set
-CONFIG_MEDIA_TUNER=y
-# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
-CONFIG_MEDIA_TUNER_SIMPLE=y
-CONFIG_MEDIA_TUNER_TDA8290=y
-CONFIG_MEDIA_TUNER_TDA9887=y
-CONFIG_MEDIA_TUNER_TEA5761=y
-CONFIG_MEDIA_TUNER_TEA5767=y
-CONFIG_MEDIA_TUNER_MT20XX=y
-CONFIG_MEDIA_TUNER_XC2028=y
-CONFIG_MEDIA_TUNER_XC5000=y
-CONFIG_VIDEO_V4L2=y
-CONFIG_VIDEO_CAPTURE_DRIVERS=y
-# CONFIG_VIDEO_ADV_DEBUG is not set
-# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
-CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
-# CONFIG_VIDEO_VIVI is not set
-# CONFIG_VIDEO_SAA5246A is not set
-# CONFIG_VIDEO_SAA5249 is not set
-# CONFIG_SOC_CAMERA is not set
-
-#
-# Qualcomm MSM Camera And Video
-#
-CONFIG_MSM_CAMERA=y
-# CONFIG_MSM_CAMERA_DEBUG is not set
-
-#
-# Camera Sensor Selection
-#
-CONFIG_MSM_CAMERA_FLASH=y
-# CONFIG_MT9T013 is not set
-# CONFIG_MT9D112 is not set
-# CONFIG_MT9P012 is not set
-# CONFIG_MSM_CAMERA_AF_FOXCONN is not set
-# CONFIG_MSM_CAMERA_AF_BAM is not set
-# CONFIG_S5K3E2FX is not set
-# CONFIG_VB6801 is not set
-CONFIG_OV9665=y
-CONFIG_OV8810=y
-
-#
-# Camera Sensor Selection
-#
-CONFIG_RADIO_ADAPTERS=y
-# CONFIG_RADIO_TEA5764 is not set
-# CONFIG_DAB is not set
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-CONFIG_VIDEO_OUTPUT_CONTROL=y
-CONFIG_FB=y
-CONFIG_FB_MSM_TVOUT=n
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MB862XX is not set
-CONFIG_FB_MSM=y
-CONFIG_FB_565=y
-CONFIG_FB_MSM_LCDC=y
-CONFIG_GPU_MSM_KGSL=y
-CONFIG_MSM_KGSL_MMU=y
-CONFIG_MSM_HDMI=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-# CONFIG_LOGO is not set
-# CONFIG_SOUND is not set
-CONFIG_HID_SUPPORT=y
-CONFIG_HID=y
-# CONFIG_HID_DEBUG is not set
-# CONFIG_HIDRAW is not set
-# CONFIG_HID_PID is not set
-
-#
-# Special HID drivers
-#
-CONFIG_HID_COMPAT=y
-# CONFIG_HID_APPLE is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-
-#
-# Enable Host or Gadget support to see Inventra options
-#
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# OTG and related infrastructure
-#
-
-#
-# USB Function Support
-#
-CONFIG_USB_FUNCTION=y
-CONFIG_USB_FUNCTION_MSM_HSUSB=y
-# CONFIG_USB_FUNCTION_NULL is not set
-# CONFIG_USB_FUNCTION_ZERO is not set
-# CONFIG_USB_FUNCTION_LOOPBACK is not set
-CONFIG_USB_FUNCTION_ADB=y
-# CONFIG_USB_FUNCTION_UMS is not set
-CONFIG_USB_FUNCTION_MASS_STORAGE=y
-CONFIG_USB_FUNCTION_DIAG=y
-CONFIG_USB_FUNCTION_ETHER=y
-CONFIG_USB_FUNCTION_RNDIS=y
-CONFIG_USB_FUNCTION_MODEM=y
-CONFIG_USB_FUNCTION_PROJECTOR=y
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-# Andrew 0224
-#CONFIG_MMC_DEBUG=y
-CONFIG_MMC_UNSAFE_RESUME=y
-CONFIG_MMC_EMBEDDED_SDIO=y
-CONFIG_MMC_PARANOID_SD_INIT=y
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-# CONFIG_MMC_BLOCK_BOUNCE is not set
-CONFIG_MMC_BLOCK_PARANOID_RESUME=y
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-CONFIG_MMC_BUSCLK_PWRSAVE=y
-CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-# CONFIG_MMC_SDHCI is not set
-CONFIG_MMC_MSM7X00A=y
-# CONFIG_MMC_MSM7X00A_RESUME_IN_WQ is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_ACCESSIBILITY is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-CONFIG_MMC_BLOCK_PROG_ENA=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_PCA9532 is not set
-CONFIG_LEDS_GPIO=y
-CONFIG_LEDS_CPLD=y
-# CONFIG_LEDS_PCA955X is not set
-CONFIG_FLASHLIGHT=y
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-CONFIG_LEDS_TRIGGER_SLEEP=y
-CONFIG_SWITCH=y
-CONFIG_SWITCH_GPIO=y
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-# CONFIG_RTC_INTF_SYSFS is not set
-# CONFIG_RTC_INTF_PROC is not set
-# CONFIG_RTC_INTF_DEV is not set
-CONFIG_RTC_INTF_ALARM=y
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-
-#
-# SPI RTC drivers
-#
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_CMOS is not set
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-
-#
-# on-CPU RTC drivers
-#
-CONFIG_RTC_DRV_MSM7X00A=y
-# CONFIG_DMADEVICES is not set
-CONFIG_REGULATOR=y
-CONFIG_REGULATOR_DEBUG=y
-# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
-# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
-# CONFIG_REGULATOR_BQ24022 is not set
-CONFIG_REGULATOR_TPS65023=y
-# CONFIG_UIO is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_EXCLUDE_BUILD is not set
-# CONFIG_MEILHAUS is not set
-# CONFIG_ECHO is not set
-# CONFIG_COMEDI is not set
-
-#
-# Android
-#
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_RAM_CONSOLE=y
-CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
-CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
-# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
-CONFIG_ANDROID_TIMED_OUTPUT=y
-CONFIG_ANDROID_TIMED_GPIO=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-# CONFIG_BTPORT is not set
-# CONFIG_BTPORT_DRV is not set
-
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-# CONFIG_EXT2_FS_XIP is not set
-CONFIG_EXT3_FS=y
-CONFIG_EXT3_FS_XATTR=y
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-# CONFIG_EXT4_FS is not set
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-# CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_YAFFS_FS=y
-CONFIG_YAFFS_YAFFS1=y
-# CONFIG_YAFFS_9BYTE_TAGS is not set
-# CONFIG_YAFFS_DOES_ECC is not set
-CONFIG_YAFFS_YAFFS2=y
-CONFIG_YAFFS_AUTO_YAFFS2=y
-# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
-# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
-# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
-CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
-# CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFSD is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_UNUSED_SYMBOLS is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-CONFIG_DETECT_SOFTLOCKUP=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
-CONFIG_SCHEDSTATS=y
-CONFIG_TIMER_STATS=y
-# CONFIG_DEBUG_OBJECTS is not set
-#CONFIG_DEBUG_SLAB is not set
-#CONFIG_DEBUG_SLAB_LEAK is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-CONFIG_DEBUG_MUTEXES=y
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO=y
-CONFIG_DEBUG_VM=y
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_LIST is not set
-CONFIG_DEBUG_SG=y
-# CONFIG_DEBUG_NOTIFIERS is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-# CONFIG_RCU_CPU_STALL_DETECTOR is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_LATENCYTOP is not set
-CONFIG_HAVE_FUNCTION_TRACER=y
-
-#
-# Tracers
-#
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_BOOT_TRACER is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-# CONFIG_STACK_TRACER is not set
-# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-# CONFIG_DEBUG_USER is not set
-# CONFIG_DEBUG_ERRORS is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_LL is not set
-# CONFIG_DEBUG_ICEDCC is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_FIPS is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-CONFIG_CRYPTO_AUTHENC=y
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-CONFIG_CRYPTO_ECB=y
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_MD4 is not set
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
-CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_TWOFISH_COMMON=y
-
-#
-# Compression
-#
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_LZO is not set
-
-#
-# Random Number Generation
-#
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRYPTO_HW=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_FIND_LAST_BIT=y
-CONFIG_CRC_CCITT=y
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_ALLOCATOR=y
-CONFIG_REED_SOLOMON=y
-CONFIG_REED_SOLOMON_ENC8=y
-CONFIG_REED_SOLOMON_DEC8=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff --git a/arch/arm/mach-msm/Makefile b/arch/arm/mach-msm/Makefile
index 54b930b..ad4d807 100755
--- a/arch/arm/mach-msm/Makefile
+++ b/arch/arm/mach-msm/Makefile
@@ -32,7 +32,6 @@ obj-$(CONFIG_MSM_DALRPC) += dal.o
 obj-$(CONFIG_MSM_DALRPC_TEST) += dal_remotetest.o
 obj-$(CONFIG_MSM_ADSP) += qdsp5/
 obj-$(CONFIG_MSM_ADSP_COMP) += qdsp5_comp/
-obj-$(CONFIG_QSD_AUDIO) += qdsp6/
 obj-$(CONFIG_MSM_HW3D) += hw3d.o
 obj-$(CONFIG_PM) += pm.o
 obj-$(CONFIG_CPU_FREQ) += cpufreq.o
@@ -41,116 +40,11 @@ obj-$(CONFIG_HTC_ACOUSTIC) += htc_acoustic.o
 obj-$(CONFIG_HTC_ACOUSTIC_QSD) += htc_acoustic_qsd.o
 obj-$(CONFIG_SENSORS_AKM8976) += htc_akm_cal.o
 
-obj-$(CONFIG_MACH_HALIBUT) += board-halibut.o board-halibut-panel.o
-obj-$(CONFIG_MACH_HALIBUT) += board-halibut-keypad.o fish_battery.o
-obj-$(CONFIG_MACH_SWORDFISH) += board-swordfish.o
-obj-$(CONFIG_MACH_SWORDFISH) += board-swordfish-keypad.o fish_battery.o
-obj-$(CONFIG_MACH_SWORDFISH) += board-swordfish-panel.o
-obj-$(CONFIG_MACH_SWORDFISH) += board-swordfish-mmc.o
-obj-$(CONFIG_MACH_FIRESTONE) += board-firestone.o board-firestone-panel.o
-obj-$(CONFIG_MACH_FIRESTONE) += board-firestone-keypad.o board-firestone-mmc.o
-obj-$(CONFIG_MACH_FIRESTONE) += board-firestone-rfkill.o
-obj-$(CONFIG_MACH_TROUT) += board-trout.o board-trout-gpio.o
-obj-$(CONFIG_MACH_TROUT) += board-trout-keypad.o board-trout-panel.o
-obj-$(CONFIG_MACH_TROUT) += htc_akm_cal.o htc_wifi_nvs.o htc_acoustic.o
-obj-$(CONFIG_MACH_TROUT) += board-trout-mmc.o board-trout-wifi.o
-obj-$(CONFIG_MACH_TROUT) += devices_htc.o
-obj-$(CONFIG_MACH_MAHIMAHI) += board-mahimahi.o board-mahimahi-panel.o
-obj-$(CONFIG_MACH_MAHIMAHI) += board-mahimahi-keypad.o board-mahimahi-mmc.o
-
-obj-$(CONFIG_MACH_MAHIMAHI) += board-mahimahi-rfkill.o
-obj-$(CONFIG_MACH_MAHIMAHI) += board-mahimahi-wifi.o board-mahimahi-audio.o
-obj-$(CONFIG_MACH_MAHIMAHI) += msm_vibrator.o
-obj-$(CONFIG_MACH_MAHIMAHI) += board-mahimahi-microp.o
-obj-$(CONFIG_MACH_MAHIMAHI) += htc_acoustic_qsd.o
-# obj-$(CONFIG_MACH_MAHIMAHI) += board-mahimahi-flashlight.o
-
-obj-$(CONFIG_MACH_PASSIONC) += board-passionc.o board-amoled-panel.o
-obj-$(CONFIG_MACH_PASSIONC) += board-passionc-keypad.o board-passionc-mmc.o
-obj-$(CONFIG_MACH_PASSIONC) += board-passionc-rfkill.o board-passionc-audio.o
-obj-$(CONFIG_MACH_PASSIONC) += board-passionc-wifi.o htc_awb_cal.o
-obj-$(CONFIG_MACH_PASSIONC) += board-passionc-microp.o
-obj-$(CONFIG_MACH_INCREDIBLE) += board-incredible.o board-incredible-panel.o
-obj-$(CONFIG_MACH_INCREDIBLE) += board-incredible-keypad.o board-incredible-mmc.o
-obj-$(CONFIG_MACH_INCREDIBLE) += board-incredible-rfkill.o board-incredible-audio.o
-obj-$(CONFIG_MACH_INCREDIBLEC) += board-incrediblec.o board-amoled-panel.o board-incrediblec-tv.o
-obj-$(CONFIG_MACH_INCREDIBLEC) += board-incrediblec-keypad.o board-incrediblec-mmc.o
-obj-$(CONFIG_MACH_INCREDIBLEC) += board-incrediblec-rfkill.o board-incrediblec-audio.o
-obj-$(CONFIG_MACH_INCREDIBLEC) += board-incrediblec-wifi.o htc_awb_cal.o
-obj-$(CONFIG_MACH_INCREDIBLEC) += board-incrediblec-microp.o
-obj-$(CONFIG_MACH_INCREDIBLEC) += proc_engineerid.o
-obj-$(CONFIG_MACH_SUPERSONIC) += board-supersonic.o board-supersonic-panel.o
-obj-$(CONFIG_MACH_SUPERSONIC) += board-supersonic-keypad.o board-supersonic-mmc.o
-obj-$(CONFIG_MACH_SUPERSONIC) += board-supersonic-rfkill.o board-supersonic-audio.o
-obj-$(CONFIG_MACH_SUPERSONIC) += board-supersonic-wifi.o htc_awb_cal.o
-obj-$(CONFIG_MACH_SUPERSONIC) += board-supersonic-microp.o
-obj-$(CONFIG_MACH_ORCA) += board-orca.o board-orca-panel.o
-obj-$(CONFIG_MACH_ORCA) += board-orca-keypad.o board-orca-mmc.o
-obj-$(CONFIG_MACH_ORCA) += board-orca-rfkill.o
-obj-$(CONFIG_MACH_ORCA) += board-orca-audio.o board-orca-wifi.o
-obj-$(CONFIG_MACH_ORCA) += board-orca-microp.o
-obj-$(CONFIG_MACH_BRAVO) += board-bravo.o board-amoled-panel.o
-obj-$(CONFIG_MACH_BRAVO) += board-bravo-keypad.o board-bravo-mmc.o
-obj-$(CONFIG_MACH_BRAVO) += board-bravo-rfkill.o
-obj-$(CONFIG_MACH_BRAVO) += board-bravo-audio.o board-bravo-wifi.o htc_awb_cal.o
-obj-$(CONFIG_MACH_BRAVO) += board-bravo-microp.o
-obj-$(CONFIG_MACH_BRAVOC) += board-bravoc.o board-amoled-panel.o
-obj-$(CONFIG_MACH_BRAVOC) += board-bravoc-keypad.o board-bravoc-mmc.o
-obj-$(CONFIG_MACH_BRAVOC) += board-bravoc-rfkill.o board-bravoc-audio.o
-obj-$(CONFIG_MACH_BRAVOC) += board-bravoc-wifi.o htc_awb_cal.o
-obj-$(CONFIG_MACH_BRAVOC) += board-bravoc-microp.o
-
-# MSM7200A boards
-obj-$(CONFIG_MACH_HERO) += board-hero.o board-hero-panel.o board-hero-keypad.o
-obj-$(CONFIG_MACH_HERO) += board-hero-rfkill.o
-obj-$(CONFIG_MACH_HERO) += board-hero-mmc.o board-hero-wifi.o htc_wifi_nvs.o htc_awb_cal.o
-
-obj-$(CONFIG_MACH_SAPPHIRE) += board-sapphire.o board-sapphire-panel.o board-sapphire-keypad.o board-sapphire-gpio.o
-obj-$(CONFIG_MACH_SAPPHIRE) += board-sapphire-rfkill.o
-obj-$(CONFIG_MACH_SAPPHIRE) += board-sapphire-mmc.o board-sapphire-wifi.o
-#obj-$(CONFIG_MACH_SAPPHIRE) +=  msm_vibrator.o
-#obj-$(CONFIG_MACH_SAPPHIRE) += devices_htc.o
-
-
-# MSM7225 boards
-obj-$(CONFIG_MACH_BUZZ) += board-buzz.o board-buzz-panel.o board-buzz-keypad.o board-buzz-microp.o
-obj-$(CONFIG_MACH_BUZZ) += board-buzz-rfkill.o board-buzz-mmc.o board-buzz-wifi.o
-obj-$(CONFIG_MACH_BEE) += board-bee.o board-bee-panel.o board-bee-keypad.o board-bee-microp.o
-obj-$(CONFIG_MACH_BEE) += board-bee-rfkill.o board-bee-mmc.o board-bee-wifi.o
-obj-$(CONFIG_MACH_BUZZC) += board-buzzc.o board-buzzc-panel.o board-buzzc-keypad.o board-buzzc-microp.o
-obj-$(CONFIG_MACH_BUZZC) += board-buzzc-rfkill.o board-buzzc-mmc.o board-buzzc-wifi.o
-obj-$(CONFIG_MACH_PARADISE) += board-paradise.o board-paradise-panel.o board-paradise-keypad.o
-obj-$(CONFIG_MACH_PARADISE) += board-paradise-rfkill.o board-paradise-wifi.o
-obj-$(CONFIG_MACH_PARADISE) += board-paradise-mmc.o board-paradise-microp.o
-obj-$(CONFIG_MACH_BAHAMAS) += board-bahamas.o board-click-panel.o board-bahamas-keypad.o
-obj-$(CONFIG_MACH_BAHAMAS) += board-bahamas-mmc.o board-bahamas-rfkill.o
-
-# MSM7227 boards
-obj-$(CONFIG_MACH_LEGEND) += board-legend-rfkill.o
-obj-$(CONFIG_MACH_LEGEND) += board-legend.o board-legend-keypad.o board-legend-panel.o
-obj-$(CONFIG_MACH_LEGEND) += board-legend-mmc.o board-legend-wifi.o board-legend-microp.o
-obj-$(CONFIG_MACH_LATTE) += board-latte-rfkill.o
-obj-$(CONFIG_MACH_LATTE) += board-latte.o board-latte-keypad.o board-latte-panel.o
-obj-$(CONFIG_MACH_LATTE) += board-latte-mmc.o board-latte-wifi.o board-latte-microp.o
-obj-$(CONFIG_MACH_LIBERTY) += board-liberty-rfkill.o htc_bluetooth.o
-obj-$(CONFIG_MACH_LIBERTY) += board-liberty.o board-liberty-keypad.o board-liberty-panel.o
-obj-$(CONFIG_MACH_LIBERTY) += board-liberty-mmc.o board-liberty-wifi.o board-liberty-microp.o
-
-# MSM7600 boards
-obj-$(CONFIG_MACH_DESIREC) += board-desirec.o board-desirec-panel.o board-desirec-keypad.o
-obj-$(CONFIG_MACH_DESIREC) += board-desirec-rfkill.o
-obj-$(CONFIG_MACH_DESIREC) += board-desirec-mmc.o board-desirec-wifi.o htc_wifi_nvs.o
 obj-$(CONFIG_MACH_HEROC) += board-heroc.o board-heroc-panel.o board-heroc-keypad.o
 obj-$(CONFIG_MACH_HEROC) += board-heroc-rfkill.o
 obj-$(CONFIG_MACH_HEROC) += board-heroc-mmc.o board-heroc-wifi.o htc_wifi_nvs.o
 
 obj-$(CONFIG_ARCH_MSM7X00A) += msm_vibrator.o devices_htc.o
-obj-$(CONFIG_ARCH_MSM7225) += msm_vibrator.o devices_htc.o htc_wifi_nvs.o htc_awb_cal.o htc_bluetooth.o
-obj-$(CONFIG_ARCH_MSM7227) += msm_vibrator.o devices_htc.o htc_wifi_nvs.o htc_awb_cal.o
-obj-$(CONFIG_ARCH_QSD8X50) += msm_vibrator.o
-obj-$(CONFIG_ARCH_MSM_FLASHLIGHT) += msm_flashlight.o
-# obj-$(CONFIG_TROUT_BATTCHG) += htc_battery.o
-# obj-$(CONFIG_TROUT_BATTCHG) += htc_power_supply.o
 obj-$(CONFIG_TROUT_BATTCHG_DOCK) += htc_one_wire.o
 
 obj-$(CONFIG_TROUT_BATTCHG) += htc_battery_trout.o
diff --git a/arch/arm/mach-msm/board-bahamas-keypad.c b/arch/arm/mach-msm/board-bahamas-keypad.c
deleted file mode 100644
index de7b83a..0000000
--- a/arch/arm/mach-msm/board-bahamas-keypad.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* arch/arm/mach-msm7225/board-bahamas-keypad.c
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Tony Liu <tony_liu@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <linux/keyreset.h>
-#include <asm/mach-types.h>
-
-#include "board-bahamas.h"
-
-
-static unsigned int bahamas_col_gpios[] = { 35, 34, 33 };
-static unsigned int bahamas_row_gpios[] = { 42, 41, 40, 39 };
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(bahamas_row_gpios) + (row))
-
-static const unsigned short
-bahamas_keymap[ARRAY_SIZE(bahamas_col_gpios) * ARRAY_SIZE(bahamas_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_REPLY,
-	[KEYMAP_INDEX(0, 1)] = KEY_UP,
-	[KEYMAP_INDEX(0, 2)] = KEY_RIGHT,
-	[KEYMAP_INDEX(0, 3)] = KEY_VOLUMEUP,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_SEARCH,
-	[KEYMAP_INDEX(1, 1)] = KEY_DOWN,
-	[KEYMAP_INDEX(1, 2)] = KEY_BACK,
-	[KEYMAP_INDEX(1, 3)] = KEY_VOLUMEDOWN,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_HOME,
-	[KEYMAP_INDEX(2, 1)] = KEY_SEND,
-	[KEYMAP_INDEX(2, 2)] = KEY_LEFT,
-	[KEYMAP_INDEX(2, 3)] = KEY_MENU,
-};
-
-static struct gpio_event_matrix_info bahamas_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = bahamas_keymap,
-	.output_gpios = bahamas_col_gpios,
-	.input_gpios = bahamas_row_gpios,
-	.noutputs = ARRAY_SIZE(bahamas_col_gpios),
-	.ninputs = ARRAY_SIZE(bahamas_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.flags = GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		GPIOKPF_REMOVE_PHANTOM_KEYS |
-		GPIOKPF_PRINT_UNMAPPED_KEYS /*| GPIOKPF_PRINT_MAPPED_KEYS*/
-};
-
-static struct gpio_event_direct_entry bahamas_keypad_nav_map[] = {
-	{ BAHAMAS_POWER_KEY,               KEY_END    },
-};
-
-static struct gpio_event_input_info bahamas_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.flags = 0,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = bahamas_keypad_nav_map,
-	.keymap_size = ARRAY_SIZE(bahamas_keypad_nav_map)
-};
-
-static struct gpio_event_info *bahamas_keypad_info[] = {
-	&bahamas_keypad_matrix_info.info,
-	&bahamas_keypad_nav_info.info,
-};
-
-static struct gpio_event_platform_data bahamas_keypad_data = {
-	.name = "bahamas-keypad",
-	.info = bahamas_keypad_info,
-	.info_count = ARRAY_SIZE(bahamas_keypad_info)
-};
-
-static struct platform_device bahamas_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &bahamas_keypad_data,
-	},
-};
-
-static int bahamas_reset_keys_up[] = {
-	BTN_MOUSE,
-	0
-};
-
-static struct keyreset_platform_data bahamas_reset_keys_pdata0 = {
-	.keys_up = bahamas_reset_keys_up,
-	.keys_down = {
-		KEY_HOME,
-		KEY_MENU,
-		KEY_END,
-		0
-	},
-};
-
-static struct keyreset_platform_data bahamas_reset_keys_pdata1 = {
-	.keys_up = bahamas_reset_keys_up,
-	.keys_down = {
-		KEY_SEND,
-		KEY_MENU,
-		KEY_END,
-		0
-	},
-};
-
-struct platform_device bahamas_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &bahamas_reset_keys_pdata1,
-};
-
-static int __init bahamas_init_keypad(void)
-{
-	if (!machine_is_bahamas())
-		return 0;
-
-	if (!system_rev)
-		bahamas_reset_keys_device.dev.platform_data =
-						    &bahamas_reset_keys_pdata0;
-
-	if (platform_device_register(&bahamas_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	return platform_device_register(&bahamas_keypad_device);
-}
-
-device_initcall(bahamas_init_keypad);
diff --git a/arch/arm/mach-msm/board-bahamas-mmc.c b/arch/arm/mach-msm/board-bahamas-mmc.c
deleted file mode 100644
index 4e8159c..0000000
--- a/arch/arm/mach-msm/board-bahamas-mmc.c
+++ /dev/null
@@ -1,473 +0,0 @@
-/* linux/arch/arm/mach-msm7225/board-bahamas-mmc.c
- *
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Tony Liu <tony_liu@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <asm/mach-types.h>
-
-#include <mach/vreg.h>
-
-#include <asm/mach/mmc.h>
-
-#include "devices.h"
-#include "board-bahamas.h"
-#include "proc_comm.h"
-
-/* #include <linux/irq.h> */
-
-#define DEBUG_SDSLOT_VDD 1
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init bahamas_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_bahamas.disable_sdcard=", bahamas_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_27_28,	2800 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t bahamas_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		vreg_enable(vreg_sdslot);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-#if DEBUG_SDSLOT_VDD
-			printk(KERN_INFO "%s: Setting level to %u\n",
-					__func__, mmc_vdd_table[i].level);
-#endif
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-			return 0;
-		}
-	}
-
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int bahamas_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(BAHAMAS_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define BAHAMAS_MMC_VDD	MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
-
-static unsigned int bahamas_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data bahamas_sdslot_data = {
-	.ocr_mask	= BAHAMAS_MMC_VDD,
-	/* .status_irq		= MSM_GPIO_TO_INT(BAHAMAS_GPIO_SDMC_CD_N), */
-	.status		= bahamas_sdslot_status,
-	.translate_vdd	= bahamas_sdslot_switchvdd,
-	.slot_type	= &bahamas_sdslot_type,
-};
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-static struct vreg *vreg_wifi_osc;	/* WIFI 32khz oscilator */
-static struct vreg *vreg_wifi_batpa;	/* WIFI main power */
-static int bahamas_wifi_cd;		/* WIFI virtual 'card detect' status */
-
-static struct sdio_embedded_func wifi_func = {
-	.f_class	= SDIO_CLASS_WLAN,
-	.f_maxblksize	= 512,
-};
-
-static struct embedded_sdio_data bahamas_wifi_emb_data = {
-	.cis	= {
-		.vendor		= 0x104c,
-		.device		= 0x9066,
-		.blksize	= 512,
-		/* .max_dtr	= 24000000, */
-		.max_dtr	= 20000000,
-	},
-	.cccr	= {
-		.multi_block	= 0,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 0,
-		.high_speed	= 0,
-	},
-	.funcs	= &wifi_func,
-	.num_funcs = 1,
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-bahamas_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int bahamas_wifi_status(struct device *dev)
-{
-	return bahamas_wifi_cd;
-}
-
-static struct mmc_platform_data bahamas_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= bahamas_wifi_status,
-	.register_status_notify	= bahamas_wifi_status_register,
-	.embedded_sdio		= &bahamas_wifi_emb_data,
-};
-
-int bahamas_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	bahamas_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-
-int bahamas_wifi_power_state = 0;
-int bahamas_bt_power_state = 0;
-
-int bahamas_wifi_power(int on)
-{
-	int rc;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		vreg_enable(vreg_wifi_batpa);
-		vreg_set_level(vreg_wifi_batpa, 3000);
-		mdelay(50);
-		rc = vreg_enable(vreg_wifi_osc);
-		vreg_set_level(vreg_wifi_osc, 1800);
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-	mdelay(100);
-	gpio_set_value(BAHAMAS_GPIO_WIFI_EN, on);
-	mdelay(100);
-	if (!on) {
-		if (!bahamas_bt_power_state) {
-			vreg_disable(vreg_wifi_osc);
-			vreg_disable(vreg_wifi_batpa);
-		} else
-			printk(KERN_ERR "WiFi shouldn't disable vreg_wifi_osc. "
-						"BT is using it!!\n");
-	}
-	bahamas_wifi_power_state = on;
-	return 0;
-}
-#ifndef CONFIG_WIFI_CONTROL_FUNC
-EXPORT_SYMBOL(bahamas_wifi_power);
-#endif
-
-/* Eenable VREG_MMC pin to turn on fastclock oscillator : colin */
-int bahamas_bt_fastclock_power(int on)
-{
-	int rc;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (vreg_wifi_osc) {
-		if (on) {
-			rc = vreg_enable(vreg_wifi_osc);
-
-			if (rc) {
-				printk(KERN_ERR "Error turn bt_fastclock_power "
-							"rc=%d\n", rc);
-				return rc;
-			}
-		} else {
-			if (!bahamas_wifi_power_state)
-				vreg_disable(vreg_wifi_osc);
-		}
-	}
-	bahamas_bt_power_state = on;
-	return 0;
-}
-EXPORT_SYMBOL(bahamas_bt_fastclock_power);
-
-static int bahamas_wifi_reset_state;
-int bahamas_wifi_reset(int on)
-{
-#if 1
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-#else
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-	gpio_set_value(TROUT_GPIO_WIFI_PA_RESETX, !on);
-	bahamas_wifi_reset_state = on;
-	mdelay(50);
-#endif
-	return 0;
-}
-#ifndef CONFIG_WIFI_CONTROL_FUNC
-EXPORT_SYMBOL(bahamas_wifi_reset);
-#endif
-
-int __init bahamas_init_mmc(unsigned int sys_rev)
-{
-	wifi_status_cb = NULL;
-
-
-	sdslot_vreg_enabled = 0;
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-
-	printk(KERN_INFO "%s\n", __func__);
-
-	vreg_wifi_batpa = vreg_get(0, "wlan");
-	if (IS_ERR(vreg_wifi_batpa))
-		return PTR_ERR(vreg_wifi_batpa);
-	vreg_set_level(vreg_wifi_batpa, 3000);
-
-	vreg_wifi_osc = vreg_get(0, "rftx");
-	if (IS_ERR(vreg_wifi_osc))
-		return PTR_ERR(vreg_wifi_osc);
-	vreg_set_level(vreg_wifi_osc, 1800);
-
-	set_irq_wake(MSM_GPIO_TO_INT(BAHAMAS_GPIO_SDMC_CD_N), 1);
-
-    msm_add_sdcc(1, &bahamas_wifi_data, 0, 0);
-
-	if (!opt_disable_sdcard)
-		msm_add_sdcc(2, &bahamas_sdslot_data,
-			MSM_GPIO_TO_INT(BAHAMAS_GPIO_SDMC_CD_N),
-			IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-	else
-		printk(KERN_INFO "bahamas: SD-Card interface disabled\n");
-
-	return 0;
-}
-
-
-#if defined(CONFIG_DEBUG_FS)
-
-static int bahamasmmc_dbg_wifi_reset_set(void *data, u64 val)
-{
-	bahamas_wifi_reset((int) val);
-	return 0;
-}
-
-static int bahamasmmc_dbg_wifi_reset_get(void *data, u64 *val)
-{
-	*val = bahamas_wifi_reset_state;
-	return 0;
-}
-
-static int bahamasmmc_dbg_wifi_cd_set(void *data, u64 val)
-{
-	bahamas_wifi_set_carddetect((int) val);
-	return 0;
-}
-
-static int bahamasmmc_dbg_wifi_cd_get(void *data, u64 *val)
-{
-	*val = bahamas_wifi_cd;
-	return 0;
-}
-
-static int bahamasmmc_dbg_wifi_pwr_set(void *data, u64 val)
-{
-	bahamas_wifi_power((int) val);
-	return 0;
-}
-
-static int bahamasmmc_dbg_wifi_pwr_get(void *data, u64 *val)
-{
-	*val = bahamas_wifi_power_state;
-	return 0;
-}
-
-static int bahamasmmc_dbg_sd_pwr_set(void *data, u64 val)
-{
-	bahamas_sdslot_switchvdd(NULL, (unsigned int) val);
-	return 0;
-}
-
-static int bahamasmmc_dbg_sd_pwr_get(void *data, u64 *val)
-{
-	*val = sdslot_vdd;
-	return 0;
-}
-
-static int bahamasmmc_dbg_sd_cd_set(void *data, u64 val)
-{
-	return -ENOSYS;
-}
-
-static int bahamasmmc_dbg_sd_cd_get(void *data, u64 *val)
-{
-	*val = bahamas_sdslot_status(NULL);
-	return 0;
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(bahamasmmc_dbg_wifi_reset_fops,
-			bahamasmmc_dbg_wifi_reset_get,
-			bahamasmmc_dbg_wifi_reset_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(bahamasmmc_dbg_wifi_cd_fops,
-			bahamasmmc_dbg_wifi_cd_get,
-			bahamasmmc_dbg_wifi_cd_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(bahamasmmc_dbg_wifi_pwr_fops,
-			bahamasmmc_dbg_wifi_pwr_get,
-			bahamasmmc_dbg_wifi_pwr_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(bahamasmmc_dbg_sd_pwr_fops,
-			bahamasmmc_dbg_sd_pwr_get,
-			bahamasmmc_dbg_sd_pwr_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(bahamasmmc_dbg_sd_cd_fops,
-			bahamasmmc_dbg_sd_cd_get,
-			bahamasmmc_dbg_sd_cd_set, "%llu\n");
-
-static int __init bahamasmmc_dbg_init(void)
-{
-	if (!machine_is_bahamas())
-		return 0;
-	struct dentry *dent;
-
-	dent = debugfs_create_dir("bahamasmmc_dbg", 0);
-	if (IS_ERR(dent))
-		return PTR_ERR(dent);
-
-	debugfs_create_file("wifi_reset", 0644, dent, NULL,
-			    &bahamasmmc_dbg_wifi_reset_fops);
-	debugfs_create_file("wifi_cd", 0644, dent, NULL,
-			    &bahamasmmc_dbg_wifi_cd_fops);
-	debugfs_create_file("wifi_pwr", 0644, dent, NULL,
-			    &bahamasmmc_dbg_wifi_pwr_fops);
-	debugfs_create_file("sd_pwr", 0644, dent, NULL,
-			    &bahamasmmc_dbg_sd_pwr_fops);
-	debugfs_create_file("sd_cd", 0644, dent, NULL,
-			    &bahamasmmc_dbg_sd_cd_fops);
-	return 0;
-}
-
-device_initcall(bahamasmmc_dbg_init);
-
-#endif
diff --git a/arch/arm/mach-msm/board-bahamas-rfkill.c b/arch/arm/mach-msm/board-bahamas-rfkill.c
deleted file mode 100644
index 1a5a542..0000000
--- a/arch/arm/mach-msm/board-bahamas-rfkill.c
+++ /dev/null
@@ -1,109 +0,0 @@
-/* linux/arch/arm/mach-msm7225/board-bahamas-rfkill.c
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Tony Liu <tony_liu@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-/* Control bluetooth power for bahamas platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-#include "board-bahamas.h"
-
-extern int bahamas_bt_fastclock_power(int on);
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "brf6300";
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		bahamas_bt_fastclock_power(1);
-		udelay(10);
-		gpio_configure(101, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		gpio_configure(101, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-		bahamas_bt_fastclock_power(0);
-		break;
-	default:
-		printk(KERN_ERR "bad bluetooth rfkill state %d\n", state);
-	}
-	return 0;
-}
-
-static int bahamas_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;  /* off */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;  /* user data */
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-
-	if (rc)
-		rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int bahamas_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver bahamas_rfkill_driver = {
-	.probe = bahamas_rfkill_probe,
-	.remove = bahamas_rfkill_remove,
-	.driver = {
-		.name = "bahamas_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init bahamas_rfkill_init(void)
-{
-	if (!machine_is_bahamas())
-		return 0;
-	return platform_driver_register(&bahamas_rfkill_driver);
-}
-
-static void __exit bahamas_rfkill_exit(void)
-{
-	platform_driver_unregister(&bahamas_rfkill_driver);
-}
-
-module_init(bahamas_rfkill_init);
-module_exit(bahamas_rfkill_exit);
-MODULE_DESCRIPTION("bahamas rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-bahamas.c b/arch/arm/mach-msm/board-bahamas.c
deleted file mode 100644
index eeac011..0000000
--- a/arch/arm/mach-msm/board-bahamas.c
+++ /dev/null
@@ -1,1115 +0,0 @@
-/* arch/arm/mach-msm/board-bahamas.c
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Tony Liu <tony_liu@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/irq.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <linux/sysdev.h>
-#include <linux/android_pmem.h>
-
-#include <mach/board.h>
-#include <mach/camera.h>
-
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/io.h>
-
-#include <mach/hardware.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <mach/system.h>
-#include <mach/vreg.h>
-#include <mach/h2w_v1.h>
-#include <mach/audio_jack.h>
-
-#include <asm/setup.h>
-
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-
-#include <asm/mach/mmc.h>
-#include <linux/mmc/sdio_ids.h>
-
-#include "board-bahamas.h"
-#include "proc_comm.h"
-#include "gpio_chip.h"
-
-#include <mach/board_htc.h>
-#include <mach/msm_serial_hs.h>
-#include <mach/msm_serial_debugger.h>
-
-#include "devices.h"
-
-#include <mach/microp_i2c.h>
-#include <mach/msm_tssc.h>
-#include <linux/keyreset.h>
-
-#include <mach/htc_pwrsink.h>
-#include <mach/perflock.h>
-#include <mach/drv_callback.h>
-#include <mach/msm_hsusb.h>
-#include <mach/msm_rpcrouter.h>
-
-void msm_init_irq(void);
-void msm_init_gpio(void);
-void msm_init_pmic_vibrator(void);
-void config_bahamas_camera_on_gpios(void);
-void config_bahamas_camera_off_gpios(void);
-
-extern int bahamas_init_mmc(unsigned int);
-static unsigned int hwid;
-static unsigned int skuid;
-static unsigned engineerid;
-
-enum {
-	PANEL_HITACHI = 0,
-	PANEL_WINTEK,
-	PANEL_SAMSUNG,
-};
-
-#define LCM_ID0 57
-#define LCM_ID1 58
-
-static struct msm_hsusb_product bahamas_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c9f,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-#define HSUSB_API_INIT_PHY_PROC	2
-#define HSUSB_API_PROG		0x30000064
-#define HSUSB_API_VERS MSM_RPC_VERS(1, 1)
-
-static void bahamas_phy_reset(void)
-{
-	struct msm_rpc_endpoint *usb_ep;
-	int rc;
-	struct hsusb_phy_start_req {
-		struct rpc_request_hdr hdr;
-	} req;
-
-	printk(KERN_INFO "msm_hsusb_phy_reset\n");
-
-	usb_ep = msm_rpc_connect(HSUSB_API_PROG, HSUSB_API_VERS, 0);
-	if (IS_ERR(usb_ep)) {
-		printk(KERN_ERR "%s: init rpc failed! error: %ld\n",
-				__func__, PTR_ERR(usb_ep));
-		return;
-	}
-	rc = msm_rpc_call(usb_ep, HSUSB_API_INIT_PHY_PROC,
-			&req, sizeof(req), 5 * HZ);
-	if (rc < 0)
-		printk(KERN_ERR "%s: rpc call failed! (%d)\n", __func__, rc);
-
-	msm_rpc_close(usb_ep);
-}
-
-static int panel_detect(void)
-{
-	int panel_id = -1 ;
-
-	panel_id = ((gpio_get_value(LCM_ID1) << 1) | gpio_get_value(LCM_ID0));
-
-	switch (panel_id) {
-	case PANEL_HITACHI:
-		break ;
-	case PANEL_WINTEK:
-		break ;
-	case PANEL_SAMSUNG:
-		break ;
-	default:
-		printk(KERN_DEBUG "%s: Invalid panel id !\n", __func__);
-		break ;
-	}
-
-	return panel_id ;
-}
-
-/* Samsung panel */
-static struct microp_pin_config microp_pins_0[] = {
-	{
-		.name   = "green",
-		.pin    = 3,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "amber",
-		.pin    = 5,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "lcd-backlight",
-		.pin    = 6,
-		.config = MICROP_PIN_CONFIG_PWM,
-		.freq   = MICROP_PIN_PWM_FREQ_HZ_15600,
-		.levels = { 3, 31, 59, 87, 115, 143, 171, 199, 227, 255 },
-		.dutys	= { 10, 16, 39, 74, 118, 154, 180, 207, 235, 255 },
-	},
-	{
-		.name	= "button-backlight",
-		.pin	= 10,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name   = "adc",
-		.pin    = 24,
-		.config = MICROP_PIN_CONFIG_ADC,
-		.levels = { 0, 0, 0, 6, 51, 319, 425, 497, 569, 638 },
-	}
-};
-
-/* Wintek panel */
-static struct microp_pin_config microp_pins_0_wint[] = {
-	{
-		.name   = "green",
-		.pin    = 3,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "amber",
-		.pin    = 5,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "lcd-backlight",
-		.pin    = 6,
-		.config = MICROP_PIN_CONFIG_PWM,
-		.freq   = MICROP_PIN_PWM_FREQ_HZ_15600,
-		.levels = { 3, 31, 59, 87, 115, 143, 171, 199, 227, 255 },
-		.dutys	= { 10, 16, 39, 74, 118, 154, 176, 201, 226, 240 },
-	},
-	{
-		.name	= "button-backlight",
-		.pin	= 10,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name   = "adc",
-		.pin    = 24,
-		.config = MICROP_PIN_CONFIG_ADC,
-		.levels = { 0, 0, 0, 6, 51, 319, 425, 497, 569, 638 },
-	}
-};
-
-/* XD after, Samsung panel */
-static struct microp_pin_config microp_pins_1[] = {
-	{	.name = "microp-pullup",
-		.pin = 23,
-		.config = MICROP_PIN_CONFIG_PULL_UP1,
-		.mask = { 0x00, 0x00, 0x02 },
-	},
-	MICROP_PIN(0, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(1, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(2, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(4, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(7, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(8, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(9, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(11, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(12, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(13, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(14, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(15, MICROP_PIN_CONFIG_GPO),
-	{
-		.name   = "green",
-		.pin    = 3,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "amber",
-		.pin    = 5,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "lcd-backlight",
-		.pin    = 6,
-		.config = MICROP_PIN_CONFIG_PWM,
-		.freq   = MICROP_PIN_PWM_FREQ_HZ_15600,
-		.levels = { 3, 31, 59, 87, 115, 143, 171, 199, 227, 255 },
-		.dutys	= { 10, 16, 39, 74, 118, 154, 180, 207, 235, 255 },
-	},
-	{
-		.name	= "button-backlight",
-		.pin	= 10,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name = "microp_11pin_mic",
-		.pin = 16,
-		.config = MICROP_PIN_CONFIG_MIC,
-		.init_value = 1,
-	},
-	{
-		.name	= "microp_intrrupt",
-		.pin	= 17,
-		.config  = MICROP_PIN_CONFIG_INTR_ALL,
-		.mask	 = { 0x00, 0x00, 0x00 },
-	},
-	{
-		.name   = "audio_remote_sensor",
-		.pin    = 25,
-		.adc_pin = 7,
-		.config = MICROP_PIN_CONFIG_ADC_READ,
-	}
-};
-
-/* XD after, Wintek panel */
-static struct microp_pin_config microp_pins_1_wint[] = {
-	{	.name = "microp-pullup",
-		.pin = 23,
-		.config = MICROP_PIN_CONFIG_PULL_UP1,
-		.mask = { 0x00, 0x00, 0x02 },
-	},
-	MICROP_PIN(0, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(1, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(2, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(4, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(7, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(8, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(9, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(11, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(12, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(13, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(14, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(15, MICROP_PIN_CONFIG_GPO),
-	{
-		.name   = "green",
-		.pin    = 3,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "amber",
-		.pin    = 5,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "lcd-backlight",
-		.pin    = 6,
-		.config = MICROP_PIN_CONFIG_PWM,
-		.freq   = MICROP_PIN_PWM_FREQ_HZ_15600,
-		.levels = { 3, 31, 59, 87, 115, 143, 171, 199, 227, 255 },
-		.dutys	= { 10, 16, 39, 74, 118, 154, 176, 201, 226, 240 },
-	},
-	{
-		.name	= "button-backlight",
-		.pin	= 10,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name = "microp_11pin_mic",
-		.pin = 16,
-		.config = MICROP_PIN_CONFIG_MIC,
-		.init_value = 1,
-	},
-	{
-		.name	= "microp_intrrupt",
-		.pin	= 17,
-		.config  = MICROP_PIN_CONFIG_INTR_ALL,
-		.mask	 = { 0x00, 0x00, 0x00 },
-	},
-	{
-		.name   = "audio_remote_sensor",
-		.pin    = 25,
-		.adc_pin = 7,
-		.config = MICROP_PIN_CONFIG_ADC_READ,
-	}
-};
-
-static struct msm_i2c_device_platform_data msm_i2c_device_data = {
-	.i2c_clock = 100000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_pins   = ARRAY_SIZE(microp_pins_1),
-	.pin_config = microp_pins_1,
-	.microp_enable_early_suspend = 1,
-	.gpio_reset = BAHAMAS_GPIO_UP_RESET_N,
-	.microp_enable_reset_button = 1,
-};
-
-static struct i2c_board_info i2c_microp_devices = {
-	I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-	.platform_data = &microp_data,
-	.irq = MSM_GPIO_TO_INT(BAHAMAS_XD_GPIO_UP_INT),
-};
-
-static struct akm8973_platform_data compass_platform_data = {
-	.reset = BAHAMA_GPIO_COMPASS_RST_N,
-	.intr = BAHAMA_GPIO_COMPASS_INT_N,
-};
-
-static struct bma150_platform_data gsensor_platform_data = {
-	.intr = BAHAMA_GPIO_GSENSOR_INT_N,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		/*I2C_BOARD_INFO("s5k4b2fx", 0x22 >> 1),*/
-		I2C_BOARD_INFO("s5k4b2fx", 0x22),
-		/* .irq = TROUT_GPIO_TO_INT(TROUT_GPIO_CAM_BTN_STEP1_N), */
-	},
-};
-
-static struct i2c_board_info i2c_sensor[] = {
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = MSM_GPIO_TO_INT(BAHAMA_GPIO_COMPASS_INT_N),
-	},
-	{
-		I2C_BOARD_INFO(BMA150_I2C_NAME, 0x38),
-		.platform_data = &gsensor_platform_data,
-		.irq = MSM_GPIO_TO_INT(BAHAMA_GPIO_GSENSOR_INT_N),
-	},
-};
-
-/* Switch between UART3 and GPIO */
-static uint32_t uart3_on_gpio_table[] = {
-	/* RX */
-	PCOM_GPIO_CFG(BAHAMAS_GPIO_UART3_RX, 1, GPIO_INPUT, GPIO_NO_PULL, 0),
-	/* TX */
-	PCOM_GPIO_CFG(BAHAMAS_GPIO_UART3_TX, 1, GPIO_OUTPUT, GPIO_NO_PULL, 0),
-};
-
-/* Set TX,RX to GPI */
-static uint32_t uart3_off_gpi_table[] = {
-	PCOM_GPIO_CFG(BAHAMAS_GPIO_H2W_DATA, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA), /* RX, H2W DATA */
-	PCOM_GPIO_CFG(BAHAMAS_GPIO_H2W_CLK, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA), /* TX, H2W CLK */
-};
-
-static int bahamas_h2w_path = H2W_GPIO;
-
-static void h2w_configure(int route)
-{
-	printk(KERN_INFO "H2W route = %s \n",
-	       route == H2W_UART3 ? "UART3" : "GPIO");
-	switch (route) {
-	case H2W_UART3:
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_on_gpio_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_on_gpio_table+1, 0);
-		bahamas_h2w_path = H2W_UART3;
-		break;
-	case H2W_GPIO:
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table+1, 0);
-		bahamas_h2w_path = H2W_GPIO;
-		break;
-	}
-}
-
-static void h2w_defconfig(void)
-{
-	h2w_configure(H2W_GPIO);
-}
-
-static void set_h2w_dat(int n)
-{
-	gpio_set_value(BAHAMAS_GPIO_H2W_DATA, n);
-}
-
-static void set_h2w_clk(int n)
-{
-	gpio_set_value(BAHAMAS_GPIO_H2W_CLK, n);
-}
-
-static void set_h2w_dat_dir(int n)
-{
-	if (n == 0) /* input */
-		gpio_direction_input(BAHAMAS_GPIO_H2W_DATA);
-	else
-		gpio_configure(BAHAMAS_GPIO_H2W_DATA, GPIOF_DRIVE_OUTPUT);
-}
-
-static void set_h2w_clk_dir(int n)
-{
-	if (n == 0) /* input */
-		gpio_direction_input(BAHAMAS_GPIO_H2W_CLK);
-	else
-		gpio_configure(BAHAMAS_GPIO_H2W_CLK, GPIOF_DRIVE_OUTPUT);
-}
-
-static int get_h2w_dat(void)
-{
-	return gpio_get_value(BAHAMAS_GPIO_H2W_DATA);
-}
-
-static int get_h2w_clk(void)
-{
-	return gpio_get_value(BAHAMAS_GPIO_H2W_CLK);
-}
-
-#ifdef CONFIG_HTC_HEADSET_V1
-static int set_h2w_path(const char *val, struct kernel_param *kp)
-{
-	int ret = -EINVAL;
-	int enable;
-
-	ret = param_set_int(val, kp);
-	if (ret)
-		return ret;
-
-	switch (bahamas_h2w_path) {
-	case H2W_GPIO:
-		enable = 1;
-		cnf_driver_event("H2W_enable_irq", &enable);
-		break;
-	case H2W_UART3:
-		enable = 0;
-		cnf_driver_event("H2W_enable_irq", &enable);
-		break;
-	default:
-		bahamas_h2w_path = -1;
-		return -EINVAL;
-	}
-
-	h2w_configure(bahamas_h2w_path);
-	return ret;
-}
-
-module_param_call(h2w_path, set_h2w_path, param_get_int,
-		&bahamas_h2w_path, S_IWUSR | S_IRUGO);
-#endif
-
-static struct h2w_platform_data bahamas_h2w_data = {
-	.headset_mic_35mm	= BAHAMAS_GPIO_HEADSET_MIC,
-	.ext_mic_sel		= BAHAMAS_GPIO_AUD_EXTMIC_SEL,
-	.wfm_ant_sw		= BAHAMAS_GPIO_WFM_ANT_SW,
-	.debug_uart 		= H2W_UART3,
-	.config 		= h2w_configure,
-	.defconfig 		= h2w_defconfig,
-};
-
-static struct platform_device bahamas_h2w = {
-	.name		= "h2w",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &bahamas_h2w_data,
-	},
-};
-
-static struct audio_jack_platform_data bahamas_jack_data = {
-	.gpio	= BAHAMAS_GPIO_35MM_HEADSET_DET,
-};
-
-static struct platform_device bahamas_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &bahamas_jack_data,
-	},
-};
-
-static struct pwr_sink bahamas_pwrsink_table[] = {
-	{
-		.id     = PWRSINK_AUDIO,
-		.ua_max = 100000,
-	},
-	{
-		.id     = PWRSINK_BACKLIGHT,
-		.ua_max = 125000,
-	},
-	{
-		.id     = PWRSINK_LED_BUTTON,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_LED_KEYBOARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_GP_CLK,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_BLUETOOTH,
-		.ua_max = 15000,
-	},
-	{
-		.id     = PWRSINK_CAMERA,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_SDCARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_VIDEO,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id     = PWRSINK_SYSTEM_LOAD,
-		.ua_max = 100000,
-		.percent_util = 38,
-	},
-};
-
-static int bahamas_pwrsink_resume_early(struct platform_device *pdev)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-	return 0;
-}
-
-static void bahamas_pwrsink_resume_late(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 38);
-}
-
-static void bahamas_pwrsink_suspend_early(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-}
-
-static int bahamas_pwrsink_suspend_late(struct platform_device *pdev,
-					pm_message_t state)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 1);
-	return 0;
-}
-
-static struct pwr_sink_platform_data bahamas_pwrsink_data = {
-	.num_sinks      = ARRAY_SIZE(bahamas_pwrsink_table),
-	.sinks          = bahamas_pwrsink_table,
-	.suspend_late	= bahamas_pwrsink_suspend_late,
-	.resume_early	= bahamas_pwrsink_resume_early,
-	.suspend_early	= bahamas_pwrsink_suspend_early,
-	.resume_late	= bahamas_pwrsink_resume_late,
-};
-
-static struct platform_device bahamas_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev    = {
-		.platform_data = &bahamas_pwrsink_data,
-	},
-};
-
-static struct msm_pmem_setting pmem_setting_monodie = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE_MONODIE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE_MONODIE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-};
-
-static struct msm_pmem_setting pmem_setting_dualdie = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE_DUALDIE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE_DUALDIE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-};
-
-static struct tssc_ts_platform_data tssc_ts_device_data = {
-	.version = 1,
-	.x_min = 0,
-	.x_max = 1023,
-	.y_min = 0,
-	.y_max = 1023,
-	.cal_range_x = 679,
-	.cal_range_y = 718,
-	.cal_err = 50,
-	.screen_width = 240,
-	.screen_height = 320,
-	.cal_x = { 15, 223, 15, 223, 119},
-	.cal_y = { 20, 20, 298, 298, 159},
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-};
-
-static struct platform_device tssc_ts_device = {
-	.name	= "tssc-manager",
-	.id	= -1,
-	.dev	= {
-		.platform_data	= &tssc_ts_device_data,
-	},
-};
-
-static struct platform_device bahamas_rfkill = {
-	.name = "bahamas_rfkill",
-	.id = -1,
-};
-
-static struct msm_i2c_device_platform_data bahamas_i2c_device_data = {
-	.i2c_clock = 100000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_smd,
-	&msm_device_nand,
-	&msm_device_i2c,
-	&bahamas_h2w,
-	&bahamas_audio_jack,
-	&tssc_ts_device,
-	&bahamas_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&bahamas_pwr_sink,
-#endif
-};
-
-extern struct sys_timer msm_timer;
-
-static void __init bahamas_init_irq(void)
-{
-	printk(KERN_DEBUG "bahamas_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint cpld_iset;
-static uint cpld_charger_en;
-static uint cpld_usb_h2w_sw;
-static uint opt_disable_uart3;
-static char *keycaps = "";
-
-module_param_named(iset, cpld_iset, uint, 0);
-module_param_named(charger_en, cpld_charger_en, uint, 0);
-module_param_named(usb_h2w_sw, cpld_usb_h2w_sw, uint, 0);
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-module_param_named(keycaps, keycaps, charp, 0);
-
-extern int bahamas_bt_fastclock_power(int on);
-
-static char bt_chip_id[10] = "brfxxxx";
-module_param_string(bt_chip_id, bt_chip_id,
-		    sizeof(bt_chip_id), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_chip_id, "BT's chip id");
-
-static char bt_fw_version[10] = "v2.0.38";
-module_param_string(bt_fw_version, bt_fw_version,
-		    sizeof(bt_fw_version), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_fw_version, "BT's fw version");
-
-static void bahamas_reset(void)
-{
-	gpio_set_value(BAHAMAS_GPIO_PS_HOLD, 0);
-}
-
-static uint32_t gpio_table[] = {
-	/* BLUETOOTH */
-#ifdef CONFIG_SERIAL_MSM_HS	/* allenou, uart hs test, 2008/11/18 */
-	PCOM_GPIO_CFG(43, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* RTS */
-	PCOM_GPIO_CFG(44, 2, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA), /* CTS */
-	PCOM_GPIO_CFG(45, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* RX */
-	PCOM_GPIO_CFG(46, 3, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* TX */
-#else
-	PCOM_GPIO_CFG(43, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* BT_RTS */
-	PCOM_GPIO_CFG(44, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* BT_CTS */
-	PCOM_GPIO_CFG(45, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* BT_RX */
-	PCOM_GPIO_CFG(46, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* BT_TX */
-#endif
-};
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-void config_bahamas_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void config_bahamas_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-static void __init config_gpios(void)
-{
-	config_gpio_table(gpio_table, ARRAY_SIZE(gpio_table));
-	config_bahamas_camera_off_gpios();
-}
-
-static struct msm_acpu_clock_platform_data bahamas_clock_data = {
-	.acpu_switch_time_us = 50,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200,
-#if defined(CONFIG_TURBO_MODE)
-	.wait_for_irq_khz = 176000,
-#else
-	.wait_for_irq_khz = 128000,
-#endif
-};
-
-static unsigned bahamas_perf_acpu_table[] = {
-	245760000,
-	480000000,
-	528000000,
-};
-
-static struct perflock_platform_data bahamas_perflock_data = {
-	.perf_acpu_table = bahamas_perf_acpu_table,
-	.table_size = ARRAY_SIZE(bahamas_perf_acpu_table),
-};
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(45),
-	.inject_rx_on_wakeup = 1,
-	.rx_to_inject = 0x32,
-	.cpu_lock_supported = 1,
-};
-#endif
-
-/*Farmer:For H2W power*/
-static struct vreg *vreg_h2w;
-static int h2w_power_configure(struct gpio_chip *chip,
-			       unsigned int gpio,
-			       unsigned long flags)
-{
-	if ((flags & GPIOF_DRIVE_OUTPUT) && !vreg_h2w)
-		vreg_h2w = vreg_get(0, BAHAMAS_H2W_POWER_NAME);
-
-	if ((flags & GPIOF_OUTPUT_HIGH) && vreg_h2w) {
-		vreg_enable(vreg_h2w);
-		vreg_set_level(vreg_h2w, 3000);
-	} else if ((flags & GPIOF_OUTPUT_LOW) && vreg_h2w)
-		vreg_disable(vreg_h2w);
-
-	return 0;
-}
-
-static int h2w_power_get_irq_num(struct gpio_chip *chip,
-				 unsigned int gpio,
-				 unsigned int *irqp,
-				 unsigned long *irqnumflagsp)
-{
-	return -1;
-}
-
-static int h2w_power_read(struct gpio_chip *chip, unsigned n)
-{
-	return -1;
-}
-static int h2w_power_write(struct gpio_chip *chip, unsigned n, unsigned on)
-{
-	if (!vreg_h2w)
-		return -1;
-
-	if (on) {
-		vreg_enable(vreg_h2w);
-		vreg_set_level(vreg_h2w, 3000);
-	} else
-		vreg_disable(vreg_h2w);
-	return 0;
-}
-
-static struct gpio_chip bahamas_h2w_gpio_chip = {
-	.start = BAHAMAS_GPIO_H2W_POWER,
-	.end = BAHAMAS_GPIO_H2W_POWER,
-	.configure = h2w_power_configure,
-	.get_irq_num = h2w_power_get_irq_num,
-	.read = h2w_power_read,
-	.write = h2w_power_write,
-};
-
-void bahamas_init_h2w_power_gpio(void)
-{
-	register_gpio_chip(&bahamas_h2w_gpio_chip);
-}
-
-static void __init bahamas_init(void)
-{
-	int rc;
-	printk(KERN_DEBUG "bahamas_init() revision=%d\n", system_rev);
-	printk(KERN_INFO "mfg_mode=%d\n", board_mfg_mode());
-	if (board_mfg_mode() == 1) {
-		tssc_ts_device_data.cal_err = 25;
-		printk(KERN_INFO "cal_err=%d\n", tssc_ts_device_data.cal_err);
-	}
-
-	/*
-	 * Setup common MSM GPIOS
-	 */
-	config_gpios();
-
-	msm_hw_reset_hook = bahamas_reset;
-
-	msm_acpu_clock_init(&bahamas_clock_data);
-	perflock_init(&bahamas_perflock_data);
-	/* adjust GPIOs based on bootloader request */
-	/* XXX: on Memphis,
-	 *      GPIO#86 is H2W DAT / UART RX for HTC 11-Pin
-	 *      GPIO#87 is H2W CLK / UART TX for HTC 11-Pin
-	 *      We would need to use UART3 as debug port
-	 *
-	 * TODO: switch UART3 and H2W (for headset detect)
-	 *       based on bootloader request.
-	 */
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-				      &msm_device_uart3.dev, 1,
-				      MSM_GPIO_TO_INT(BAHAMAS_GPIO_UART3_RX));
-#endif
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_add_serial_devices(3);
-#else
-	msm_add_serial_devices(0);
-#endif
-
-	msm_add_serial_devices(2);
-
-	msm_hsusb_set_product(bahamas_usb_products,
-		ARRAY_SIZE(bahamas_usb_products));
-	msm_add_usb_devices(bahamas_phy_reset, NULL);
-
-	/* msm_change_usb_id(0x0bb4, 0x0c06); */
-	if (board_mcp_monodie())
-		msm_add_mem_devices(&pmem_setting_monodie);
-	else
-		msm_add_mem_devices(&pmem_setting_dualdie);
-	msm_init_pmic_vibrator();
-
-	bahamas_init_h2w_power_gpio();
-#if 1
-	rc = bahamas_init_mmc(system_rev);
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-#endif
-
-	if (system_rev < 3) {
-		if (panel_detect() == PANEL_WINTEK) {
-			microp_data.num_pins   = ARRAY_SIZE(microp_pins_0_wint);
-			microp_data.pin_config = microp_pins_0_wint;
-		} else {
-			microp_data.num_pins   = ARRAY_SIZE(microp_pins_0);
-			microp_data.pin_config = microp_pins_0;
-		}
-		i2c_microp_devices.irq = 0;
-	} else if (panel_detect() == PANEL_WINTEK) {
-		microp_data.num_pins   = ARRAY_SIZE(microp_pins_1_wint);
-		microp_data.pin_config = microp_pins_1_wint;
-	}
-
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	for (rc = 0; rc < ARRAY_SIZE(devices); rc++) {
-		if (!strcmp(devices[rc]->name, "msm_i2c"))
-			devices[rc]->dev.platform_data = &msm_i2c_device_data;
-	}
-
-	msm_device_i2c.dev.platform_data = &bahamas_i2c_device_data;
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	if (system_rev >= 3)
-		bahamas_h2w_data.flags = _35MM_MIC_DET_L2H;
-
-	if (system_rev >= 5)
-		i2c_register_board_info(0, i2c_sensor, ARRAY_SIZE(i2c_sensor));
-
-	i2c_register_board_info(0, &i2c_microp_devices, 1);
-
-	/* SD card door should wake the device  */
-	/* trout_gpio_irq_set_wake(TROUT_GPIO_TO_INT(TROUT_GPIO_SD_DOOR_N), 1);*/
-}
-
-unsigned int bahamas_get_hwid(void)
-{
-	printk(KERN_DEBUG "bahamas_get_hwid=0x%x\r\n", hwid);
-	return hwid;
-}
-
-unsigned int bahamas_get_skuid(void)
-{
-	printk(KERN_DEBUG "bahamas_get_skuid=0x%x\r\n", skuid);
-	return skuid;
-}
-
-unsigned bahamas_engineerid(void)
-{
-	printk(KERN_DEBUG "bahamas_engineerid=0x%x\r\n", engineerid);
-	return engineerid;
-}
-
-int bahamas_is_3M_camera(void)
-{
-	int ret  = 0;
-
-	printk(KERN_DEBUG "bahamas_is_3M_camera, PCBID=0x%x\r\n", system_rev);
-
-	if (system_rev > 1)
-		ret  = 1;    /*system_rev==PCBID */
-
-	return ret;
-}
-
-static void __init bahamas_fixup(struct machine_desc *desc, struct tag *tags,
-				char **cmdline, struct meminfo *mi)
-{
-	hwid = 0;
-	skuid = 0;
-	engineerid = (0x01 << 1);
-
-	hwid = parse_tag_hwid((const struct tag *)tags);
-	printk(KERN_DEBUG "bahamas_fixup:hwid=0x%x\n", hwid);
-	skuid = parse_tag_skuid((const struct tag *)tags);
-	printk(KERN_DEBUG "bahamas_fixup:skuid=0x%x\n", skuid);
-	engineerid = parse_tag_engineerid((const struct tag *)tags);
-	printk(KERN_DEBUG "bahamas_fixup:engineerid=0x%x\n", engineerid);
-
-	if (board_mcp_monodie()) {
-		mi->nr_banks = 1;
-		mi->bank[0].start = MSM_LINUX_BASE1;
-		mi->bank[0].node = PHYS_TO_NID(MSM_LINUX_BASE1);
-		mi->bank[0].size = MSM_LINUX_SIZE1+MSM_LINUX_SIZE2;
-	} else {
-		mi->nr_banks = 2;
-		mi->bank[0].start = MSM_LINUX_BASE1;
-		mi->bank[0].node = PHYS_TO_NID(MSM_LINUX_BASE1);
-		mi->bank[0].size = MSM_LINUX_SIZE1;
-		mi->bank[1].start = MSM_LINUX_BASE2_DUALDIE;
-		mi->bank[1].node = PHYS_TO_NID(MSM_LINUX_BASE2_DUALDIE);
-		mi->bank[1].size = MSM_LINUX_SIZE2;
-	}
-}
-
-static void __init bahamas_map_io(void)
-{
-	printk(KERN_DEBUG "bahamas_init_map_io()\n");
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-MACHINE_START(BAHAMAS, "bahamas")
-/* Maintainer: Tony Liu <Tony_Liu@htc.com> */
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params    = 0x02E00100,
-	.fixup          = bahamas_fixup,
-	.map_io         = bahamas_map_io,
-	.init_irq       = bahamas_init_irq,
-	.init_machine   = bahamas_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-bahamas.h b/arch/arm/mach-msm/board-bahamas.h
deleted file mode 100644
index 0a6dc3a..0000000
--- a/arch/arm/mach-msm/board-bahamas.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/* linux/arch/arm/mach-msm7225/board-bahamas.h
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Tony Liu <tony_liu@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_BAHAMAS_H
-#define __ARCH_ARM_MACH_MSM_BOARD_BAHAMAS_H
-
-#include <mach/board.h>
-
-#define MSM_LINUX_BASE1    0x02E00000
-#define MSM_LINUX_SIZE1    0x05200000
-#define MSM_LINUX_BASE2_MONODIE    0x08000000
-#define MSM_LINUX_BASE2_DUALDIE    0x20000000
-#define MSM_LINUX_SIZE2    0x06E00000
-
-#define MSM_EBI1_CS0_BASE	0x00000000
-#define MSM_EBI1_CS0_SIZE	0x5500000
-
-#define MSM_EBI1_CS1_BASE	0x20000000
-#define MSM_EBI1_CS1_SIZE	0x2000000
-
-#define MSM_PMEM_MDP_BASE	0x00000000
-#define MSM_PMEM_MDP_SIZE	0x00800000
-
-#define MSM_PMEM_ADSP_BASE_MONODIE	0x0F000000
-#define MSM_PMEM_ADSP_BASE_DUALDIE	0x27000000
-#define MSM_PMEM_ADSP_SIZE	0x00800000
-
-#define MSM_PMEM_CAMERA_BASE_MONODIE	0x0F800000
-#define MSM_PMEM_CAMERA_BASE_DUALDIE	0x27800000
-#define MSM_PMEM_CAMERA_SIZE	0x00800000
-
-#define MSM_LINUX_BASE		MSM_EBI1_CS0_BASE + 0x400000
-#define MSM_LINUX_SIZE		0x5100000
-
-#define MSM_FB_BASE		0x02D00000
-#define MSM_FB_SIZE		0x9b000
-
-#define MSM_RAM_CONSOLE_BASE    MSM_FB_BASE + MSM_FB_SIZE
-#define MSM_RAM_CONSOLE_SIZE	128 * SZ_1K
-
-#define DECLARE_MSM_IOMAP
-#include <mach/msm_iomap.h>
-
-#define BAHAMAS_POWER_KEY		20
-#define BAHAMAS_GPIO_WIFI_EN	102
-#define BAHAMAS_GPIO_SDMC_CD_N	38
- /*CC090320*/
-#define BAHAMAS_MT9T013_CAM_PWDN                   (91)
-#define BAHAMAS_GPIO_CABLE_IN1		18
-#define BAHAMAS_XD_GPIO_UP_INT		27
-#define BAHAMAS_GPIO_CABLE_IN2		31
-#define BAHAMAS_GPIO_H2W_DATA		86
-#define BAHAMAS_GPIO_H2W_CLK		87
-#define BAHAMAS_GPIO_UART3_RX		86
-#define BAHAMAS_GPIO_UART3_TX		87
-#define BAHAMAS_GPIO_HEADSET_MIC	17
-#define BAHAMAS_GPIO_35MM_HEADSET_DET	112
-#define BAHAMAS_GPIO_AUD_EXTMIC_SEL	113
-#define BAHAMAS_GPIO_WFM_ANT_SW		121
-
-#define BAHAMAS_GPIO_UP_RESET_N     76
-#define BAHAMAS_GPIO_PS_HOLD        25
-#define BAHAMAS_GPIO_WB_SHUT_DOWN_N        101
-
-#define BAHAMAS_GPIO_H2W_POWER		513
-#define BAHAMAS_H2W_POWER_NAME		"gp2"
-
-#define BAHAMA_GPIO_COMPASS_RST_N	93
-#define BAHAMA_GPIO_COMPASS_INT_N	37
-#define BAHAMA_GPIO_GSENSOR_INT_N	49
-
-#define BAHAMAS_MDDI_RSTz              82
-#define BAHAMAS_V_VDDE2E_VDD2_GPIO     0
-/* int bahamas_init_keypad(unsigned int sys_rev, const char *keycaps);
-int trout_init_gpio(unsigned int sys_rev);
-int trout_init_cpldshadow(unsigned int sys_rev);
-int bahamas_init_panel(unsigned int sys_rev);
-int bahamas_init_mmc(unsigned int sys_rev);
-
-struct sys_device;
-int trout_sysdev_resume(struct sys_device *dev); */
-/*CC090330*/
-unsigned int bahamas_get_hwid(void);
-unsigned int bahamas_get_skuid(void);
-unsigned bahamas_engineerid(void);
-int bahamas_is_3M_camera(void);
-/*~CC090330*/
-
-#endif /* GUARD */
diff --git a/arch/arm/mach-msm/board-bee-keypad.c b/arch/arm/mach-msm/board-bee-keypad.c
deleted file mode 100644
index 593ebdb..0000000
--- a/arch/arm/mach-msm/board-bee-keypad.c
+++ /dev/null
@@ -1,141 +0,0 @@
-/* arch/arm/mach-msm/board--bee.c
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <linux/keyreset.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-
-#include "board-bee.h"
-
-struct bee_axis_info {
-	struct gpio_event_axis_info info;
-	uint16_t in_state;
-	uint16_t out_state;
-	uint16_t temp_state;
-};
-
-static unsigned int bee_col_gpios[] = {
-	BEE_GPIO_Q_KP_MKOUT0,
-	BEE_GPIO_Q_KP_MKOUT1,
-	BEE_GPIO_Q_KP_MKOUT2,
-};
-
-static unsigned int bee_row_gpios[] = {
-	BEE_GPIO_Q_KP_MKIN0_1,
-	BEE_GPIO_Q_KP_MKIN1_1,
-	BEE_GPIO_Q_KP_MKIN2_1,
-};
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(bee_row_gpios) + (row))
-
-static unsigned short bee_keymap[ARRAY_SIZE(bee_col_gpios) *
-					ARRAY_SIZE(bee_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_RESERVED,
-	[KEYMAP_INDEX(0, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(0, 2)] = KEY_VOLUMEUP,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_RESERVED,
-	[KEYMAP_INDEX(1, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(1, 2)] = KEY_VOLUMEDOWN,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_RESERVED,
-	[KEYMAP_INDEX(2, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(2, 2)] = KEY_RESERVED,
-};
-
-static struct gpio_event_matrix_info bee_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = bee_keymap,
-	.output_gpios = bee_col_gpios,
-	.input_gpios = bee_row_gpios,
-	.noutputs = ARRAY_SIZE(bee_col_gpios),
-	.ninputs = ARRAY_SIZE(bee_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		GPIOKPF_REMOVE_PHANTOM_KEYS |
-		GPIOKPF_PRINT_UNMAPPED_KEYS /* |
-		GPIOKPF_PRINT_MAPPED_KEYS */),
-};
-
-static struct gpio_event_direct_entry bee_keypad_dir_key_map[] = {
-	{ BEE_GPIO_POWER_KEY, KEY_POWER },
-	{ BEE_GPIO_OJ_ACTION, BTN_MOUSE },
-};
-
-static struct gpio_event_input_info bee_keypad_dir_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = GPIOEDF_PRINT_KEYS,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = bee_keypad_dir_key_map,
-	.keymap_size = ARRAY_SIZE(bee_keypad_dir_key_map)
-};
-
-static struct gpio_event_info *bee_input_info[] = {
-	&bee_keypad_matrix_info.info,
-	&bee_keypad_dir_info.info,
-};
-
-static struct gpio_event_platform_data bee_keypad_data = {
-	.names = {
-		"bee-keypad",
-		NULL,
-	},
-	.info = bee_input_info,
-	.info_count = ARRAY_SIZE(bee_input_info),
-};
-
-static struct platform_device bee_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev = {
-		.platform_data = &bee_keypad_data,
-	},
-};
-
-static int bee_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0
-};
-
-static struct keyreset_platform_data bee_reset_keys_pdata = {
-	.keys_up = bee_reset_keys_up,
-	.keys_down = {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-struct platform_device bee_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &bee_reset_keys_pdata,
-};
-
-int __init bee_init_keypad(void)
-{
-	if (platform_device_register(&bee_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	return platform_device_register(&bee_keypad_device);
-}
-
diff --git a/arch/arm/mach-msm/board-bee-microp.c b/arch/arm/mach-msm/board-bee-microp.c
deleted file mode 100644
index 983f9d6..0000000
--- a/arch/arm/mach-msm/board-bee-microp.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/* arch/arm/mach-msm/board-bee-microp.c
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <mach/atmega_microp.h>
-#include <mach/drv_callback.h>
-
-#include "board-bee.h"
-
-static struct i2c_client *bee_microp_client;
-
-static int bee_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	bee_microp_client = client;
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	ret = microp_write_interrupt(client, (1<<8), 1);
-	if (ret)
-		goto exit;
-
-	/* OJ interrupt */
-	ret = microp_function_check(client, MICROP_FUNCTION_OJ);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_oj = pdata->microp_function[i].int_pin;
-
-		ret = microp_write_interrupt(client, cdata->int_pin.int_oj, 1);
-		if (ret)
-			goto exit;
-	}
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = bee_microp_function_init,
-/*
-	.als_pwr_enable = bee_als_power,
-	.als_intr_enable = bee_als_intr_enable,
-	.als_level_change = bee_als_level_change,
-*/
-};
-
-void __init bee_microp_init(void)
-{
-	/*led_trigger_register(&bee_als_level_trigger);*/
-	microp_register_ops(&ops);
-}
-
-#endif
diff --git a/arch/arm/mach-msm/board-bee-mmc.c b/arch/arm/mach-msm/board-bee-mmc.c
deleted file mode 100644
index 9abf29c..0000000
--- a/arch/arm/mach-msm/board-bee-mmc.c
+++ /dev/null
@@ -1,293 +0,0 @@
-/* linux/arch/arm/mach-msm/board-bee-mmc.c
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <asm/mach-types.h>
-
-#include <mach/vreg.h>
-
-#include <asm/mach/mmc.h>
-
-#include "devices.h"
-#include "board-bee.h"
-#include "proc_comm.h"
-
-/* #include <linux/irq.h> */
-
-#define DEBUG_SDSLOT_VDD 1
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_16MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init bee_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_bee.disable_sdcard=", bee_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t bee_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		vreg_enable(vreg_sdslot);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-#if DEBUG_SDSLOT_VDD
-			printk(KERN_INFO "%s: Setting level to %u\n",
-					__func__, mmc_vdd_table[i].level);
-#endif
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-			return 0;
-		}
-	}
-
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int bee_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(BEE_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define BEE_MMC_VDD	MMC_VDD_28_29 | MMC_VDD_29_30
-
-static unsigned int bee_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data bee_sdslot_data = {
-	.ocr_mask	= BEE_MMC_VDD,
-	/* .status_irq		= MSM_GPIO_TO_INT(BEE_GPIO_SDMC_CD_N), */
-	.status		= bee_sdslot_status,
-	.translate_vdd	= bee_sdslot_switchvdd,
-	.slot_type	= &bee_sdslot_type,
-};
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data bee_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-static int bee_wifi_cd;		/* WIFI virtual 'card detect' status */
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-bee_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int bee_wifi_status(struct device *dev)
-{
-	return bee_wifi_cd;
-}
-
-static struct mmc_platform_data bee_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= bee_wifi_status,
-	.register_status_notify	= bee_wifi_status_register,
-	.embedded_sdio		= &bee_wifi_emb_data,
-};
-
-int bee_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	bee_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(bee_wifi_set_carddetect);
-int bee_wifi_power_state = 0;
-int bee_bt_power_state = 0;
-
-int bee_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-	bee_wifi_power_state = on;
-	mdelay(100);
-	gpio_set_value(BEE_GPIO_WIFI_EN, on);
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(bee_wifi_power);
-
-int bee_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-int __init bee_init_mmc(unsigned int sys_rev)
-{
-
-	uint32_t id;
-
-
-	/* initial WIFI_SHUTDOWN */
-	id = PCOM_GPIO_CFG(BEE_GPIO_WIFI_EN, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	wifi_status_cb = NULL;
-
-
-	sdslot_vreg_enabled = 0;
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-
-	printk(KERN_INFO "%s\n", __func__);
-
-	set_irq_wake(MSM_GPIO_TO_INT(BEE_GPIO_SDMC_CD_N), 1);
-
-    msm_add_sdcc(1, &bee_wifi_data, 0, 0);
-
-	if (!opt_disable_sdcard)
-		msm_add_sdcc(2, &bee_sdslot_data,
-			MSM_GPIO_TO_INT(BEE_GPIO_SDMC_CD_N),
-			IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-	else
-		printk(KERN_INFO "bee: SD-Card interface disabled\n");
-
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-bee-panel.c b/arch/arm/mach-msm/board-bee-panel.c
deleted file mode 100644
index ccf5272..0000000
--- a/arch/arm/mach-msm/board-bee-panel.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-
-#include <asm/io.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-#include <mach/vreg.h>
-#ifdef CONFIG_HTC_PWRSINK
-#include <mach/htc_pwrsink.h>
-#endif
-
-#include <mach/pmic.h>
-#include "board-bee.h"
-#include "proc_comm.h"
-#include "devices.h"
-
-#if 0
-#define B(s...) printk(s)
-#else
-#define B(s...) do {} while(0)
-#endif
-
-struct mddi_table {
-	uint32_t reg;
-	uint32_t value;
-	uint32_t msec;
-};
-
-static struct mddi_table bee_init_tb[] = {
-        {0x01, 0x0000, 0},
-        {0x3e, 0x0040, 0},
-        {0x16, 0x0008, 0},
-        {0x27, 0x000e, 0},
-        {0x28, 0x000e, 0},
-        {0x71, 0x0068, 0},
-        {0x60, 0x0001, 0},
-        {0x93, 0x000f, 0},
-        {0x98, 0x000f, 0},
-        {0x9a, 0x0000, 10},
-        {0x1b, 0x0010, 40},
-        {0x1c, 0x0004, 10},
-        {0x1f, 0x000c, 10},
-        {0x43, 0x0080, 60},
-        {0xd0, 0x0000, 0},
-        {0xd1, 0x0003, 0},
-        {0xd2, 0x0004, 0},
-        {0xd3, 0x000b, 0},
-        {0xd4, 0x000b, 0},
-        {0xd5, 0x003f, 0},
-        {0xd6, 0x000e, 0},
-        {0xd7, 0x0014, 0},
-        {0xd8, 0x0007, 0},
-        {0xd9, 0x000d, 0},
-        {0xda, 0x0013, 0},
-        {0xdb, 0x0016, 0},
-        {0xdc, 0x0019, 0},
-        {0xdd, 0x0018, 0},
-        {0xde, 0x0017, 0},
-        {0xdf, 0x000c, 0},
-        {0xe0, 0x0013, 0},
-        {0xe1, 0x0000, 0},
-        {0xe2, 0x0034, 0},
-        {0xe3, 0x0034, 0},
-        {0xe4, 0x003b, 0},
-        {0xe5, 0x003c, 0},
-        {0xe6, 0x003f, 0},
-        {0xe7, 0x0043, 0},
-        {0xe8, 0x0049, 0},
-        {0xe9, 0x000c, 0},
-        {0xea, 0x0013, 0},
-        {0xeb, 0x0008, 0},
-        {0xec, 0x0007, 0},
-        {0xed, 0x0007, 0},
-        {0xee, 0x0009, 0},
-        {0xef, 0x000c, 0},
-        {0xf0, 0x0011, 0},
-        {0xf1, 0x0018, 0},
-        {0xf2, 0x000f, 0},
-        {0x95, 0x0024, 0},
-        {0x96, 0x0000, 1},
-        {0x02, 0x0000, 0},
-        {0x03, 0x0000, 0},
-        {0x04, 0x0000, 0},
-        {0x05, 0x00ef, 0},
-        {0x06, 0x0000, 0},
-        {0x07, 0x0000, 0},
-        {0x08, 0x0001, 0},
-        {0x09, 0x003f, 0},
-        {0x26, 0x0024, 1},
-        {0x26, 0x0038, 1},
-        {0x26, 0x003c, 0},
-};
-
-static struct mddi_table bee_standby_tb[] = {
-	{0x95, 0x0000, 0},
-	{0x26, 0x0038, 50},
-	{0x26, 0x0020, 50},
-};
-
-#define GPIOSEL_VWAKEINT (1U << 0)
-#define INTMASK_VWAKEOUT (1U << 0)
-
-static void
-bee_process_mddi_table(struct msm_mddi_client_data *client_data,
-		struct mddi_table *table, ssize_t count)
-{
-	int i;
-	uint32_t reg, value, msec;
-
-	BUG_ON(!client_data);
-	BUG_ON(!table);
-	BUG_ON(!count);
-
-	for(i = 0; i < count; i++) {
-		reg = table[i].reg;
-		value = table[i].value;
-		msec = table[i].msec;
-
-		client_data->remote_write(client_data, value, reg);
-		if (msec)
-			mdelay(msec);
-	}
-}
-
-static struct vreg *vreg_lcm_2v85;
-static struct vreg *vreg_lcm_2v6;
-
-static void
-bee_mddi_power_client(struct msm_mddi_client_data *cdata, int on)
-{
-	B("%s: enter.\n", __func__);
-
-	if(on) {
-		B("bee resume");
-		gpio_set_value(BEE_LCMIO_2V6_EN, 1);
-		hr_msleep(1);
-		gpio_set_value(BEE_LCM_2V85_EN, 1);
-		hr_msleep(1);
-		gpio_set_value(BEE_MDDI_RSTz, 1);
-		hr_msleep(1);
-	} else {
-		B("bee suspend");
-		gpio_set_value(BEE_MDDI_RSTz, 0);
-		gpio_set_value(BEE_LCM_2V85_EN, 0);
-		gpio_set_value(BEE_LCMIO_2V6_EN, 0);
-	}
-
-}
-
-#if defined(CONFIG_ARCH_MSM7225) || defined(CONFIG_ARCH_MSM7625)
-#define LCM_ID0 57
-#define LCM_ID1 58
-#else
-#define LCM_ID0 _bad_id()
-#define LCM_ID1 _bad_id()
-#endif
-
-static int
-bee_mddi_client_init(struct msm_mddi_bridge_platform_data *bridge_data,
-		     struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-
-        return 0;
-
-}
-
-static int
-bee_mddi_client_uninit(struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *client_data)
-
-{
-	B(KERN_DEBUG "%s: N enter.\n", __func__);
-
-        return 0;
-}
-
-static int
-bee_panel_unblank(struct msm_mddi_bridge_platform_data *bridge_data,
-                  struct msm_mddi_client_data *client_data)
-{
-	BUG_ON(!bridge_data);
-	BUG_ON(!client_data);
-
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-
-	client_data->auto_hibernate(client_data, 0);
-	bee_process_mddi_table(client_data,
-			bee_init_tb,
-			ARRAY_SIZE(bee_init_tb));
-	client_data->auto_hibernate(client_data, 1);
-
-	return 0;
-}
-
-static int
-bee_panel_blank(struct msm_mddi_bridge_platform_data *bridge_data,
-                struct msm_mddi_client_data *client_data)
-{
-	BUG_ON(!bridge_data);
-	BUG_ON(!client_data);
-
-	B("%s: N enter.\n", __func__);
-
-	client_data->auto_hibernate(client_data, 0);
-	bee_process_mddi_table(client_data,
-			bee_standby_tb,
-			ARRAY_SIZE(bee_standby_tb));
-	client_data->auto_hibernate(client_data, 1);
-	return 0;
-}
-
-static void
-bee_fixup(uint16_t *mfr_name, uint16_t *product_code)
-{
-	B("%s: enter.\n", __func__);
-
-	*mfr_name = 0x4858;
-	*product_code = 0x8356;
-}
-
-static struct resource resources_msm_fb[] = {
-        {
-                .start = MSM_FB_BASE,
-                .end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-                .flags = IORESOURCE_MEM,
-        },
-};
-
-static struct msm_mddi_bridge_platform_data himax_client_data = {
-        .init = bee_mddi_client_init,
-        .uninit = bee_mddi_client_uninit,
-	.bridge_type = SAMSUNG_D,
-        .blank = bee_panel_blank,
-        .unblank = bee_panel_unblank,
-        .fb_data = {
-                .xres = 240,
-                .yres = 320,
-		.width = 49,
-		.height = 65,
-                .output_format = 0,
-        },
-};
-
-static struct msm_mddi_platform_data bee_pdata = {
-	.clk_rate = 83000000,		/*default MDDI frequenct*/
-	.power_client = bee_mddi_power_client,
-	.fixup = bee_fixup,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 1,
-	.client_platform_data = {
-		{
-			.product_id = (0x4858 << 16 | 0x8356),
-			.name = "mddi_c_4858_8356",
-			.id = 0,
-			.client_data = &himax_client_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-int __init bee_panel_init(void)
-{
-	int rc;
-	struct panel_data *config = &himax_client_data.panel_conf;
-
-	if (!machine_is_bee())
-		return 0;
-
-	B("bee panel_init");
-
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-	config->caps = MSMFB_CAP_CABC;
-	msm_device_mddi0.dev.platform_data = &bee_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-
-	return 0;
-}
-
-device_initcall(bee_panel_init);
diff --git a/arch/arm/mach-msm/board-bee-rfkill.c b/arch/arm/mach-msm/board-bee-rfkill.c
deleted file mode 100644
index 139de67..0000000
--- a/arch/arm/mach-msm/board-bee-rfkill.c
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
- * Copyright (C) 2010 Google, Inc.
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for bee platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-bee.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-/* bt initial configuration */
-static uint32_t bee_bt_init_table[] = {
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_TX, /* BT_TX */
-				3,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt on configuration */
-static uint32_t bee_bt_on_table[] = {
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_RX, /* BT_RX */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_TX, /* BT_TX */
-				3,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt off configuration */
-static uint32_t bee_bt_off_table[] = {
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_RTS, /* BT_RTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_UART1_TX, /* BT_TX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BEE_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BEE_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void bee_config_bt_init(void)
-{
-	/* set bt initial configuration*/
-	config_bt_table(bee_bt_init_table,
-				ARRAY_SIZE(bee_bt_init_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(BEE_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BEE_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(BEE_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-}
-
-static void bee_config_bt_on(void)
-{
-	/* set bt on configuration*/
-	config_bt_table(bee_bt_on_table,
-				ARRAY_SIZE(bee_bt_on_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(BEE_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BEE_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-}
-
-static void bee_config_bt_off(void)
-{
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BEE_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_RESET_N */
-	gpio_configure(BEE_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(bee_bt_off_table,
-				ARRAY_SIZE(bee_bt_off_table));
-	mdelay(5);
-
-	/* BT_RTS */
-	gpio_configure(BEE_GPIO_BT_UART1_RTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CTS */
-
-	/* BT_TX */
-	gpio_configure(BEE_GPIO_BT_UART1_TX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_RX */
-
-	/* BT_HOST_WAKE */
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(BEE_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-			bee_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-			bee_config_bt_off();
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int bee_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	bee_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int bee_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver bee_rfkill_driver = {
-	.probe = bee_rfkill_probe,
-	.remove = bee_rfkill_remove,
-	.driver = {
-		.name = "bee_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init bee_rfkill_init(void)
-{
-	if (!machine_is_bee())
-		return 0;
-
-	return platform_driver_register(&bee_rfkill_driver);
-}
-
-static void __exit bee_rfkill_exit(void)
-{
-	platform_driver_unregister(&bee_rfkill_driver);
-}
-
-module_init(bee_rfkill_init);
-module_exit(bee_rfkill_exit);
-MODULE_DESCRIPTION("bee rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-bee-wifi.c b/arch/arm/mach-msm/board-bee-wifi.c
deleted file mode 100644
index 1483b0b..0000000
--- a/arch/arm/mach-msm/board-bee-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-bee-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-bee.h"
-
-int bee_wifi_power(int on);
-int bee_wifi_reset(int on);
-int bee_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *bee_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init bee_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource bee_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(BEE_GPIO_WIFI_IRQ1),
-		.end		= MSM_GPIO_TO_INT(BEE_GPIO_WIFI_IRQ1),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data bee_wifi_control = {
-	.set_power      = bee_wifi_power,
-	.set_reset      = bee_wifi_reset,
-	.set_carddetect = bee_wifi_set_carddetect,
-	.mem_prealloc   = bee_wifi_mem_prealloc,
-};
-
-static struct platform_device bee_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(bee_wifi_resources),
-        .resource       = bee_wifi_resources,
-        .dev            = {
-                .platform_data = &bee_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned bee_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init bee_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_bee())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	bee_wifi_update_nvs("sd_oobonly=1\n");
-	bee_init_wifi_mem();
-	ret = platform_device_register(&bee_wifi_device);
-        return ret;
-}
-
-device_initcall(bee_wifi_init);
diff --git a/arch/arm/mach-msm/board-bee.c b/arch/arm/mach-msm/board-bee.c
deleted file mode 100644
index be1e559..0000000
--- a/arch/arm/mach-msm/board-bee.c
+++ /dev/null
@@ -1,1133 +0,0 @@
-/* arch/arm/mach-msm/board-bee.c
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/irq.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <linux/melfas_tsi.h>
-#include <linux/atmel_qt602240.h>
-#include <linux/akm8975.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/sysdev.h>
-#include <linux/android_pmem.h>
-
-#include <mach/board.h>
-#include <mach/camera.h>
-
-#include <linux/delay.h>
-#include <linux/gpio.h>
-
-#include <mach/hardware.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <mach/system.h>
-#include <mach/vreg.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <mach/msm_serial_debugger.h>
-
-#include <asm/io.h>
-#include <asm/delay.h>
-#include <asm/setup.h>
-
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-
-#include <asm/mach/mmc.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/curcial_oj.h>
-#include "board-bee.h"
-#include "proc_comm.h"
-#include "gpio_chip.h"
-
-#include <mach/board_htc.h>
-#include <mach/msm_serial_hs.h>
-
-#include "devices.h"
-
-#include <mach/atmega_microp.h>
-#include <mach/msm_tssc.h>
-#include <mach/htc_battery.h>
-
-#include <mach/htc_pwrsink.h>
-#include <mach/perflock.h>
-#include <mach/drv_callback.h>
-#include <mach/msm_rpcrouter.h>
-#include <mach/msm_iomap.h>
-#include <mach/msm_flashlight.h>
-#include <mach/msm_hsusb.h>
-
-void msm_init_irq(void);
-void msm_init_gpio(void);
-void msm_init_pmic_vibrator(void);
-void config_bee_camera_on_gpios(void);
-void config_bee_camera_off_gpios(void);
-#ifdef CONFIG_MICROP_COMMON
-void __init bee_microp_init(void);
-#endif
-
-static struct msm_hsusb_product bee_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0ca1,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-#define HSUSB_API_INIT_PHY_PROC	2
-#define HSUSB_API_PROG		0x30000064
-#define HSUSB_API_VERS MSM_RPC_VERS(1, 1)
-
-static void Bee_phy_reset(void)
-{
-	struct msm_rpc_endpoint *usb_ep;
-	int rc;
-	struct hsusb_phy_start_req {
-		struct rpc_request_hdr hdr;
-	} req;
-
-	printk(KERN_INFO "msm_hsusb_phy_reset\n");
-
-	usb_ep = msm_rpc_connect(HSUSB_API_PROG, HSUSB_API_VERS, 0);
-	if (IS_ERR(usb_ep)) {
-		printk(KERN_ERR "%s: init rpc failed! error: %ld\n",
-				__func__, PTR_ERR(usb_ep));
-		return;
-	}
-	rc = msm_rpc_call(usb_ep, HSUSB_API_INIT_PHY_PROC,
-			&req, sizeof(req), 5 * HZ);
-	if (rc < 0)
-		printk(KERN_ERR "%s: rpc call failed! (%d)\n", __func__, rc);
-
-close:
-	msm_rpc_close(usb_ep);
-}
-
-void config_bee_proximity_gpios(int on);
-
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-	.guage_driver = GUAGE_MODEM,
-	.charger = SWITCH_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-
-static int bee_ts_melfas_power(int on)
-{
-	printk(KERN_INFO "%s():\n", __func__);
-	if (on) {
-		gpio_set_value(BEE_TP_3V_EN, 1);
-		msleep(300);
-	} else {
-		gpio_set_value(BEE_TP_3V_EN, 0);
-		msleep(2);
-	}
-	return 0;
-}
-
-static struct melfas_i2c_rmi_platform_data bee_melfas_ts_data[] = {
-	{
-		.version = MELFAS_DIAMOND_PATTERN,
-		.power = bee_ts_melfas_power,
-		.intr = BEE_GPIO_TP_ATT_N,
-	},
-	{
-		.version = MELFAS_TRIANGLE_PATTERN,
-		.power = bee_ts_melfas_power,
-		.intr = BEE_GPIO_TP_ATT_N,
-	}
-};
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 3, 7, 11, 80, 199, 279, 479, 539, 541, 0x3FF },
-		.channel = 3,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xCF,
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 38, 82, 95, 167},
-		.channel = 1,
-		.int_pin = 1 << 5,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "reset-int",
-		.category = MICROP_FUNCTION_RESET_INT,
-		.int_pin = 1 << 8,
-	},
-	{
-		.name   = "oj",
-		.category = MICROP_FUNCTION_OJ,
-		.int_pin = 1 << 12,
-	},
-};
-static void curcial_oj_shutdown (int	enable)
-{
-	uint8_t	cmd[3];
-	memset(cmd, 0x00, sizeof(uint8_t)*3);
-
-	cmd[2] = 0x80;
-	if (enable)
-		microp_i2c_write(0x91, cmd,	3);
-	else
-		microp_i2c_write(0x90, cmd,	3);
-
-}
-
-static int curcial_oj_poweron(int	on)
-{
-
-	struct vreg	*oj_power = vreg_get(0, "wlan");
-	if (IS_ERR(oj_power)) {
-		printk(KERN_ERR"%s:Error power domain\n",__func__);
-		return 0;
-	}
-	if (on) {
-		vreg_set_level(oj_power, 2850);
-		vreg_enable(oj_power);
-		printk(KERN_ERR "%s:OJ	power	enable(%d)\n", __func__, on);
-	} else {
-		vreg_disable(oj_power);
-		printk(KERN_ERR "%s:OJ	power	enable(%d)\n", __func__, on);
-		}
-	return 1;
-}
-static void curcial_oj_adjust_xy(uint8_t *data, int16_t *mSumDeltaX, int16_t *mSumDeltaY)
-{
-	int8_t 	deltaX;
-	int8_t 	deltaY;
-
-
-	if (data[2] == 0x80)
-		data[2] = 0x81;
-	if (data[1] == 0x80)
-		data[1] = 0x81;
-	if (0) {
-		deltaX = (1)*((int8_t) data[2]); /*X=2*/
-		deltaY = (-1)*((int8_t) data[1]); /*Y=1*/
-	} else {
-		deltaX = (1)*((int8_t) data[1]);
-		deltaY = (1)*((int8_t) data[2]);
-	}
-	*mSumDeltaX += -((int16_t)deltaX);
-	*mSumDeltaY += -((int16_t)deltaY);
-}
-#define BEE_MICROP_VER	0x01
-
-static struct curcial_oj_platform_data bee_oj_data = {
-	.oj_poweron = curcial_oj_poweron,
-	.oj_shutdown = curcial_oj_shutdown,
-	.oj_adjust_xy = curcial_oj_adjust_xy,
-	.microp_version = BEE_MICROP_VER,
-	.mdelay_time = 0,
-	.msleep_time = 1,
-	.x_send_count = 3,
-	.y_send_count = 3,
-	.fast_th = 2,
-	.normal_th = 20,
-	.continue_th = 3,
-	.continue_max = 0,
-	.xy_ratio = 15,
-	.interval = 60,
-	.softclick = 0,
-	.swap = 1,
-	.x = 1,
-	.y = -1,
-	.share_power = false,
-	.Xsteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-	.Ysteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-};
-
-static struct platform_device bee_oj = {
-	.name = CURCIAL_OJ_NAME,
-	.id = -1,
-	.dev = {
-		.platform_data	= &bee_oj_data,
-	}
-};
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct bma150_platform_data buzz_g_sensor_pdata = {
-	.microp_new_cmd = 1,
-};
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev = {
-			.platform_data = &lightsensor_data,
-		},
-	},
-	{
-		.name = "leds-microp",
-		.id = -1,
-		.dev = {
-			.platform_data = &microp_leds_data,
-		},
-	},
-	{
-		.name = BMA150_G_SENSOR_NAME,
-		.dev = {
-			.platform_data = &buzz_g_sensor_pdata,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = BEE_GPIO_UP_RESET_N,
-	.spi_devices = SPI_OJ | SPI_GSENSOR,
-};
-
-static struct gpio_led bee_led_list[] = {
-	{
-		.name = "button-backlight",
-		.gpio = BEE_AP_KEY_LED_EN,
-		.active_low = 0,
-	},
-};
-
-static struct gpio_led_platform_data bee_leds_data = {
-	.num_leds = ARRAY_SIZE(bee_led_list),
-	.leds = bee_led_list,
-};
-
-static struct platform_device bee_leds = {
-	.name = "leds-gpio",
-	.id = -1,
-	.dev = {
-		.platform_data = &bee_leds_data,
-	},
-};
-static struct i2c_board_info i2c_microp_devices = {
-	I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-	.platform_data = &microp_data,
-	.irq = MSM_GPIO_TO_INT(BEE_GPIO_UP_INT),
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_bee_camera_on_gpios,
-	.camera_gpio_off = config_bee_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		.end	= INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
-	.camera_flash		= flashlight_control,
-	.num_flash_levels	= FLASHLIGHT_NUM,
-	.low_temp_limit		= 5,
-	.low_cap_limit		= 15,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_s5k4e1gx_data = {
-	.sensor_name    = "s5k4e1gx",
-	.sensor_reset   = 118,
-	.vcm_pwd        = BEE_GPIO_VCM_PWDN,
-	.pdata          = &msm_camera_device_data,
-	.flash_type     = MSM_CAMERA_FLASH_LED,
-	.resource       = msm_camera_resources,
-	.num_resources  = ARRAY_SIZE(msm_camera_resources),
-	.flash_cfg	= &msm_camera_sensor_flash_cfg,
-};
-
-static struct platform_device msm_camera_sensor_s5k4e1gx = {
-	.name      = "msm_camera_s5k4e1gx",
-	.dev       = {
-		.platform_data = &msm_camera_sensor_s5k4e1gx_data,
-	},
-};
-
-static struct akm8975_platform_data compass_platform_data = {
-	.layouts = BEE_LAYOUTS,
-};
-
-static int bee_ts_atmel_power(int on)
-{
-	printk(KERN_INFO "%s():\n", __func__);
-	if (on) {
-		gpio_set_value(BEE_GPIO_TP_RST, 0);
-		msleep(5);
-		gpio_set_value(BEE_TP_3V_EN, 1);
-		msleep(5);
-		gpio_set_value(BEE_GPIO_TP_RST, 1);
-		msleep(40);
-	} else {
-		gpio_set_value(BEE_TP_3V_EN, 0);
-		msleep(2);
-	}
-	return 0;
-}
-
-struct atmel_i2c_platform_data bee_ts_atmel_data = {
-	.version = 0x0015,
-	.abs_x_min = 0,
-	.abs_x_max = 1023,
-	.abs_y_min = 0,
-	.abs_y_max = 915,
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-	.abs_width_min = 0,
-	.abs_width_max = 20,
-	.gpio_irq = BEE_GPIO_TP_ATT_N,
-	.power = bee_ts_atmel_power,
-	.config_T6 = {0, 0, 0, 0, 0, 0},
-	.config_T7 = {50, 15, 25},
-	.config_T8 = {8, 0, 20, 20, 0, 0, 10, 10},
-	.config_T9 = {131, 0, 0, 16, 11, 0, 16, 35, 2, 3, 0, 2, 2, 46, 2, 10, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 150, 57, 150, 83},
-	.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T20 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T22 = {5, 0, 0, 25, 0, -25, 255, 4, 30, 0, 1, 10, 15, 20, 10, 10, 0},
-	.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T25 = {3, 0, 224, 46, 88, 27, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-	.config_T28 = {0, 0, 0, 4, 8, 60},
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(ATMEL_QT602240_NAME, 0x94 >> 1),
-		.platform_data = &bee_ts_atmel_data,
-		.irq = MSM_GPIO_TO_INT(BEE_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(MELFAS_I2C_NAME, 0x22),
-		.platform_data = &bee_melfas_ts_data,
-		.irq = MSM_GPIO_TO_INT(BEE_GPIO_TP_ATT_N)
-	},
-	{
-		/*I2C_BOARD_INFO("s5k4b2fx", 0x22 >> 1),*/
-		I2C_BOARD_INFO("s5k4b2fx", 0x22),
-		/* .irq = TROUT_GPIO_TO_INT(TROUT_GPIO_CAM_BTN_STEP1_N), */
-	},
-	{
-		I2C_BOARD_INFO("s5k4e1gx", 0x20 >> 1),   /*5M bayer sensor*/
-		.platform_data = &msm_camera_device_data,
-	},
-	{
-		I2C_BOARD_INFO("tps65200", 0xD4 >> 1),
-	},
-};
-
-static struct i2c_board_info i2c_sensor[] = {
-	{
-		I2C_BOARD_INFO(AKM8975_I2C_NAME, 0x0C),
-		.platform_data = &compass_platform_data,
-		.irq = MSM_GPIO_TO_INT(BEE_GPIO_COMPASS_INT_N),
-	},
-};
-
-static struct h2w_platform_data bee_h2w_data = {
-	.key_int_shutdown_gpio = BEE_GPIO_35MM_KEY_INT_SHUTDOWN,
-};
-
-static struct platform_device bee_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &bee_h2w_data,
-	},
-};
-
-static struct audio_jack_platform_data bee_jack_data = {
-	.gpio	= BEE_GPIO_35MM_HEADSET_DET,
-};
-
-
-static struct platform_device bee_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &bee_jack_data,
-	},
-};
-
-static struct pwr_sink bee_pwrsink_table[] = {
-	{
-		.id     = PWRSINK_AUDIO,
-		.ua_max = 100000,
-	},
-	{
-		.id     = PWRSINK_BACKLIGHT,
-		.ua_max = 125000,
-	},
-	{
-		.id     = PWRSINK_LED_BUTTON,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_LED_KEYBOARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_GP_CLK,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_BLUETOOTH,
-		.ua_max = 15000,
-	},
-	{
-		.id     = PWRSINK_CAMERA,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_SDCARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_VIDEO,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id     = PWRSINK_SYSTEM_LOAD,
-		.ua_max = 100000,
-		.percent_util = 38,
-	},
-};
-
-static int bee_pwrsink_resume_early(struct platform_device *pdev)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-	return 0;
-}
-
-static void bee_pwrsink_resume_late(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 38);
-}
-
-static void bee_pwrsink_suspend_early(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-}
-
-static int bee_pwrsink_suspend_late(struct platform_device *pdev, pm_message_t state)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 1);
-	return 0;
-}
-
-static struct pwr_sink_platform_data bee_pwrsink_data = {
-	.num_sinks      = ARRAY_SIZE(bee_pwrsink_table),
-	.sinks          = bee_pwrsink_table,
-	.suspend_late	= bee_pwrsink_suspend_late,
-	.resume_early	= bee_pwrsink_resume_early,
-	.suspend_early	= bee_pwrsink_suspend_early,
-	.resume_late	= bee_pwrsink_resume_late,
-};
-
-static struct platform_device bee_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev    = {
-		.platform_data = &bee_pwrsink_data,
-	},
-};
-
-static struct msm_pmem_setting pmem_setting = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-};
-
-static ssize_t bee_melfas_virtual_keys_show(struct kobject *kobj,
-			       struct kobj_attribute *attr, char *buf)
-{
-	return sprintf(buf,
-			__stringify(EV_KEY) ":" __stringify(KEY_HOME)	":24:327:44:5"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)	":84:327:73:5"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)	":154:327:69:5"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":224:327:36:5"
-			"\n");
-
-}
-
-static ssize_t bee_virtual_keys_show(struct kobject *kobj,
-			       struct kobj_attribute *attr, char *buf)
-{
-	return sprintf(buf,
-		__stringify(EV_KEY) ":" __stringify(KEY_HOME)  ":13:350:25:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":71:350:32:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":162:350:28:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":223:350:30:55"
-	   "\n");
-}
-
-static struct kobj_attribute bee_melfas_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.melfas-tsi-ts",
-		.mode = S_IRUGO,
-	},
-	.show = &bee_melfas_virtual_keys_show,
-};
-
-static struct kobj_attribute bee_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.atmel-touchscreen",
-		.mode = S_IRUGO,
-	},
-	.show = &bee_virtual_keys_show,
-};
-
-static struct attribute *bee_properties_attrs[] = {
-	&bee_melfas_virtual_keys_attr.attr,
-	&bee_virtual_keys_attr.attr,
-	NULL
-};
-
-static struct attribute_group bee_properties_attr_group = {
-	.attrs = bee_properties_attrs,
-};
-
-static struct msm_i2c_device_platform_data bee_i2c_device_data = {
-	.i2c_clock = 400000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-static struct platform_device bee_rfkill = {
-	.name = "bee_rfkill",
-	.id = -1,
-};
-
-static int __capella_cm3602_power(int on)
-{
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on) {
-		config_bee_proximity_gpios(1);
-		gpio_direction_output(BEE_GPIO_PROXIMITY_EN, 1);
-		gpio_direction_output(BEE_GPIO_LS_EN, 0);
-		gpio_direction_output(BEE_PS_2V85_EN, 1);
-	} else {
-		gpio_direction_output(BEE_PS_2V85_EN, 0);
-		gpio_direction_output(BEE_GPIO_LS_EN, 1);
-		gpio_direction_output(BEE_GPIO_PROXIMITY_EN, 0);
-		config_bee_proximity_gpios(0);
-	}
-	return 0;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static unsigned int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable)
-		als_power_control |= pwr_device;
-	else
-		als_power_control &= ~pwr_device;
-
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-		ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-}
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.p_out = BEE_GPIO_PROXIMITY_INT,
-	.p_en = BEE_GPIO_PROXIMITY_EN,
-	.power = capella_cm3602_power,
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-
-static void config_bee_flashlight_gpios(void)
-{
-	static uint32_t bee_flashlight_gpio_table[] = {
-		PCOM_GPIO_CFG(BEE_GPIO_FL_TORCH, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-								GPIO_2MA),
-		PCOM_GPIO_CFG(BEE_GPIO_FL_FLASH, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-								GPIO_2MA),
-	};
-	config_gpio_table(bee_flashlight_gpio_table,
-		ARRAY_SIZE(bee_flashlight_gpio_table));
-}
-
-static struct flashlight_platform_data bee_flashlight_data = {
-	.gpio_init = config_bee_flashlight_gpios,
-	.torch = BEE_GPIO_FL_TORCH,
-	.flash = BEE_GPIO_FL_FLASH,
-	.flash_duration_ms = 600,
-};
-
-static struct platform_device bee_flashlight_device = {
-	.name = FLASHLIGHT_NAME,
-	.dev = {
-		.platform_data  = &bee_flashlight_data,
-	},
-};
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_smd,
-	&msm_device_nand,
-	&msm_device_i2c,
-	&bee_h2w,
-	&htc_battery_pdev,
-	&bee_audio_jack,
-	&msm_camera_sensor_s5k4e1gx,
-	&bee_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&bee_pwr_sink,
-#endif
-
-#ifdef CONFIG_INPUT_CAPELLA_CM3602
-	&capella_cm3602,
-#endif
-	&bee_leds,
-	&bee_flashlight_device,
-	&bee_oj,
-};
-
-extern struct sys_timer msm_timer;
-
-static void __init bee_init_irq(void)
-{
-	printk("bee_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint cpld_iset;
-static uint cpld_charger_en;
-static uint cpld_usb_h2w_sw;
-static uint opt_disable_uart3;
-static char *keycaps = "";
-
-module_param_named(iset, cpld_iset, uint, 0);
-module_param_named(charger_en, cpld_charger_en, uint, 0);
-module_param_named(usb_h2w_sw, cpld_usb_h2w_sw, uint, 0);
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-module_param_named(keycaps, keycaps, charp, 0);
-
-static char bt_chip_id[10] = "bcm4329";
-module_param_string(bt_chip_id, bt_chip_id, sizeof(bt_chip_id), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_chip_id, "BT's chip id");
-
-static char bt_fw_version[10] = "v2.0.38";
-module_param_string(bt_fw_version, bt_fw_version, sizeof(bt_fw_version), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_fw_version, "BT's fw version");
-
-static void bee_reset(void)
-{
-	gpio_set_value(BEE_GPIO_PS_HOLD, 0);
-}
-
-static uint32_t proximity_on_gpio_table[] = {
-	PCOM_GPIO_CFG(BEE_GPIO_PROXIMITY_INT,
-		0, GPIO_INPUT, GPIO_NO_PULL, 0), /* PS_VOUT */
-};
-
-static uint32_t proximity_off_gpio_table[] = {
-	PCOM_GPIO_CFG(BEE_GPIO_PROXIMITY_INT,
-		0, GPIO_INPUT, GPIO_PULL_DOWN, 0) /* PS_VOUT */
-};
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA),/*HSYNC_IN*/
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA),/*VSYNC_IN*/
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA),/*MCLK*/
-
-	PCOM_GPIO_CFG(61, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),/*CAM_I2C_SDA*/
-	PCOM_GPIO_CFG(60, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),/*CAM_I2C_SCL*/
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-void config_bee_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void config_bee_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-/* for bcm */
-static char bdaddress[20];
-extern unsigned char *get_bt_bd_ram(void);
-
-static void bt_export_bd_address(void)
-{
-	unsigned char cTemp[6];
-
-	memcpy(cTemp, get_bt_bd_ram(), 6);
-	sprintf(bdaddress, "%02x:%02x:%02x:%02x:%02x:%02x",
-		cTemp[0], cTemp[1], cTemp[2], cTemp[3], cTemp[4], cTemp[5]);
-	printk(KERN_INFO "YoYo--BD_ADDRESS=%s\n", bdaddress);
-}
-
-module_param_string(bdaddress, bdaddress, sizeof(bdaddress), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bdaddress, "BT MAC ADDRESS");
-
-void config_bee_proximity_gpios(int on)
-{
-	if (on)
-		config_gpio_table(proximity_on_gpio_table,
-			ARRAY_SIZE(proximity_on_gpio_table));
-	else
-		config_gpio_table(proximity_off_gpio_table,
-			ARRAY_SIZE(proximity_off_gpio_table));
-}
-
-static uint32_t bee_serial_debug_table[] = {
-	/* config as serial debug uart */
-	PCOM_GPIO_CFG(BEE_GPIO_UART3_RX, 1,
-			GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* UART3 RX */
-	PCOM_GPIO_CFG(BEE_GPIO_UART3_TX, 1,
-			GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* UART3 TX */
-};
-
-static void bee_config_serial_debug_gpios(void)
-{
-	config_gpio_table(bee_serial_debug_table,
-			ARRAY_SIZE(bee_serial_debug_table));
-}
-
-
-static void __init config_gpios(void)
-{
-	bee_config_serial_debug_gpios();
-	config_bee_camera_off_gpios();
-}
-
-static struct msm_acpu_clock_platform_data bee_clock_data = {
-	.acpu_switch_time_us = 50,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200,
-#if defined(CONFIG_TURBO_MODE)
-	.wait_for_irq_khz = 176000,
-#else
-	.wait_for_irq_khz = 128000,
-#endif
-};
-
-static unsigned bee_perf_acpu_table[] = {
-	245760000,
-	480000000,
-	528000000,
-};
-
-static struct perflock_platform_data bee_perflock_data = {
-	.perf_acpu_table = bee_perf_acpu_table,
-	.table_size = ARRAY_SIZE(bee_perf_acpu_table),
-};
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(BEE_GPIO_BT_HOST_WAKE),
-	.inject_rx_on_wakeup = 0,
-	.cpu_lock_supported = 1,
-
-	/* for bcm */
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = BEE_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = BEE_GPIO_BT_HOST_WAKE,
-
-};
-#endif
-
-static void __init bee_init(void)
-{
-	int rc;
-	struct kobject *properties_kobj;
-
-	printk("bee_init() revision=%d\n", system_rev);
-	printk(KERN_INFO "mfg_mode=%d\n", board_mfg_mode());
-
-	/* for bcm */
-	bt_export_bd_address();
-
-	/*
-	 * Setup common MSM GPIOS
-	 */
-	config_gpios();
-
-	/* We need to set this pin to 0 only once on power-up; we will
-	 * not actually enable the chip until we apply power to it via
-	 * vreg.
-	 */
-	gpio_direction_output(BEE_GPIO_LS_EN, 0);
-	/* disable power for cm3602 chip */
-	__capella_cm3602_power(0);
-
-	msm_hw_reset_hook = bee_reset;
-
-	msm_acpu_clock_init(&bee_clock_data);
-	perflock_init(&bee_perflock_data);
-	/* adjust GPIOs based on bootloader request */
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-			&msm_device_uart3.dev, 1,
-				MSM_GPIO_TO_INT(BEE_GPIO_UART3_RX));
-#endif
-
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_device_uart_dm1.name = "msm_serial_hs_bcm";	/* for bcm */
-	msm_add_serial_devices(3);
-#else
-	msm_add_serial_devices(0);
-#endif
-
-	msm_add_serial_devices(2);
-	msm_init_ums_lun(2);
-	msm_set_ums_device_id(0x1);
-	msm_add_usb_id_pin_gpio(BEE_GPIO_USB_ID_PIN);
-	msm_hsusb_set_product(bee_usb_products,
-		ARRAY_SIZE(bee_usb_products));
-	msm_add_usb_devices(NULL, NULL);
-
-	msm_add_mem_devices(&pmem_setting);
-	msm_init_pmic_vibrator();
-#ifdef CONFIG_MICROP_COMMON
-	bee_microp_init();
-#endif
-
-	rc = bee_init_mmc(system_rev);
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-
-	properties_kobj = kobject_create_and_add("board_properties", NULL);
-
-	if (properties_kobj)
-		rc = sysfs_create_group(properties_kobj,
-					 &bee_properties_attr_group);
-	if (!properties_kobj || rc)
-		pr_err("failed to create board_properties\n");
-
-	msm_device_i2c.dev.platform_data = &bee_i2c_device_data;
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	i2c_register_board_info(0, i2c_sensor, ARRAY_SIZE(i2c_sensor));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-	i2c_register_board_info(0 , &i2c_microp_devices, 1);
-
-	bee_init_keypad();
-}
-
-static void __init bee_fixup(struct machine_desc *desc, struct tag *tags,
-				char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 2;
-	mi->bank[0].start = MSM_LINUX_BASE1;
-	mi->bank[0].node = PHYS_TO_NID(MSM_LINUX_BASE1);
-	mi->bank[0].size = MSM_LINUX_SIZE1;
-	mi->bank[1].start = MSM_LINUX_BASE2;
-	mi->bank[1].node = PHYS_TO_NID(MSM_LINUX_BASE2);
-	mi->bank[1].size = MSM_LINUX_SIZE2;
-}
-
-static void __init bee_map_io(void)
-{
-	printk("bee_init_map_io()\n");
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-MACHINE_START(BEE, "bee")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params    = 0x02E00100,
-	.fixup          = bee_fixup,
-	.map_io         = bee_map_io,
-	.init_irq       = bee_init_irq,
-	.init_machine   = bee_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-bee.h b/arch/arm/mach-msm/board-bee.h
deleted file mode 100644
index 3dbb210..0000000
--- a/arch/arm/mach-msm/board-bee.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/* linux/arch/arm/mach-msm/board-bee.h
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_BEE_H
-#define __ARCH_ARM_MACH_MSM_BOARD_BEE_H
-
-#include <mach/board.h>
-
-#define MSM_LINUX_BASE1                 0x02E00000
-#define MSM_LINUX_SIZE1                 0x0D200000
-#define MSM_LINUX_BASE2                 0x20000000
-#define MSM_LINUX_SIZE2                 0x06F00000
-
-#define MSM_PMEM_MDP_BASE               0x00000000
-#define MSM_PMEM_MDP_SIZE               0x00800000
-
-#define MSM_FB_BASE                     0x26F00000
-#define MSM_FB_SIZE                     0x9b000
-
-#define MSM_RAM_CONSOLE_BASE            MSM_FB_BASE + MSM_FB_SIZE
-#define MSM_RAM_CONSOLE_SIZE            128 * SZ_1K
-
-#define MSM_PMEM_ADSP_BASE              0x27000000
-#define MSM_PMEM_ADSP_SIZE              0x00800000
-
-#define MSM_PMEM_CAMERA_BASE            0x27800000
-#define MSM_PMEM_CAMERA_SIZE            0x00800000
-
-#define BEE_GPIO_USB_ID_PIN          (19)
-
-/* key */
-#define BEE_GPIO_POWER_KEY         (20)
-#define BEE_GPIO_Q_KP_MKOUT0       (35)
-#define BEE_GPIO_Q_KP_MKOUT1       (34)
-#define BEE_GPIO_Q_KP_MKOUT2       (33)
-#define BEE_GPIO_Q_KP_MKIN0_1      (42)
-#define BEE_GPIO_Q_KP_MKIN1_1      (41)
-#define BEE_GPIO_Q_KP_MKIN2_1      (40)
-#define BEE_GPIO_OJ_ACTION         (83)
-/*
-#define BEE_GPIO_BALL_UP     (94)
-#define BEE_GPIO_BALL_LEFT   (17)
-#define BEE_GPIO_BALL_DOWN   (83)
-#define BEE_GPIO_BALL_RIGHT  (18)
-*/
-#define BEE_GPIO_WIFI_IRQ1         (29)
-#define BEE_GPIO_WIFI_EN           (116)
-#define BEE_GPIO_SDMC_CD_N         (38)
-#define BEE_GPIO_UP_INT            (27)
-#define BEE_GPIO_UART3_RX          (86)
-#define BEE_GPIO_UART3_TX          (87)
-#define BEE_GPIO_VCM_PWDN          (31)
-#define BEE_GPIO_UP_RESET_N        (76)
-#define BEE_GPIO_PS_HOLD           (25)
-/* flashlight */
-#define BEE_GPIO_FL_TORCH	(84)
-#define BEE_GPIO_FL_FLASH	(85)
-
-/* 35mm headset */
-#define BEE_GPIO_35MM_HEADSET_DET	(112)
-#define BEE_GPIO_35MM_KEY_INT_SHUTDOWN	(93)
-
-/* AP Key Led turn on*/
-#define BEE_AP_KEY_LED_EN			(119)
-
-/* Compass */
-#define BEE_GPIO_COMPASS_INT_N		(37)
-#define BEE_LAYOUTS		{ \
-		{ { 0,  1, 0}, {  1,  0, 0}, {0, 0, -1} }, \
-		{ { 0, -1, 0}, { -1,  0, 0}, {0, 0,  1} }, \
-		{ { 1,  0, 0}, {  0, -1, 0}, {0, 0, -1} }, \
-		{ { 1,  0, 0}, {  0,  0, 1}, {0, 1,  0} }  \
-					}
-
-/* Proximity  */
-#define BEE_GPIO_PROXIMITY_INT     114 // PS_VOUT
-#define BEE_GPIO_PROXIMITY_EN      115 // PS_SHDN
-
-#define BEE_GPIO_LS_EN             111
-#define BEE_PS_2V85_EN             117
-
-/* BT */
-#define BEE_GPIO_BT_UART1_RTS      (43)
-#define BEE_GPIO_BT_UART1_CTS      (44)
-#define BEE_GPIO_BT_UART1_RX       (45)
-#define BEE_GPIO_BT_UART1_TX       (46)
-#define BEE_GPIO_BT_RESET_N        (131)
-#define BEE_GPIO_BT_HOST_WAKE      (21)
-#define BEE_GPIO_BT_CHIP_WAKE      (91)
-#define BEE_GPIO_BT_SHUTDOWN_N     (113)
-
-/* Touch Panel */
-#define BEE_TP_3V_EN                 (108)
-#define BEE_GPIO_TP_ATT_N            (92)
-#define BEE_GPIO_TP_RST              (107)
-
-/* Display */
-#define BEE_LCM_2V85_EN		   (78)
-#define BEE_LCMIO_2V6_EN	   (79)
-#define BEE_MDDI_RSTz              (82)
-
-int bee_init_mmc(unsigned int);
-int __init bee_init_keypad(void);
-
-//struct sys_device;
-unsigned int bee_get_hwid(void);
-unsigned int bee_get_skuid(void);
-unsigned bee_engineerid(void);
-int bee_is_3M_camera(void);
-
-#endif /* GUARD */
diff --git a/arch/arm/mach-msm/board-bravo-audio.c b/arch/arm/mach-msm/board-bravo-audio.c
deleted file mode 100644
index 56743b9..0000000
--- a/arch/arm/mach-msm/board-bravo-audio.c
+++ /dev/null
@@ -1,230 +0,0 @@
-/* arch/arm/mach-msm/board-bravo-audio.c
- *
- * Copyright (C) 2009 HTC Corporation
- * Copyright (C) 2009 Google Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/gpio.h>
-#include <mach/msm_qdsp6_audio.h>
-#include <mach/htc_acoustic_qsd.h>
-#include <linux/delay.h>
-#include "board-bravo.h"
-#include "proc_comm.h"
-#include "pmic.h"
-
-#if 1
-#define D(fmt, args...) printk(KERN_INFO "Audio: "fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-static struct mutex mic_lock;
-static struct mutex bt_sco_lock;
-
-static struct q6_hw_info q6_audio_hw[Q6_HW_COUNT] = {
-	[Q6_HW_HANDSET] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_HEADSET] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_SPEAKER] = {
-		.min_gain = -1500,
-		.max_gain = 0,
-	},
-	[Q6_HW_TTY] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_BT_SCO] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_BT_A2DP] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-};
-
-void bravo_headset_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	/* enable audio amp */
-	gpio_set_value(BRAVO_AUD_JACKHP_EN, !!en);
-}
-
-void bravo_speaker_enable(int en)
-{
-	struct spkr_config_mode scm;
-	memset(&scm, 0, sizeof(scm));
-
-	D("%s %d\n", __func__, en);
-	if (en) {
-		scm.is_right_chan_en = 0;
-		scm.is_left_chan_en = 1;
-		scm.is_stereo_en = 0;
-		scm.is_hpf_en = 1;
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-		pmic_spkr_en_mute(RIGHT_SPKR, 0);
-		pmic_set_spkr_configuration(&scm);
-		pmic_spkr_en(LEFT_SPKR, 1);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		/* unmute */
-		pmic_spkr_en_mute(LEFT_SPKR, 1);
-		mdelay(40);
-	} else {
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-
-		pmic_spkr_en(LEFT_SPKR, 0);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		pmic_set_spkr_configuration(&scm);
-	}
-}
-
-void bravo_receiver_enable(int en)
-{
-	/* Do nothing for bravo. */
-}
-
-static uint32_t bt_sco_enable[] = {
-	PCOM_GPIO_CFG(BRAVO_BT_PCM_OUT, 1, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVO_BT_PCM_IN, 1, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVO_BT_PCM_SYNC, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVO_BT_PCM_CLK, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-static uint32_t bt_sco_disable[] = {
-	PCOM_GPIO_CFG(BRAVO_BT_PCM_OUT, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVO_BT_PCM_IN, 0, GPIO_INPUT,
-			GPIO_PULL_UP, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVO_BT_PCM_SYNC, 0, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVO_BT_PCM_CLK, 0, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-void bravo_bt_sco_enable(int en)
-{
-	static int bt_sco_refcount;
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&bt_sco_lock);
-	if (en) {
-		if (++bt_sco_refcount == 1)
-			config_gpio_table(bt_sco_enable,
-					ARRAY_SIZE(bt_sco_enable));
-	} else {
-		if (--bt_sco_refcount == 0) {
-			config_gpio_table(bt_sco_disable,
-					ARRAY_SIZE(bt_sco_disable));
-			gpio_set_value(BRAVO_BT_PCM_OUT, 0);
-		}
-	}
-	mutex_unlock(&bt_sco_lock);
-}
-
-void bravo_mic_enable(int en)
-{
-	static int old_state = 0, new_state = 0;
-
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&mic_lock);
-	if (!!en)
-		new_state++;
-	else
-		new_state--;
-
-	if (new_state == 1 && old_state == 0)
-		gpio_set_value(BRAVO_AUD_2V5_EN, 1);
-	else if (new_state == 0 && old_state == 1)
-		gpio_set_value(BRAVO_AUD_2V5_EN, 0);
-	else
-		D("%s: do nothing %d %d\n", __func__, old_state, new_state);
-
-	old_state = new_state;
-	mutex_unlock(&mic_lock);
-}
-
-void bravo_analog_init(void)
-{
-	D("%s\n", __func__);
-	/* stereo pmic init */
-	pmic_spkr_set_gain(LEFT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_set_gain(RIGHT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_en_right_chan(OFF_CMD);
-	pmic_spkr_en_left_chan(OFF_CMD);
-	pmic_spkr_add_right_left_chan(OFF_CMD);
-	pmic_spkr_en_stereo(OFF_CMD);
-	pmic_spkr_select_usb_with_hpf_20hz(OFF_CMD);
-	pmic_spkr_bypass_mux(OFF_CMD);
-	pmic_spkr_en_hpf(ON_CMD);
-	pmic_spkr_en_sink_curr_from_ref_volt_cir(OFF_CMD);
-	pmic_spkr_set_mux_hpf_corner_freq(SPKR_FREQ_0_73KHZ);
-	pmic_mic_set_volt(MIC_VOLT_1_80V);
-	pmic_set_speaker_delay(SPKR_DLY_100MS);
-
-	gpio_direction_output(BRAVO_AUD_JACKHP_EN, 1);
-	gpio_set_value(BRAVO_AUD_JACKHP_EN, 0);
-
-	mutex_lock(&bt_sco_lock);
-	config_gpio_table(bt_sco_disable,
-			ARRAY_SIZE(bt_sco_disable));
-	gpio_set_value(BRAVO_BT_PCM_OUT, 0);
-	mutex_unlock(&bt_sco_lock);
-}
-
-int bravo_get_rx_vol(uint8_t hw, int level)
-{
-	struct q6_hw_info *info;
-	int vol;
-
-	info = &q6_audio_hw[hw];
-	vol = info->min_gain + ((info->max_gain - info->min_gain) * level) / 100;
-	D("%s %d\n", __func__, vol);
-	return vol;
-}
-
-static struct qsd_acoustic_ops acoustic = {
-	.enable_mic_bias = bravo_mic_enable,
-};
-
-static struct q6audio_analog_ops ops = {
-	.init = bravo_analog_init,
-	.speaker_enable = bravo_speaker_enable,
-	.headset_enable = bravo_headset_enable,
-	.receiver_enable = bravo_receiver_enable,
-	.bt_sco_enable = bravo_bt_sco_enable,
-	.int_mic_enable = bravo_mic_enable,
-	.ext_mic_enable = bravo_mic_enable,
-	.get_rx_vol = bravo_get_rx_vol,
-};
-
-void __init bravo_audio_init(void)
-{
-	mutex_init(&mic_lock);
-	mutex_init(&bt_sco_lock);
-#if defined(CONFIG_QSD_AUDIO)
-	q6audio_register_analog_ops(&ops);
-#endif
-	acoustic_register_ops(&acoustic);
-}
diff --git a/arch/arm/mach-msm/board-bravo-keypad.c b/arch/arm/mach-msm/board-bravo-keypad.c
deleted file mode 100644
index b5ec50b..0000000
--- a/arch/arm/mach-msm/board-bravo-keypad.c
+++ /dev/null
@@ -1,151 +0,0 @@
-/* arch/arm/mach-msm/board-bravo-keypad.c
- *
- * Copyright (C) 2009 Google, Inc
- * Copyright (C) 2009 HTC Corporation.
- *
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/gpio_event.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/keyreset.h>
-#include <linux/platform_device.h>
-#include <mach/vreg.h>
-
-#include <asm/mach-types.h>
-
-#include "board-bravo.h"
-
-static unsigned int bravo_col_gpios[] = {
-	BRAVO_GPIO_KP_MKOUT0,
-	BRAVO_GPIO_KP_MKOUT1,
-	BRAVO_GPIO_KP_MKOUT2,
-};
-
-static unsigned int bravo_row_gpios[] = {
-	BRAVO_GPIO_KP_MPIN0,
-	BRAVO_GPIO_KP_MPIN1,
-	BRAVO_GPIO_KP_MPIN2,
-};
-
-#define KEYMAP_INDEX(col, row)	((col)*ARRAY_SIZE(bravo_row_gpios) + (row))
-#define KEYMAP_SIZE		(ARRAY_SIZE(bravo_col_gpios) * \
-				 ARRAY_SIZE(bravo_row_gpios))
-
-/* keypad */
-static const unsigned short bravo_keymap[KEYMAP_SIZE] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 1)] = BTN_MOUSE, /* OJ Action key */
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(1, 2)] = KEY_SEARCH,
-	[KEYMAP_INDEX(2, 0)] = KEY_HOME,
-	[KEYMAP_INDEX(2, 2)] = KEY_BACK,
-};
-
-static struct gpio_event_matrix_info bravo_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = bravo_keymap,
-	.output_gpios = bravo_col_gpios,
-	.input_gpios = bravo_row_gpios,
-	.noutputs = ARRAY_SIZE(bravo_col_gpios),
-	.ninputs = ARRAY_SIZE(bravo_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		  GPIOKPF_REMOVE_PHANTOM_KEYS |
-		  GPIOKPF_PRINT_UNMAPPED_KEYS),
-};
-
-static struct gpio_event_direct_entry bravo_keypad_key_map[] = {
-	{
-		.gpio	= BRAVO_GPIO_POWER_KEY,
-		.code	= KEY_POWER,
-	},
-};
-
-static struct gpio_event_input_info bravo_keypad_key_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = GPIOEDF_PRINT_KEYS,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = bravo_keypad_key_map,
-	.keymap_size = ARRAY_SIZE(bravo_keypad_key_map)
-};
-
-static struct gpio_event_info *bravo_input_info[] = {
-	&bravo_keypad_matrix_info.info,
-	&bravo_keypad_key_info.info,
-};
-
-static struct gpio_event_platform_data bravo_input_data = {
-	.names = {
-		"bravo-keypad",
-		NULL,
-	},
-	.info = bravo_input_info,
-	.info_count = ARRAY_SIZE(bravo_input_info),
-};
-
-static struct platform_device bravo_input_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev = {
-		.platform_data = &bravo_input_data,
-	},
-};
-
-static int bravo_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0,
-};
-
-static struct keyreset_platform_data bravo_reset_keys_pdata = {
-	.keys_up	= bravo_reset_keys_up,
-	.keys_down	= {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-struct platform_device bravo_reset_keys_device = {
-	.name	= KEYRESET_NAME,
-	.dev	= {
-		.platform_data = &bravo_reset_keys_pdata,
-	},
-};
-
-
-static int __init bravo_init_keypad_jogball(void)
-{
-	int ret;
-
-	if (!machine_is_bravo())
-		return 0;
-
-	ret = platform_device_register(&bravo_reset_keys_device);
-	if (ret != 0)
-		return ret;
-
-	ret = platform_device_register(&bravo_input_device);
-	if (ret != 0)
-		return ret;
-
-	return 0;
-}
-
-device_initcall(bravo_init_keypad_jogball);
diff --git a/arch/arm/mach-msm/board-bravo-microp.c b/arch/arm/mach-msm/board-bravo-microp.c
deleted file mode 100644
index 3fbf900..0000000
--- a/arch/arm/mach-msm/board-bravo-microp.c
+++ /dev/null
@@ -1,224 +0,0 @@
-/* arch/arm/mach-msm/board-bravo-microp.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <mach/atmega_microp.h>
-#include <mach/htc_35mm_remote.h>
-#include <mach/drv_callback.h>
-
-#include "board-bravo.h"
-
-#ifdef CONFIG_HTC_HEADSET
-#define notify_35mm_headset_insert(insert) \
-	htc_35mm_remote_notify_insert_ext_headset(insert)
-#else
-#define notify_35mm_headset_insert(insert) do {} while (0)
-#endif
-
-/*
-static int bravo_als_intr_enable(struct i2c_client *client,
-		uint32_t als_func, uint8_t enable)
-{
-	struct microp_i2c_client_data *cdata;
-
-	cdata = i2c_get_clientdata(client);
-	mutex_lock(&cdata->microp_i2c_mutex);
-	cdata->als_func = enable ? (cdata->als_func |= als_func)
-				: (cdata->als_func &= ~als_func);
-	mutex_unlock(&cdata->microp_i2c_mutex);
-
-	return microp_write_interrupt(client,
-		cdata->int_pin.int_lsensor, enable);
-}
-
-static int bravo_als_power(int pwr_device, uint8_t enable)
-{
-	int value;
-
-	value = enable ? 0 : 1;
-	gpio_set_value(BRAVO_GPIO_LS_EN, value);
-
-	return 0;
-}
-
-static int bravo_als_table_init(struct i2c_client *client,
-			int i, uint32_t kadc, uint32_t gadc)
-{
-	struct microp_i2c_platform_data *pdata;
-	uint8_t data[20];
-	int j;
-
-	pdata = client->dev.platform_data;
-
-	for (j = 0; j < 10; j++) {
-		data[j] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc >> 8);
-		data[j + 10] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc);
-	}
-
-	return microp_i2c_write(MICROP_I2C_WCMD_ADC_TABLE, data, 20);
-}
-
-static int bravo_als_power_init(struct microp_i2c_platform_data *pdata)
-{
-	int ret = 0;
-
-	ret = gpio_request(pdata->gpio_ls_on, "microp_i2c");
-	if (ret < 0) {
-		pr_err("%s: failed on request gpio ls_on\n", __func__);
-		goto exit;
-	}
-
-	ret = gpio_direction_output(pdata->gpio_ls_on, 0);
-	if (ret < 0) {
-		pr_err("%s: failed on gpio_direction_output ls_on\n", __func__);
-		goto exit;
-	}
-
-exit:
-	return ret;
-
-}
-*/
-
-static int bravo_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Light sensor */
-/*
-	ret = microp_function_check(client, MICROP_FUNCTION_LSENSOR);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_LSENSOR] = i;
-		cdata->int_pin.int_lsensor = pdata->microp_function[i].int_pin;
-		microp_get_als_kvalue(i);
-
-		ret = bravo_als_table_init(client, i, cdata->als_kadc,
-				cdata->als_gadc);
-		if (ret < 0)
-			goto exit;
-
-		bravo_als_power_init(pdata);
-	}
-*/
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Headset plugin */
-	ret = microp_function_check(client, MICROP_FUNCTION_HPIN);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_hpin = pdata->microp_function[i].int_pin;
-		cdata->gpio.hpin = pdata->microp_function[i].mask_r[0] << 16
-					| pdata->microp_function[i].mask_r[1] << 8
-					| pdata->microp_function[i].mask_r[2];
-
-		wake_lock_init(&cdata->hpin_wake_lock,
-					WAKE_LOCK_SUSPEND, "microp_35mm_hpin");
-
-		microp_read_gpio_status(data);
-		cdata->headset_is_in =
-				!((data[0] << 16 | data[1] << 8 | data[2])
-				& cdata->gpio.hpin);
-		if (cdata->headset_is_in)
-			notify_35mm_headset_insert(cdata->headset_is_in);
-
-		ret = microp_write_interrupt(client,
-				cdata->int_pin.int_hpin, 1);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	ret = microp_write_interrupt(client, (1<<8), 1);
-	if (ret)
-		goto exit;
-
-	/* OJ interrupt */
-	ret = microp_function_check(client, MICROP_FUNCTION_OJ);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_oj = pdata->microp_function[i].int_pin;
-
-		ret = microp_write_interrupt(client, cdata->int_pin.int_oj, 1);
-		if (ret)
-			goto exit;
-	}
-
-	/* SD Card detect */
-	ret = microp_function_check(client, MICROP_FUNCTION_SDCARD);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_sdcard = pdata->microp_function[i].int_pin;
-		cdata->gpio.sdcard = pdata->microp_function[i].mask_r[0] << 16
-					| pdata->microp_function[i].mask_r[1] << 8
-					| pdata->microp_function[i].mask_r[2];
-
-		microp_read_gpio_status(data);
-		cdata->sdcard_is_in = ((data[0] << 16 | data[1] << 8 | data[2])
-						& cdata->gpio.sdcard) ? 1 : 0;
-		cnf_driver_event("sdcard_detect", &cdata->sdcard_is_in);
-
-		ret = microp_write_interrupt(client,
-				cdata->int_pin.int_sdcard, 1);
-		if (ret)
-			goto exit;
-	}
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = bravo_microp_function_init,
-/*
-	.als_pwr_enable = bravo_als_power,
-	.als_intr_enable = bravo_als_intr_enable,
-*/
-};
-
-void __init bravo_microp_init(void)
-{
-	microp_register_ops(&ops);
-}
-
-#endif
diff --git a/arch/arm/mach-msm/board-bravo-mmc.c b/arch/arm/mach-msm/board-bravo-mmc.c
deleted file mode 100644
index 845b748..0000000
--- a/arch/arm/mach-msm/board-bravo-mmc.c
+++ /dev/null
@@ -1,346 +0,0 @@
-/* linux/arch/arm/mach-msm/board-bravo-mmc.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-
-#include "board-bravo.h"
-#include "devices.h"
-#include "proc_comm.h"
-
-#include <mach/drv_callback.h>
-
-#define DEBUG_SDSLOT_VDD 1
-
-static bool opt_disable_sdcard;
-static int __init bravo_disablesdcard_setup(char *str)
-{
-	opt_disable_sdcard = (bool)simple_strtol(str, NULL, 0);
-	return 1;
-}
-
-__setup("board_bravo.disable_sdcard=", bravo_disablesdcard_setup);
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static struct vreg	*sdslot_vreg;
-static uint32_t		sdslot_vdd = 0xffffffff;
-static uint32_t		sdslot_vreg_enabled;
-
-static struct {
-	int mask;
-	int level;
-} mmc_vdd_table[] = {
-	{ MMC_VDD_27_28,	2800 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static uint32_t bravo_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-	int ret;
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(sdslot_vreg);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		ret = vreg_enable(sdslot_vreg);
-		if (ret)
-			pr_err("%s: Error enabling vreg (%d)\n", __func__, ret);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask != (1 << vdd))
-			continue;
-		ret = vreg_set_level(sdslot_vreg, mmc_vdd_table[i].level);
-		if (ret)
-			pr_err("%s: Error setting level (%d)\n", __func__, ret);
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Setting level to %u (%s)\n",
-					__func__, mmc_vdd_table[i].level,
-				ret?"Failed":"Success");
-#endif
-		return 0;
-	}
-
-	pr_err("%s: Invalid VDD (%d) specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int bravo_sd_status;
-
-static void (*sdslot_status_cb)(int card_present, void *dev_id);
-static void *sdslot_status_cb_devid;
-
-static int microp_check_status(int *st)
-{
-	bravo_sd_status = !((unsigned) *st);
-
-	if (sdslot_status_cb)
-		sdslot_status_cb(bravo_sd_status, sdslot_status_cb_devid);
-
-	return 0;
-}
-
-bool bravo_sd_gpio(void)
-{
-	return false;
-}
-
-static unsigned int bravo_sdslot_status(struct device *dev)
-{
-	if (bravo_sd_gpio())
-		return !gpio_get_value(BRAVO_GPIO_SDMC_CD_N);
-	else
-		return bravo_sd_status;
-}
-
-#define BRAVO_MMC_VDD	(MMC_VDD_27_28 | MMC_VDD_28_29 | \
-				 MMC_VDD_29_30)
-
-static int
-bravo_sdslot_register_cb(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (sdslot_status_cb)
-		return -EAGAIN;
-
-	sdslot_status_cb = callback;
-	sdslot_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int bravo_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data bravo_sdslot_data = {
-	.ocr_mask		= BRAVO_MMC_VDD,
-	.status			= bravo_sdslot_status,
-	.translate_vdd		= bravo_sdslot_switchvdd,
-	.register_status_notify = bravo_sdslot_register_cb,
-	.slot_type		= &bravo_sdslot_type,
-};
-
-int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-		 unsigned int stat_irq, unsigned long stat_irq_flags);
-
-
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data bravo_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-bravo_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static int bravo_wifi_cd;	/* WiFi virtual 'card detect' status */
-
-static unsigned int bravo_wifi_status(struct device *dev)
-{
-	return bravo_wifi_cd;
-}
-
-static struct mmc_platform_data bravo_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= bravo_wifi_status,
-	.register_status_notify	= bravo_wifi_status_register,
-	.embedded_sdio		= &bravo_wifi_emb_data,
-};
-
-int bravo_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	bravo_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(bravo_wifi_set_carddetect);
-
-int bravo_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-
-	mdelay(100);
-	gpio_set_value(127, on); /* WIFI_SHUTDOWN */
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(bravo_wifi_power);
-
-int bravo_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-
-int __init bravo_init_mmc(unsigned int sys_rev)
-{
-	uint32_t id;
-	struct cnf_driver *microp_sdcard_detect;
-
-	wifi_status_cb = NULL;
-
-	printk(KERN_INFO "%s()+\n", __func__);
-
-	/* initial WIFI_SHUTDOWN# */
-	id = PCOM_GPIO_CFG(127, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	msm_add_sdcc(1, &bravo_wifi_data, 0, 0);
-
-	if (opt_disable_sdcard) {
-		pr_info("%s: sdcard disabled on cmdline\n", __func__);
-		goto done;
-	}
-
-	sdslot_vreg_enabled = 0;
-
-	sdslot_vreg = vreg_get(0, "gp6");
-	if (IS_ERR(sdslot_vreg))
-		return PTR_ERR(sdslot_vreg);
-
-	if (bravo_sd_gpio()) {
-		set_irq_wake(MSM_GPIO_TO_INT(BRAVO_GPIO_SDMC_CD_N), 1);
-
-		msm_add_sdcc(2, &bravo_sdslot_data,
-			     MSM_GPIO_TO_INT(BRAVO_GPIO_SDMC_CD_N),
-			     IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-	} else {
-		microp_sdcard_detect = kzalloc(sizeof(struct cnf_driver),
-							GFP_KERNEL);
-		if (microp_sdcard_detect) {
-			microp_sdcard_detect->name = "sdcard_detect";
-			microp_sdcard_detect->func = &microp_check_status;
-		} else {
-			printk(KERN_ERR "%s: Alloc SD callback func error\n",
-						__func__);
-			goto done;
-		}
-		cnf_driver_register(microp_sdcard_detect);
-
-		msm_add_sdcc(2, &bravo_sdslot_data, 0, 0);
-	}
-
-done:
-	printk(KERN_INFO "%s()-\n", __func__);
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-bravo-rfkill.c b/arch/arm/mach-msm/board-bravo-rfkill.c
deleted file mode 100644
index d322e4a..0000000
--- a/arch/arm/mach-msm/board-bravo-rfkill.c
+++ /dev/null
@@ -1,334 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for bravo platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-bravo.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-/* bt initial configuration */
-static uint32_t bravo_bt_init_table[] = {
-
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt on configuration */
-static uint32_t bravo_bt_on_table[] = {
-
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_RX, /* BT_RX */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt off configuration */
-static uint32_t bravo_bt_off_table[] = {
-
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_RTS, /* BT_RTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_UART1_TX, /* BT_TX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void bravo_config_bt_init(void)
-{
-	/* set bt initial configuration*/
-	config_bt_table(bravo_bt_init_table,
-				ARRAY_SIZE(bravo_bt_init_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(BRAVO_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BRAVO_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(BRAVO_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-
-}
-
-static void bravo_config_bt_on(void)
-{
-	/* set bt on configuration*/
-	config_bt_table(bravo_bt_on_table,
-				ARRAY_SIZE(bravo_bt_on_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(BRAVO_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BRAVO_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-}
-
-static void bravo_config_bt_off(void)
-{
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BRAVO_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_RESET_N */
-	gpio_configure(BRAVO_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(bravo_bt_off_table,
-				ARRAY_SIZE(bravo_bt_off_table));
-	mdelay(5);
-
-	/* BT_RTS */
-	gpio_configure(BRAVO_GPIO_BT_UART1_RTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_TX */
-	gpio_configure(BRAVO_GPIO_BT_UART1_TX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(BRAVO_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		bravo_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		bravo_config_bt_off();
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int bravo_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	bravo_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int bravo_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver bravo_rfkill_driver = {
-	.probe = bravo_rfkill_probe,
-	.remove = bravo_rfkill_remove,
-	.driver = {
-		.name = "bravo_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init bravo_rfkill_init(void)
-{
-	if (!machine_is_bravo())
-		return 0;
-
-	return platform_driver_register(&bravo_rfkill_driver);
-}
-
-static void __exit bravo_rfkill_exit(void)
-{
-	platform_driver_unregister(&bravo_rfkill_driver);
-}
-
-module_init(bravo_rfkill_init);
-module_exit(bravo_rfkill_exit);
-MODULE_DESCRIPTION("bravo rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-bravo-wifi.c b/arch/arm/mach-msm/board-bravo-wifi.c
deleted file mode 100644
index 97e2b85..0000000
--- a/arch/arm/mach-msm/board-bravo-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-bravo-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-bravo.h"
-
-int bravo_wifi_power(int on);
-int bravo_wifi_reset(int on);
-int bravo_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *bravo_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init bravo_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource bravo_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(BRAVO_GPIO_WIFI_IRQ),
-		.end		= MSM_GPIO_TO_INT(BRAVO_GPIO_WIFI_IRQ),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data bravo_wifi_control = {
-	.set_power      = bravo_wifi_power,
-	.set_reset      = bravo_wifi_reset,
-	.set_carddetect = bravo_wifi_set_carddetect,
-	.mem_prealloc   = bravo_wifi_mem_prealloc,
-};
-
-static struct platform_device bravo_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(bravo_wifi_resources),
-        .resource       = bravo_wifi_resources,
-        .dev            = {
-                .platform_data = &bravo_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned bravo_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init bravo_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_bravo())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	bravo_wifi_update_nvs("sd_oobonly=1\n");
-	bravo_init_wifi_mem();
-	ret = platform_device_register(&bravo_wifi_device);
-        return ret;
-}
-
-device_initcall(bravo_wifi_init);
diff --git a/arch/arm/mach-msm/board-bravo.c b/arch/arm/mach-msm/board-bravo.c
deleted file mode 100644
index f65869e..0000000
--- a/arch/arm/mach-msm/board-bravo.c
+++ /dev/null
@@ -1,1273 +0,0 @@
-/* linux/arch/arm/mach-msm/board-bravo.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/usb/mass_storage_function.h>
-#include <linux/android_pmem.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/input.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/regulator/machine.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/setup.h>
-#include <../../../drivers/staging/android/timed_gpio.h>
-
-#include <mach/board.h>
-#include <mach/board_htc.h>
-#include <mach/hardware.h>
-#include <mach/atmega_microp.h>
-#include <mach/camera.h>
-#include <mach/msm_hsusb.h>
-#include <mach/msm_iomap.h>
-#include <mach/htc_battery.h>
-#include <mach/perflock.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/system.h>
-#include <linux/spi/spi.h>
-#include <linux/curcial_oj.h>
-#include <mach/vreg.h>
-#include <mach/msm_panel.h>
-#include "board-bravo.h"
-#include "devices.h"
-#include "proc_comm.h"
-#include "smd_private.h"
-#include <mach/msm_serial_hs.h>
-#include <mach/msm_flashlight.h>
-#include <linux/mfd/tps65023.h>
-
-#define SMEM_SPINLOCK_I2C      6
-
-#ifdef CONFIG_ARCH_QSD8X50
-extern unsigned char *get_bt_bd_ram(void);
-#endif
-
-void msm_init_pmic_vibrator(void);
-extern void __init bravo_audio_init(void);
-#ifdef CONFIG_MICROP_COMMON
-void __init bravo_microp_init(void);
-#endif
-
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-	.gpio_mbat_in = BRAVO_GPIO_MBAT_IN,
-	.gpio_mchg_en_n = BRAVO_GPIO_MCHG_EN_N,
-	.gpio_iset = BRAVO_GPIO_ISET,
-	.guage_driver = GUAGE_DS2784,
-	.charger = LINEAR_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0, 0x21, 0x4D, 0xDC, 0x134, 0x18D, 0x1E5, 0x3FF, 0x3FF, 0x3FF },
-		.channel = 6,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xC0,
-		.ls_power = capella_cm3602_power,
-		/*.ls_gpio_on = BRAVO_GPIO_LS_EN,*/
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 31, 43, 98, 129, 192},
-		.channel = 7,
-		.int_pin = 1 << 7,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "headset-in",
-		.category = MICROP_FUNCTION_HPIN,
-		.int_pin = 1 << 2,
-		.mask_r = {0x00, 0x00, 0x04},
-	},
-	{
-		.name   = "sdcard-detect",
-		.category = MICROP_FUNCTION_SDCARD,
-		.int_pin = 1 << 0,
-		.mask_r = {0x80, 0x00, 0x00},
-	},
-	{
-		.name   = "oj",
-		.category = MICROP_FUNCTION_OJ,
-		.int_pin = 1 << 12,
-	},
-};
-
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "button-backlight",
-		.type = LED_PWM,
-		.mask_w = {0x02, 0x00, 0x00},
-		.led_pin = 1 << 2,
-		.init_value = 0xFF,
-		.fade_time = 1,
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct bma150_platform_data bravo_g_sensor_pdata = {
-	.microp_new_cmd = 1,
-	.chip_layout = 1,
-};
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev = {
-			.platform_data = &lightsensor_data,
-		},
-	},
-	{
-		.name = "leds-microp",
-		.id = -1,
-		.dev = {
-			.platform_data = &microp_leds_data,
-		},
-	},
-	{
-		.name = BMA150_G_SENSOR_NAME,
-		.dev = {
-			.platform_data = &bravo_g_sensor_pdata,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = BRAVO_GPIO_UP_RESET_N,
-	.spi_devices = SPI_OJ | SPI_GSENSOR,
-};
-
-static uint opt_usb_h2w_sw;
-module_param_named(usb_h2w_sw, opt_usb_h2w_sw, uint, 0);
-
-extern void msm_hsusb_8x50_phy_reset(void);
-static int bravo_phy_init_seq[] = { 0x0C, 0x31, 0x31, 0x32, 0x1D, 0x0D, 0x1D, 0x10, -1 };
-static struct msm_hsusb_product bravo_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c87,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-
-static uint32_t usb_phy_3v3_table[] = {
-	PCOM_GPIO_CFG(BRAVO_USB_PHY_3V3_ENABLE, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA)
-};
-
-static uint32_t usb_ID_PIN_input_table[] = {
-	PCOM_GPIO_CFG(BRAVO_GPIO_USB_ID_PIN, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVO_GPIO_USB_ID1_PIN, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),
-};
-
-static uint32_t usb_ID_PIN_ouput_table[] = {
-	PCOM_GPIO_CFG(BRAVO_GPIO_USB_ID_PIN, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),
-};
-
-void config_bravo_usb_id_gpios(bool output)
-{
-	if (output){
-		config_gpio_table(usb_ID_PIN_ouput_table, ARRAY_SIZE(usb_ID_PIN_ouput_table));
-		gpio_set_value(BRAVO_GPIO_USB_ID_PIN, 1);
-		printk(KERN_INFO "%s %d output high\n",  __func__, BRAVO_GPIO_USB_ID_PIN);
-	}else{
-		config_gpio_table(usb_ID_PIN_input_table, ARRAY_SIZE(usb_ID_PIN_input_table));
-		printk(KERN_INFO "%s %d input none pull\n",  __func__, BRAVO_GPIO_USB_ID_PIN);
-	}
-}
-static struct platform_device bravo_rfkill = {
-	.name = "bravo_rfkill",
-	.id = -1,
-};
-
-static struct resource qsd_spi_resources[] = {
-	{
-		.name   = "spi_irq_in",
-		.start  = INT_SPI_INPUT,
-		.end    = INT_SPI_INPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_out",
-		.start  = INT_SPI_OUTPUT,
-		.end    = INT_SPI_OUTPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_err",
-		.start  = INT_SPI_ERROR,
-		.end    = INT_SPI_ERROR,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_base",
-		.start  = 0xA1200000,
-		.end    = 0xA1200000 + SZ_4K - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.name   = "spi_clk",
-		.start  = 17,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_mosi",
-		.start  = 18,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_miso",
-		.start  = 19,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_cs0",
-		.start  = 20,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_pwr",
-		.start  = 21,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_cs0",
-		.start  = 22,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device qsd_device_spi = {
-	.name           = "spi_qsd",
-	.id             = 0,
-	.num_resources  = ARRAY_SIZE(qsd_spi_resources),
-	.resource       = qsd_spi_resources,
-};
-
-static struct resource msm_kgsl_resources[] = {
-	{
-		.name	= "kgsl_reg_memory",
-		.start	= MSM_GPU_REG_PHYS,
-		.end	= MSM_GPU_REG_PHYS + MSM_GPU_REG_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "kgsl_phys_memory",
-		.start	= MSM_GPU_MEM_BASE,
-		.end	= MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_GRAPHICS,
-		.end	= INT_GRAPHICS,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-#define PWR_RAIL_GRP_CLK		8
-static int bravo_kgsl_power_rail_mode(int follow_clk)
-{
-	int mode = follow_clk ? 0 : 1;
-	int rail_id = PWR_RAIL_GRP_CLK;
-
-	return msm_proc_comm(PCOM_CLKCTL_RPC_RAIL_CONTROL, &rail_id, &mode);
-}
-
-static int bravo_kgsl_power(bool on)
-{
-	int cmd;
-	int rail_id = PWR_RAIL_GRP_CLK;
-
-	cmd = on ? PCOM_CLKCTL_RPC_RAIL_ENABLE : PCOM_CLKCTL_RPC_RAIL_DISABLE;
-	return msm_proc_comm(cmd, &rail_id, NULL);
-}
-
-static struct platform_device msm_kgsl_device = {
-	.name		= "kgsl",
-	.id		= -1,
-	.resource	= msm_kgsl_resources,
-	.num_resources	= ARRAY_SIZE(msm_kgsl_resources),
-};
-
-static struct android_pmem_platform_data mdp_pmem_pdata = {
-	.name		= "pmem",
-	.start		= MSM_PMEM_MDP_BASE,
-	.size		= MSM_PMEM_MDP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-static struct android_pmem_platform_data android_pmem_adsp_pdata = {
-	.name		= "pmem_adsp",
-	.start		= MSM_PMEM_ADSP_BASE,
-	.size		= MSM_PMEM_ADSP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-
-static struct android_pmem_platform_data android_pmem_camera_pdata = {
-	.name		= "pmem_camera",
-	.start		= MSM_PMEM_CAMERA_BASE,
-	.size		= MSM_PMEM_CAMERA_SIZE,
-	.no_allocator	= 1,
-	.cached		= 1,
-};
-
-static struct platform_device android_pmem_mdp_device = {
-	.name		= "android_pmem",
-	.id		= 0,
-	.dev		= {
-		.platform_data = &mdp_pmem_pdata
-	},
-};
-
-static struct platform_device android_pmem_adsp_device = {
-	.name		= "android_pmem",
-	.id		= 4,
-	.dev		= {
-		.platform_data = &android_pmem_adsp_pdata,
-	},
-};
-
-static struct platform_device android_pmem_camera_device = {
-	.name		= "android_pmem",
-	.id		= 5,
-	.dev		= {
-		.platform_data = &android_pmem_camera_pdata,
-	},
-};
-
-static struct resource ram_console_resources[] = {
-	{
-		.start	= MSM_RAM_CONSOLE_BASE,
-		.end	= MSM_RAM_CONSOLE_BASE + MSM_RAM_CONSOLE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device ram_console_device = {
-	.name		= "ram_console",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(ram_console_resources),
-	.resource	= ram_console_resources,
-};
-
-static int bravo_ts_power(int on)
-{
-	pr_info("%s: power %d\n", __func__, on);
-
-	if (on) {
-		/* level shifter should be off */
-		gpio_set_value(BRAVO_GPIO_TP_EN, 1);
-		msleep(120);
-		/* enable touch panel level shift */
-		gpio_set_value(BRAVO_GPIO_TP_LS_EN, 1);
-		msleep(3);
-	} else {
-		gpio_set_value(BRAVO_GPIO_TP_LS_EN, 0);
-		gpio_set_value(BRAVO_GPIO_TP_EN, 0);
-		udelay(50);
-	}
-
-	return 0;
-}
-
-static struct synaptics_i2c_rmi_platform_data bravo_ts_data[] = {
-	{
-		.version = 0x0100,
-		.power = bravo_ts_power,
-		.sensitivity_adjust = 12,
-		.flags = SYNAPTICS_FLIP_Y  | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = -1 * 0x10000 / 480,
-		.inactive_right = -1 * 0x10000 / 480,
-		.inactive_top = -5 * 0x10000 / 800,
-		.inactive_bottom = -5 * 0x10000 / 800,
-		.display_width = 480,
-		.display_height = 800,
-		.dup_threshold = 10,
-		.margin_inactive_pixel = {8, 32, 32, 8},
-	},
-};
-
-static struct regulator_consumer_supply tps65023_dcdc1_supplies[] = {
-	{
-		.supply = "acpu_vcore",
-	},
-};
-
-static struct regulator_init_data tps65023_data[5] = {
-	{
-		.constraints = {
-			.name = "dcdc1", /* VREG_MSMC2_1V29 */
-			.min_uV = 1000000,
-			.max_uV = 1300000,
-			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
-		},
-		.consumer_supplies = tps65023_dcdc1_supplies,
-		.num_consumer_supplies = ARRAY_SIZE(tps65023_dcdc1_supplies),
-	},
-	/* dummy values for unused regulators to not crash driver: */
-	{
-		.constraints = {
-			.name = "dcdc2", /* VREG_MSMC1_1V26 */
-			.min_uV = 1260000,
-			.max_uV = 1260000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "dcdc3", /* unused */
-			.min_uV = 800000,
-			.max_uV = 3300000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo1", /* unused */
-			.min_uV = 1000000,
-			.max_uV = 3150000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo2", /* V_USBPHY_3V3 */
-			.min_uV = 3300000,
-			.max_uV = 3300000,
-		},
-	},
-};
-
-static struct h2w_platform_data bravo_h2w_data = {
-	.key_int_shutdown_gpio = BRAVO_GPIO_35MM_KEY_INT_SHUTDOWN,
-};
-
-static struct platform_device bravo_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &bravo_h2w_data,
-	},
-};
-
-static uint32_t key_int_shutdown_gpio_table[] = {
-	PCOM_GPIO_CFG(BRAVO_GPIO_35MM_KEY_INT_SHUTDOWN, 0,
-		GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-};
-
-static void headset_init()
-{
-	config_gpio_table(key_int_shutdown_gpio_table,
-		ARRAY_SIZE(key_int_shutdown_gpio_table));
-	gpio_set_value(BRAVO_GPIO_35MM_KEY_INT_SHUTDOWN, 0);
-	return;
-}
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = BRAVO_LAYOUTS,
-	.project_name = BRAVO_PROJECT_NAME,
-	.reset = BRAVO_GPIO_COMPASS_RST_N,
-	.intr = BRAVO_GPIO_COMPASS_INT,
-};
-
-static void ds2482_set_slp_n(unsigned n)
-{
-	gpio_direction_output(BRAVO_GPIO_DQ_PWRDN_N, n);
-}
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x40),
-		.platform_data = &bravo_ts_data,
-		.irq = MSM_GPIO_TO_INT(BRAVO_GPIO_TP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = MSM_GPIO_TO_INT(BRAVO_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO("ds2482", 0x30 >> 1),
-		.platform_data = ds2482_set_slp_n,
-		//.irq = MSM_GPIO_TO_INT(PASSION_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = MSM_GPIO_TO_INT(BRAVO_GPIO_COMPASS_INT),
-	},
-#ifdef CONFIG_MSM_CAMERA
-#ifdef CONFIG_S5K3E2FX
-	{
-		I2C_BOARD_INFO("s5k3e2fx", 0x20 >> 1),
-	},
-#endif
-#endif/*CONIFIG_MSM_CAMERA*/
-	{
-		I2C_BOARD_INFO("tps65023", 0x48),
-		.platform_data = tps65023_data,
-	},
-};
-
-#ifdef CONFIG_ARCH_QSD8X50
-static char bdaddress[20];
-
-static void bt_export_bd_address(void)
- {
-        unsigned char cTemp[6];
-
-        memcpy(cTemp, get_bt_bd_ram(), 6);
-	sprintf(bdaddress, "%02x:%02x:%02x:%02x:%02x:%02x", cTemp[0], cTemp[1],cTemp[2],cTemp[3],cTemp[4],cTemp[5]);
-        printk(KERN_INFO "YoYo--BD_ADDRESS=%s\n", bdaddress);
-}
-
-module_param_string(bdaddress, bdaddress, sizeof(bdaddress), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bdaddress, "BT MAC ADDRESS");
-#endif
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* VSYNC */
-/*	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_16MA),*/ /* MCLK */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* MCLK */
-	/*steven yeh: modify MCLK driving strength to avoid overshot issue*/
-};
-
-void bravo_config_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void bravo_config_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		 INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = bravo_config_camera_on_gpios,
-	.camera_gpio_off = bravo_config_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
-	.camera_flash		= flashlight_control,
-	.num_flash_levels	= FLASHLIGHT_NUM,
-	.low_temp_limit		= 5,
-	.low_cap_limit		= 15,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_s5k3e2fx_data = {
-	.sensor_name    = "s5k3e2fx",
-	.sensor_reset	= 144, /* CAM1_RST */
-	.sensor_pwd	= 143,  /* CAM1_PWDN, enabled in a9 */
-	.pdata		= &msm_camera_device_data,
-	.resource	= msm_camera_resources,
-	.num_resources	= ARRAY_SIZE(msm_camera_resources),
-	.flash_cfg	= &msm_camera_sensor_flash_cfg,
-};
-
-static struct platform_device msm_camera_sensor_s5k3e2fx = {
-	.name		= "msm_camera_s5k3e2fx",
-	.dev		= {
-	.platform_data = &msm_camera_sensor_s5k3e2fx_data,
-	},
-};
-
-
-static int __capella_cm3602_power(int on)
-{
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on)
-		gpio_direction_output(BRAVO_GPIO_LS_EN, 0);
-		/*gpio_set_value(BRAVO_GPIO_LS_EN, 0);*/
-	else
-		gpio_direction_output(BRAVO_GPIO_LS_EN, 1);
-		/*gpio_set_value(BRAVO_GPIO_LS_EN, 1);*/
-	return 0;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	/* TODO eolsen Add Voltage reg control */
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable) {
-		if (pwr_device == PS_PWR_ON)
-			gpio_direction_output(BRAVO_GPIO_PROXIMITY_EN, 0);
-			/*gpio_set_value(BRAVO_GPIO_PROXIMITY_EN, 0);*/
-		als_power_control |= pwr_device;
-	} else {
-		if (pwr_device == PS_PWR_ON)
-			gpio_direction_output(BRAVO_GPIO_PROXIMITY_EN, 1);
-			/*gpio_set_value(BRAVO_GPIO_PROXIMITY_EN, 1);*/
-		als_power_control &= ~pwr_device;
-	}
-
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-		ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-}
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.power = capella_cm3602_power,
-	.p_en = BRAVO_GPIO_PROXIMITY_EN,
-	.p_out = BRAVO_GPIO_PROXIMITY_INT_N
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.id = -1,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-
-static int config_bravo_flashlight_gpios(void)
-{
-	uint32_t flashlight_gpio_table[] = {
-		PCOM_GPIO_CFG(BRAVO_GPIO_FLASHLIGHT_TORCH, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-		PCOM_GPIO_CFG(BRAVO_GPIO_FLASHLIGHT_FLASH, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-	};
-	config_gpio_table(flashlight_gpio_table,
-		ARRAY_SIZE(flashlight_gpio_table));
-	return 0;
-}
-
-static struct flashlight_platform_data bravo_flashlight_data = {
-	.gpio_init  = config_bravo_flashlight_gpios,
-	.torch = BRAVO_GPIO_FLASHLIGHT_TORCH,
-	.flash = BRAVO_GPIO_FLASHLIGHT_FLASH,
-	.flash_duration_ms = 600
-};
-
-static struct platform_device bravo_flashlight_device = {
-	.name = FLASHLIGHT_NAME,
-	.dev		= {
-		.platform_data	= &bravo_flashlight_data,
-	},
-};
-
-static struct timed_gpio timed_gpios[] = {
-	{
-		.name = "vibrator",
-		.gpio = BRAVO_VIB_3V3_EN,
-		.max_timeout = 15000,
-	},
-};
-
-static struct timed_gpio_platform_data timed_gpio_data = {
-	.num_gpios	= ARRAY_SIZE(timed_gpios),
-	.gpios		= timed_gpios,
-};
-
-static struct platform_device android_timed_gpios = {
-	.name		= "timed-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data = &timed_gpio_data,
-	},
-};
-static void curcial_oj_shutdown (int	enable)
-{
-	uint8_t cmd[3];
-	memset(cmd, 0x00, sizeof(uint8_t)*3);
-	/* microp firmware(v04) non-shutdown by default */
-	cmd[2] = 0x20;
-	microp_i2c_write(0x90, cmd,	3);
-
-}
-
-
-
-static int curcial_oj_poweron(int	on)
-{
-	uint8_t data[2];
-	struct vreg	*oj_power = vreg_get(0, "gp2");
-	if (IS_ERR(oj_power)) {
-		printk(KERN_ERR"%s:Error power domain\n",__func__);
-		return 0;
-	}
-
-
-	if (on) {
-		vreg_set_level(oj_power, 2750);
-		vreg_enable(oj_power);
-		printk(KERN_ERR "%s:OJ	power	enable(%d)\n", __func__, on);
-	} else {
-	/* for microp firmware(v04) setting*/
-		microp_i2c_read(MICROP_I2C_RCMD_VERSION, data, 2);
-		if (data[0] < 4) {
-			printk("Microp firmware version:%d\n",data[0]);
-			return 1;
-		}
-		vreg_disable(oj_power);
-		printk(KERN_ERR "%s:OJ	power	enable(%d)\n", __func__, on);
-		}
-	return 1;
-}
-static void curcial_oj_adjust_xy(uint8_t *data, int16_t *mSumDeltaX, int16_t *mSumDeltaY)
-{
-	int8_t 	deltaX;
-	int8_t 	deltaY;
-
-
-	if (data[2] == 0x80)
-		data[2] = 0x81;
-	if (data[1] == 0x80)
-		data[1] = 0x81;
-	if (1) {
-		deltaX = (1)*((int8_t) data[2]); /*X=2*/
-		deltaY = (-1)*((int8_t) data[1]); /*Y=1*/
-	} else {
-		deltaX = (-1)*((int8_t) data[1]);
-		deltaY = (1)*((int8_t) data[2]);
-	}
-	*mSumDeltaX += -((int16_t)deltaX);
-	*mSumDeltaY += -((int16_t)deltaY);
-}
-#define BRAVO_MICROP_VER	0x03
-
-static struct curcial_oj_platform_data bravo_oj_data = {
-	.oj_poweron = curcial_oj_poweron,
-	.oj_shutdown = curcial_oj_shutdown,
-	.oj_adjust_xy = curcial_oj_adjust_xy,
-	.microp_version = BRAVO_MICROP_VER,
-	.mdelay_time = 0,
-	.msleep_time = 1,
-	.x_send_count = 4,
-	.y_send_count = 2,
-	.fast_th = 1,
-	.normal_th = 8,
-	.continue_th = 3,
-	.continue_max = 0,
-	.xy_ratio = 15,
-	.interval = 200,
-	.softclick = 0,
-	.swap = 0,
-	.x = 1,
-	.y = -1,
-	.share_power = false,
-	.Xsteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-	.Ysteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-};
-
-static struct platform_device bravo_oj = {
-	.name = CURCIAL_OJ_NAME,
-	.id = -1,
-	.dev = {
-		.platform_data	= &bravo_oj_data,
-	}
-};
-
-static int amoled_power(int on)
-{
-        if (on) {
-                gpio_set_value(BRAVO_LCD_RSTz, 1);
-                mdelay(25);
-                gpio_set_value(BRAVO_LCD_RSTz, 0);
-                mdelay(10);
-                gpio_set_value(BRAVO_LCD_RSTz, 1);
-                mdelay(20);
-        } else {
-                gpio_set_value(BRAVO_LCD_RSTz, 0);
-        }
-        return 0;
-}
-
-#define LCM_GPIO_CFG(gpio, func) \
-PCOM_GPIO_CFG(gpio, func, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA)
-static uint32_t display_on_gpio_table[] = {
-        LCM_GPIO_CFG(BRAVO_LCD_R1, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_R2, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_R3, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_R4, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_R5, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_G0, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_G1, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_G2, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_G3, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_G4, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_G5, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_B1, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_B2, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_B3, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_B4, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_B5, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_PCLK, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_VSYNC, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_HSYNC, 1),
-        LCM_GPIO_CFG(BRAVO_LCD_DE, 1),
-};
-
-
-static uint32_t display_off_gpio_table[] = {
-        LCM_GPIO_CFG(BRAVO_LCD_R1, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_R2, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_R3, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_R4, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_R5, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_G0, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_G1, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_G2, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_G3, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_G4, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_G5, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_B1, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_B2, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_B3, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_B4, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_B5, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_PCLK, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_VSYNC, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_HSYNC, 0),
-        LCM_GPIO_CFG(BRAVO_LCD_DE, 0),
-};
-
-static int panel_gpio_switch(int on)
-{
-	config_gpio_table(
-		!!on ? display_on_gpio_table : display_off_gpio_table,
-		ARRAY_SIZE(display_on_gpio_table));
-
-        return 0;
-}
-
-static struct resource resources_msm_fb[] = {
-        {
-                .start = MSM_FB_BASE,
-                .end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-                .flags = IORESOURCE_MEM,
-        },
-};
-
-static struct panel_platform_data amoled_data = {
-        .fb_res = &resources_msm_fb[0],
-        .power = amoled_power,
-        .gpio_switch = panel_gpio_switch,
-};
-
-static struct platform_device amoled_panel = {
-        .name = "amoled-panel",
-        .id = -1,
-        .dev = {
-                .platform_data = &amoled_data,
-        },
-};
-
-static struct platform_device *devices[] __initdata = {
-	&amoled_panel,
-	&msm_device_uart1,
-#ifdef CONFIG_SERIAL_MSM_HS
-	&msm_device_uart_dm1,
-#endif
-	&bravo_h2w,
-	&htc_battery_pdev,
-	&ram_console_device,
-	&bravo_rfkill,
-	&msm_device_smd,
-	&msm_device_nand,
-	&android_pmem_mdp_device,
-	&android_pmem_adsp_device,
-	&android_pmem_camera_device,
-#ifdef CONFIG_MSM_CAMERA
-#ifdef CONFIG_S5K3E2FX
-	&msm_camera_sensor_s5k3e2fx,
-#endif
-#endif
-	&msm_kgsl_device,
-	&msm_device_i2c,
-	&bravo_flashlight_device,
-
-#if defined(CONFIG_SPI_QSD)
-	&qsd_device_spi,
-#endif
-	&bravo_oj,
-#ifdef CONFIG_INPUT_CAPELLA_CM3602
-	&capella_cm3602,
-#endif
-};
-
-
-static uint32_t bravo_serial_debug_table[] = {
-	/* for uart debugger. It should be removed when support usb to serial function */
-	/* RX */
-	PCOM_GPIO_CFG(BRAVO_GPIO_UART3_RX, 3, GPIO_INPUT, GPIO_NO_PULL,
-		      GPIO_4MA),
-	/* TX , note here set GPIO to input!!! */
-	PCOM_GPIO_CFG(BRAVO_GPIO_UART3_TX, 3, GPIO_INPUT, GPIO_NO_PULL,
-		      GPIO_4MA),
-};
-
-static void bravo_config_serial_debug_gpios(void)
-{
-	config_gpio_table(bravo_serial_debug_table, ARRAY_SIZE(bravo_serial_debug_table));
-}
-
-static struct msm_i2c_device_platform_data msm_i2c_pdata = {
-	.i2c_clock = 100000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_8MA,
-};
-
-static void __init msm_device_i2c_init(void)
-{
-	msm_device_i2c.dev.platform_data = &msm_i2c_pdata;
-}
-
-static struct msm_acpu_clock_platform_data bravo_clock_data = {
-	.acpu_switch_time_us	= 20,
-	.max_speed_delta_khz	= 256000,
-	.vdd_switch_time_us	= 62,
-	.power_collapse_khz	= 245000,
-	.wait_for_irq_khz	= 245000,
-};
-
-static unsigned bravo_perf_acpu_table[] = {
-	245000000,
-	576000000,
-	998400000,
-};
-
-static struct perflock_platform_data bravo_perflock_data = {
-	.perf_acpu_table = bravo_perf_acpu_table,
-	.table_size = ARRAY_SIZE(bravo_perf_acpu_table),
-};
-
-int bravo_init_mmc(int sysrev);
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	/* Chip to Device */
-	.wakeup_irq = MSM_GPIO_TO_INT(BRAVO_GPIO_BT_HOST_WAKE),
-	.inject_rx_on_wakeup = 0,
-	.cpu_lock_supported = 0,
-
-	/* for bcm */
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = BRAVO_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = BRAVO_GPIO_BT_HOST_WAKE,
-
-};
-#endif
-
-static void bravo_reset(void)
-{
-       gpio_set_value(BRAVO_GPIO_PS_HOLD, 0);
-}
-
-static void __init bravo_init(void)
-{
-	int ret;
-
-	printk("bravo_init() revision=%d\n", system_rev);
-	printk(KERN_INFO "%s: microp version = %s\n", __func__, microp_ver);
-
-	if (system_rev >= 2) {
-		mdp_pmem_pdata.start = MSM_PMEM_MDP_BASE + MSM_MEM_128MB_OFFSET;
-		android_pmem_adsp_pdata.start = MSM_PMEM_ADSP_BASE + MSM_MEM_128MB_OFFSET;
-	}
-
-	msm_hw_reset_hook = bravo_reset;
-	msm_acpu_clock_init(&bravo_clock_data);
-	perflock_init(&bravo_perflock_data);
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	msm_serial_debug_init(MSM_UART1_PHYS, INT_UART1,
-			      &msm_device_uart1.dev, 1, MSM_GPIO_TO_INT(139));
-#endif
-
-#ifdef CONFIG_ARCH_QSD8X50
-        bt_export_bd_address();
-#endif
-
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_device_uart_dm1.name = "msm_serial_hs_bcm";	/* for bcm */
-#endif
-
-	bravo_config_serial_debug_gpios();
-
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-	gpio_direction_output(BRAVO_GPIO_TP_LS_EN, 0);
-	gpio_direction_output(BRAVO_GPIO_TP_EN, 0);
-
-	bravo_audio_init();
-	msm_device_i2c_init();
-#ifdef CONFIG_MICROP_COMMON
-	bravo_microp_init();
-#endif
-
-	/* set the gpu power rail to manual mode so clk en/dis will not
-	 * turn off gpu power, and hang it on resume */
-	bravo_kgsl_power_rail_mode(0);
-	bravo_kgsl_power(true);
-
-	if (!opt_usb_h2w_sw) {
-		msm_register_usb_phy_init_seq(bravo_phy_init_seq);
-		msm_add_usb_id_pin_gpio(BRAVO_GPIO_USB_ID_PIN);
-		msm_add_usb_id_pin_function(config_bravo_usb_id_gpios);
-		config_bravo_usb_id_gpios(0);
-		msm_enable_car_kit_detect(1);
-		msm_hsusb_set_product(bravo_usb_products,
-			ARRAY_SIZE(bravo_usb_products));
-		msm_add_usb_devices(msm_hsusb_8x50_phy_reset, NULL);
-	}
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	for (ret = 0; ret < ARRAY_SIZE(i2c_devices); ret++) {
-		if (!strcmp(i2c_devices[ret].type, AKM8973_I2C_NAME))
-			i2c_devices[ret].irq = MSM_GPIO_TO_INT(BRAVO_GPIO_COMPASS_INT);
-       }
-	compass_platform_data.intr = BRAVO_GPIO_COMPASS_INT;
-
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	ret = bravo_init_mmc(system_rev);
-	if (ret != 0)
-		pr_crit("%s: Unable to initialize MMC\n", __func__);
-
-	ret = platform_device_register(&android_timed_gpios);
-	if (ret != 0)
-		pr_err("failed to register vibrator\n");
-
-	headset_init();
-
-	config_gpio_table(usb_phy_3v3_table, ARRAY_SIZE(usb_phy_3v3_table));
-	gpio_set_value(BRAVO_USB_PHY_3V3_ENABLE, 1);
-}
-
-#define ATAG_REVISION 0x54410007
-static void __init bravo_fixup(struct machine_desc *desc, struct tag *tags,
-				 char **cmdline, struct meminfo *mi)
-{
-	int bravo_system_rev = 0, find = 0;
-	struct tag *t = (struct tag *)tags;
-
-	for (; t->hdr.size; t = tag_next(t)) {
-		if(t->hdr.tag == ATAG_REVISION) {
-			find = 1;
-			break;
-		}
-	}
-	if (find)
-		bravo_system_rev = t->u.revision.rev;
-
-	mi->nr_banks = 2;
-	mi->bank[0].start = MSM_EBI1_BANK0_BASE;
-	mi->bank[0].node = PHYS_TO_NID(MSM_EBI1_BANK0_BASE);
-	mi->bank[0].size = MSM_EBI1_BANK0_SIZE;
-	mi->bank[1].start = MSM_EBI1_BANK1_BASE;
-	mi->bank[1].node = PHYS_TO_NID(MSM_EBI1_BANK1_BASE);
-	mi->bank[1].size = MSM_EBI1_BANK1_SIZE;
-	if (bravo_system_rev >=2) {
-		mi->bank[1].size = MSM_EBI1_BANK1_SIZE + MSM_MEM_128MB_OFFSET;
-	}
-}
-
-static void __init bravo_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-extern struct sys_timer msm_timer;
-
-MACHINE_START(BRAVO, "bravo")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params	= 0x20000100,
-	.fixup		= bravo_fixup,
-	.map_io		= bravo_map_io,
-	.init_irq	= msm_init_irq,
-	.init_machine	= bravo_init,
-	.timer		= &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-bravo.h b/arch/arm/mach-msm/board-bravo.h
deleted file mode 100644
index 8573f45..0000000
--- a/arch/arm/mach-msm/board-bravo.h
+++ /dev/null
@@ -1,162 +0,0 @@
-/* arch/arm/mach-msm/board-bravo.h
- *
- * Copyright (C) 2009 HTC Corporation.
- * Author: Haley Teng <Haley_Teng@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_BRAVO_H
-#define __ARCH_ARM_MACH_MSM_BOARD_BRAVO_H
-
-#include <mach/board.h>
-
-#define MSM_SMI_BASE		0x02B00000
-#define MSM_SMI_SIZE		0x01500000
-
-
-#define MSM_PMEM_CAMERA_BASE	0x02B00000
-#define MSM_PMEM_CAMERA_SIZE	0x00800000
-
-#define MSM_GPU_MEM_BASE	0x03300000
-#define MSM_GPU_MEM_SIZE	0x00300000
-
-#define MSM_RAM_CONSOLE_BASE	0x03A00000
-#define MSM_RAM_CONSOLE_SIZE	0x00040000
-
-#define MSM_FB_BASE		0x03B00000
-#define MSM_FB_SIZE		0x00465000
-
-#define MSM_EBI1_BANK0_BASE	0x20000000
-#define MSM_EBI1_BANK0_SIZE	0x0E000000
-
-#define MSM_EBI1_BANK1_BASE 	0x30000000
-#define MSM_EBI1_BANK1_SIZE	0x03700000
-
-#define MSM_PMEM_MDP_BASE	0x33700000
-#define MSM_PMEM_MDP_SIZE	0x02000000
-
-#define MSM_PMEM_ADSP_BASE	0x35700000
-#define MSM_PMEM_ADSP_SIZE	0x02900000
-
-#define MSM_MEM_128MB_OFFSET	0x08000000
-
-/* PCB ID */
-#define BRAVO_PCBID_EVT1		0
-#define BRAVO_PCBID_EVT2		1
-
-#define BRAVO_GPIO_PS_HOLD		25
-
-#define BRAVO_GPIO_UP_INT_N		35
-#define BRAVO_GPIO_UP_RESET_N	82
-#define BRAVO_GPIO_LS_EN			119
-
-#define BRAVO_GPIO_TP_INT_N		92
-#define BRAVO_GPIO_TP_LS_EN		93
-#define BRAVO_GPIO_TP_EN		160
-
-#define BRAVO_GPIO_POWER_KEY		94
-#define BRAVO_GPIO_SDMC_CD_N		153
-
-#define BRAVO_GPIO_WIFI_SHUTDOWN_N	127
-#define BRAVO_GPIO_WIFI_IRQ		152
-#define BRAVO_GPIO_BALL_UP		38
-#define BRAVO_GPIO_BALL_DOWN		37
-#define BRAVO_GPIO_BALL_LEFT		145
-#define BRAVO_GPIO_BALL_RIGHT	21
-
-/* BT */
-#define BRAVO_GPIO_BT_UART1_RTS	43
-#define BRAVO_GPIO_BT_UART1_CTS	44
-#define BRAVO_GPIO_BT_UART1_RX	45
-#define BRAVO_GPIO_BT_UART1_TX	46
-#define BRAVO_GPIO_BT_RESET_N	146
-#define BRAVO_GPIO_BT_SHUTDOWN_N	128
-#define BRAVO_GPIO_BT_HOST_WAKE	86
-#define BRAVO_GPIO_BT_CHIP_WAKE	57
-
-/* serial debugger */
-#define BRAVO_GPIO_UART3_RX 139
-#define BRAVO_GPIO_UART3_TX 140
-
-#define BRAVO_GPIO_COMPASS_RST_N	107
-#define BRAVO_GPIO_COMPASS_INT		153
-#define BRAVO_PROJECT_NAME		"bravo"
-#define BRAVO_LAYOUTS			{ \
-		{ {-1,  0, 0}, { 0, -1,  0}, {0, 0,  1} }, \
-		{ { 0, -1, 0}, { 1,  0,  0}, {0, 0, -1} }, \
-		{ { 0, -1, 0}, { 1,  0,  0}, {0, 0,  1} }, \
-		{ {-1,  0, 0}, { 0,  0, -1}, {0, 1,  0} }  \
-					}
-/* Proximity */
-#define BRAVO_GPIO_PROXIMITY_EN		120
-#define BRAVO_GPIO_PROXIMITY_INT_N	90
-
-/* Battery */
-#define BRAVO_GPIO_MBAT_IN		39
-#define BRAVO_GPIO_MCHG_EN_N		22
-#define BRAVO_GPIO_ISET			16
-#define BRAVO_GPIO_DQ_PWRDN_N	87
-
-/*Audio */
-#define BRAVO_AUD_JACKHP_EN		157
-#define BRAVO_AUD_2V5_EN		158
-
-/* Bluetooth PCM */
-#define BRAVO_BT_PCM_OUT		68
-#define BRAVO_BT_PCM_IN		69
-#define BRAVO_BT_PCM_SYNC		70
-#define BRAVO_BT_PCM_CLK		71
-
-#define BRAVO_VIB_3V3_EN		89
-
-/* flash light */
-#define BRAVO_GPIO_FLASHLIGHT_TORCH (58)
-#define BRAVO_GPIO_FLASHLIGHT_FLASH (84)
-
-/* keypad */
-#define BRAVO_GPIO_KP_MKOUT0		33
-#define BRAVO_GPIO_KP_MKOUT1		32
-#define BRAVO_GPIO_KP_MKOUT2		31
-#define BRAVO_GPIO_KP_MPIN0		42
-#define BRAVO_GPIO_KP_MPIN1		41
-#define BRAVO_GPIO_KP_MPIN2		40
-
-/* 3.5mm remote control key interrupt shutdown signal */
-#define BRAVO_GPIO_35MM_KEY_INT_SHUTDOWN	19
-
-#define BRAVO_GPIO_USB_ID_PIN			142/*for BRAVO USB ID pin*/
-#define BRAVO_GPIO_USB_ID1_PIN		36/*for BRAVO USB ID pin*/
-#define BRAVO_USB_PHY_3V3_ENABLE		161 /*for BRAVO USB 3V3*/
-
-/* display relative */
-#define BRAVO_LCD_RSTz               (29)
-#define BRAVO_LCD_R1                 (114)
-#define BRAVO_LCD_R2                 (115)
-#define BRAVO_LCD_R3                 (116)
-#define BRAVO_LCD_R4                 (117)
-#define BRAVO_LCD_R5                 (118)
-#define BRAVO_LCD_G0                 (121)
-#define BRAVO_LCD_G1                 (122)
-#define BRAVO_LCD_G2                 (123)
-#define BRAVO_LCD_G3                 (124)
-#define BRAVO_LCD_G4                 (125)
-#define BRAVO_LCD_G5                 (126)
-#define BRAVO_LCD_B1                 (130)
-#define BRAVO_LCD_B2                 (131)
-#define BRAVO_LCD_B3                 (132)
-#define BRAVO_LCD_B4                 (133)
-#define BRAVO_LCD_B5                 (134)
-#define BRAVO_LCD_PCLK               (135)
-#define BRAVO_LCD_VSYNC              (136)
-#define BRAVO_LCD_HSYNC              (137)
-#define BRAVO_LCD_DE                 (138)
-
-#endif /* __ARCH_ARM_MACH_MSM_BOARD_BRAVO_H */
diff --git a/arch/arm/mach-msm/board-bravoc-audio.c b/arch/arm/mach-msm/board-bravoc-audio.c
deleted file mode 100644
index e8ad5a1..0000000
--- a/arch/arm/mach-msm/board-bravoc-audio.c
+++ /dev/null
@@ -1,212 +0,0 @@
-/* arch/arm/mach-msm/board-bravoc-audio.c
- *
- * Copyright (C) 2009 HTC Corporation
- * Copyright (C) 2009 Google Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/gpio.h>
-#include <linux/delay.h>
-#include <mach/pmic.h>
-#include <mach/msm_qdsp6_audio.h>
-#include <mach/htc_acoustic_qsd.h>
-#include <mach/tpa2018d1.h>
-
-#include "board-bravoc.h"
-#include "proc_comm.h"
-
-#if 1
-#define D(fmt, args...) printk(KERN_INFO "Audio: "fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-static struct mutex mic_lock;
-
-void bravoc_headset_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	/* enable audio amp */
-	if (en) mdelay(15);
-	gpio_set_value(BRAVOC_AUD_JACKHP_EN, !!en);
-}
-void bravoc_speaker_enable(int en)
-{
-	struct spkr_config_mode scm;
-	memset(&scm, 0, sizeof(scm));
-
-	D("%s %d\n", __func__, en);
-	if (en) {
-		scm.is_right_chan_en = 0;
-		scm.is_left_chan_en = 1;
-		scm.is_stereo_en = 0;
-		scm.is_hpf_en = 1;
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-		pmic_spkr_en_mute(RIGHT_SPKR, 0);
-		pmic_set_spkr_configuration(&scm);
-		pmic_spkr_en(LEFT_SPKR, 1);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		/* unmute */
-		pmic_spkr_en_mute(LEFT_SPKR, 1);
-	} else {
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-
-		pmic_spkr_en(LEFT_SPKR, 0);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		pmic_set_spkr_configuration(&scm);
-	}
-#ifdef CONFIG_AMP_TPA2018D1
-	set_speaker_amp(en);
-#endif
-}
-
-void bravoc_receiver_enable(int en)
-{
-	/* After XB*/
-	if (system_rev == 1 ||
-	   (system_rev == 2 && bravoc_get_engineerid() == 0)) {
-		struct spkr_config_mode scm;
-		memset(&scm, 0, sizeof(scm));
-
-		D("%s %d\n", __func__, en);
-		if (en) {
-			scm.is_right_chan_en = 1;
-			scm.is_left_chan_en = 0;
-			scm.is_stereo_en = 0;
-			scm.is_hpf_en = 1;
-			pmic_spkr_en_mute(RIGHT_SPKR, 0);
-			pmic_set_spkr_configuration(&scm);
-			pmic_spkr_en(RIGHT_SPKR, 1);
-
-			/* unmute */
-			pmic_spkr_en_mute(RIGHT_SPKR, 1);
-		} else {
-			pmic_spkr_en_mute(RIGHT_SPKR, 0);
-
-			pmic_spkr_en(RIGHT_SPKR, 0);
-
-			pmic_set_spkr_configuration(&scm);
-		}
-	}
-}
-
-static uint32_t bt_sco_enable[] = {
-	PCOM_GPIO_CFG(BRAVOC_BT_PCM_OUT, 1, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVOC_BT_PCM_IN, 1, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVOC_BT_PCM_SYNC, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVOC_BT_PCM_CLK, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-static uint32_t bt_sco_disable[] = {
-	PCOM_GPIO_CFG(BRAVOC_BT_PCM_OUT, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVOC_BT_PCM_IN, 0, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVOC_BT_PCM_SYNC, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(BRAVOC_BT_PCM_CLK, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-void bravoc_bt_sco_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	if (en)
-		config_gpio_table(bt_sco_enable, ARRAY_SIZE(bt_sco_enable));
-	else {
-		config_gpio_table(bt_sco_disable, ARRAY_SIZE(bt_sco_disable));
-		gpio_set_value(BRAVOC_BT_PCM_OUT, 0);
-	}
-}
-
-
-void bravoc_mic_enable(int en)
-{
-	static int old_state = 0, new_state = 0;
-
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&mic_lock);
-	if (!!en)
-		new_state++;
-	else
-		new_state--;
-
-	if (new_state == 1 && old_state == 0) {
-		gpio_set_value(BRAVOC_AUD_2V5_EN, 1);
-		mdelay(60);
-	} else if (new_state == 0 && old_state == 1)
-		gpio_set_value(BRAVOC_AUD_2V5_EN, 0);
-	else
-		D("%s: do nothing %d %d\n", __func__, old_state, new_state);
-
-	old_state = new_state;
-	mutex_unlock(&mic_lock);
-}
-
-void bravoc_analog_init(void)
-{
-	D("%s\n", __func__);
-	/* stereo pmic init */
-	pmic_spkr_set_gain(LEFT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_set_gain(RIGHT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_en_right_chan(OFF_CMD);
-	pmic_spkr_en_left_chan(OFF_CMD);
-	pmic_spkr_add_right_left_chan(OFF_CMD);
-	pmic_spkr_en_stereo(OFF_CMD);
-	pmic_spkr_select_usb_with_hpf_20hz(OFF_CMD);
-	pmic_spkr_bypass_mux(OFF_CMD);
-	pmic_spkr_en_hpf(ON_CMD);
-	pmic_spkr_en_sink_curr_from_ref_volt_cir(OFF_CMD);
-	pmic_spkr_set_mux_hpf_corner_freq(SPKR_FREQ_0_73KHZ);
-	pmic_mic_set_volt(MIC_VOLT_1_80V);
-	pmic_set_speaker_delay(SPKR_DLY_100MS);
-
-	gpio_direction_output(BRAVOC_AUD_JACKHP_EN, 0);
-	gpio_set_value(BRAVOC_AUD_JACKHP_EN, 0);
-
-	config_gpio_table(bt_sco_disable,
-			ARRAY_SIZE(bt_sco_disable));
-	gpio_set_value(BRAVOC_BT_PCM_OUT, 0);
-	gpio_set_value(BRAVOC_BT_PCM_SYNC, 0);
-	gpio_set_value(BRAVOC_BT_PCM_CLK, 0);
-}
-
-static struct qsd_acoustic_ops acoustic = {
-	.enable_mic_bias = bravoc_mic_enable,
-};
-
-static struct q6audio_analog_ops ops = {
-	.init = bravoc_analog_init,
-	.speaker_enable = bravoc_speaker_enable,
-	.headset_enable = bravoc_headset_enable,
-	.receiver_enable = bravoc_receiver_enable,
-	.bt_sco_enable = bravoc_bt_sco_enable,
-	.int_mic_enable = bravoc_mic_enable,
-	.ext_mic_enable = bravoc_mic_enable,
-};
-
-void __init bravoc_audio_init(void)
-{
-	mutex_init(&mic_lock);
-#if defined(CONFIG_QSD_AUDIO)
-	q6audio_register_analog_ops(&ops);
-#endif
-	acoustic_register_ops(&acoustic);
-}
-
diff --git a/arch/arm/mach-msm/board-bravoc-keypad.c b/arch/arm/mach-msm/board-bravoc-keypad.c
deleted file mode 100644
index 0011438..0000000
--- a/arch/arm/mach-msm/board-bravoc-keypad.c
+++ /dev/null
@@ -1,168 +0,0 @@
-/* arch/arm/mach-msm/board-bravoc-keypad.c
- *
- * Copyright (C) 2009 Google, Inc
- * Copyright (C) 2009 HTC Corporation.
- *
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/gpio_event.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/keyreset.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-bravoc.h"
-
-struct jog_axis_info {
-	struct gpio_event_axis_info	info;
-	uint16_t			in_state;
-	uint16_t			out_state;
-};
-
-static unsigned int bravoc_col_gpios[] = {
-	BRAVOC_GPIO_KP_MKOUT0,
-	BRAVOC_GPIO_KP_MKOUT1,
-	BRAVOC_GPIO_KP_MKOUT2,
-};
-static unsigned int bravoc_row_gpios[] = {
-	BRAVOC_GPIO_KP_MPIN0,
-	BRAVOC_GPIO_KP_MPIN1,
-	BRAVOC_GPIO_KP_MPIN2,
-};
-
-#define KEYMAP_INDEX(col, row)	((col)*ARRAY_SIZE(bravoc_row_gpios) + (row))
-#define KEYMAP_SIZE		(ARRAY_SIZE(bravoc_col_gpios) * \
-				 ARRAY_SIZE(bravoc_row_gpios))
-
-/* keypad */
-static const unsigned short bravoc_keymap[KEYMAP_SIZE] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 1)] = BTN_MOUSE, /* OJ Action key */
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(1, 2)] = KEY_SEARCH,
-	[KEYMAP_INDEX(2, 0)] = KEY_HOME,
-	[KEYMAP_INDEX(2, 2)] = KEY_BACK,
-};
-
-static struct gpio_event_matrix_info bravoc_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = bravoc_keymap,
-	.output_gpios = bravoc_col_gpios,
-	.input_gpios = bravoc_row_gpios,
-	.noutputs = ARRAY_SIZE(bravoc_col_gpios),
-	.ninputs = ARRAY_SIZE(bravoc_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		  GPIOKPF_REMOVE_PHANTOM_KEYS |
-		  GPIOKPF_PRINT_UNMAPPED_KEYS),
-};
-
-static struct gpio_event_direct_entry bravoc_keypad_key_map[] = {
-	{
-		.gpio	= BRAVOC_GPIO_POWER_KEY,
-		.code	= KEY_POWER,
-	},
-};
-
-static struct gpio_event_input_info bravoc_keypad_key_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = GPIOEDF_PRINT_KEYS,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = bravoc_keypad_key_map,
-	.keymap_size = ARRAY_SIZE(bravoc_keypad_key_map)
-};
-
-static struct gpio_event_info *bravoc_input_info[] = {
-	&bravoc_keypad_matrix_info.info,
-	&bravoc_keypad_key_info.info,
-};
-
-static struct gpio_event_platform_data bravoc_input_data = {
-	.names = {
-		"bravoc-keypad",
-		NULL,
-	},
-	.info = bravoc_input_info,
-	.info_count = ARRAY_SIZE(bravoc_input_info),
-};
-
-static struct platform_device bravoc_input_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev = {
-		.platform_data = &bravoc_input_data,
-	},
-};
-
-static int bravoc_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0,
-};
-
-static struct keyreset_platform_data bravoc_reset_keys_pdata = {
-	.keys_up	= bravoc_reset_keys_up,
-	.keys_down	= {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-struct platform_device bravoc_reset_keys_device = {
-	.name	= KEYRESET_NAME,
-	.dev	= {
-		.platform_data = &bravoc_reset_keys_pdata,
-	},
-};
-
-static void bravoc_reset_btn_initialize(void)
-{
-	static uint32_t reset_btn_setup[] = {
-		PCOM_GPIO_CFG(BRAVOC_GPIO_RESET_BTN, 0, GPIO_INPUT,
-						GPIO_NO_PULL, GPIO_4MA),
-	};
-	config_gpio_table(reset_btn_setup, ARRAY_SIZE(reset_btn_setup));
-
-}
-
-static int __init bravoc_init_keypad_jogball(void)
-{
-	int ret;
-
-	if (!machine_is_bravoc())
-		return 0;
-
-	ret = platform_device_register(&bravoc_reset_keys_device);
-	if (ret != 0)
-		return ret;
-
-	bravoc_reset_btn_initialize();
-
-	ret = platform_device_register(&bravoc_input_device);
-	if (ret != 0)
-		return ret;
-
-	return 0;
-}
-
-device_initcall(bravoc_init_keypad_jogball);
diff --git a/arch/arm/mach-msm/board-bravoc-microp.c b/arch/arm/mach-msm/board-bravoc-microp.c
deleted file mode 100644
index db9dc36..0000000
--- a/arch/arm/mach-msm/board-bravoc-microp.c
+++ /dev/null
@@ -1,253 +0,0 @@
-/* arch/arm/mach-msm/board-bravoc-microp.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <mach/atmega_microp.h>
-#include <mach/htc_35mm_remote.h>
-#include <mach/drv_callback.h>
-
-#include "board-bravoc.h"
-
-#ifdef CONFIG_HTC_HEADSET
-#define notify_35mm_headset_insert(insert) \
-	htc_35mm_remote_notify_insert_ext_headset(insert)
-#else
-#define notify_35mm_headset_insert(insert) do {} while (0)
-#endif
-
-/*
-static struct led_trigger bravoc_als_level_trigger = {
-	.name     = "auto-backlight-trigger",
-};
-*/
-
-/*
-static int bravoc_als_intr_enable(struct i2c_client *client,
-		uint32_t als_func, uint8_t enable)
-{
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[2];
-	int ret = 0;
-
-	cdata = i2c_get_clientdata(client);
-	mutex_lock(&cdata->microp_i2c_mutex);
-	cdata->als_func = enable ? (cdata->als_func |= als_func)
-				: (cdata->als_func &= ~als_func);
-
-	data[0] = 0;
-	if (cdata->als_func)
-		data[1] = 1;
-	else
-		data[1] = 0;
-
-	ret = microp_i2c_write(MICROP_I2C_WCMD_AUTO_BL_CTL, data, 2);
-	if (ret != 0)
-		printk(KERN_ERR "%s: set auto light sensor fail\n", __func__);
-
-	mutex_unlock(&cdata->microp_i2c_mutex);
-
-	return ret;
-}
-
-static void bravoc_als_level_change(struct i2c_client *client,
-		uint8_t *data)
-{
-	struct microp_i2c_client_data *cdata  = i2c_get_clientdata(client);
-
-	if (cdata->als_func & ALS_BACKLIGHT)
-		led_trigger_event(&bravoc_als_level_trigger, data[2]);
-}
-
-static int bravoc_als_power(int pwr_device, uint8_t enable)
-{
-	int value;
-
-	value = enable ? 0 : 1;
-	gpio_set_value(BRAVOC_GPIO_LS_EN, value);
-
-	return 0;
-}
-
-static int bravoc_als_table_init(struct i2c_client *client,
-			int i, uint32_t kadc, uint32_t gadc)
-{
-	struct microp_i2c_platform_data *pdata;
-	uint8_t data[20];
-	int j;
-
-	pdata = client->dev.platform_data;
-
-	for (j = 0; j < 10; j++) {
-		data[j] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc >> 8);
-		data[j + 10] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc);
-	}
-
-	return microp_i2c_write(MICROP_I2C_WCMD_ADC_TABLE, data, 20);
-}
-
-static int bravoc_als_power_init(struct microp_i2c_platform_data *pdata)
-{
-	int ret = 0;
-
-	ret = gpio_request(pdata->gpio_ls_on, "microp_i2c");
-	if (ret < 0) {
-		pr_err("%s: failed on request gpio ls_on\n", __func__);
-		goto exit;
-	}
-
-	ret = gpio_direction_output(pdata->gpio_ls_on, 0);
-	if (ret < 0) {
-		pr_err("%s: failed on gpio_direction_output ls_on\n", __func__);
-		goto exit;
-	}
-
-exit:
-	return ret;
-
-}
-*/
-static int bravoc_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Light sensor */
-/*
-	ret = microp_function_check(client, MICROP_FUNCTION_LSENSOR);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_LSENSOR] = i;
-		cdata->int_pin.int_lsensor = pdata->microp_function[i].int_pin;
-		microp_get_als_kvalue(i);
-
-		ret = bravoc_als_table_init(client, i, cdata->als_kadc,
-				cdata->als_gadc);
-		if (ret < 0)
-			goto exit;
-
-		bravoc_als_power_init(pdata);
-	}
-*/
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* OJ interrupt */
-	ret = microp_function_check(client, MICROP_FUNCTION_OJ);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_oj = pdata->microp_function[i].int_pin;
-
-		ret = microp_write_interrupt(client, cdata->int_pin.int_oj, 1);
-		if (ret)
-			goto exit;
-	}
-
-	/* Headset plugin */
-	ret = microp_function_check(client, MICROP_FUNCTION_HPIN);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_hpin = pdata->microp_function[i].int_pin;
-		cdata->gpio.hpin = pdata->microp_function[i].mask_r[0] << 16
-					| pdata->microp_function[i].mask_r[1] << 8
-					| pdata->microp_function[i].mask_r[2];
-
-		wake_lock_init(&cdata->hpin_wake_lock,
-					WAKE_LOCK_SUSPEND, "microp_35mm_hpin");
-
-		microp_read_gpio_status(data);
-		cdata->headset_is_in =
-				!((data[0] << 16 | data[1] << 8 | data[2])
-				& cdata->gpio.hpin);
-		if (cdata->headset_is_in)
-			notify_35mm_headset_insert(cdata->headset_is_in);
-
-		ret = microp_write_interrupt(client,
-				cdata->int_pin.int_hpin, 1);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	data[0] = 0x08;
-	ret = microp_i2c_write(MICROP_I2C_WCMD_MISC, data, 1);
-	if (ret)
-		goto exit;
-
-	/* SD Card detect */
-	ret = microp_function_check(client, MICROP_FUNCTION_SDCARD);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_sdcard = pdata->microp_function[i].int_pin;
-		cdata->gpio.sdcard = pdata->microp_function[i].mask_r[0] << 16
-					| pdata->microp_function[i].mask_r[1] << 8
-					| pdata->microp_function[i].mask_r[2];
-
-		microp_read_gpio_status(data);
-		cdata->sdcard_is_in = ((data[0] << 16 | data[1] << 8 | data[2])
-						& cdata->gpio.sdcard) ? 1 : 0;
-		cnf_driver_event("sdcard_detect", &cdata->sdcard_is_in);
-
-		ret = microp_write_interrupt(client,
-				cdata->int_pin.int_sdcard, 1);
-		if (ret)
-			goto exit;
-	}
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = bravoc_microp_function_init,
-/*
-	.als_pwr_enable = bravoc_als_power,
-	.als_intr_enable = bravoc_als_intr_enable,
-	.als_level_change = bravoc_als_level_change,
-*/
-};
-
-void __init bravoc_microp_init(void)
-{
-	/*led_trigger_register(&bravoc_als_level_trigger);*/
-	microp_register_ops(&ops);
-}
-
-#endif
diff --git a/arch/arm/mach-msm/board-bravoc-mmc.c b/arch/arm/mach-msm/board-bravoc-mmc.c
deleted file mode 100644
index 6ad2c3f..0000000
--- a/arch/arm/mach-msm/board-bravoc-mmc.c
+++ /dev/null
@@ -1,303 +0,0 @@
-/* linux/arch/arm/mach-msm/board-bravoc-mmc.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-
-#include "board-bravoc.h"
-#include "devices.h"
-#include "proc_comm.h"
-
-#include <mach/drv_callback.h>
-
-#define DEBUG_SDSLOT_VDD 1
-
-static bool opt_disable_sdcard;
-static int __init bravoc_disablesdcard_setup(char *str)
-{
-	opt_disable_sdcard = (bool)simple_strtol(str, NULL, 0);
-	return 1;
-}
-
-__setup("board_bravoc.disable_sdcard=", bravoc_disablesdcard_setup);
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t		sdslot_vdd = 0xffffffff;
-static uint32_t		sdslot_vreg_enabled;
-
-static struct {
-	int mask;
-	int level;
-} mmc_vdd_table[] = {
-	{ MMC_VDD_27_28,	2800 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static uint32_t bravoc_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = (vdd == 0) ? 0 : 2850;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		gpio_set_value(100, 0); /* PWR OFF */
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		gpio_set_value(100, 1); /* PWR ON */
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-#if DEBUG_SDSLOT_VDD
-	printk(KERN_INFO "%s: Setting level to %u\n", __func__, sdslot_vdd);
-#endif
-	return 0;
-
-}
-
-static unsigned int bravoc_sd_status;
-
-static void (*sdslot_status_cb)(int card_present, void *dev_id);
-static void *sdslot_status_cb_devid;
-
-static int microp_check_status(int *st)
-{
-	bravoc_sd_status = !((unsigned) *st);
-
-	if (sdslot_status_cb)
-		sdslot_status_cb(bravoc_sd_status, sdslot_status_cb_devid);
-
-	return 0;
-}
-
-static unsigned int bravoc_sdslot_status(struct device *dev)
-{
-	return 1;  /*bravoc_sd_status;*/
-}
-
-#define BRAVOC_MMC_VDD	(MMC_VDD_27_28 | MMC_VDD_28_29 | \
-				 MMC_VDD_29_30)
-
-static int
-bravoc_sdslot_register_cb(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (sdslot_status_cb)
-		return -EAGAIN;
-
-	sdslot_status_cb = callback;
-	sdslot_status_cb_devid = dev_id;
-	return 0;
-}
-
-static struct mmc_platform_data bravoc_sdslot_data = {
-	.ocr_mask		= BRAVOC_MMC_VDD,
-	.status			= bravoc_sdslot_status,
-	.translate_vdd		= bravoc_sdslot_switchvdd,
-	.register_status_notify = bravoc_sdslot_register_cb,
-};
-
-int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-		 unsigned int stat_irq, unsigned long stat_irq_flags);
-
-
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data bravoc_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-bravoc_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static int bravoc_wifi_cd;	/* WiFi virtual 'card detect' status */
-
-static unsigned int bravoc_wifi_status(struct device *dev)
-{
-	return bravoc_wifi_cd;
-}
-
-static struct mmc_platform_data bravoc_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= bravoc_wifi_status,
-	.register_status_notify	= bravoc_wifi_status_register,
-	.embedded_sdio		= &bravoc_wifi_emb_data,
-};
-
-int bravoc_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	bravoc_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(bravoc_wifi_set_carddetect);
-
-int bravoc_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-
-	mdelay(100);
-	gpio_set_value(127, on); /* WIFI_SHUTDOWN */
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(bravoc_wifi_power);
-
-int bravoc_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-int __init bravoc_init_mmc(unsigned int sys_rev)
-{
-	uint32_t id;
-	struct cnf_driver *microp_sdcard_detect;
-
-	wifi_status_cb = NULL;
-
-	printk(KERN_INFO "%s()+\n", __func__);
-
-	/* initial WIFI_SHUTDOWN# */
-	id = PCOM_GPIO_CFG(127, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	msm_add_sdcc(1, &bravoc_wifi_data, 0, 0);
-
-	if (opt_disable_sdcard) {
-		pr_info("%s: sdcard disabled on cmdline\n", __func__);
-		goto done;
-	}
-
-	sdslot_vreg_enabled = 0;
-
-	microp_sdcard_detect = kzalloc(sizeof(struct cnf_driver), GFP_KERNEL);
-	if (microp_sdcard_detect) {
-		microp_sdcard_detect->name = "sdcard_detect";
-		microp_sdcard_detect->func = &microp_check_status;
-	} else {
-		printk(KERN_ERR "%s: Alloc SD callback func error\n", __func__);
-		goto done;
-	}
-	cnf_driver_register(microp_sdcard_detect);
-
-	msm_add_sdcc(2, &bravoc_sdslot_data, 0, 0);
-
-done:
-	printk(KERN_INFO "%s()-\n", __func__);
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-bravoc-rfkill.c b/arch/arm/mach-msm/board-bravoc-rfkill.c
deleted file mode 100644
index 0cfa89e..0000000
--- a/arch/arm/mach-msm/board-bravoc-rfkill.c
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for bravoc platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-bravoc.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-/* bt initial configuration */
-static uint32_t bravoc_bt_init_table[] = {
-
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt on configuration */
-static uint32_t bravoc_bt_on_table[] = {
-
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_RX, /* BT_RX */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt off configuration */
-static uint32_t bravoc_bt_off_table[] = {
-
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_UART1_TX, /* BT_TX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BRAVOC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void bravoc_config_bt_init(void)
-{
-	/* set bt initial configuration*/
-	config_bt_table(bravoc_bt_init_table,
-				ARRAY_SIZE(bravoc_bt_init_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(BRAVOC_GPIO_BT_RESET_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BRAVOC_GPIO_BT_SHUTDOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(BRAVOC_GPIO_BT_CHIP_WAKE,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-
-}
-
-static void bravoc_config_bt_on(void)
-{
-	/* set bt on configuration*/
-	config_bt_table(bravoc_bt_on_table,
-			ARRAY_SIZE(bravoc_bt_on_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(BRAVOC_GPIO_BT_RESET_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BRAVOC_GPIO_BT_SHUTDOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-}
-
-static void bravoc_config_bt_off(void)
-{
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BRAVOC_GPIO_BT_SHUTDOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_RESET_N */
-	gpio_configure(BRAVOC_GPIO_BT_RESET_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(bravoc_bt_off_table,
-			ARRAY_SIZE(bravoc_bt_off_table));
-	mdelay(5);
-
-	/* BT_RTS */
-	gpio_configure(BRAVOC_GPIO_BT_UART1_RTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CTS */
-	gpio_configure(BRAVOC_GPIO_BT_UART1_CTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_TX */
-	gpio_configure(BRAVOC_GPIO_BT_UART1_TX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_RX */
-	gpio_configure(BRAVOC_GPIO_BT_UART1_RX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-
-	/* BT_HOST_WAKE */
-	gpio_configure(BRAVOC_GPIO_BT_HOST_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CHIP_WAKE */
-	gpio_configure(BRAVOC_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		bravoc_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		bravoc_config_bt_off();
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int bravoc_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	bravoc_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int bravoc_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver bravoc_rfkill_driver = {
-	.probe = bravoc_rfkill_probe,
-	.remove = bravoc_rfkill_remove,
-	.driver = {
-		.name = "bravoc_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init bravoc_rfkill_init(void)
-{
-	if (!machine_is_bravoc())
-		return 0;
-
-	return platform_driver_register(&bravoc_rfkill_driver);
-}
-
-static void __exit bravoc_rfkill_exit(void)
-{
-	platform_driver_unregister(&bravoc_rfkill_driver);
-}
-
-module_init(bravoc_rfkill_init);
-module_exit(bravoc_rfkill_exit);
-MODULE_DESCRIPTION("bravoc rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-bravoc-wifi.c b/arch/arm/mach-msm/board-bravoc-wifi.c
deleted file mode 100644
index 86b65cf..0000000
--- a/arch/arm/mach-msm/board-bravoc-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-bravoc-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-bravoc.h"
-
-int bravoc_wifi_power(int on);
-int bravoc_wifi_reset(int on);
-int bravoc_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *bravoc_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init bravoc_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource bravoc_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(BRAVOC_GPIO_WIFI_IRQ),
-		.end		= MSM_GPIO_TO_INT(BRAVOC_GPIO_WIFI_IRQ),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data bravoc_wifi_control = {
-	.set_power      = bravoc_wifi_power,
-	.set_reset      = bravoc_wifi_reset,
-	.set_carddetect = bravoc_wifi_set_carddetect,
-	.mem_prealloc   = bravoc_wifi_mem_prealloc,
-};
-
-static struct platform_device bravoc_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(bravoc_wifi_resources),
-        .resource       = bravoc_wifi_resources,
-        .dev            = {
-                .platform_data = &bravoc_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned bravoc_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init bravoc_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_bravoc())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	bravoc_wifi_update_nvs("sd_oobonly=1\n");
-	bravoc_init_wifi_mem();
-	ret = platform_device_register(&bravoc_wifi_device);
-        return ret;
-}
-
-device_initcall(bravoc_wifi_init);
diff --git a/arch/arm/mach-msm/board-bravoc.c b/arch/arm/mach-msm/board-bravoc.c
deleted file mode 100644
index f098c9b..0000000
--- a/arch/arm/mach-msm/board-bravoc.c
+++ /dev/null
@@ -1,1196 +0,0 @@
-/* linux/arch/arm/mach-msm/board-bravoc.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/android_pmem.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/input.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <mach/tpa2018d1.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/regulator/machine.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/setup.h>
-#include <../../../drivers/staging/android/timed_gpio.h>
-
-#include <mach/board.h>
-#include <mach/board_htc.h>
-#include <mach/hardware.h>
-#include <mach/atmega_microp.h>
-#include <mach/camera.h>
-#include <mach/msm_iomap.h>
-#include <mach/htc_battery.h>
-#include <mach/perflock.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/system.h>
-#include <linux/spi/spi.h>
-#include <linux/curcial_oj.h>
-#include <mach/vreg.h>
-#include <mach/msm_panel.h>
-#include "board-bravoc.h"
-#include "devices.h"
-#include "proc_comm.h"
-#include "smd_private.h"
-#include <mach/msm_serial_hs.h>
-#include <mach/msm_flashlight.h>
-#include <linux/mfd/tps65023.h>
-#define SMEM_SPINLOCK_I2C      6
-
-#ifdef CONFIG_ARCH_QSD8X50
-extern unsigned char *get_bt_bd_ram(void);
-#endif
-
-void msm_init_pmic_vibrator(void);
-extern void __init bravoc_audio_init(void);
-#ifdef CONFIG_MICROP_COMMON
-void __init bravoc_microp_init(void);
-#endif
-
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-
-static unsigned int bravoc_engineerid;
-
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-/*	.gpio_mbat_in = BRAVOC_GPIO_MBAT_IN,*/
-/*	.gpio_mchg_en_n = BRAVOC_GPIO_MCHG_EN_N,*/
-/*	.gpio_iset = BRAVOC_GPIO_ISET,*/
-	.guage_driver = GUAGE_DS2784,
-	.charger = SWITCH_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0, 0x21, 0x4D, 0xDC, 0x134, 0x18D, 0x1E5, 0x3FF, 0x3FF, 0x3FF },
-		.channel = 6,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xC0,
-		/*.ls_gpio_on = BRAVOC_GPIO_LS_EN,*/
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 50, 110, 160, 220},
-		.channel = 7,
-		.int_pin = 1 << 7,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "headset-in",
-		.category = MICROP_FUNCTION_HPIN,
-		.int_pin = 1 << 2,
-		.mask_r = {0x00, 0x00, 0x04},
-	},
-	{
-		.name   = "sdcard-detect",
-		.category = MICROP_FUNCTION_SDCARD,
-		.int_pin = 1 << 0,
-		.mask_r = {0x00, 0x01, 0x00},
-	},
-	{
-		.name   = "oj",
-		.category = MICROP_FUNCTION_OJ,
-		.int_pin = 1 << 12,
-	},
-};
-
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-};
-
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "blue",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "button-backlight",
-		.type = LED_PWM,
-		.mask_w = {0x02, 0x00, 0x00},
-		.led_pin = 1 << 2,
-		.init_value = 0xFF,
-		.fade_time = 1,
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct bma150_platform_data bravoc_g_sensor_pdata = {
-	.microp_new_cmd = 1,
-	.chip_layout = 1,
-};
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev = {
-			.platform_data = &lightsensor_data,
-		},
-	},
-	{
-		.name = "leds-microp",
-		.id = -1,
-		.dev = {
-			.platform_data = &microp_leds_data,
-		},
-	},
-	{
-		.name = BMA150_G_SENSOR_NAME,
-		.dev = {
-			.platform_data = &bravoc_g_sensor_pdata,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = BRAVOC_GPIO_UP_RESET_N,
-	.spi_devices = SPI_OJ | SPI_GSENSOR,
-};
-
-static int bravoc_phy_init_seq[] = { 0x1D, 0x0D, 0x1D, 0x10, -1 };
-
-static struct platform_device bravoc_rfkill = {
-	.name = "bravoc_rfkill",
-	.id = -1,
-};
-
-static int __capella_cm3602_power(int on)
-{
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on)
-		gpio_direction_output(BRAVOC_GPIO_LS_EN, 0);
-		/*gpio_set_value(BRAVOC_GPIO_LS_EN, 0);*/
-	else
-		gpio_direction_output(BRAVOC_GPIO_LS_EN, 1);
-		/*gpio_set_value(BRAVOC_GPIO_LS_EN, 1);*/
-	return 0;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	/* TODO eolsen Add Voltage reg control */
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable) {
-		if (pwr_device == PS_PWR_ON)
-			gpio_direction_output(BRAVOC_GPIO_PROXIMITY_EN, 0);
-			/*gpio_set_value(BRAVOC_GPIO_PROXIMITY_EN, 0);*/
-			als_power_control |= pwr_device;
-		} else {
-		if (pwr_device == PS_PWR_ON)
-			gpio_direction_output(BRAVOC_GPIO_PROXIMITY_EN, 1);
-			/*gpio_set_value(BRAVOC_GPIO_PROXIMITY_EN, 1);*/
-			als_power_control &= ~pwr_device;
-	}
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-		ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-}
-
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.p_out = BRAVOC_GPIO_PROXIMITY_INT,
-	.p_en = BRAVOC_GPIO_PROXIMITY_EN,
-	.power = capella_cm3602_power,
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-
-static struct resource qsd_spi_resources[] = {
-	{
-		.name   = "spi_irq_in",
-		.start  = INT_SPI_INPUT,
-		.end    = INT_SPI_INPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_out",
-		.start  = INT_SPI_OUTPUT,
-		.end    = INT_SPI_OUTPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_err",
-		.start  = INT_SPI_ERROR,
-		.end    = INT_SPI_ERROR,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_base",
-		.start  = 0xA1200000,
-		.end    = 0xA1200000 + SZ_4K - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.name   = "spi_clk",
-		.start  = 17,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_mosi",
-		.start  = 18,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_miso",
-		.start  = 19,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_cs0",
-		.start  = 20,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_pwr",
-		.start  = 21,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_cs0",
-		.start  = 22,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device qsd_device_spi = {
-	.name           = "spi_qsd",
-	.id             = 0,
-	.num_resources  = ARRAY_SIZE(qsd_spi_resources),
-	.resource       = qsd_spi_resources,
-};
-
-static struct resource msm_kgsl_resources[] = {
-	{
-		.name	= "kgsl_reg_memory",
-		.start	= MSM_GPU_REG_PHYS,
-		.end	= MSM_GPU_REG_PHYS + MSM_GPU_REG_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "kgsl_phys_memory",
-		.start	= MSM_GPU_MEM_BASE,
-		.end	= MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_GRAPHICS,
-		.end	= INT_GRAPHICS,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-#define PWR_RAIL_GRP_CLK		8
-static int bravoc_kgsl_power_rail_mode(int follow_clk)
-{
-	int mode = follow_clk ? 0 : 1;
-	int rail_id = PWR_RAIL_GRP_CLK;
-
-	return msm_proc_comm(PCOM_CLKCTL_RPC_RAIL_CONTROL, &rail_id, &mode);
-}
-
-static int bravoc_kgsl_power(bool on)
-{
-	int cmd;
-	int rail_id = PWR_RAIL_GRP_CLK;
-
-	cmd = on ? PCOM_CLKCTL_RPC_RAIL_ENABLE : PCOM_CLKCTL_RPC_RAIL_DISABLE;
-	return msm_proc_comm(cmd, &rail_id, NULL);
-}
-
-static struct platform_device msm_kgsl_device = {
-	.name		= "kgsl",
-	.id		= -1,
-	.resource	= msm_kgsl_resources,
-	.num_resources	= ARRAY_SIZE(msm_kgsl_resources),
-};
-
-static struct android_pmem_platform_data mdp_pmem_pdata = {
-	.name		= "pmem",
-	.start		= MSM_PMEM_MDP_BASE,
-	.size		= MSM_PMEM_MDP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-static struct android_pmem_platform_data android_pmem_adsp_pdata = {
-	.name		= "pmem_adsp",
-	.start		= MSM_PMEM_ADSP_BASE,
-	.size		= MSM_PMEM_ADSP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-
-static struct android_pmem_platform_data android_pmem_camera_pdata = {
-	.name		= "pmem_camera",
-	.start		= MSM_PMEM_CAMERA_BASE,
-	.size		= MSM_PMEM_CAMERA_SIZE,
-	.no_allocator	= 1,
-	.cached		= 1,
-};
-
-static struct platform_device android_pmem_mdp_device = {
-	.name		= "android_pmem",
-	.id		= 0,
-	.dev		= {
-		.platform_data = &mdp_pmem_pdata
-	},
-};
-
-static struct platform_device android_pmem_adsp_device = {
-	.name		= "android_pmem",
-	.id		= 4,
-	.dev		= {
-		.platform_data = &android_pmem_adsp_pdata,
-	},
-};
-
-static struct platform_device android_pmem_camera_device = {
-	.name		= "android_pmem",
-	.id		= 5,
-	.dev		= {
-		.platform_data = &android_pmem_camera_pdata,
-	},
-};
-
-static struct resource ram_console_resources[] = {
-	{
-		.start	= MSM_RAM_CONSOLE_BASE,
-		.end	= MSM_RAM_CONSOLE_BASE + MSM_RAM_CONSOLE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device ram_console_device = {
-	.name		= "ram_console",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(ram_console_resources),
-	.resource	= ram_console_resources,
-};
-
-static int bravoc_ts_power(int on)
-{
-	pr_info("%s: power %d\n", __func__, on);
-
-	if (on) {
-		/* level shifter should be off */
-		gpio_set_value(BRAVOC_GPIO_TP_EN, 1);
-		msleep(120);
-		/* enable touch panel level shift */
-		gpio_set_value(BRAVOC_GPIO_TP_LS_EN, 1);
-		msleep(3);
-	} else {
-		gpio_set_value(BRAVOC_GPIO_TP_LS_EN, 0);
-		gpio_set_value(BRAVOC_GPIO_TP_EN, 0);
-		udelay(50);
-	}
-
-	return 0;
-}
-
-static struct synaptics_i2c_rmi_platform_data bravoc_ts_data[] = {
-	{
-		.version = 0x0100,
-		.power = bravoc_ts_power,
-		.sensitivity_adjust = 12,
-		.flags = SYNAPTICS_FLIP_Y  | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = -1 * 0x10000 / 480,
-		.inactive_right = -1 * 0x10000 / 480,
-		.inactive_top = -5 * 0x10000 / 800,
-		.inactive_bottom = -5 * 0x10000 / 800,
-		.display_width = 480,
-		.display_height = 800,
-		.dup_threshold = 10,
-		.margin_inactive_pixel = {8, 32, 32, 8},
-	},
-};
-
-static struct regulator_consumer_supply tps65023_dcdc1_supplies[] = {
-	{
-		.supply = "acpu_vcore",
-	},
-};
-
-static struct regulator_init_data tps65023_data[5] = {
-	{
-		.constraints = {
-			.name = "dcdc1", /* VREG_MSMC2_1V29 */
-			.min_uV = 1000000,
-			.max_uV = 1300000,
-			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
-		},
-		.consumer_supplies = tps65023_dcdc1_supplies,
-		.num_consumer_supplies = ARRAY_SIZE(tps65023_dcdc1_supplies),
-	},
-	/* dummy values for unused regulators to not crash driver: */
-	{
-		.constraints = {
-			.name = "dcdc2", /* VREG_MSMC1_1V26 */
-			.min_uV = 1260000,
-			.max_uV = 1260000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "dcdc3", /* unused */
-			.min_uV = 800000,
-			.max_uV = 3300000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo1", /* unused */
-			.min_uV = 1000000,
-			.max_uV = 3150000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo2", /* V_USBPHY_3V3 */
-			.min_uV = 3300000,
-			.max_uV = 3300000,
-		},
-	},
-};
-
-static struct h2w_platform_data bravoc_h2w_data = {
-
-};
-
-static struct platform_device bravoc_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &bravoc_h2w_data,
-	},
-};
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = BRAVOC_LAYOUTS,
-	.project_name = BRAVOC_PROJECT_NAME,
-	.reset = BRAVOC_GPIO_COMPASS_RST_N,
-	.intr = BRAVOC_GPIO_COMPASS_INT_N,
-};
-
-static struct tpa2018d1_platform_data tpa2018_data = {
-	.gpio_tpa2018_spk_en = BRAVOC_AUD_SPK_EN,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x40),
-		.platform_data = &bravoc_ts_data,
-		.irq = MSM_GPIO_TO_INT(BRAVOC_GPIO_TP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = MSM_GPIO_TO_INT(BRAVOC_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO("smb329", 0x6E >> 1),
-	},
-	{
-		I2C_BOARD_INFO("ds2482", 0x30 >> 1),
-		/*.platform_data = &microp_data,*/
-		/*.irq = MSM_GPIO_TO_INT(PASSION_GPIO_UP_INT_N)*/
-	},
-	{
-		I2C_BOARD_INFO("tpa2018d1", 0x58),
-		.platform_data = &tpa2018_data,
-	},
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = MSM_GPIO_TO_INT(BRAVOC_GPIO_COMPASS_INT_N),
-	},
-#ifdef CONFIG_MSM_CAMERA
-#ifdef CONFIG_S5K3E2FX
-	{
-		I2C_BOARD_INFO("s5k3e2fx", 0x20 >> 1),
-	},
-#endif
-#endif/*CONIFIG_MSM_CAMERA*/
-	{
-		I2C_BOARD_INFO("tps65023", 0x48),
-		.platform_data = tps65023_data,
-	},
-};
-
-#ifdef CONFIG_ARCH_QSD8X50
-static char bdaddress[20];
-
-static void bt_export_bd_address(void)
-{
-	unsigned char cTemp[6];
-
-	memcpy(cTemp, get_bt_bd_ram(), 6);
-	sprintf(bdaddress, "%02x:%02x:%02x:%02x:%02x:%02x",
-		cTemp[0], cTemp[1], cTemp[2], cTemp[3], cTemp[4], cTemp[5]);
-	printk(KERN_INFO "YoYo--BD_ADDRESS=%s\n", bdaddress);
-}
-
-module_param_string(bdaddress, bdaddress, sizeof(bdaddress), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bdaddress, "BT MAC ADDRESS");
-#endif
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* VSYNC */
-/*	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_16MA),*/ /* MCLK */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* MCLK */
-	/*steven yeh: modify MCLK driving strength to avoid overshot issue*/
-};
-
-static void config_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-static void config_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		 INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_camera_on_gpios,
-	.camera_gpio_off = config_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
-	.camera_flash		= flashlight_control,
-	.num_flash_levels	= FLASHLIGHT_NUM,
-	.low_temp_limit		= 5,
-	.low_cap_limit		= 15,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_s5k3e2fx_data = {
-	.sensor_name = "s5k3e2fx",
-	.sensor_reset = 144, /* CAM1_RST */
-	.sensor_pwd = 143,  /* CAM1_PWDN, enabled in a9 */
-	.pdata = &msm_camera_device_data,
-	.resource = msm_camera_resources,
-	.num_resources = ARRAY_SIZE(msm_camera_resources),
-	.flash_cfg = &msm_camera_sensor_flash_cfg,
-};
-
-static struct platform_device msm_camera_sensor_s5k3e2fx = {
-	.name		= "msm_camera_s5k3e2fx",
-	.dev		= {
-	.platform_data = &msm_camera_sensor_s5k3e2fx_data,
-	},
-};
-
-static void config_bravoc_flashlight_gpios(void)
-{
-	static uint32_t flashlight_gpio_table[] = {
-		PCOM_GPIO_CFG(BRAVOC_GPIO_FLASHLIGHT_TORCH, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-		PCOM_GPIO_CFG(BRAVOC_GPIO_FLASHLIGHT_FLASH, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-	};
-	config_gpio_table(flashlight_gpio_table,
-		ARRAY_SIZE(flashlight_gpio_table));
-}
-
-static struct flashlight_platform_data bravoc_flashlight_data = {
-	.gpio_init  = config_bravoc_flashlight_gpios,
-	.torch = BRAVOC_GPIO_FLASHLIGHT_TORCH,
-	.flash = BRAVOC_GPIO_FLASHLIGHT_FLASH,
-	.flash_duration_ms = 600,
-};
-
-static struct platform_device bravoc_flashlight_device = {
-	.name = FLASHLIGHT_NAME,
-	.dev		= {
-		.platform_data	= &bravoc_flashlight_data,
-	},
-};
-
-static struct timed_gpio timed_gpios[] = {
-	{
-		.name = "vibrator",
-		.gpio = BRAVOC_VIB_3V3_EN,
-		.max_timeout = 15000,
-	},
-};
-
-static struct timed_gpio_platform_data timed_gpio_data = {
-	.num_gpios	= ARRAY_SIZE(timed_gpios),
-	.gpios		= timed_gpios,
-};
-
-static struct platform_device android_timed_gpios = {
-	.name		= "timed-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data = &timed_gpio_data,
-	},
-};
-
-#define CURCIAL_OJ_POWER            150
-static void curcial_oj_shutdown (int	enable)
-{
-	uint8_t cmd[3];
-	memset(cmd, 0x00, sizeof(uint8_t)*3);
-	/* microp firmware(v04) non-shutdown by default */
-	cmd[2] = 0x20;
-	microp_i2c_write(0x90, cmd,	3);
-
-}
-
-static int curcial_oj_poweron(int	on)
-{
-	uint8_t data[2];
-		/* for microp firmware(v04) setting*/
-	if (on == 0) {
-		microp_i2c_read(MICROP_I2C_RCMD_VERSION, data, 2);
-		if (data[0] < 4) {
-			printk("Microp firmware version:%d\n",data[0]);
-			return 1;
-		}
-	}
-
-	gpio_set_value(CURCIAL_OJ_POWER, on);
-
-	if (gpio_get_value(CURCIAL_OJ_POWER) != on) {
-		printk(KERN_ERR "%s:OJ:power status fail \n", __func__);
-		return 0;
-	}
-		printk(KERN_ERR "%s:OJ:power status ok \n", __func__);
-	return 1;
-}
-static void curcial_oj_adjust_xy(uint8_t *data, int16_t *mSumDeltaX, int16_t *mSumDeltaY)
-{
-	int8_t 	deltaX;
-	int8_t 	deltaY;
-
-
-	if (data[2] == 0x80)
-		data[2] = 0x81;
-	if (data[1] == 0x80)
-		data[1] = 0x81;
-	if (1) {
-		deltaX = (1)*((int8_t) data[2]); /*X=2*/
-		deltaY = (-1)*((int8_t) data[1]); /*Y=1*/
-	} else {
-		deltaX = (-1)*((int8_t) data[1]);
-		deltaY = (1)*((int8_t) data[2]);
-	}
-	*mSumDeltaX += -((int16_t)deltaX);
-	*mSumDeltaY += -((int16_t)deltaY);
-}
-#define BRAVOC_MICROP_VER	0x03
-
-static struct curcial_oj_platform_data bravoc_oj_data = {
-	.oj_poweron = curcial_oj_poweron,
-	.oj_shutdown = curcial_oj_shutdown,
-	.oj_adjust_xy = curcial_oj_adjust_xy,
-	.microp_version = BRAVOC_MICROP_VER,
-	.mdelay_time = 0,
-	.msleep_time = 1,
-	.x_send_count = 3,
-	.y_send_count = 3,
-	.fast_th = 0,
-	.normal_th = 15,
-	.continue_th = 3,
-	.continue_max = 0,
-	.xy_ratio = 15,
-	.interval = 80,
-	.softclick = 0,
-	.swap = true,
-	.x = 1,
-	.y = 1,
-	.share_power = false,
-	.Xsteps = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-	.Ysteps = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-};
-
-static struct platform_device bravoc_oj = {
-	.name = CURCIAL_OJ_NAME,
-	.id = -1,
-	.dev = {
-		.platform_data	= &bravoc_oj_data,
-	}
-};
-
-static int amoled_power(int on)
-{
-	if (on) {
-		gpio_set_value(BRAVOC_LCD_RSTz, 1);
-		mdelay(25);
-		gpio_set_value(BRAVOC_LCD_RSTz, 0);
-		mdelay(10);
-		gpio_set_value(BRAVOC_LCD_RSTz, 1);
-		mdelay(20);
-	} else {
-		gpio_set_value(BRAVOC_LCD_RSTz, 0);
-	}
-	return 0;
-}
-
-#define LCM_GPIO_CFG(gpio, func) \
-PCOM_GPIO_CFG(gpio, func, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA)
-static uint32_t display_on_gpio_table[] = {
-	LCM_GPIO_CFG(BRAVOC_LCD_R0, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_B0, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_R1, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_R2, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_R3, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_R4, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_R5, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_G0, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_G1, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_G2, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_G3, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_G4, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_G5, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_B1, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_B2, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_B3, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_B4, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_B5, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_PCLK, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_VSYNC, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_HSYNC, 1),
-	LCM_GPIO_CFG(BRAVOC_LCD_DE, 1),
-};
-
-static uint32_t display_off_gpio_table[] = {
-	LCM_GPIO_CFG(BRAVOC_LCD_R0, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_B0, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_R1, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_R2, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_R3, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_R4, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_R5, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_G0, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_G1, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_G2, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_G3, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_G4, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_G5, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_B1, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_B2, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_B3, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_B4, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_B5, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_PCLK, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_VSYNC, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_HSYNC, 0),
-	LCM_GPIO_CFG(BRAVOC_LCD_DE, 0),
-};
-
-static int panel_gpio_switch(int on)
-{
-	if (on) {
-		u32 *table = display_on_gpio_table;
-		int len = ARRAY_SIZE(display_on_gpio_table);
-
-		if (system_rev < 1) {
-			table = &display_on_gpio_table[2];
-			len -= 2;
-		}
-		config_gpio_table(table, len);
-	} else {
-		u32 *table = display_off_gpio_table;
-		int len = ARRAY_SIZE(display_off_gpio_table);
-		int i;
-
-		if (system_rev < 1) {
-			table = &display_off_gpio_table[2];
-			len -= 2;
-		}
-		config_gpio_table(table, len);
-
-		for (i = BRAVOC_LCD_R0; i <= BRAVOC_LCD_R5; i++) {
-			/* skip R0 for XA */
-			if (system_rev < 1)
-				continue;
-			gpio_set_value(i, 0);
-		}
-		for (i = BRAVOC_LCD_G0; i <= BRAVOC_LCD_G5; i++)
-			gpio_set_value(i, 0);
-		for (i = BRAVOC_LCD_B0; i <= BRAVOC_LCD_DE; i++) {
-			/* skip B0 for XA */
-			if (system_rev < 1)
-				continue;
-			gpio_set_value(i, 0);
-		}
-	}
-	return 0;
-}
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct panel_platform_data amoled_data = {
-	.fb_res = &resources_msm_fb[0],
-	.power = amoled_power,
-	.gpio_switch = panel_gpio_switch,
-};
-
-static struct platform_device amoled_panel = {
-	.name = "amoled-panel",
-	.id = -1,
-	.dev = {
-		.platform_data = &amoled_data,
-	},
-};
-
-static struct platform_device *devices[] __initdata = {
-	&amoled_panel,
-	&msm_device_uart1,
-#ifdef CONFIG_SERIAL_MSM_HS
-	&msm_device_uart_dm1,
-#endif
-	&bravoc_h2w,
-	&htc_battery_pdev,
-	&ram_console_device,
-	&bravoc_rfkill,
-	&msm_device_smd,
-	&msm_device_nand,
-	&android_pmem_mdp_device,
-	&android_pmem_adsp_device,
-	&android_pmem_camera_device,
-#ifdef CONFIG_MSM_CAMERA
-#ifdef CONFIG_S5K3E2FX
-	&msm_camera_sensor_s5k3e2fx,
-#endif
-#endif
-	&msm_kgsl_device,
-	&msm_device_i2c,
-	&bravoc_flashlight_device,
-
-#if defined(CONFIG_SPI_QSD)
-	&qsd_device_spi,
-#endif
-	&bravoc_oj,
-#ifdef CONFIG_INPUT_CAPELLA_CM3602
-	&capella_cm3602,
-#endif
-};
-
-
-static uint32_t bravoc_serial_debug_table[] = {
-	/* for uart debugger.
-	 * It should be removed when support usb to serial function.
-	 * */
-	PCOM_GPIO_CFG(BRAVOC_GPIO_UART3_RX, 3, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_4MA), /* RX */
-	PCOM_GPIO_CFG(BRAVOC_GPIO_UART3_TX, 3, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_4MA), /* TX */
-};
-
-static void bravoc_config_serial_debug_gpios(void)
-{
-	config_gpio_table(bravoc_serial_debug_table,
-				ARRAY_SIZE(bravoc_serial_debug_table));
-}
-
-static struct msm_i2c_device_platform_data msm_i2c_pdata = {
-	.i2c_clock = 100000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_8MA,
-};
-
-static void __init msm_device_i2c_init(void)
-{
-	msm_device_i2c.dev.platform_data = &msm_i2c_pdata;
-}
-
-static struct msm_acpu_clock_platform_data bravoc_clock_data = {
-	.acpu_switch_time_us	= 20,
-	.max_speed_delta_khz	= 256000,
-	.vdd_switch_time_us	= 62,
-	.power_collapse_khz	= 245000,
-	.wait_for_irq_khz	= 245000,
-};
-
-static unsigned bravoc_perf_acpu_table[] = {
-	245000000,
-	576000000,
-	998400000,
-};
-
-static struct perflock_platform_data bravoc_perflock_data = {
-	.perf_acpu_table = bravoc_perf_acpu_table,
-	.table_size = ARRAY_SIZE(bravoc_perf_acpu_table),
-};
-
-int bravoc_init_mmc(int sysrev);
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	/* Chip to Device */
-	.wakeup_irq = MSM_GPIO_TO_INT(BRAVOC_GPIO_BT_HOST_WAKE),
-	.inject_rx_on_wakeup = 0,
-	.cpu_lock_supported = 0,
-
-	/* for bcm */
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = BRAVOC_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = BRAVOC_GPIO_BT_HOST_WAKE,
-};
-#endif
-
-
-unsigned int bravoc_get_engineerid(void)
-{
-	return bravoc_engineerid;
-}
-
-static void bravoc_reset(void)
-{
-	gpio_set_value(BRAVOC_GPIO_PS_HOLD, 0);
-}
-
-static void __init bravoc_init(void)
-{
-	int ret;
-	struct kobject *properties_kobj;
-
-	printk("bravoc_init() revision=%d, engineerid=%d\n", system_rev, bravoc_engineerid);
-	printk(KERN_INFO "%s: microp version = %s\n", __func__, microp_ver);
-
-	msm_hw_reset_hook = bravoc_reset;
-
-	msm_acpu_clock_init(&bravoc_clock_data);
-	perflock_init(&bravoc_perflock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	msm_serial_debug_init(MSM_UART1_PHYS, INT_UART1,
-			      &msm_device_uart1.dev, 1, MSM_GPIO_TO_INT(139));
-#endif
-
-#ifdef CONFIG_ARCH_QSD8X50
-	bt_export_bd_address();
-#endif
-
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-#endif
-
-	bravoc_config_serial_debug_gpios();
-
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-	gpio_direction_output(BRAVOC_GPIO_TP_LS_EN, 0);
-	gpio_direction_output(BRAVOC_GPIO_TP_EN, 0);
-
-	bravoc_audio_init();
-	msm_device_i2c_init();
-#ifdef CONFIG_MICROP_COMMON
-	bravoc_microp_init();
-#endif
-
-	/* set the gpu power rail to manual mode so clk en/dis will not
-	 * turn off gpu power, and hang it on resume */
-	bravoc_kgsl_power_rail_mode(0);
-	bravoc_kgsl_power(true);
-	msm_register_usb_phy_init_seq(bravoc_phy_init_seq);
-	msm_register_uart_usb_switch(NULL);
-	msm_add_usb_id_pin_gpio(BRAVOC_GPIO_USB_ID_PIN);
-	msm_add_usb_devices(NULL, NULL);
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	for (ret = 0; ret < ARRAY_SIZE(i2c_devices); ret++) {
-		if (!strcmp(i2c_devices[ret].type, AKM8973_I2C_NAME))
-			i2c_devices[ret].irq = MSM_GPIO_TO_INT(BRAVOC_GPIO_COMPASS_INT_N);
-	}
-	compass_platform_data.intr = BRAVOC_GPIO_COMPASS_INT_N;
-
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	ret = bravoc_init_mmc(system_rev);
-	if (ret != 0)
-		pr_crit("%s: Unable to initialize MMC\n", __func__);
-
-	ret = platform_device_register(&android_timed_gpios);
-	if (ret != 0)
-		pr_err("failed to register vibrator\n");
-
-}
-
-static void __init bravoc_fixup(struct machine_desc *desc, struct tag *tags,
-				 char **cmdline, struct meminfo *mi)
-{
-	bravoc_engineerid = parse_tag_engineerid(tags);
-	mi->nr_banks = 2;
-	mi->bank[0].start = MSM_EBI1_BANK0_BASE;
-	mi->bank[0].node = PHYS_TO_NID(MSM_EBI1_BANK0_BASE);
-	mi->bank[0].size = MSM_EBI1_BANK0_SIZE;
-	mi->bank[1].start = MSM_EBI1_BANK1_BASE;
-	mi->bank[1].node = PHYS_TO_NID(MSM_EBI1_BANK1_BASE);
-	mi->bank[1].size = MSM_EBI1_BANK1_SIZE;
-}
-
-static void __init bravoc_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-extern struct sys_timer msm_timer;
-
-MACHINE_START(BRAVOC, "bravoc")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params	= 0x20000100,
-	.fixup		= bravoc_fixup,
-	.map_io		= bravoc_map_io,
-	.init_irq	= msm_init_irq,
-	.init_machine	= bravoc_init,
-	.timer		= &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-bravoc.h b/arch/arm/mach-msm/board-bravoc.h
deleted file mode 100644
index 6516465..0000000
--- a/arch/arm/mach-msm/board-bravoc.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/* arch/arm/mach-msm/board-bravoc.h
- *
- * Copyright (C) 2009 HTC Corporation.
- * Author: Haley Teng <Haley_Teng@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_BRAVOC_H
-#define __ARCH_ARM_MACH_MSM_BOARD_BRAVOC_H
-
-#include <mach/board.h>
-
-#define MSM_SMI_BASE		0x02B00000
-#define MSM_SMI_SIZE		0x01500000
-
-#define MSM_PMEM_CAMERA_BASE	0x02B00000
-#define MSM_PMEM_CAMERA_SIZE	0x00800000
-
-#define MSM_GPU_MEM_BASE	0x03300000
-#define MSM_GPU_MEM_SIZE	0x00300000
-
-#define MSM_RAM_CONSOLE_BASE	0x03A00000
-#define MSM_RAM_CONSOLE_SIZE	0x00040000
-
-#define MSM_FB_BASE		0x03B00000
-#define MSM_FB_SIZE		0x00465000
-
-#define MSM_EBI1_BANK0_BASE	0x20000000
-#define MSM_EBI1_BANK0_SIZE	0x0E800000
-
-#define MSM_EBI1_BANK1_BASE 	0x30000000
-#define MSM_EBI1_BANK1_SIZE	0x0B700000
-
-#define MSM_PMEM_MDP_BASE	0x3B700000
-#define MSM_PMEM_MDP_SIZE	0x02000000
-
-#define MSM_PMEM_ADSP_BASE	0x3D700000
-#define MSM_PMEM_ADSP_SIZE	0x02900000
-
-#define	BRAVOC_GPIO_PS_HOLD		25
-
-#define BRAVOC_GPIO_UP_INT_N		35
-#define BRAVOC_GPIO_UP_RESET_N	82
-#define BRAVOC_GPIO_LS_EN		119
-
-#define BRAVOC_GPIO_TP_INT_N		92
-#define BRAVOC_GPIO_TP_LS_EN		93
-#define BRAVOC_GPIO_TP_EN		160
-
-#define BRAVOC_GPIO_POWER_KEY		94
-
-#define BRAVOC_GPIO_RESET_BTN		27
-#define BRAVOC_GPIO_WIFI_SHUTDOWN_N	127
-#define BRAVOC_GPIO_WIFI_IRQ		152
-
-#define BRAVOC_GPIO_JOGBALL_POWER	150
-
-#define BRAVOC_GPIO_KP_MPIN0		42
-#define BRAVOC_GPIO_KP_MPIN1		41
-#define BRAVOC_GPIO_KP_MPIN2		40
-#define BRAVOC_GPIO_KP_MKOUT0		33
-#define BRAVOC_GPIO_KP_MKOUT1		32
-#define BRAVOC_GPIO_KP_MKOUT2		31
-
-/* Bluetooth */
-#define BRAVOC_GPIO_BT_UART1_RTS	43
-#define BRAVOC_GPIO_BT_UART1_CTS	44
-#define BRAVOC_GPIO_BT_UART1_RX	45
-#define BRAVOC_GPIO_BT_UART1_TX	46
-#define BRAVOC_GPIO_BT_RESET_N	146
-#define BRAVOC_GPIO_BT_SHUTDOWN_N	128
-#define BRAVOC_GPIO_BT_HOST_WAKE	86
-#define BRAVOC_GPIO_BT_CHIP_WAKE	28
-
-#define BRAVOC_GPIO_UART3_RX 139
-#define BRAVOC_GPIO_UART3_TX 140
-
-#define BRAVOC_GPIO_COMPASS_RST_N	107
-#define BRAVOC_GPIO_COMPASS_INT_N	153
-#define BRAVOC_PROJECT_NAME		"bravoc"
-#define BRAVOC_LAYOUTS		{ \
-		{ {-1,  0, 0}, { 0, -1,  0}, {0, 0,  1} }, /*cspec_Hlayout*/ \
-		{ { 0, -1, 0}, { 1,  0,  0}, {0, 0, -1} }, /*cspec_Alayout*/ \
-		{ { 0, -1, 0}, { 1,  0,  0}, {0, 0,  1} }, /*m_Hlayout*/ \
-		{ {-1,  0, 0}, { 0,  0, -1}, {0, 1,  0} }  /*m_Alayout*/ \
-					}
-
-/* Proximity */
-#define BRAVOC_GPIO_PROXIMITY_INT	90
-#define BRAVOC_GPIO_PROXIMITY_EN	120
-
-/* Battery */
-#define BRAVOC_GPIO_MBAT_IN		39
-#define BRAVOC_GPIO_MCHG_EN_N		22
-
-#define BRAVOC_GPIO_DQ_PWRDN_N		87
-
-/*Audio */
-#define BRAVOC_AUD_JACKHP_EN		157
-#define BRAVOC_AUD_2V5_EN		158
-
-#define BRAVOC_AUD_SPK_EN		104
-
-
-/* Bluetooth PCM */
-#define BRAVOC_BT_PCM_OUT		68
-#define BRAVOC_BT_PCM_IN		69
-#define BRAVOC_BT_PCM_SYNC		70
-#define BRAVOC_BT_PCM_CLK		71
-
-#define BRAVOC_VIB_3V3_EN		89
-
-/* flash light */
-#define BRAVOC_GPIO_FLASHLIGHT_TORCH (26)
-#define BRAVOC_GPIO_FLASHLIGHT_FLASH (84)
-
-/* LCM */
-#define BRAVOC_LCD_RSTz			(29)
-#define BRAVOC_LCD_R0			(113) /* XB new added */
-#define BRAVOC_LCD_R1			(114)
-#define BRAVOC_LCD_R2			(115)
-#define BRAVOC_LCD_R3			(116)
-#define BRAVOC_LCD_R4			(117)
-#define BRAVOC_LCD_R5			(118)
-#define BRAVOC_LCD_G0			(121)
-#define BRAVOC_LCD_G1			(122)
-#define BRAVOC_LCD_G2			(123)
-#define BRAVOC_LCD_G3			(124)
-#define BRAVOC_LCD_G4			(125)
-#define BRAVOC_LCD_G5			(126)
-#define BRAVOC_LCD_B0			(129) /* XB new added*/
-#define BRAVOC_LCD_B1			(130)
-#define BRAVOC_LCD_B2			(131)
-#define BRAVOC_LCD_B3			(132)
-#define BRAVOC_LCD_B4			(133)
-#define BRAVOC_LCD_B5			(134)
-#define BRAVOC_LCD_PCLK			(135)
-#define BRAVOC_LCD_VSYNC		(136)
-#define BRAVOC_LCD_HSYNC		(137)
-#define BRAVOC_LCD_DE			(138)
-
-#define BRAVOC_GPIO_USB_ID_PIN          (36)
-
-unsigned int bravoc_get_engineerid(void);
-
-#endif /* __ARCH_ARM_MACH_MSM_BOARD_BRAVOC_H */
diff --git a/arch/arm/mach-msm/board-buzz-keypad.c b/arch/arm/mach-msm/board-buzz-keypad.c
deleted file mode 100644
index 0c9124d..0000000
--- a/arch/arm/mach-msm/board-buzz-keypad.c
+++ /dev/null
@@ -1,269 +0,0 @@
-/* arch/arm/mach-msm/board-buzz.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <linux/keyreset.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <mach/vreg.h>
-
-#include "board-buzz.h"
-
-static int opt_x_axis_threshold = 1, opt_y_axis_threshold = 1;
-
-struct buzz_axis_info {
-	struct gpio_event_axis_info info;
-	uint16_t in_state;
-	uint16_t out_state;
-	uint16_t temp_state;
-};
-
-static bool nav_just_on;
-static int nav_on_jiffies;
-
-static unsigned int buzz_col_gpios[] = {
-	BUZZ_GPIO_Q_KP_MKOUT0,
-	BUZZ_GPIO_Q_KP_MKOUT1,
-	BUZZ_GPIO_Q_KP_MKOUT2,
-};
-
-static unsigned int buzz_row_gpios[] = {
-	BUZZ_GPIO_Q_KP_MKIN0_1,
-	BUZZ_GPIO_Q_KP_MKIN1_1,
-	BUZZ_GPIO_Q_KP_MKIN2_1,
-};
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(buzz_row_gpios) + (row))
-
-static unsigned short buzz_keymap[ARRAY_SIZE(buzz_col_gpios) *
-					ARRAY_SIZE(buzz_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = MATRIX_KEY(1, BTN_MOUSE),
-	[KEYMAP_INDEX(0, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(0, 2)] = KEY_VOLUMEUP,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_SEARCH,
-	[KEYMAP_INDEX(1, 1)] = KEY_BACK,
-	[KEYMAP_INDEX(1, 2)] = KEY_VOLUMEDOWN,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_HOME,
-	[KEYMAP_INDEX(2, 1)] = KEY_MENU,
-	[KEYMAP_INDEX(2, 2)] = KEY_RESERVED,
-};
-
-static struct gpio_event_matrix_info buzz_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = buzz_keymap,
-	.output_gpios = buzz_col_gpios,
-	.input_gpios = buzz_row_gpios,
-	.noutputs = ARRAY_SIZE(buzz_col_gpios),
-	.ninputs = ARRAY_SIZE(buzz_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		GPIOKPF_REMOVE_PHANTOM_KEYS |
-		GPIOKPF_PRINT_UNMAPPED_KEYS /* |
-		GPIOKPF_PRINT_MAPPED_KEYS */),
-};
-
-static struct gpio_event_direct_entry buzz_keypad_nav_map[] = {
-	{ BUZZ_GPIO_POWER_KEY, KEY_POWER },
-};
-
-static struct gpio_event_input_info buzz_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = GPIOEDF_PRINT_KEYS,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = buzz_keypad_nav_map,
-	.keymap_size = ARRAY_SIZE(buzz_keypad_nav_map)
-};
-
-uint16_t buzz_x_axis_map(struct gpio_event_axis_info *info, uint16_t in)
-{
-	struct buzz_axis_info *ai =
-			container_of(info, struct buzz_axis_info, info);
-	uint16_t out = ai->out_state;
-
-	if (nav_just_on) {
-		if (jiffies == nav_on_jiffies || jiffies == nav_on_jiffies + 1)
-			goto ignore;
-		nav_just_on = 0;
-	}
-	if ((ai->in_state ^ in) & 1)
-		out--;
-	if ((ai->in_state ^ in) & 2)
-		out++;
-	ai->out_state = out;
-ignore:
-	ai->in_state = in;
-	if (ai->out_state - ai->temp_state == opt_x_axis_threshold) {
-		ai->temp_state++;
-		ai->out_state = ai->temp_state;
-	} else if (ai->temp_state - ai->out_state == opt_x_axis_threshold) {
-		ai->temp_state--;
-		ai->out_state = ai->temp_state;
-	} else if (abs(ai->out_state - ai->temp_state) > opt_x_axis_threshold)
-		ai->temp_state = ai->out_state;
-
-	return ai->temp_state;
-}
-
-uint16_t buzz_y_axis_map(struct gpio_event_axis_info *info, uint16_t in)
-{
-	struct buzz_axis_info *ai =
-			container_of(info, struct buzz_axis_info, info);
-	uint16_t out = ai->out_state;
-
-	if (nav_just_on) {
-		if (jiffies == nav_on_jiffies || jiffies == nav_on_jiffies + 1)
-			goto ignore;
-		nav_just_on = 0;
-	}
-	if ((ai->in_state ^ in) & 1)
-		out--;
-	if ((ai->in_state ^ in) & 2)
-		out++;
-	ai->out_state = out;
-ignore:
-	ai->in_state = in;
-	if (ai->out_state - ai->temp_state == opt_y_axis_threshold) {
-		ai->temp_state++;
-		ai->out_state = ai->temp_state;
-	} else if (ai->temp_state - ai->out_state == opt_y_axis_threshold) {
-		ai->temp_state--;
-		ai->out_state = ai->temp_state;
-	} else if (abs(ai->out_state - ai->temp_state) > opt_y_axis_threshold)
-		ai->temp_state = ai->out_state;
-
-	return ai->temp_state;
-}
-
-static struct vreg *jog_vreg;
-
-int buzz_nav_power(const struct gpio_event_platform_data *pdata, bool on)
-{
-	if (on) {
-		vreg_enable(jog_vreg);
-		nav_just_on = 1;
-		nav_on_jiffies = jiffies;
-	} else
-		vreg_disable(jog_vreg);
-
-	return 0;
-}
-
-static uint32_t buzz_x_axis_gpios[] = {
-	BUZZ_GPIO_BALL_LEFT, BUZZ_GPIO_BALL_RIGHT
-};
-
-static struct buzz_axis_info buzz_x_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(buzz_x_axis_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_X,
-		.decoded_size = 1U << ARRAY_SIZE(buzz_x_axis_gpios),
-		.map = buzz_x_axis_map,
-		.gpio = buzz_x_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION
-			/*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT */,
-	}
-};
-
-static uint32_t buzz_y_axis_gpios[] = {
-	BUZZ_GPIO_BALL_UP, BUZZ_GPIO_BALL_DOWN
-};
-
-static struct buzz_axis_info buzz_y_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(buzz_y_axis_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_Y,
-		.decoded_size = 1U << ARRAY_SIZE(buzz_y_axis_gpios),
-		.map = buzz_y_axis_map,
-		.gpio = buzz_y_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION
-			/*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT  */
-	}
-};
-
-static struct gpio_event_info *buzz_input_info[] = {
-	&buzz_keypad_matrix_info.info,
-	&buzz_keypad_nav_info.info,
-	&buzz_x_axis.info.info,
-	&buzz_y_axis.info.info,
-};
-
-static struct gpio_event_platform_data buzz_keypad_data = {
-	.names = {
-		"buzz-keypad",
-		"buzz-nav",
-		NULL,
-	},
-	.info = buzz_input_info,
-	.info_count = ARRAY_SIZE(buzz_input_info),
-	.power = buzz_nav_power,
-};
-
-static struct platform_device buzz_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev = {
-		.platform_data = &buzz_keypad_data,
-	},
-};
-
-static int buzz_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0
-};
-
-static struct keyreset_platform_data buzz_reset_keys_pdata = {
-	.keys_up = buzz_reset_keys_up,
-	.keys_down = {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-struct platform_device buzz_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &buzz_reset_keys_pdata,
-};
-
-int __init buzz_init_keypad(void)
-{
-	jog_vreg = vreg_get(&buzz_keypad_device.dev, "wlan");
-	if (jog_vreg == NULL) {
-		printk(KERN_WARNING "%s: can't initialize jogball power\n",
-								__func__);
-		return -ENOENT;
-	}
-
-	if (platform_device_register(&buzz_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	return platform_device_register(&buzz_keypad_device);
-}
-
diff --git a/arch/arm/mach-msm/board-buzz-microp.c b/arch/arm/mach-msm/board-buzz-microp.c
deleted file mode 100644
index 7dada3d..0000000
--- a/arch/arm/mach-msm/board-buzz-microp.c
+++ /dev/null
@@ -1,81 +0,0 @@
-/* arch/arm/mach-msm/board-buzz-microp.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <mach/atmega_microp.h>
-#include <mach/drv_callback.h>
-
-#include "board-buzz.h"
-
-static struct i2c_client *buzz_microp_client;
-
-static int buzz_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	buzz_microp_client = client;
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	ret = microp_write_interrupt(client, (1<<8), 1);
-	if (ret)
-		goto exit;
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = buzz_microp_function_init,
-/*
-	.als_pwr_enable = buzz_als_power,
-	.als_intr_enable = buzz_als_intr_enable,
-	.als_level_change = buzz_als_level_change,
-*/
-};
-
-void __init buzz_microp_init(void)
-{
-	/*led_trigger_register(&buzz_als_level_trigger);*/
-	microp_register_ops(&ops);
-}
-
-#endif
diff --git a/arch/arm/mach-msm/board-buzz-mmc.c b/arch/arm/mach-msm/board-buzz-mmc.c
deleted file mode 100644
index 053bbe7..0000000
--- a/arch/arm/mach-msm/board-buzz-mmc.c
+++ /dev/null
@@ -1,293 +0,0 @@
-/* linux/arch/arm/mach-msm/board-buzz-mmc.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <asm/mach-types.h>
-
-#include <mach/vreg.h>
-
-#include <asm/mach/mmc.h>
-
-#include "devices.h"
-#include "board-buzz.h"
-#include "proc_comm.h"
-
-/* #include <linux/irq.h> */
-
-#define DEBUG_SDSLOT_VDD 1
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_16MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init buzz_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_buzz.disable_sdcard=", buzz_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t buzz_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		vreg_enable(vreg_sdslot);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-#if DEBUG_SDSLOT_VDD
-			printk(KERN_INFO "%s: Setting level to %u\n",
-					__func__, mmc_vdd_table[i].level);
-#endif
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-			return 0;
-		}
-	}
-
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int buzz_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(BUZZ_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define BUZZ_MMC_VDD	MMC_VDD_28_29 | MMC_VDD_29_30
-
-static unsigned int buzz_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data buzz_sdslot_data = {
-	.ocr_mask	= BUZZ_MMC_VDD,
-	/* .status_irq		= MSM_GPIO_TO_INT(BUZZ_GPIO_SDMC_CD_N), */
-	.status		= buzz_sdslot_status,
-	.translate_vdd	= buzz_sdslot_switchvdd,
-	.slot_type	= &buzz_sdslot_type,
-};
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data buzz_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-static int buzz_wifi_cd;		/* WIFI virtual 'card detect' status */
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-buzz_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int buzz_wifi_status(struct device *dev)
-{
-	return buzz_wifi_cd;
-}
-
-static struct mmc_platform_data buzz_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= buzz_wifi_status,
-	.register_status_notify	= buzz_wifi_status_register,
-	.embedded_sdio		= &buzz_wifi_emb_data,
-};
-
-int buzz_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	buzz_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(buzz_wifi_set_carddetect);
-int buzz_wifi_power_state = 0;
-int buzz_bt_power_state = 0;
-
-int buzz_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-	buzz_wifi_power_state = on;
-	mdelay(100);
-	gpio_set_value(BUZZ_GPIO_WIFI_EN, on);
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(buzz_wifi_power);
-
-int buzz_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-int __init buzz_init_mmc(unsigned int sys_rev)
-{
-
-	uint32_t id;
-
-
-	/* initial WIFI_SHUTDOWN */
-	id = PCOM_GPIO_CFG(BUZZ_GPIO_WIFI_EN, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	wifi_status_cb = NULL;
-
-
-	sdslot_vreg_enabled = 0;
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-
-	printk(KERN_INFO "%s\n", __func__);
-
-	set_irq_wake(MSM_GPIO_TO_INT(BUZZ_GPIO_SDMC_CD_N), 1);
-
-    msm_add_sdcc(1, &buzz_wifi_data, 0, 0);
-
-	if (!opt_disable_sdcard)
-		msm_add_sdcc(2, &buzz_sdslot_data,
-			MSM_GPIO_TO_INT(BUZZ_GPIO_SDMC_CD_N),
-			IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-	else
-		printk(KERN_INFO "buzz: SD-Card interface disabled\n");
-
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-buzz-panel.c b/arch/arm/mach-msm/board-buzz-panel.c
deleted file mode 100644
index a3b1bec..0000000
--- a/arch/arm/mach-msm/board-buzz-panel.c
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-
-#include <asm/io.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-#include <mach/vreg.h>
-#ifdef CONFIG_HTC_PWRSINK
-#include <mach/htc_pwrsink.h>
-#endif
-
-#include <mach/pmic.h>
-#include "board-buzz.h"
-#include "proc_comm.h"
-#include "devices.h"
-
-#if 1
-#define B(s...) printk("[panel]"s)
-#else
-#define B(s...) do {} while(0)
-#endif
-
-struct mddi_table {
-	uint32_t reg;
-	uint32_t value;
-	uint32_t msec;
-};
-
-static struct mddi_table buzz_init_tb[] = {
-        {0x01, 0x0000, 0},
-        {0x3e, 0x0040, 0},
-        {0x16, 0x0008, 0},
-        {0x27, 0x000e, 0},
-        {0x28, 0x000e, 0},
-        {0x71, 0x0068, 0},
-        {0x60, 0x0001, 0},
-        {0x93, 0x000f, 0},
-        {0x98, 0x000f, 0},
-	{0x9a, 0x0000, 10},
-        {0x1b, 0x0010, 40},
-        {0x1c, 0x0004, 10},
-	{0x1f, 0x000c, 10},
-        {0x43, 0x0080, 60},
-        {0xd0, 0x0000, 0},
-	{0xd1, 0x0003, 0},
-	{0xd2, 0x0004, 0},
-        {0xd3, 0x000b, 0},
-        {0xd4, 0x000b, 0},
-        {0xd5, 0x003f, 0},
-        {0xd6, 0x000e, 0},
-        {0xd7, 0x0014, 0},
-        {0xd8, 0x0007, 0},
-        {0xd9, 0x000d, 0},
-        {0xda, 0x0013, 0},
-        {0xdb, 0x0016, 0},
-        {0xdc, 0x0019, 0},
-        {0xdd, 0x0018, 0},
-        {0xde, 0x0017, 0},
-        {0xdf, 0x000c, 0},
-        {0xe0, 0x0013, 0},
-        {0xe1, 0x0000, 0},
-        {0xe2, 0x0034, 0},
-        {0xe3, 0x0034, 0},
-        {0xe4, 0x003b, 0},
-        {0xe5, 0x003c, 0},
-        {0xe6, 0x003f, 0},
-        {0xe7, 0x0043, 0},
-        {0xe8, 0x0049, 0},
-        {0xe9, 0x000c, 0},
-        {0xea, 0x0013, 0},
-        {0xeb, 0x0008, 0},
-        {0xec, 0x0007, 0},
-        {0xed, 0x0007, 0},
-        {0xee, 0x0009, 0},
-        {0xef, 0x000c, 0},
-        {0xf0, 0x0011, 0},
-        {0xf1, 0x0018, 0},
-        {0xf2, 0x000f, 0},
-        {0x95, 0x0024, 0},
-        {0x96, 0x0000, 1},
-        {0x02, 0x0000, 0},
-        {0x03, 0x0000, 0},
-        {0x04, 0x0000, 0},
-        {0x05, 0x00ef, 0},
-        {0x06, 0x0000, 0},
-        {0x07, 0x0000, 0},
-        {0x08, 0x0001, 0},
-        {0x09, 0x003f, 0},
-        {0x26, 0x0024, 1},
-        {0x26, 0x0038, 1},
-        {0x26, 0x003c, 0},
-};
-
-static struct mddi_table buzz_standby_tb[] = {
-	{0x95, 0x0000, 0},
-	{0x26, 0x0038, 50},
-        {0x26, 0x0020, 50},
-};
-
-#define GPIOSEL_VWAKEINT (1U << 0)
-#define INTMASK_VWAKEOUT (1U << 0)
-
-static void
-buzz_process_mddi_table(struct msm_mddi_client_data *client_data,
-		struct mddi_table *table, ssize_t count)
-
-{
-	int i;
-	uint32_t reg, value, msec;
-
-	BUG_ON(!client_data);
-	BUG_ON(!table);
-	BUG_ON(!count);
-
-	for(i = 0; i < count; i++) {
-		reg = table[i].reg;
-		value = table[i].value;
-		msec = table[i].msec;
-
-		client_data->remote_write(client_data, value, reg);
-		if (msec)
-			mdelay(msec);
-	}
-}
-
-static struct vreg *vreg_lcm_2v85;
-static struct vreg *vreg_lcm_2v6;
-
-static void
-buzz_mddi_power_client(struct msm_mddi_client_data *cdata, int on)
-{
-	B("%s: enter.\n", __func__);
-	unsigned id, on_off;
-
-	if(on) {
-		B("buzz resume");
-		on_off = 0;
-
-                gpio_set_value(BUZZ_MDDI_RSTz, 0);
-
-                id = PM_VREG_PDOWN_GP2_ID;
-                msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-
-                vreg_enable(vreg_lcm_2v6);
-                hr_msleep(1);
-
-                id = PM_VREG_PDOWN_GP4_ID;
-                msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-
-                vreg_enable(vreg_lcm_2v85);
-                hr_msleep(10);
-
-                gpio_set_value(BUZZ_MDDI_RSTz, 1);
-                hr_msleep(50);
-	} else {
-		B("buzz suspend");
-                on_off = 1;
-
-                id = PM_VREG_PDOWN_GP4_ID;
-                msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-
-                hr_msleep(20);
-                vreg_disable(vreg_lcm_2v85);
-                hr_msleep(1);
-
-                id = PM_VREG_PDOWN_GP2_ID;
-                msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-
-                vreg_disable(vreg_lcm_2v6);
-
-                hr_msleep(10);
-
-                gpio_set_value(BUZZ_MDDI_RSTz, 0);
-	}
-}
-
-#if defined(CONFIG_ARCH_MSM7225) || defined(CONFIG_ARCH_MSM7625)
-#define LCM_ID0 57
-#define LCM_ID1 58
-#else
-#define LCM_ID0 _bad_id()
-#define LCM_ID1 _bad_id()
-#endif
-
-static int
-buzz_mddi_client_init(struct msm_mddi_bridge_platform_data *bridge_data,
-		     struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-
-        return 0;
-
-}
-
-static int
-buzz_mddi_client_uninit(struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *client_data)
-
-{
-	B(KERN_DEBUG "%s: N enter.\n", __func__);
-
-        return 0;
-}
-
-static int
-buzz_panel_unblank(struct msm_mddi_bridge_platform_data *bridge_data,
-                  struct msm_mddi_client_data *client_data)
-{
-	BUG_ON(!bridge_data);
-	BUG_ON(!client_data);
-
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-
-	client_data->auto_hibernate(client_data, 0);
-	buzz_process_mddi_table(client_data,
-			buzz_init_tb,
-			ARRAY_SIZE(buzz_init_tb));
-	client_data->auto_hibernate(client_data, 1);
-
-return 0;
-}
-
-static int
-buzz_panel_blank(struct msm_mddi_bridge_platform_data *bridge_data,
-                struct msm_mddi_client_data *client_data)
-{
-	BUG_ON(!bridge_data);
-	BUG_ON(!client_data);
-
-	B("%s: N enter.\n", __func__);
-
-	client_data->auto_hibernate(client_data, 0);
-	buzz_process_mddi_table(client_data,
-			buzz_standby_tb,
-			ARRAY_SIZE(buzz_standby_tb));
-	client_data->auto_hibernate(client_data, 1);
-	return 0;
-}
-
-static void
-buzz_fixup(uint16_t *mfr_name, uint16_t *product_code)
-{
-	B("%s: enter.\n", __func__);
-
-	*mfr_name = 0x4858;
-	*product_code = 0x8356;
-}
-
-static struct resource resources_msm_fb[] = {
-        {
-                .start = MSM_FB_BASE,
-                .end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-                .flags = IORESOURCE_MEM,
-        },
-};
-
-static struct msm_mddi_bridge_platform_data himax_client_data = {
-        .init = buzz_mddi_client_init,
-        .uninit = buzz_mddi_client_uninit,
-	.bridge_type = SAMSUNG_D,
-        .blank = buzz_panel_blank,
-        .unblank = buzz_panel_unblank,
-        .fb_data = {
-                .xres = 240,
-                .yres = 320,
-		.width = 49,
-		.height = 65,
-                .output_format = 0,
-        },
-};
-
-static struct msm_mddi_platform_data buzz_pdata = {
-	.clk_rate = 83000000,		/*default MDDI frequenct*/
-	.power_client = buzz_mddi_power_client,
-	.fixup = buzz_fixup,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 1,
-	.client_platform_data = {
-		{
-			.product_id = (0x4858 << 16 | 0x8356),
-			.name = "mddi_c_4858_8356",
-			.id = 0,
-			.client_data = &himax_client_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-int __init buzz_panel_init(void)
-{
-	int rc;
-	struct panel_data *config = &himax_client_data.panel_conf;
-
-	if (!machine_is_buzz())
-		return 0;
-
-	B("buzz panel_init");
-	vreg_lcm_2v85 = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_lcm_2v85))
-		return PTR_ERR(vreg_lcm_2v85);
-
-	vreg_lcm_2v6 = vreg_get(0, "gp2");
-	if (IS_ERR(vreg_lcm_2v6))
-		return PTR_ERR(vreg_lcm_2v6);
-
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-
-	config->caps = MSMFB_CAP_CABC;
-	msm_device_mddi0.dev.platform_data = &buzz_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-
-	return 0;
-}
-
-device_initcall(buzz_panel_init);
diff --git a/arch/arm/mach-msm/board-buzz-rfkill.c b/arch/arm/mach-msm/board-buzz-rfkill.c
deleted file mode 100644
index 227c5dc..0000000
--- a/arch/arm/mach-msm/board-buzz-rfkill.c
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for buzz platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-buzz.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-/* bt initial configuration */
-static uint32_t buzz_bt_init_table[] = {
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_TX, /* BT_TX */
-				3,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt on configuration */
-static uint32_t buzz_bt_on_table[] = {
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_RX, /* BT_RX */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_TX, /* BT_TX */
-				3,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt off configuration */
-static uint32_t buzz_bt_off_table[] = {
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_RTS, /* BT_RTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_UART1_TX, /* BT_TX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZ_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void buzz_config_bt_init(void)
-{
-	/* set bt initial configuration*/
-	config_bt_table(buzz_bt_init_table,
-				ARRAY_SIZE(buzz_bt_init_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(BUZZ_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BUZZ_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(BUZZ_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-}
-
-static void buzz_config_bt_on(void)
-{
-	/* set bt on configuration*/
-	config_bt_table(buzz_bt_on_table,
-				ARRAY_SIZE(buzz_bt_on_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(BUZZ_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BUZZ_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-}
-
-static void buzz_config_bt_off(void)
-{
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BUZZ_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_RESET_N */
-	gpio_configure(BUZZ_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(buzz_bt_off_table,
-				ARRAY_SIZE(buzz_bt_off_table));
-	mdelay(5);
-
-	/* BT_RTS */
-	gpio_configure(BUZZ_GPIO_BT_UART1_RTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CTS */
-
-	/* BT_TX */
-	gpio_configure(BUZZ_GPIO_BT_UART1_TX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_RX */
-
-	/* BT_HOST_WAKE */
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(BUZZ_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-			buzz_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-			buzz_config_bt_off();
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int buzz_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	buzz_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int buzz_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver buzz_rfkill_driver = {
-	.probe = buzz_rfkill_probe,
-	.remove = buzz_rfkill_remove,
-	.driver = {
-		.name = "buzz_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init buzz_rfkill_init(void)
-{
-	if (!machine_is_buzz())
-		return 0;
-
-	return platform_driver_register(&buzz_rfkill_driver);
-}
-
-static void __exit buzz_rfkill_exit(void)
-{
-	platform_driver_unregister(&buzz_rfkill_driver);
-}
-
-module_init(buzz_rfkill_init);
-module_exit(buzz_rfkill_exit);
-MODULE_DESCRIPTION("buzz rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-buzz-wifi.c b/arch/arm/mach-msm/board-buzz-wifi.c
deleted file mode 100644
index 5f28dcc..0000000
--- a/arch/arm/mach-msm/board-buzz-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-buzz-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-buzz.h"
-
-int buzz_wifi_power(int on);
-int buzz_wifi_reset(int on);
-int buzz_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *buzz_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init buzz_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource buzz_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(BUZZ_GPIO_WIFI_IRQ1),
-		.end		= MSM_GPIO_TO_INT(BUZZ_GPIO_WIFI_IRQ1),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data buzz_wifi_control = {
-	.set_power      = buzz_wifi_power,
-	.set_reset      = buzz_wifi_reset,
-	.set_carddetect = buzz_wifi_set_carddetect,
-	.mem_prealloc   = buzz_wifi_mem_prealloc,
-};
-
-static struct platform_device buzz_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(buzz_wifi_resources),
-        .resource       = buzz_wifi_resources,
-        .dev            = {
-                .platform_data = &buzz_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned buzz_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init buzz_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_buzz())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	buzz_wifi_update_nvs("sd_oobonly=1\n");
-	buzz_init_wifi_mem();
-	ret = platform_device_register(&buzz_wifi_device);
-        return ret;
-}
-
-device_initcall(buzz_wifi_init);
diff --git a/arch/arm/mach-msm/board-buzz.c b/arch/arm/mach-msm/board-buzz.c
deleted file mode 100644
index 4debe8d..0000000
--- a/arch/arm/mach-msm/board-buzz.c
+++ /dev/null
@@ -1,993 +0,0 @@
-/* arch/arm/mach-msm/board-buzz.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/irq.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <linux/atmel_qt602240.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/sysdev.h>
-#include <linux/android_pmem.h>
-
-#include <mach/board.h>
-#include <mach/camera.h>
-
-#include <linux/delay.h>
-#include <linux/gpio.h>
-
-#include <mach/hardware.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <mach/system.h>
-#include <mach/vreg.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <mach/msm_serial_debugger.h>
-
-#include <asm/io.h>
-#include <asm/delay.h>
-#include <asm/setup.h>
-
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-
-#include <asm/mach/mmc.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/curcial_oj.h>
-#include "board-buzz.h"
-#include "proc_comm.h"
-#include "gpio_chip.h"
-
-#include <mach/board_htc.h>
-#include <mach/msm_serial_hs.h>
-
-#include "devices.h"
-
-#include <mach/atmega_microp.h>
-#include <mach/htc_battery.h>
-
-#include <mach/htc_pwrsink.h>
-#include <mach/perflock.h>
-#include <mach/drv_callback.h>
-#include <mach/msm_rpcrouter.h>
-#include <mach/msm_iomap.h>
-#include <mach/msm_flashlight.h>
-#include <mach/msm_hsusb.h>
-
-void msm_init_irq(void);
-void msm_init_gpio(void);
-void msm_init_pmic_vibrator(void);
-void config_buzz_camera_on_gpios(void);
-void config_buzz_camera_off_gpios(void);
-#ifdef CONFIG_MICROP_COMMON
-void __init buzz_microp_init(void);
-#endif
-static int buzz_phy_init_seq[] = {0x0C, 0x31, 0x31, 0x32, 0x1, 0x0D, 0x1, 0x10, -1};
-static struct msm_hsusb_product buzz_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c8b,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-
-#define HSUSB_API_INIT_PHY_PROC	2
-#define HSUSB_API_PROG		0x30000064
-#define HSUSB_API_VERS MSM_RPC_VERS(1, 1)
-
-static void Buzz_phy_reset(void)
-{
-	struct msm_rpc_endpoint *usb_ep;
-	int rc;
-	struct hsusb_phy_start_req {
-		struct rpc_request_hdr hdr;
-	} req;
-
-	printk(KERN_INFO "msm_hsusb_phy_reset\n");
-
-	usb_ep = msm_rpc_connect(HSUSB_API_PROG, HSUSB_API_VERS, 0);
-	if (IS_ERR(usb_ep)) {
-		printk(KERN_ERR "%s: init rpc failed! error: %ld\n",
-				__func__, PTR_ERR(usb_ep));
-		return;
-	}
-	rc = msm_rpc_call(usb_ep, HSUSB_API_INIT_PHY_PROC,
-			&req, sizeof(req), 5 * HZ);
-	if (rc < 0)
-		printk(KERN_ERR "%s: rpc call failed! (%d)\n", __func__, rc);
-
-close:
-	msm_rpc_close(usb_ep);
-}
-
-void config_buzz_proximity_gpios(int on);
-
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-	.guage_driver = GUAGE_MODEM,
-	.charger = LINEAR_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0, 0x23, 0x53, 0xED, 0x14C, 0x1AB, 0x20A, 0x3FF, 0x3FF, 0x3FF },
-		.channel = 3,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xCF,
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 38, 82, 95, 167},
-		.channel = 1,
-		.int_pin = 1 << 5,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "reset-int",
-		.category = MICROP_FUNCTION_RESET_INT,
-		.int_pin = 1 << 8,
-	},
-};
-
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "jogball-backlight",
-		.type = LED_JOGBALL,
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct bma150_platform_data buzz_g_sensor_pdata = {
-	.microp_new_cmd = 1,
-};
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev = {
-			.platform_data = &lightsensor_data,
-		},
-	},
-	{
-		.name = "leds-microp",
-		.id = -1,
-		.dev = {
-			.platform_data = &microp_leds_data,
-		},
-	},
-	{
-		.name = BMA150_G_SENSOR_NAME,
-		.dev = {
-			.platform_data = &buzz_g_sensor_pdata,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = BUZZ_GPIO_UP_RESET_N,
-	.spi_devices = SPI_GSENSOR,
-};
-
-static struct i2c_board_info i2c_microp_devices = {
-	I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-	.platform_data = &microp_data,
-	.irq = MSM_GPIO_TO_INT(BUZZ_GPIO_UP_INT),
-};
-
-static struct gpio_led buzz_led_list[] = {
-	{
-		.name = "button-backlight",
-		.gpio = BUZZ_AP_KEY_LED_EN,
-		.active_low = 0,
-	},
-};
-
-static struct gpio_led_platform_data buzz_leds_data = {
-	.num_leds = ARRAY_SIZE(buzz_led_list),
-	.leds = buzz_led_list,
-};
-
-static struct platform_device buzz_leds = {
-	.name = "leds-gpio",
-	.id = -1,
-	.dev = {
-		.platform_data = &buzz_leds_data,
-	},
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_buzz_camera_on_gpios,
-	.camera_gpio_off = config_buzz_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		.end	= INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
-	.camera_flash		= flashlight_control,
-	.num_flash_levels	= FLASHLIGHT_NUM,
-	.low_temp_limit		= 5,
-	.low_cap_limit		= 15,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_s5k4e1gx_data = {
-	.sensor_name    = "s5k4e1gx",
-	.sensor_reset   = 118,
-	.vcm_pwd        = BUZZ_GPIO_VCM_PWDN,
-	.pdata          = &msm_camera_device_data,
-	.resource       = msm_camera_resources,
-	.num_resources  = ARRAY_SIZE(msm_camera_resources),
-	.flash_cfg	= &msm_camera_sensor_flash_cfg,
-};
-
-static struct platform_device msm_camera_sensor_s5k4e1gx = {
-	.name      = "msm_camera_s5k4e1gx",
-	.dev       = {
-		.platform_data = &msm_camera_sensor_s5k4e1gx_data,
-	},
-};
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = BUZZ_LAYOUTS,
-	.project_name = BUZZ_PROJECT_NAME,
-	.reset = BUZZ_GPIO_COMPASS_RST_N,
-	.intr = BUZZ_GPIO_COMPASS_INT_N,
-};
-
-static int buzz_ts_atmel_power(int on)
-{
-	int ret;
-
-	printk(KERN_INFO "%s():\n", __func__);
-	if (on) {
-		printk(KERN_INFO "RST: %d\n", gpio_get_value(BUZZ_GPIO_TP_RST));
-		gpio_set_value(BUZZ_GPIO_TP_RST, 0);
-		msleep(5);
-		gpio_set_value(BUZZ_TP_3V_EN, 1);
-		msleep(5);
-		printk(KERN_INFO "RST: %d\n", gpio_get_value(BUZZ_GPIO_TP_RST));
-		gpio_set_value(BUZZ_GPIO_TP_RST, 1);
-		msleep(40);
-		printk(KERN_INFO "RST: %d\n", gpio_get_value(BUZZ_GPIO_TP_RST));
-	} else {
-		gpio_set_value(BUZZ_TP_3V_EN, 0);
-		msleep(2);
-	}
-	return 0;
-}
-
-struct atmel_i2c_platform_data buzz_ts_atmel_data = {
-	.version = 0x0015,
-	.abs_x_min = 0,
-	.abs_x_max = 1023,
-	.abs_y_min = 0,
-	.abs_y_max = 915,
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-	.abs_width_min = 0,
-	.abs_width_max = 20,
-	.gpio_irq = BUZZ_GPIO_TP_ATT_N,
-	.power = buzz_ts_atmel_power,
-	.config_T6 = {0, 0, 0, 0, 0, 0},
-	.config_T7 = {50, 15, 25},
-	.config_T8 = {8, 0, 20, 20, 0, 0, 10, 10},
-	.config_T9 = {131, 0, 0, 16, 11, 0, 16, 35, 2, 3, 0, 2, 2, 46, 2, 10, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 150, 57, 150, 83},
-	.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T20 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T22 = {5, 0, 0, 25, 0, -25, 255, 4, 30, 0, 1, 10, 15, 20, 10, 10, 0},
-	.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T25 = {3, 0, 224, 46, 88, 27, 0, 0, 0, 0, 0, 0, 0, 0},
-	.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-	.config_T28 = {0, 0, 0, 4, 8, 60},
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(ATMEL_QT602240_NAME, 0x94 >> 1),
-		.platform_data = &buzz_ts_atmel_data,
-		.irq = MSM_GPIO_TO_INT(BUZZ_GPIO_TP_ATT_N)
-	},
-	{
-		/*I2C_BOARD_INFO("s5k4b2fx", 0x22 >> 1),*/
-		I2C_BOARD_INFO("s5k4b2fx", 0x22),
-		/* .irq = TROUT_GPIO_TO_INT(TROUT_GPIO_CAM_BTN_STEP1_N), */
-	},
-	{
-		I2C_BOARD_INFO("s5k4e1gx", 0x20 >> 1),   /*5M bayer sensor*/
-		.platform_data = &msm_camera_device_data,
-	},
-};
-
-static struct i2c_board_info i2c_sensor[] = {
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = MSM_GPIO_TO_INT(BUZZ_GPIO_COMPASS_INT_N),
-	},
-};
-
-static struct h2w_platform_data buzz_h2w_data = {
-};
-
-static struct platform_device buzz_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &buzz_h2w_data,
-	},
-};
-
-static struct audio_jack_platform_data buzz_jack_data = {
-	.gpio	= BUZZ_GPIO_35MM_HEADSET_DET,
-};
-
-
-static struct platform_device buzz_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &buzz_jack_data,
-	},
-};
-
-static struct pwr_sink buzz_pwrsink_table[] = {
-	{
-		.id     = PWRSINK_AUDIO,
-		.ua_max = 100000,
-	},
-	{
-		.id     = PWRSINK_BACKLIGHT,
-		.ua_max = 125000,
-	},
-	{
-		.id     = PWRSINK_LED_BUTTON,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_LED_KEYBOARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_GP_CLK,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_BLUETOOTH,
-		.ua_max = 15000,
-	},
-	{
-		.id     = PWRSINK_CAMERA,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_SDCARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_VIDEO,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id     = PWRSINK_SYSTEM_LOAD,
-		.ua_max = 100000,
-		.percent_util = 38,
-	},
-};
-
-static int buzz_pwrsink_resume_early(struct platform_device *pdev)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-	return 0;
-}
-
-static void buzz_pwrsink_resume_late(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 38);
-}
-
-static void buzz_pwrsink_suspend_early(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-}
-
-static int buzz_pwrsink_suspend_late(struct platform_device *pdev, pm_message_t state)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 1);
-	return 0;
-}
-
-static struct pwr_sink_platform_data buzz_pwrsink_data = {
-	.num_sinks      = ARRAY_SIZE(buzz_pwrsink_table),
-	.sinks          = buzz_pwrsink_table,
-	.suspend_late	= buzz_pwrsink_suspend_late,
-	.resume_early	= buzz_pwrsink_resume_early,
-	.suspend_early	= buzz_pwrsink_suspend_early,
-	.resume_late	= buzz_pwrsink_resume_late,
-};
-
-static struct platform_device buzz_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev    = {
-		.platform_data = &buzz_pwrsink_data,
-	},
-};
-
-static struct msm_pmem_setting pmem_setting = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-};
-
-static ssize_t buzz_virtual_keys_show(struct kobject *kobj,
-			       struct kobj_attribute *attr, char *buf)
-{
-	return sprintf(buf,
-		__stringify(EV_KEY) ":" __stringify(KEY_HOME)  ":22:350:40:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":74:350:48:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":169:350:48:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":218:350:40:55"
-	   "\n");
-}
-
-static struct kobj_attribute buzz_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.atmel-touchscreen",
-		.mode = S_IRUGO,
-	},
-	.show = &buzz_virtual_keys_show,
-};
-
-static struct attribute *buzz_properties_attrs[] = {
-	&buzz_virtual_keys_attr.attr,
-	NULL
-};
-
-static struct attribute_group buzz_properties_attr_group = {
-	.attrs = buzz_properties_attrs,
-};
-
-static struct msm_i2c_device_platform_data buzz_i2c_device_data = {
-	.i2c_clock = 400000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-static struct platform_device buzz_rfkill = {
-	.name = "buzz_rfkill",
-	.id = -1,
-};
-
-static int __capella_cm3602_power(int on)
-{
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on) {
-		config_buzz_proximity_gpios(1);
-		gpio_direction_output(BUZZ_GPIO_PROXIMITY_EN, 1);
-		gpio_direction_output(BUZZ_GPIO_LS_EN, 0);
-		gpio_direction_output(BUZZ_PS_2V85_EN, 1);
-	} else {
-		gpio_direction_output(BUZZ_PS_2V85_EN, 0);
-		gpio_direction_output(BUZZ_GPIO_LS_EN, 1);
-		gpio_direction_output(BUZZ_GPIO_PROXIMITY_EN, 0);
-		config_buzz_proximity_gpios(0);
-	}
-	return 0;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static unsigned int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable)
-		als_power_control |= pwr_device;
-	else
-		als_power_control &= ~pwr_device;
-
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-		ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-}
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.p_out = BUZZ_GPIO_PROXIMITY_INT,
-	.p_en = BUZZ_GPIO_PROXIMITY_EN,
-	.power = capella_cm3602_power,
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-
-static void config_buzz_flashlight_gpios(void)
-{
-	static uint32_t buzz_flashlight_gpio_table[] = {
-		PCOM_GPIO_CFG(BUZZ_GPIO_FL_TORCH, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-								GPIO_2MA),
-		PCOM_GPIO_CFG(BUZZ_GPIO_FL_FLASH, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-								GPIO_2MA),
-	};
-	config_gpio_table(buzz_flashlight_gpio_table,
-		ARRAY_SIZE(buzz_flashlight_gpio_table));
-}
-
-static struct flashlight_platform_data buzz_flashlight_data = {
-	.gpio_init = config_buzz_flashlight_gpios,
-	.torch = BUZZ_GPIO_FL_TORCH,
-	.flash = BUZZ_GPIO_FL_FLASH,
-	.flash_duration_ms = 600,
-};
-
-static struct platform_device buzz_flashlight_device = {
-	.name = FLASHLIGHT_NAME,
-	.dev = {
-		.platform_data  = &buzz_flashlight_data,
-	},
-};
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_smd,
-	&msm_device_nand,
-	&msm_device_i2c,
-	&buzz_h2w,
-	&htc_battery_pdev,
-	&buzz_audio_jack,
-	&msm_camera_sensor_s5k4e1gx,
-	&buzz_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&buzz_pwr_sink,
-#endif
-	/* &buzz_oj, TODO:JOGALL */
-#ifdef CONFIG_INPUT_CAPELLA_CM3602
-	&capella_cm3602,
-#endif
-	&buzz_leds,
-	&buzz_flashlight_device,
-};
-
-extern struct sys_timer msm_timer;
-
-static void __init buzz_init_irq(void)
-{
-	printk("buzz_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint cpld_iset;
-static uint cpld_charger_en;
-static uint cpld_usb_h2w_sw;
-static uint opt_disable_uart3;
-static char *keycaps = "";
-
-module_param_named(iset, cpld_iset, uint, 0);
-module_param_named(charger_en, cpld_charger_en, uint, 0);
-module_param_named(usb_h2w_sw, cpld_usb_h2w_sw, uint, 0);
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-module_param_named(keycaps, keycaps, charp, 0);
-
-static char bt_chip_id[10] = "bcm4329";
-module_param_string(bt_chip_id, bt_chip_id, sizeof(bt_chip_id), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_chip_id, "BT's chip id");
-
-static char bt_fw_version[10] = "v2.0.38";
-module_param_string(bt_fw_version, bt_fw_version, sizeof(bt_fw_version), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_fw_version, "BT's fw version");
-
-static void buzz_reset(void)
-{
-	gpio_set_value(BUZZ_GPIO_PS_HOLD, 0);
-}
-
-static uint32_t proximity_on_gpio_table[] = {
-	PCOM_GPIO_CFG(BUZZ_GPIO_PROXIMITY_INT,
-		0, GPIO_INPUT, GPIO_NO_PULL, 0), /* PS_VOUT */
-};
-
-static uint32_t proximity_off_gpio_table[] = {
-	PCOM_GPIO_CFG(BUZZ_GPIO_PROXIMITY_INT,
-		0, GPIO_INPUT, GPIO_PULL_DOWN, 0) /* PS_VOUT */
-};
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA),/*HSYNC_IN*/
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA),/*VSYNC_IN*/
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA),/*MCLK*/
-
-	PCOM_GPIO_CFG(61, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),/*CAM_I2C_SDA*/
-	PCOM_GPIO_CFG(60, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),/*CAM_I2C_SCL*/
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-void config_buzz_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void config_buzz_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-/* for bcm */
-static char bdaddress[20];
-extern unsigned char *get_bt_bd_ram(void);
-
-static void bt_export_bd_address(void)
-{
-	unsigned char cTemp[6];
-
-	memcpy(cTemp, get_bt_bd_ram(), 6);
-	sprintf(bdaddress, "%02x:%02x:%02x:%02x:%02x:%02x",
-		cTemp[0], cTemp[1], cTemp[2], cTemp[3], cTemp[4], cTemp[5]);
-	printk(KERN_INFO "YoYo--BD_ADDRESS=%s\n", bdaddress);
-}
-
-module_param_string(bdaddress, bdaddress, sizeof(bdaddress), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bdaddress, "BT MAC ADDRESS");
-
-void config_buzz_proximity_gpios(int on)
-{
-	if (on)
-		config_gpio_table(proximity_on_gpio_table,
-			ARRAY_SIZE(proximity_on_gpio_table));
-	else
-		config_gpio_table(proximity_off_gpio_table,
-			ARRAY_SIZE(proximity_off_gpio_table));
-}
-
-static uint32_t buzz_serial_debug_table[] = {
-	/* config as serial debug uart */
-	PCOM_GPIO_CFG(BUZZ_GPIO_UART3_RX, 1,
-			GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* UART3 RX */
-	PCOM_GPIO_CFG(BUZZ_GPIO_UART3_TX, 1,
-			GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* UART3 TX */
-};
-
-static void buzz_config_serial_debug_gpios(void)
-{
-	config_gpio_table(buzz_serial_debug_table,
-			ARRAY_SIZE(buzz_serial_debug_table));
-}
-
-
-static void __init config_gpios(void)
-{
-	buzz_config_serial_debug_gpios();
-	config_buzz_camera_off_gpios();
-}
-
-static struct msm_acpu_clock_platform_data buzz_clock_data = {
-	.acpu_switch_time_us = 50,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200,
-#if defined(CONFIG_TURBO_MODE)
-	.wait_for_irq_khz = 176000,
-#else
-	.wait_for_irq_khz = 128000,
-#endif
-};
-
-static unsigned buzz_perf_acpu_table[] = {
-	245760000,
-	480000000,
-	528000000,
-};
-
-static struct perflock_platform_data buzz_perflock_data = {
-	.perf_acpu_table = buzz_perf_acpu_table,
-	.table_size = ARRAY_SIZE(buzz_perf_acpu_table),
-};
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(BUZZ_GPIO_BT_HOST_WAKE),
-	.inject_rx_on_wakeup = 0,
-	.cpu_lock_supported = 1,
-
-	/* for bcm */
-	.bt_wakeup_pin_supported = 1,
-	//.bt_wakeup_pin = BUZZ_GPIO_BT_CHIP_WAKE, //TODO
-	.host_wakeup_pin = BUZZ_GPIO_BT_HOST_WAKE,
-
-};
-#endif
-
-static void __init buzz_init(void)
-{
-	int rc;
-	struct kobject *properties_kobj;
-
-	printk("buzz_init() revision=%d\n", system_rev);
-	printk(KERN_INFO "mfg_mode=%d\n", board_mfg_mode());
-
-	/* for bcm */
-	bt_export_bd_address();
-
-	/*
-	 * Setup common MSM GPIOS
-	 */
-	config_gpios();
-
-	/* We need to set this pin to 0 only once on power-up; we will
-	 * not actually enable the chip until we apply power to it via
-	 * vreg.
-	 */
-	gpio_direction_output(BUZZ_GPIO_LS_EN, 0);
-	/* disable power for cm3602 chip */
-	__capella_cm3602_power(0);
-
-	msm_hw_reset_hook = buzz_reset;
-
-	msm_acpu_clock_init(&buzz_clock_data);
-	perflock_init(&buzz_perflock_data);
-	/* adjust GPIOs based on bootloader request */
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-			&msm_device_uart3.dev, 1,
-				MSM_GPIO_TO_INT(BUZZ_GPIO_UART3_RX));
-#endif
-
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_device_uart_dm1.name = "msm_serial_hs_bcm";	/* for bcm */
-	msm_add_serial_devices(3);
-#else
-	msm_add_serial_devices(0);
-#endif
-
-	msm_add_serial_devices(2);
-	msm_register_usb_phy_init_seq(buzz_phy_init_seq);
-	msm_add_usb_id_pin_gpio(BUZZ_GPIO_USB_ID_PIN);
-	msm_hsusb_set_product(buzz_usb_products,
-		ARRAY_SIZE(buzz_usb_products));
-	msm_add_usb_devices(Buzz_phy_reset, NULL);
-
-	msm_add_mem_devices(&pmem_setting);
-	msm_init_pmic_vibrator();
-#ifdef CONFIG_MICROP_COMMON
-	buzz_microp_init();
-#endif
-
-	rc = buzz_init_mmc(system_rev);
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-
-	properties_kobj = kobject_create_and_add("board_properties", NULL);
-
-	if (properties_kobj)
-		rc = sysfs_create_group(properties_kobj,
-					 &buzz_properties_attr_group);
-	if (!properties_kobj || rc)
-		pr_err("failed to create board_properties\n");
-
-	msm_device_i2c.dev.platform_data = &buzz_i2c_device_data;
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	i2c_register_board_info(0, i2c_sensor, ARRAY_SIZE(i2c_sensor));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-	i2c_register_board_info(0 , &i2c_microp_devices, 1);
-
-	buzz_init_keypad();
-}
-
-static void __init buzz_fixup(struct machine_desc *desc, struct tag *tags,
-				char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 2;
-	mi->bank[0].start = MSM_LINUX_BASE1;
-	mi->bank[0].node = PHYS_TO_NID(MSM_LINUX_BASE1);
-	mi->bank[0].size = MSM_LINUX_SIZE1;
-	mi->bank[1].start = MSM_LINUX_BASE2;
-	mi->bank[1].node = PHYS_TO_NID(MSM_LINUX_BASE2);
-	mi->bank[1].size = MSM_LINUX_SIZE2;
-}
-
-static void __init buzz_map_io(void)
-{
-	printk("buzz_init_map_io()\n");
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-MACHINE_START(BUZZ, "buzz")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params    = 0x02E00100,
-	.fixup          = buzz_fixup,
-	.map_io         = buzz_map_io,
-	.init_irq       = buzz_init_irq,
-	.init_machine   = buzz_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-buzz.h b/arch/arm/mach-msm/board-buzz.h
deleted file mode 100644
index 4cdb37d..0000000
--- a/arch/arm/mach-msm/board-buzz.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/* linux/arch/arm/mach-msm/board-buzz.h
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_BUZZ_H
-#define __ARCH_ARM_MACH_MSM_BOARD_BUZZ_H
-
-#include <mach/board.h>
-
-#define MSM_LINUX_BASE1                 0x02E00000
-#define MSM_LINUX_SIZE1                 0x0D200000
-#define MSM_LINUX_BASE2                 0x20000000
-#define MSM_LINUX_SIZE2                 0x07000000
-
-#define MSM_PMEM_MDP_BASE               0x00000000
-#define MSM_PMEM_MDP_SIZE               0x00800000
-
-#define MSM_FB_BASE                     0x02D00000
-#define MSM_FB_SIZE                     0x9b000
-
-#define MSM_RAM_CONSOLE_BASE            MSM_FB_BASE + MSM_FB_SIZE
-#define MSM_RAM_CONSOLE_SIZE            128 * SZ_1K
-
-#define MSM_PMEM_ADSP_BASE              0x27000000
-#define MSM_PMEM_ADSP_SIZE              0x00800000
-
-#define MSM_PMEM_CAMERA_BASE            0x27800000
-#define MSM_PMEM_CAMERA_SIZE            0x00800000
-
-#define BUZZ_GPIO_USB_ID_PIN          (19)
-
-/* key */
-#define BUZZ_GPIO_POWER_KEY         (20)
-#define BUZZ_GPIO_Q_KP_MKOUT0       (35)
-#define BUZZ_GPIO_Q_KP_MKOUT1       (34)
-#define BUZZ_GPIO_Q_KP_MKOUT2       (33)
-#define BUZZ_GPIO_Q_KP_MKIN0_1      (42)
-#define BUZZ_GPIO_Q_KP_MKIN1_1      (41)
-#define BUZZ_GPIO_Q_KP_MKIN2_1      (40)
-
-#define BUZZ_GPIO_BALL_UP     (94)
-#define BUZZ_GPIO_BALL_LEFT   (17)
-#define BUZZ_GPIO_BALL_DOWN   (83)
-#define BUZZ_GPIO_BALL_RIGHT  (18)
-
-#define BUZZ_GPIO_WIFI_IRQ1         (29)
-#define BUZZ_GPIO_WIFI_EN           (116)
-#define BUZZ_GPIO_SDMC_CD_N         (38)
-#define BUZZ_GPIO_UP_INT            (27)
-#define BUZZ_GPIO_UART3_RX          (86)
-#define BUZZ_GPIO_UART3_TX          (87)
-#define BUZZ_GPIO_VCM_PWDN          (31)
-#define BUZZ_GPIO_UP_RESET_N        (76)
-#define BUZZ_GPIO_PS_HOLD           (25)
-/* flashlight */
-#define BUZZ_GPIO_FL_TORCH	(84)
-#define BUZZ_GPIO_FL_FLASH	(85)
-
-/* 35mm headset */
-#define BUZZ_GPIO_35MM_HEADSET_DET  (112)
-#define BUZZ_GPIO_COMPASS_RST_N     (93)
-#define BUZZ_GPIO_COMPASS_INT_N     (37)
-#define BUZZ_PROJECT_NAME           "buzz"
-
-/* AP Key Led turn on*/
-#define BUZZ_AP_KEY_LED_EN		(119)
-
-#define BUZZ_LAYOUTS		{ \
-		{ {  0, -1, 0}, {  1,  0, 0}, {0, 0,  1} },  \
-		{ {  0, -1, 0}, { -1,  0, 0}, {0, 0,  1} },  \
-		{ {  1,  0, 0}, {  0,  1, 0}, {0, 0,  1} },  \
-		{ {  1,  0, 0}, {  0,  0, 1}, {0, 1,  0} }   \
-					}
-
-/* Proximity  */
-#define BUZZ_GPIO_PROXIMITY_INT     114 // PS_VOUT
-#define BUZZ_GPIO_PROXIMITY_EN      115 // PS_SHDN
-
-#define BUZZ_GPIO_LS_EN             111
-#define BUZZ_PS_2V85_EN             117
-
-/* BT */
-#define BUZZ_GPIO_BT_UART1_RTS      (43)
-#define BUZZ_GPIO_BT_UART1_CTS      (44)
-#define BUZZ_GPIO_BT_UART1_RX       (45)
-#define BUZZ_GPIO_BT_UART1_TX       (46)
-#define BUZZ_GPIO_BT_RESET_N        (131)
-#define BUZZ_GPIO_BT_HOST_WAKE      (21)
-#define BUZZ_GPIO_BT_CHIP_WAKE      (91)
-#define BUZZ_GPIO_BT_SHUTDOWN_N     (113)
-
-/* Touch Panel */
-#define BUZZ_TP_3V_EN                 (108)
-#define BUZZ_GPIO_TP_ATT_N            (92)
-#define BUZZ_GPIO_TP_RST              (107)
-
-#define BUZZ_MDDI_RSTz              (82)
-
-int buzz_init_mmc(unsigned int);
-
-//struct sys_device;
-unsigned int buzz_get_hwid(void);
-unsigned int buzz_get_skuid(void);
-unsigned buzz_engineerid(void);
-int buzz_is_3M_camera(void);
-int __init buzz_init_keypad(void);
-
-#endif /* GUARD */
diff --git a/arch/arm/mach-msm/board-buzzc-keypad.c b/arch/arm/mach-msm/board-buzzc-keypad.c
deleted file mode 100644
index fd18ea6..0000000
--- a/arch/arm/mach-msm/board-buzzc-keypad.c
+++ /dev/null
@@ -1,259 +0,0 @@
-/* arch/arm/mach-msm/board--buzzc.c
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <linux/keyreset.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-
-#include "board-buzzc.h"
-
-static int opt_x_axis_threshold = 1, opt_y_axis_threshold = 1;
-
-struct buzzc_axis_info {
-	struct gpio_event_axis_info info;
-	uint16_t in_state;
-	uint16_t out_state;
-	uint16_t temp_state;
-};
-
-static bool nav_just_on;
-static int nav_on_jiffies;
-
-static unsigned int buzzc_col_gpios[] = {
-	BUZZC_GPIO_Q_KP_MKOUT0,
-	BUZZC_GPIO_Q_KP_MKOUT1,
-	BUZZC_GPIO_Q_KP_MKOUT2,
-};
-
-static unsigned int buzzc_row_gpios[] = {
-	BUZZC_GPIO_Q_KP_MKIN0_1,
-	BUZZC_GPIO_Q_KP_MKIN1_1,
-	BUZZC_GPIO_Q_KP_MKIN2_1,
-};
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(buzzc_row_gpios) + (row))
-
-static unsigned short buzzc_keymap[ARRAY_SIZE(buzzc_col_gpios) *
-					ARRAY_SIZE(buzzc_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = MATRIX_KEY(1, BTN_MOUSE),
-	[KEYMAP_INDEX(0, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(0, 2)] = KEY_VOLUMEUP,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_SEARCH,
-	[KEYMAP_INDEX(1, 1)] = KEY_BACK,
-	[KEYMAP_INDEX(1, 2)] = KEY_VOLUMEDOWN,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_HOME,
-	[KEYMAP_INDEX(2, 1)] = KEY_MENU,
-	[KEYMAP_INDEX(2, 2)] = KEY_RESERVED,
-};
-
-static struct gpio_event_matrix_info buzzc_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = buzzc_keymap,
-	.output_gpios = buzzc_col_gpios,
-	.input_gpios = buzzc_row_gpios,
-	.noutputs = ARRAY_SIZE(buzzc_col_gpios),
-	.ninputs = ARRAY_SIZE(buzzc_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		GPIOKPF_REMOVE_PHANTOM_KEYS |
-		GPIOKPF_PRINT_UNMAPPED_KEYS /* |
-		GPIOKPF_PRINT_MAPPED_KEYS */),
-};
-
-static struct gpio_event_direct_entry buzzc_keypad_nav_map[] = {
-	{ BUZZC_GPIO_POWER_KEY, KEY_POWER },
-};
-
-static struct gpio_event_input_info buzzc_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = GPIOEDF_PRINT_KEYS,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = buzzc_keypad_nav_map,
-	.keymap_size = ARRAY_SIZE(buzzc_keypad_nav_map)
-};
-
-uint16_t buzzc_x_axis_map(struct gpio_event_axis_info *info, uint16_t in)
-{
-	struct buzzc_axis_info *ai =
-			container_of(info, struct buzzc_axis_info, info);
-	uint16_t out = ai->out_state;
-
-	if (nav_just_on) {
-		if (jiffies == nav_on_jiffies || jiffies == nav_on_jiffies + 1)
-			goto ignore;
-		nav_just_on = 0;
-	}
-	if ((ai->in_state ^ in) & 1)
-		out--;
-	if ((ai->in_state ^ in) & 2)
-		out++;
-	ai->out_state = out;
-ignore:
-	ai->in_state = in;
-	if (ai->out_state - ai->temp_state == opt_x_axis_threshold) {
-		ai->temp_state++;
-		ai->out_state = ai->temp_state;
-	} else if (ai->temp_state - ai->out_state == opt_x_axis_threshold) {
-		ai->temp_state--;
-		ai->out_state = ai->temp_state;
-	} else if (abs(ai->out_state - ai->temp_state) > opt_x_axis_threshold)
-		ai->temp_state = ai->out_state;
-
-	return ai->temp_state;
-}
-
-uint16_t buzzc_y_axis_map(struct gpio_event_axis_info *info, uint16_t in)
-{
-	struct buzzc_axis_info *ai =
-			container_of(info, struct buzzc_axis_info, info);
-	uint16_t out = ai->out_state;
-
-	if (nav_just_on) {
-		if (jiffies == nav_on_jiffies || jiffies == nav_on_jiffies + 1)
-			goto ignore;
-		nav_just_on = 0;
-	}
-	if ((ai->in_state ^ in) & 1)
-		out--;
-	if ((ai->in_state ^ in) & 2)
-		out++;
-	ai->out_state = out;
-ignore:
-	ai->in_state = in;
-	if (ai->out_state - ai->temp_state == opt_y_axis_threshold) {
-		ai->temp_state++;
-		ai->out_state = ai->temp_state;
-	} else if (ai->temp_state - ai->out_state == opt_y_axis_threshold) {
-		ai->temp_state--;
-		ai->out_state = ai->temp_state;
-	} else if (abs(ai->out_state - ai->temp_state) > opt_y_axis_threshold)
-		ai->temp_state = ai->out_state;
-
-	return ai->temp_state;
-}
-
-
-int buzzc_nav_power(const struct gpio_event_platform_data *pdata, bool on)
-{
-	/* gpio_set_value(BUZZ_GPIO_JOGBALL_EN, on); */
-	if (on) {
-		nav_just_on = 1;
-		nav_on_jiffies = jiffies;
-	}
-	return 0;
-}
-
-static uint32_t buzzc_x_axis_gpios[] = {
-	BUZZC_GPIO_BALL_LEFT, BUZZC_GPIO_BALL_RIGHT
-};
-
-static struct buzzc_axis_info buzzc_x_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(buzzc_x_axis_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_X,
-		.decoded_size = 1U << ARRAY_SIZE(buzzc_x_axis_gpios),
-		.map = buzzc_x_axis_map,
-		.gpio = buzzc_x_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION
-			/*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT */,
-	}
-};
-
-static uint32_t buzzc_y_axis_gpios[] = {
-	BUZZC_GPIO_BALL_UP, BUZZC_GPIO_BALL_DOWN
-};
-
-static struct buzzc_axis_info buzzc_y_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(buzzc_y_axis_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_Y,
-		.decoded_size = 1U << ARRAY_SIZE(buzzc_y_axis_gpios),
-		.map = buzzc_y_axis_map,
-		.gpio = buzzc_y_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION
-			/*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT  */
-	}
-};
-
-
-static struct gpio_event_info *buzzc_input_info[] = {
-	&buzzc_keypad_matrix_info.info,
-	&buzzc_keypad_nav_info.info,
-	&buzzc_x_axis.info.info,
-	&buzzc_y_axis.info.info,
-};
-
-static struct gpio_event_platform_data buzzc_keypad_data = {
-	.names = {
-		"buzzc-keypad",
-		"buzzc-nav",
-		NULL,
-	},
-	.info = buzzc_input_info,
-	.info_count = ARRAY_SIZE(buzzc_input_info),
-	.power = buzzc_nav_power,
-};
-
-static struct platform_device buzzc_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev = {
-		.platform_data = &buzzc_keypad_data,
-	},
-};
-
-static int buzzc_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0
-};
-
-static struct keyreset_platform_data buzzc_reset_keys_pdata = {
-	.keys_up = buzzc_reset_keys_up,
-	.keys_down = {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-struct platform_device buzzc_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &buzzc_reset_keys_pdata,
-};
-
-int __init buzzc_init_keypad(void)
-{
-	if (platform_device_register(&buzzc_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	return platform_device_register(&buzzc_keypad_device);
-}
-
diff --git a/arch/arm/mach-msm/board-buzzc-microp.c b/arch/arm/mach-msm/board-buzzc-microp.c
deleted file mode 100644
index d2af80d..0000000
--- a/arch/arm/mach-msm/board-buzzc-microp.c
+++ /dev/null
@@ -1,81 +0,0 @@
-/* arch/arm/mach-msm/board-buzzc-microp.c
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <mach/atmega_microp.h>
-#include <mach/drv_callback.h>
-
-#include "board-buzzc.h"
-
-static struct i2c_client *buzzc_microp_client;
-
-static int buzzc_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	buzzc_microp_client = client;
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	ret = microp_write_interrupt(client, (1<<8), 1);
-	if (ret)
-		goto exit;
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = buzzc_microp_function_init,
-/*
-	.als_pwr_enable = buzzc_als_power,
-	.als_intr_enable = buzzc_als_intr_enable,
-	.als_level_change = buzzc_als_level_change,
-*/
-};
-
-void __init buzzc_microp_init(void)
-{
-	/*led_trigger_register(&buzzc_als_level_trigger);*/
-	microp_register_ops(&ops);
-}
-
-#endif
diff --git a/arch/arm/mach-msm/board-buzzc-mmc.c b/arch/arm/mach-msm/board-buzzc-mmc.c
deleted file mode 100644
index c4bc62d..0000000
--- a/arch/arm/mach-msm/board-buzzc-mmc.c
+++ /dev/null
@@ -1,293 +0,0 @@
-/* linux/arch/arm/mach-msm/board-buzzc-mmc.c
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <asm/mach-types.h>
-
-#include <mach/vreg.h>
-
-#include <asm/mach/mmc.h>
-
-#include "devices.h"
-#include "board-buzzc.h"
-#include "proc_comm.h"
-
-/* #include <linux/irq.h> */
-
-#define DEBUG_SDSLOT_VDD 1
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_16MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init buzzc_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_buzzc.disable_sdcard=", buzzc_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t buzzc_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		vreg_enable(vreg_sdslot);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-#if DEBUG_SDSLOT_VDD
-			printk(KERN_INFO "%s: Setting level to %u\n",
-					__func__, mmc_vdd_table[i].level);
-#endif
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-			return 0;
-		}
-	}
-
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int buzzc_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(BUZZC_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define BUZZC_MMC_VDD	MMC_VDD_28_29 | MMC_VDD_29_30
-
-static unsigned int buzzc_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data buzzc_sdslot_data = {
-	.ocr_mask	= BUZZC_MMC_VDD,
-	/* .status_irq		= MSM_GPIO_TO_INT(BUZZC_GPIO_SDMC_CD_N), */
-	.status		= buzzc_sdslot_status,
-	.translate_vdd	= buzzc_sdslot_switchvdd,
-	.slot_type	= &buzzc_sdslot_type,
-};
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data buzzc_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-static int buzzc_wifi_cd;		/* WIFI virtual 'card detect' status */
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-buzzc_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int buzzc_wifi_status(struct device *dev)
-{
-	return buzzc_wifi_cd;
-}
-
-static struct mmc_platform_data buzzc_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= buzzc_wifi_status,
-	.register_status_notify	= buzzc_wifi_status_register,
-	.embedded_sdio		= &buzzc_wifi_emb_data,
-};
-
-int buzzc_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	buzzc_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(buzzc_wifi_set_carddetect);
-int buzzc_wifi_power_state = 0;
-int buzzc_bt_power_state = 0;
-
-int buzzc_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-	buzzc_wifi_power_state = on;
-	mdelay(100);
-	gpio_set_value(BUZZC_GPIO_WIFI_EN, on);
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(buzzc_wifi_power);
-
-int buzzc_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-int __init buzzc_init_mmc(unsigned int sys_rev)
-{
-
-	uint32_t id;
-
-
-	/* initial WIFI_SHUTDOWN */
-	id = PCOM_GPIO_CFG(BUZZC_GPIO_WIFI_EN, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	wifi_status_cb = NULL;
-
-
-	sdslot_vreg_enabled = 0;
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-
-	printk(KERN_INFO "%s\n", __func__);
-
-	set_irq_wake(MSM_GPIO_TO_INT(BUZZC_GPIO_SDMC_CD_N), 1);
-
-    msm_add_sdcc(1, &buzzc_wifi_data, 0, 0);
-
-	if (!opt_disable_sdcard)
-		msm_add_sdcc(2, &buzzc_sdslot_data,
-			MSM_GPIO_TO_INT(BUZZC_GPIO_SDMC_CD_N),
-			IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-	else
-		printk(KERN_INFO "buzzc: SD-Card interface disabled\n");
-
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-buzzc-panel.c b/arch/arm/mach-msm/board-buzzc-panel.c
deleted file mode 100644
index 5cfb02b..0000000
--- a/arch/arm/mach-msm/board-buzzc-panel.c
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-
-#include <asm/io.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-#include <mach/vreg.h>
-#ifdef CONFIG_HTC_PWRSINK
-#include <mach/htc_pwrsink.h>
-#endif
-
-#include <mach/pmic.h>
-#include "board-buzzc.h"
-#include "proc_comm.h"
-#include "devices.h"
-
-#if 0
-#define B(s...) printk(s)
-#else
-#define B(s...) do {} while(0)
-#endif
-
-static struct led_trigger *buzzc_lcd_backlight;
-static void buzzc_set_backlight(int on)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-
-	if (on)
-		led_trigger_event(buzzc_lcd_backlight, LED_FULL);
-	else
-		led_trigger_event(buzzc_lcd_backlight, LED_OFF);
-}
-
-struct mddi_table {
-	uint32_t reg;
-	uint32_t value;
-	uint32_t msec;
-};
-
-static struct mddi_table buzzc_init_tb[] = {
-        {0x01, 0x0000, 0},
-        {0x3e, 0x0040, 0},
-        {0x16, 0x0008, 0},
-        {0x27, 0x000e, 0},
-        {0x28, 0x000e, 0},
-        {0x71, 0x0068, 0},
-        {0x72, 0x0001, 0},
-        {0x60, 0x0001, 0},
-        {0x93, 0x000f, 10},
-        {0x1c, 0x0004, 10},
-        {0x1b, 0x0010, 40},
-        {0x43, 0x0080, 0},
-        {0x44, 0x003c, 0},
-        {0x45, 0x000e, 60},
-        {0xd0, 0x0000, 0},
-        {0xd1, 0x000b, 0},
-        {0xd2, 0x000a, 0},
-        {0xd3, 0x000f, 0},
-        {0xd4, 0x0011, 0},
-        {0xd5, 0x003f, 0},
-        {0xd6, 0x0018, 0},
-        {0xd7, 0x001f, 0},
-        {0xd8, 0x0007, 0},
-        {0xd9, 0x000e, 0},
-        {0xda, 0x0011, 0},
-        {0xdb, 0x0017, 0},
-        {0xdc, 0x0018, 0},
-        {0xdd, 0x0016, 0},
-        {0xde, 0x0016, 0},
-        {0xdf, 0x000d, 0},
-        {0xe0, 0x0013, 0},
-        {0xe1, 0x0000, 0},
-        {0xe2, 0x002e, 0},
-        {0xe3, 0x0030, 0},
-        {0xe4, 0x0035, 0},
-        {0xe5, 0x0034, 0},
-        {0xe6, 0x003f, 0},
-        {0xe7, 0x0038, 0},
-        {0xe8, 0x003f, 0},
-        {0xe9, 0x000c, 0},
-        {0xea, 0x0012, 0},
-        {0xeb, 0x0009, 0},
-        {0xec, 0x0009, 0},
-        {0xed, 0x0007, 0},
-        {0xee, 0x0008, 0},
-        {0xef, 0x000e, 0},
-        {0xf0, 0x0011, 0},
-        {0xf1, 0x0018, 0},
-        {0xf2, 0x000f, 0},
-        {0x5f, 0x0000, 0},
-        {0x94, 0x00ff, 0},
-        {0x95, 0x0024, 0},
-        {0x96, 0x0002, 1},
-        {0x02, 0x0000, 0},
-        {0x03, 0x0000, 0},
-        {0x04, 0x0000, 0},
-        {0x05, 0x00ef, 0},
-        {0x06, 0x0000, 0},
-        {0x07, 0x0000, 0},
-        {0x08, 0x0001, 0},
-        {0x09, 0x003f, 0},
-        {0x26, 0x0024, 1},
-        {0x26, 0x0038, 1},
-        {0x26, 0x003c, 0},
-};
-
-#define GPIOSEL_VWAKEINT (1U << 0)
-#define INTMASK_VWAKEOUT (1U << 0)
-
-static void
-buzzc_process_mddi_table(struct msm_mddi_client_data *client_data,
-		struct mddi_table *table, ssize_t count)
-
-{
-	int i;
-	uint32_t reg, value, msec;
-
-	BUG_ON(!client_data);
-	BUG_ON(!table);
-	BUG_ON(!count);
-
-	for(i = 0; i < count; i++) {
-		reg = table[i].reg;
-		value = table[i].value;
-		msec = table[i].msec;
-
-		client_data->remote_write(client_data, value, reg);
-		if (msec)
-			mdelay(msec);
-	}
-}
-
-static struct vreg *vreg_lcm_2v85;
-static struct vreg *vreg_lcm_2v6;
-
-static void
-buzzc_mddi_power_client(struct msm_mddi_client_data *cdata, int on)
-{
-	unsigned id, on_off;
-
-	B("KERN_DEBUG %s: enter.\n", __func__);
-
-	if(on) {
-
-		gpio_set_value(82, 1);
-		msleep(3);
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v6);
-
-		msleep(10);
-		id = PM_VREG_PDOWN_GP2_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v85);
-
-		msleep(10);
-		gpio_set_value(82, 1);
-		msleep(1);
-	} else {
-		gpio_set_value(82, 0);
-		msleep(10);
-		on_off = 1;
-
-		vreg_disable(vreg_lcm_2v85);
-		id = PM_VREG_PDOWN_GP2_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		msleep(1);
-
-		vreg_disable(vreg_lcm_2v6);
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		msleep(10);
-
-		gpio_set_value(82, 0);
-		msleep(200);
-
-		id = PM_VREG_PDOWN_MDDI_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-	}
-
-}
-
-#if defined(CONFIG_ARCH_MSM7225) || defined(CONFIG_ARCH_MSM7625)
-#define LCM_ID0 57
-#define LCM_ID1 58
-#else
-#define LCM_ID0 _bad_id()
-#define LCM_ID1 _bad_id()
-#endif
-
-static int
-buzzc_mddi_client_init(struct msm_mddi_bridge_platform_data *bridge_data,
-		     struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-        client_data->auto_hibernate(client_data, 0);
-
-	buzzc_process_mddi_table(client_data,
-			buzzc_init_tb,
-			ARRAY_SIZE(buzzc_init_tb));
-	client_data->auto_hibernate(client_data, 1);
-
-        return 0;
-
-}
-
-static int
-buzzc_mddi_client_uninit(struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *client_data)
-
-{
-        return 0;
-}
-
-static int panel_inited = 0;
-static int
-buzzc_panel_unblank(struct msm_mddi_bridge_platform_data *bridge_data,
-                  struct msm_mddi_client_data *client_data)
-{
-
-	BUG_ON(!bridge_data);
-	BUG_ON(!client_data);
-
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-
-        client_data->auto_hibernate(client_data, 0);
-
-	if (!panel_inited)
-	{
-		panel_inited = 1;
-	}
-	else
-	{
-		buzzc_process_mddi_table(client_data,
-			buzzc_init_tb,
-			ARRAY_SIZE(buzzc_init_tb));
-	}
-	buzzc_set_backlight(1);
-	client_data->auto_hibernate(client_data, 1);
-	return 0;
-
-}
-
-static int
-buzzc_panel_blank(struct msm_mddi_bridge_platform_data *bridge_data,
-                struct msm_mddi_client_data *client_data)
-{
-	//FIXME: add de-initial strings heere
-	buzzc_set_backlight(0);
-	return 0;
-}
-
-static void
-buzzc_fixup(uint16_t *mfr_name, uint16_t *product_code)
-{
-	B("%s: enter.\n", __func__);
-	*mfr_name = 0x0101;
-	*product_code = 0x0154;
-}
-
-static struct resource resources_msm_fb[] = {
-        {
-                .start = MSM_FB_BASE,
-                .end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-                .flags = IORESOURCE_MEM,
-        },
-};
-
-static struct msm_mddi_bridge_platform_data himax_client_data = {
-        .init = buzzc_mddi_client_init,
-        .uninit = buzzc_mddi_client_uninit,
-	.bridge_type = SAMSUNG_D,
-        .blank = buzzc_panel_blank,
-        .unblank = buzzc_panel_unblank,
-        .fb_data = {
-                .xres = 240,
-                .yres = 320,
-		.width = 42,
-		.height = 56,
-                .output_format = 0,
-        },
-};
-
-static struct msm_mddi_platform_data buzzc_pdata = {
-	.clk_rate = 61440000,		/*default MDDI frequenct*/
-	/*.clk_rate = 68571000,	set MDDI frequency to 68.57Mhz*/
-	.power_client = buzzc_mddi_power_client,
-	.fixup = buzzc_fixup,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 1,
-	.client_platform_data = {
-		{
-			.product_id = (0x4858 << 16 | 0x8356),
-			.name = "mddi_c_4858_8356",
-			.id = 0,
-			.client_data = &himax_client_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-int __init buzzc_panel_init(void)
-{
-	int rc;
-
-	if (!machine_is_buzzc())
-		return 0;
-
-	vreg_lcm_2v85 = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_lcm_2v85))
-		return PTR_ERR(vreg_lcm_2v85);
-
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-	msm_device_mddi0.dev.platform_data = &buzzc_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-
-	return 0;
-}
-
-device_initcall(buzzc_panel_init);
diff --git a/arch/arm/mach-msm/board-buzzc-rfkill.c b/arch/arm/mach-msm/board-buzzc-rfkill.c
deleted file mode 100644
index 761102c..0000000
--- a/arch/arm/mach-msm/board-buzzc-rfkill.c
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
- * Copyright (C) 2010 Google, Inc.
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for buzzc platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-buzzc.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-/* bt initial configuration */
-static uint32_t buzzc_bt_init_table[] = {
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_TX, /* BT_TX */
-				3,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt on configuration */
-static uint32_t buzzc_bt_on_table[] = {
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_RX, /* BT_RX */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_TX, /* BT_TX */
-				3,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt off configuration */
-static uint32_t buzzc_bt_off_table[] = {
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_UART1_TX, /* BT_TX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(BUZZC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void buzzc_config_bt_init(void)
-{
-	/* set bt initial configuration*/
-	config_bt_table(buzzc_bt_init_table,
-				ARRAY_SIZE(buzzc_bt_init_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(BUZZC_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BUZZC_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(BUZZC_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-}
-
-static void buzzc_config_bt_on(void)
-{
-	/* set bt on configuration*/
-	config_bt_table(buzzc_bt_on_table,
-				ARRAY_SIZE(buzzc_bt_on_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(BUZZC_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BUZZC_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-}
-
-static void buzzc_config_bt_off(void)
-{
-	/* BT_SHUTDOWN_N */
-	gpio_configure(BUZZC_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_RESET_N */
-	gpio_configure(BUZZC_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(buzzc_bt_off_table,
-				ARRAY_SIZE(buzzc_bt_off_table));
-	mdelay(5);
-
-	/* BT_RTS */
-	gpio_configure(BUZZC_GPIO_BT_UART1_RTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CTS */
-
-	/* BT_TX */
-	gpio_configure(BUZZC_GPIO_BT_UART1_TX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_RX */
-
-	/* BT_HOST_WAKE */
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(BUZZC_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-			buzzc_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-			buzzc_config_bt_off();
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int buzzc_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	buzzc_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int buzzc_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver buzzc_rfkill_driver = {
-	.probe = buzzc_rfkill_probe,
-	.remove = buzzc_rfkill_remove,
-	.driver = {
-		.name = "buzzc_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init buzzc_rfkill_init(void)
-{
-	if (!machine_is_buzzc())
-		return 0;
-
-	return platform_driver_register(&buzzc_rfkill_driver);
-}
-
-static void __exit buzzc_rfkill_exit(void)
-{
-	platform_driver_unregister(&buzzc_rfkill_driver);
-}
-
-module_init(buzzc_rfkill_init);
-module_exit(buzzc_rfkill_exit);
-MODULE_DESCRIPTION("buzzc rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-buzzc-wifi.c b/arch/arm/mach-msm/board-buzzc-wifi.c
deleted file mode 100644
index 272d8f9..0000000
--- a/arch/arm/mach-msm/board-buzzc-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-buzzc-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-buzzc.h"
-
-int buzzc_wifi_power(int on);
-int buzzc_wifi_reset(int on);
-int buzzc_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *buzzc_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init buzzc_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource buzzc_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(BUZZC_GPIO_WIFI_IRQ1),
-		.end		= MSM_GPIO_TO_INT(BUZZC_GPIO_WIFI_IRQ1),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data buzzc_wifi_control = {
-	.set_power      = buzzc_wifi_power,
-	.set_reset      = buzzc_wifi_reset,
-	.set_carddetect = buzzc_wifi_set_carddetect,
-	.mem_prealloc   = buzzc_wifi_mem_prealloc,
-};
-
-static struct platform_device buzzc_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(buzzc_wifi_resources),
-        .resource       = buzzc_wifi_resources,
-        .dev            = {
-                .platform_data = &buzzc_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned buzzc_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init buzzc_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_buzzc())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	buzzc_wifi_update_nvs("sd_oobonly=1\n");
-	buzzc_init_wifi_mem();
-	ret = platform_device_register(&buzzc_wifi_device);
-        return ret;
-}
-
-device_initcall(buzzc_wifi_init);
diff --git a/arch/arm/mach-msm/board-buzzc.c b/arch/arm/mach-msm/board-buzzc.c
deleted file mode 100644
index cbc328f..0000000
--- a/arch/arm/mach-msm/board-buzzc.c
+++ /dev/null
@@ -1,882 +0,0 @@
-/* arch/arm/mach-msm/board-buzzc.c
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/irq.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/sysdev.h>
-#include <linux/android_pmem.h>
-
-#include <mach/board.h>
-#include <mach/camera.h>
-
-#include <linux/delay.h>
-#include <linux/gpio.h>
-
-#include <mach/hardware.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <mach/system.h>
-#include <mach/vreg.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <mach/msm_serial_debugger.h>
-
-#include <asm/io.h>
-#include <asm/delay.h>
-#include <asm/setup.h>
-
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-
-#include <asm/mach/mmc.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/curcial_oj.h>
-#include "board-buzzc.h"
-#include "proc_comm.h"
-#include "gpio_chip.h"
-
-#include <mach/board_htc.h>
-#include <mach/msm_serial_hs.h>
-
-#include "devices.h"
-
-#include <mach/atmega_microp.h>
-#include <mach/msm_tssc.h>
-#include <mach/htc_battery.h>
-
-#include <mach/htc_pwrsink.h>
-#include <mach/perflock.h>
-#include <mach/drv_callback.h>
-#include <mach/msm_rpcrouter.h>
-#include <mach/msm_iomap.h>
-#include <mach/msm_flashlight.h>
-
-void msm_init_irq(void);
-void msm_init_gpio(void);
-void msm_init_pmic_vibrator(void);
-void config_buzzc_camera_on_gpios(void);
-void config_buzzc_camera_off_gpios(void);
-#ifdef CONFIG_MICROP_COMMON
-void __init buzzc_microp_init(void);
-#endif
-
-#define HSUSB_API_INIT_PHY_PROC	2
-#define HSUSB_API_PROG		0x30000064
-#define HSUSB_API_VERS MSM_RPC_VERS(1, 1)
-
-static void Buzzc_phy_reset(void)
-{
-	struct msm_rpc_endpoint *usb_ep;
-	int rc;
-	struct hsusb_phy_start_req {
-		struct rpc_request_hdr hdr;
-	} req;
-
-	printk(KERN_INFO "msm_hsusb_phy_reset\n");
-
-	usb_ep = msm_rpc_connect(HSUSB_API_PROG, HSUSB_API_VERS, 0);
-	if (IS_ERR(usb_ep)) {
-		printk(KERN_ERR "%s: init rpc failed! error: %ld\n",
-				__func__, PTR_ERR(usb_ep));
-		return;
-	}
-	rc = msm_rpc_call(usb_ep, HSUSB_API_INIT_PHY_PROC,
-			&req, sizeof(req), 5 * HZ);
-	if (rc < 0)
-		printk(KERN_ERR "%s: rpc call failed! (%d)\n", __func__, rc);
-
-close:
-	msm_rpc_close(usb_ep);
-}
-
-void config_buzzc_proximity_gpios(int on);
-
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-	.guage_driver = GUAGE_MODEM,
-	.charger = LINEAR_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0, 0x23, 0x53, 0xED, 0x14C, 0x1AB, 0x20A, 0x3FF, 0x3FF, 0x3FF },
-		.channel = 3,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xCF,
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 38, 82, 95, 167},
-		.channel = 1,
-		.int_pin = 1 << 5,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "reset-int",
-		.category = MICROP_FUNCTION_RESET_INT,
-		.int_pin = 1 << 8,
-	},
-};
-
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "button-backlight",
-		.type = LED_GPO,
-		.mask_w = {0x00, 0x00, 0x40},
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev = {
-			.platform_data = &lightsensor_data,
-		},
-	},
-	{
-		.name = "leds-microp",
-		.id = -1,
-		.dev = {
-			.platform_data = &microp_leds_data,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = BUZZC_GPIO_UP_RESET_N,
-	.spi_devices = SPI_GSENSOR,
-};
-
-static struct i2c_board_info i2c_microp_devices = {
-	I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-	.platform_data = &microp_data,
-	.irq = MSM_GPIO_TO_INT(BUZZC_GPIO_UP_INT),
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_buzzc_camera_on_gpios,
-	.camera_gpio_off = config_buzzc_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-
-static struct msm_camera_sensor_info msm_camera_sensor_mt9t013_data = {
-	.sensor_name    = "mt9t013",
-	.sensor_reset   = 118,
-	.vcm_pwd        = BUZZC_GPIO_VCM_PWDN,
-	.pdata          = &msm_camera_device_data,
-	.flash_type     = MSM_CAMERA_FLASH_LED
-};
-
-static struct platform_device msm_camera_sensor_mt9t013 = {
-	.name      = "msm_camera_mt9t013",
-	.dev       = {
-		.platform_data = &msm_camera_sensor_mt9t013_data,
-	},
-};
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = BUZZC_LAYOUTS,
-	.project_name = BUZZC_PROJECT_NAME,
-	//TODO
-	//.reset = BUZZC_GPIO_COMPASS_RST_N,
-	//.intr = BUZZC_GPIO_COMPASS_INT_N,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		/*I2C_BOARD_INFO("s5k4b2fx", 0x22 >> 1),*/
-		I2C_BOARD_INFO("s5k4b2fx", 0x22),
-		/* .irq = TROUT_GPIO_TO_INT(TROUT_GPIO_CAM_BTN_STEP1_N), */
-	},
-	{
-		I2C_BOARD_INFO("mt9t013", 0x6C),   /*3M bayer sensor driver*/
-		.platform_data = &msm_camera_device_data,
-	},
-};
-
-static struct i2c_board_info i2c_sensor[] = {
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		// .irq = MSM_GPIO_TO_INT(BUZZC_GPIO_COMPASS_INT_N), TODO
-	},
-};
-
-static struct h2w_platform_data buzzc_h2w_data = {
-};
-
-static struct platform_device buzzc_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &buzzc_h2w_data,
-	},
-};
-
-static struct audio_jack_platform_data buzzc_jack_data = {
-	.gpio	= BUZZC_GPIO_35MM_HEADSET_DET,
-};
-
-
-static struct platform_device buzzc_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &buzzc_jack_data,
-	},
-};
-
-static struct pwr_sink buzzc_pwrsink_table[] = {
-	{
-		.id     = PWRSINK_AUDIO,
-		.ua_max = 100000,
-	},
-	{
-		.id     = PWRSINK_BACKLIGHT,
-		.ua_max = 125000,
-	},
-	{
-		.id     = PWRSINK_LED_BUTTON,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_LED_KEYBOARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_GP_CLK,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_BLUETOOTH,
-		.ua_max = 15000,
-	},
-	{
-		.id     = PWRSINK_CAMERA,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_SDCARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_VIDEO,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id     = PWRSINK_SYSTEM_LOAD,
-		.ua_max = 100000,
-		.percent_util = 38,
-	},
-};
-
-static int buzzc_pwrsink_resume_early(struct platform_device *pdev)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-	return 0;
-}
-
-static void buzzc_pwrsink_resume_late(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 38);
-}
-
-static void buzzc_pwrsink_suspend_early(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-}
-
-static int buzzc_pwrsink_suspend_late(struct platform_device *pdev, pm_message_t state)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 1);
-	return 0;
-}
-
-static struct pwr_sink_platform_data buzzc_pwrsink_data = {
-	.num_sinks      = ARRAY_SIZE(buzzc_pwrsink_table),
-	.sinks          = buzzc_pwrsink_table,
-	.suspend_late	= buzzc_pwrsink_suspend_late,
-	.resume_early	= buzzc_pwrsink_resume_early,
-	.suspend_early	= buzzc_pwrsink_suspend_early,
-	.resume_late	= buzzc_pwrsink_resume_late,
-};
-
-static struct platform_device buzzc_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev    = {
-		.platform_data = &buzzc_pwrsink_data,
-	},
-};
-
-static struct msm_pmem_setting pmem_setting = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-};
-
-static ssize_t buzzc_virtual_keys_show(struct kobject *kobj,
-			       struct kobj_attribute *attr, char *buf)
-{
-	return sprintf(buf,
-		__stringify(EV_KEY) ":" __stringify(KEY_HOME)  ":7:440:70:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":77:440:100:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":159:440:70:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":230:440:70:55"
-	   "\n");
-}
-
-static struct kobj_attribute buzzc_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.tssc-manager",
-		.mode = S_IRUGO,
-	},
-	.show = &buzzc_virtual_keys_show,
-};
-
-static struct attribute *buzzc_properties_attrs[] = {
-	&buzzc_virtual_keys_attr.attr,
-	NULL
-};
-
-static struct attribute_group buzzc_properties_attr_group = {
-	.attrs = buzzc_properties_attrs,
-};
-
-static struct tssc_ts_platform_data tssc_ts_device_data = {
-	.version = 1,
-	.x_min = 0,
-	.x_max = 1023,
-	.y_min = 0,
-	.y_max = 1023,
-	.cal_range_x = 653,
-	.cal_range_y = 672,
-	.cal_err = 50,
-	.screen_width = 240,
-	.screen_height = 400,
-	.cal_x = { 15, 223, 15, 223, 119},
-	.cal_y = { 20, 20, 378, 378, 199},
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-};
-
-static struct platform_device tssc_ts_device = {
-	.name	= "tssc-manager",
-	.id	= -1,
-	.dev	= {
-		.platform_data	= &tssc_ts_device_data,
-	},
-};
-
-static struct msm_i2c_device_platform_data buzzc_i2c_device_data = {
-	.i2c_clock = 400000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-static struct platform_device buzzc_rfkill = {
-	.name = "buzzc_rfkill",
-	.id = -1,
-};
-
-static int __capella_cm3602_power(int on)
-{
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on) {
-		config_buzzc_proximity_gpios(1);
-		gpio_direction_output(BUZZC_GPIO_PROXIMITY_EN, 1);
-		gpio_direction_output(BUZZC_GPIO_LS_EN, 0);
-		gpio_direction_output(BUZZC_PS_2V85_EN, 1);
-	} else {
-		gpio_direction_output(BUZZC_PS_2V85_EN, 0);
-		gpio_direction_output(BUZZC_GPIO_LS_EN, 1);
-		gpio_direction_output(BUZZC_GPIO_PROXIMITY_EN, 0);
-		config_buzzc_proximity_gpios(0);
-	}
-	return 0;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static unsigned int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable)
-		als_power_control |= pwr_device;
-	else
-		als_power_control &= ~pwr_device;
-
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-		ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-}
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.p_out = BUZZC_GPIO_PROXIMITY_INT,
-	.p_en = BUZZC_GPIO_PROXIMITY_EN,
-	.power = capella_cm3602_power,
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-
-/*
-static struct gpio_led buzz_led_list[] = {
-	{
-		.name = "caps",
-		.gpio = BUZZ_GPIO_LED_CAP_LED_EN,
-	},
-	{
-		.name = "func",
-		.gpio = BUZZ_GPIO_LED_FN_LED_EN,
-	},
-};
-
-static struct gpio_led_platform_data buzz_leds_data = {
-	.num_leds	= ARRAY_SIZE(buzz_led_list),
-	.leds		= buzz_led_list,
-};
-
-static struct platform_device buzz_leds = {
-	.name		= "leds-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &buzz_leds_data,
-	},
-};*/
-
-
-static void config_buzzc_flashlight_gpios(void)
-{
-	static uint32_t buzzc_flashlight_gpio_table[] = {
-		PCOM_GPIO_CFG(BUZZC_GPIO_FL_TORCH, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-								GPIO_2MA),
-		PCOM_GPIO_CFG(BUZZC_GPIO_FL_FLASH, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-								GPIO_2MA),
-	};
-	config_gpio_table(buzzc_flashlight_gpio_table,
-		ARRAY_SIZE(buzzc_flashlight_gpio_table));
-}
-
-static struct flashlight_platform_data buzzc_flashlight_data = {
-	.gpio_init = config_buzzc_flashlight_gpios,
-	.torch = BUZZC_GPIO_FL_TORCH,
-	.flash = BUZZC_GPIO_FL_FLASH,
-	.flash_duration_ms = 600,
-};
-
-static struct platform_device buzzc_flashlight_device = {
-	.name = FLASHLIGHT_NAME,
-	.dev = {
-		.platform_data  = &buzzc_flashlight_data,
-	},
-};
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_smd,
-	&msm_device_nand,
-	&msm_device_i2c,
-	&buzzc_h2w,
-	&htc_battery_pdev,
-	&buzzc_audio_jack,
-	&tssc_ts_device,
-	&msm_camera_sensor_mt9t013,
-	&buzzc_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&buzzc_pwr_sink,
-#endif
-	/* &buzzc_oj, TODO:JOGALL */
-#ifdef CONFIG_INPUT_CAPELLA_CM3602
-	&capella_cm3602,
-#endif
-	/* &buzz_leds, */
-	&buzzc_flashlight_device,
-};
-
-extern struct sys_timer msm_timer;
-
-static void __init buzzc_init_irq(void)
-{
-	printk("buzzc_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint cpld_iset;
-static uint cpld_charger_en;
-static uint cpld_usb_h2w_sw;
-static uint opt_disable_uart3;
-static char *keycaps = "";
-
-module_param_named(iset, cpld_iset, uint, 0);
-module_param_named(charger_en, cpld_charger_en, uint, 0);
-module_param_named(usb_h2w_sw, cpld_usb_h2w_sw, uint, 0);
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-module_param_named(keycaps, keycaps, charp, 0);
-
-static char bt_chip_id[10] = "bcm4329";
-module_param_string(bt_chip_id, bt_chip_id, sizeof(bt_chip_id), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_chip_id, "BT's chip id");
-
-static char bt_fw_version[10] = "v2.0.38";
-module_param_string(bt_fw_version, bt_fw_version, sizeof(bt_fw_version), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_fw_version, "BT's fw version");
-
-static void buzzc_reset(void)
-{
-	gpio_set_value(BUZZC_GPIO_PS_HOLD, 0);
-}
-
-static uint32_t proximity_on_gpio_table[] = {
-	PCOM_GPIO_CFG(BUZZC_GPIO_PROXIMITY_INT,
-		0, GPIO_INPUT, GPIO_NO_PULL, 0), /* PS_VOUT */
-};
-
-static uint32_t proximity_off_gpio_table[] = {
-	PCOM_GPIO_CFG(BUZZC_GPIO_PROXIMITY_INT,
-		0, GPIO_INPUT, GPIO_PULL_DOWN, 0) /* PS_VOUT */
-};
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-void config_buzzc_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void config_buzzc_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-/* for bcm */
-static char bdaddress[20];
-extern unsigned char *get_bt_bd_ram(void);
-
-static void bt_export_bd_address(void)
-{
-	unsigned char cTemp[6];
-
-	memcpy(cTemp, get_bt_bd_ram(), 6);
-	sprintf(bdaddress, "%02x:%02x:%02x:%02x:%02x:%02x",
-		cTemp[0], cTemp[1], cTemp[2], cTemp[3], cTemp[4], cTemp[5]);
-	printk(KERN_INFO "YoYo--BD_ADDRESS=%s\n", bdaddress);
-}
-
-module_param_string(bdaddress, bdaddress, sizeof(bdaddress), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bdaddress, "BT MAC ADDRESS");
-
-void config_buzzc_proximity_gpios(int on)
-{
-	if (on)
-		config_gpio_table(proximity_on_gpio_table,
-			ARRAY_SIZE(proximity_on_gpio_table));
-	else
-		config_gpio_table(proximity_off_gpio_table,
-			ARRAY_SIZE(proximity_off_gpio_table));
-}
-
-static uint32_t buzzc_serial_debug_table[] = {
-	/* config as serial debug uart */
-	PCOM_GPIO_CFG(BUZZC_GPIO_UART3_RX, 1,
-			GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* UART3 RX */
-	PCOM_GPIO_CFG(BUZZC_GPIO_UART3_TX, 1,
-			GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* UART3 TX */
-};
-
-static void buzzc_config_serial_debug_gpios(void)
-{
-	config_gpio_table(buzzc_serial_debug_table,
-			ARRAY_SIZE(buzzc_serial_debug_table));
-}
-
-
-static void __init config_gpios(void)
-{
-	buzzc_config_serial_debug_gpios();
-	config_buzzc_camera_off_gpios();
-}
-
-static struct msm_acpu_clock_platform_data buzzc_clock_data = {
-	.acpu_switch_time_us = 50,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200,
-#if defined(CONFIG_TURBO_MODE)
-	.wait_for_irq_khz = 176000,
-#else
-	.wait_for_irq_khz = 128000,
-#endif
-};
-
-static unsigned buzzc_perf_acpu_table[] = {
-	245760000,
-	480000000,
-	528000000,
-};
-
-static struct perflock_platform_data buzzc_perflock_data = {
-	.perf_acpu_table = buzzc_perf_acpu_table,
-	.table_size = ARRAY_SIZE(buzzc_perf_acpu_table),
-};
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(BUZZC_GPIO_BT_HOST_WAKE),
-	.inject_rx_on_wakeup = 0,
-	.cpu_lock_supported = 1,
-
-	/* for bcm */
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = BUZZC_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = BUZZC_GPIO_BT_HOST_WAKE,
-
-};
-#endif
-
-static void __init buzzc_init(void)
-{
-	int rc;
-	struct kobject *properties_kobj;
-
-	printk("buzzc_init() revision=%d\n", system_rev);
-	printk(KERN_INFO "mfg_mode=%d\n", board_mfg_mode());
-	if (board_mfg_mode() == 1) {
-		tssc_ts_device_data.cal_err = 25;
-		printk(KERN_INFO "cal_err=%d\n", tssc_ts_device_data.cal_err);
-	}
-
-
-	/* for bcm */
-	bt_export_bd_address();
-
-	/*
-	 * Setup common MSM GPIOS
-	 */
-	config_gpios();
-
-	/* We need to set this pin to 0 only once on power-up; we will
-	 * not actually enable the chip until we apply power to it via
-	 * vreg.
-	 */
-	gpio_direction_output(BUZZC_GPIO_LS_EN, 0);
-	/* disable power for cm3602 chip */
-	__capella_cm3602_power(0);
-
-	msm_hw_reset_hook = buzzc_reset;
-
-	msm_acpu_clock_init(&buzzc_clock_data);
-	perflock_init(&buzzc_perflock_data);
-	/* adjust GPIOs based on bootloader request */
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-			&msm_device_uart3.dev, 1,
-				MSM_GPIO_TO_INT(BUZZC_GPIO_UART3_RX));
-#endif
-
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_device_uart_dm1.name = "msm_serial_hs_bcm";	/* for bcm */
-	msm_add_serial_devices(3);
-#else
-	msm_add_serial_devices(0);
-#endif
-
-	msm_add_serial_devices(2);
-	msm_add_usb_id_pin_gpio(BUZZC_GPIO_USB_ID_PIN);
-	msm_add_usb_devices(Buzzc_phy_reset, NULL);
-
-	msm_add_mem_devices(&pmem_setting);
-	msm_init_pmic_vibrator();
-#ifdef CONFIG_MICROP_COMMON
-	buzzc_microp_init();
-#endif
-
-	rc = buzzc_init_mmc(system_rev);
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-
-	properties_kobj = kobject_create_and_add("board_properties", NULL);
-
-	if (properties_kobj)
-		rc = sysfs_create_group(properties_kobj,
-					 &buzzc_properties_attr_group);
-	if (!properties_kobj || rc)
-		pr_err("failed to create board_properties\n");
-
-	msm_device_i2c.dev.platform_data = &buzzc_i2c_device_data;
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	i2c_register_board_info(0, i2c_sensor, ARRAY_SIZE(i2c_sensor));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-	i2c_register_board_info(0 , &i2c_microp_devices, 1);
-
-	buzzc_init_keypad();
-}
-
-static void __init buzzc_fixup(struct machine_desc *desc, struct tag *tags,
-				char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 2;
-	mi->bank[0].start = MSM_LINUX_BASE1;
-	mi->bank[0].node = PHYS_TO_NID(MSM_LINUX_BASE1);
-	mi->bank[0].size = MSM_LINUX_SIZE1;
-	mi->bank[1].start = MSM_LINUX_BASE2;
-	mi->bank[1].node = PHYS_TO_NID(MSM_LINUX_BASE2);
-	mi->bank[1].size = MSM_LINUX_SIZE2;
-}
-
-static void __init buzzc_map_io(void)
-{
-	printk("buzzc_init_map_io()\n");
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-MACHINE_START(BUZZC, "buzzc")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params    = 0x02E00100,
-	.fixup          = buzzc_fixup,
-	.map_io         = buzzc_map_io,
-	.init_irq       = buzzc_init_irq,
-	.init_machine   = buzzc_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-buzzc.h b/arch/arm/mach-msm/board-buzzc.h
deleted file mode 100644
index 4ec672d..0000000
--- a/arch/arm/mach-msm/board-buzzc.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/* linux/arch/arm/mach-msm/board-buzzc.h
- * Copyright (C) 2010 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_BUZZC_H
-#define __ARCH_ARM_MACH_MSM_BOARD_BUZZC_H
-
-#include <mach/board.h>
-
-#define MSM_LINUX_BASE1                 0x02E00000
-#define MSM_LINUX_SIZE1                 0x0D200000
-#define MSM_LINUX_BASE2                 0x20000000
-#define MSM_LINUX_SIZE2                 0x06F00000
-
-#define MSM_PMEM_MDP_BASE               0x00000000
-#define MSM_PMEM_MDP_SIZE               0x00800000
-
-#define MSM_FB_BASE                     0x26F00000
-#define MSM_FB_SIZE                     0x9b000
-
-#define MSM_RAM_CONSOLE_BASE            MSM_FB_BASE + MSM_FB_SIZE
-#define MSM_RAM_CONSOLE_SIZE            128 * SZ_1K
-
-#define MSM_PMEM_ADSP_BASE              0x27000000
-#define MSM_PMEM_ADSP_SIZE              0x00800000
-
-#define MSM_PMEM_CAMERA_BASE            0x27800000
-#define MSM_PMEM_CAMERA_SIZE            0x00800000
-
-#define MSM_LINUX_BASE                  MSM_EBI1_CS0_BASE + 0x400000
-#define MSM_LINUX_SIZE                  0x5100000
-
-#define BUZZC_GPIO_USB_ID_PIN          (19)
-
-/* key */
-#define BUZZC_GPIO_POWER_KEY         (20)
-#define BUZZC_GPIO_Q_KP_MKOUT0       (35)
-#define BUZZC_GPIO_Q_KP_MKOUT1       (34)
-#define BUZZC_GPIO_Q_KP_MKOUT2       (33)
-#define BUZZC_GPIO_Q_KP_MKIN0_1      (42)
-#define BUZZC_GPIO_Q_KP_MKIN1_1      (41)
-#define BUZZC_GPIO_Q_KP_MKIN2_1      (40)
-
-#define BUZZC_GPIO_BALL_UP     (94)
-#define BUZZC_GPIO_BALL_LEFT   (17)
-#define BUZZC_GPIO_BALL_DOWN   (83)
-#define BUZZC_GPIO_BALL_RIGHT  (18)
-
-#define BUZZC_GPIO_WIFI_IRQ1         (29)
-#define BUZZC_GPIO_WIFI_EN           (116)
-#define BUZZC_GPIO_SDMC_CD_N         (38)
-#define BUZZC_GPIO_UP_INT            (27)
-#define BUZZC_GPIO_UART3_RX          (86)
-#define BUZZC_GPIO_UART3_TX          (87)
-#define BUZZC_GPIO_VCM_PWDN          (31)
-#define BUZZC_GPIO_UP_RESET_N        (76)
-#define BUZZC_GPIO_PS_HOLD           (25)
-/* flashlight */
-#define BUZZC_GPIO_FL_TORCH	(84)
-#define BUZZC_GPIO_FL_FLASH	(85)
-
-/* 35mm headset */
-#define BUZZC_GPIO_35MM_HEADSET_DET  (112)
-// TODO
-/* #define BUZZC_GPIO_COMPASS_RST_N     (93) */
-/* #define BUZZC_GPIO_COMPASS_INT_N     (37) */
-#define BUZZC_PROJECT_NAME           "buzzc"
-
-
-#define BUZZC_LAYOUTS		{ \
-		{ {  1,  0, 0}, {  0,  1, 0}, {0, 0,  1} },  \
-		{ {  0, -1, 0}, { -1,  0, 0}, {0, 0,  1} },  \
-		{ {  0,  1, 0}, { -1,  0, 0}, {0, 0,  1} },  \
-		{ {  1,  0, 0}, {  0,  0, 1}, {0, 1,  0} }   \
-					}
-
-/* Proximity  */
-#define BUZZC_GPIO_PROXIMITY_INT     114 // PS_VOUT
-#define BUZZC_GPIO_PROXIMITY_EN      115 // PS_SHDN
-
-#define BUZZC_GPIO_LS_EN             111
-#define BUZZC_PS_2V85_EN             117
-
-/* BT */
-#define BUZZC_GPIO_BT_UART1_RTS      (43)
-#define BUZZC_GPIO_BT_UART1_CTS      (44)
-#define BUZZC_GPIO_BT_UART1_RX       (45)
-#define BUZZC_GPIO_BT_UART1_TX       (46)
-#define BUZZC_GPIO_BT_RESET_N        (131)
-#define BUZZC_GPIO_BT_HOST_WAKE      (21)
-#define BUZZC_GPIO_BT_CHIP_WAKE      (91)
-#define BUZZC_GPIO_BT_SHUTDOWN_N     (113)
-
-#define BUZZC_MDDI_RSTz              (82)
-
-int buzzc_init_mmc(unsigned int);
-int __init buzzc_init_keypad(void);
-
-//struct sys_device;
-unsigned int buzzc_get_hwid(void);
-unsigned int buzzc_get_skuid(void);
-unsigned buzzc_engineerid(void);
-int buzzc_is_3M_camera(void);
-
-#endif /* GUARD */
diff --git a/arch/arm/mach-msm/board-click-panel.c b/arch/arm/mach-msm/board-click-panel.c
deleted file mode 100644
index 86721ee..0000000
--- a/arch/arm/mach-msm/board-click-panel.c
+++ /dev/null
@@ -1,686 +0,0 @@
-/*
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/gpio.h>
-#include <linux/io.h>
-
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-#include <mach/vreg.h>
-#ifdef CONFIG_HTC_PWRSINK
-#include <mach/htc_pwrsink.h>
-#endif
-
-#include <mach/pmic.h>
-
-#include "board-bahamas.h"
-#include "proc_comm.h"
-#include "devices.h"
-
-#if 0
-#define B(s...) printk(s)
-#else
-#define B(s...) do {} while (0)
-#endif
-
-static struct led_trigger *eid_lcd_backlight;
-static void eid_set_backlight(int on)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-
-	if (on)
-		led_trigger_event(eid_lcd_backlight, LED_FULL);
-	else
-		led_trigger_event(eid_lcd_backlight, LED_OFF);
-}
-
-struct mddi_table {
-	uint32_t reg;
-	uint32_t value;
-	uint32_t msec;
-};
-
-static struct mddi_table hitachi_init_tb[] = {
-	/* switching (a)->(b) */
-	{0x11, 0x001A, 0},
-	{0x12, 0x2000, 0},
-	{0x13, 0x0070, 0},
-	{0x14, 0x24e9, 0},
-	{0x15, 0x0070, 0},
-	{0x10, 0x0710, 10},
-	{0x11, 0x0110, 10},
-	{0x11, 0x0312, 10},
-	{0x11, 0x0712, 10},
-	{0x11, 0x0F1A, 20},
-	{0x11, 0x0F3A, 30},
-	{0x01, 0x0528, 0},
-	{0x02, 0x0100, 0},
-	{0x03, 0x1130, 0},
-	{0x07, 0x0000, 0},
-	{0x08, 0x0808, 0},
-	{0x0B, 0x2107, 0},
-	{0x0C, 0x0000, 0},
-	{0x0F, 0x1801, 10},
-	/* Jay, for adding delay after vsync */
-	{0x29, 0x64, 0},
-	/* Gamma setting */
-	{0x50, 0x0005, 0},
-	{0x51, 0x0109, 0},
-	{0x52, 0x0000, 0},
-	{0x53, 0x0008, 0},
-	{0x54, 0x0000, 0},
-	{0x55, 0x0901, 0},
-	{0x56, 0x0500, 0},
-	{0x57, 0x0800, 0},
-	{0x58, 0x0000, 0},
-	{0x59, 0x0000, 0},
-
-	{0x30, 0x0000, 0},
-	{0x31, 0x013F, 0},
-	{0x32, 0x0000, 0},
-	{0x33, 0x0000, 0},
-	{0x36, 0x00EF, 0},
-	{0x37, 0x0000, 0},
-	{0x38, 0x013F, 0},
-	{0x39, 0x0000, 30}, /* wait 2 frames */
-	{0x07, 0x0012, 30}, /* wait 2 frames */
-	{0x07, 0x1013, 0},
-	{0x20, 0x0000, 0},
-	{0x21, 0x0000, 0},
-};
-
-static struct mddi_table hitachi_deinit_tb[] = {
-	/* switching (b)->(a) */
-	{0x07, 0x0012, 30}, /* wait 2 frames */
-	{0x11, 0x0F1A, 10},
-	{0x11, 0x0712, 10},
-	{0x11, 0x0312, 10},
-	{0x11, 0x0110, 10},
-	{0x07, 0x0000,  0},
-};
-
-static struct mddi_table wintek_init_tb[] = {
-	{0x0F, 0x0b01,  0},	/*set frame rate to 68.2Hz*/
-	{0x11, 0x0019,  0},
-	{0x12, 0x1101,  0},
-	{0x13, 0x007F,  0},
-
-	{0x14, 0x6b68,  0}, /* flicker */
-	{0x10, 0x0500,  0},
-	{0x15, 0x0040,  0}, /* flicker */
-
-	{0x11, 0x011a, 10},
-	{0x11, 0x031a, 10},
-	{0x11, 0x071a, 10},
-	{0x11, 0x0F1a, 20},
-	{0x11, 0x0F3a, 30},
-
-	{0x01, 0x0128,  0},
-	{0x02, 0x0100,  0},
-	{0x03, 0x1030,  0},
-	{0x08, 0x0404,  0},
-	{0x0B, 0x1100,  0},
-	{0x0C, 0x0000,  0},
-	{0x30, 0x0000,  0},
-
-	{0x36, 0x00EF,  0},
-	{0x37, 0x0000,  0},
-	{0x38, 0x013F,  0},
-	{0x39, 0x0000,  0},
-	/* Jay, for adding delay after vsync */
-	{0x29, 0x64, 0},
-	/* gamma curve */
-	{0x50, 0x0105,  0},
-	{0x51, 0x0808,  0},
-	{0x52, 0x0f0D,  0},
-	{0x53, 0x0604,  0},
-	{0x54, 0x0D0f,  0},
-	{0x55, 0x0808,  0},
-	{0x56, 0x0501,  0},
-	{0x57, 0x0406,  0},
-	{0x58, 0x0600,  0},
-	{0x59, 0x0006,  0},
-
-	{0x07, 0x1012, 40},
-	{0x07, 0x1013,  0},
-
-	{0x20, 0x0000,  0},
-	{0x21, 0x0000,  0},
-	{0x22, 0x0000,  0},
-};
-
-static struct mddi_table wintek_deinit_tb[] = {
-	{0x07, 0x1012, 32},
-	{0x07, 0x1000, 16},
-	{0x10, 0x0001, 20},
-};
-
-static struct mddi_table samsung_init_tb[] = {
-	/* Power on sequence */
-	{0x0f, 0x0f01, 0},
-	{0x0b, 0x8101, 0},	/*set frame rate to 69Hz*/
-	/* Power setting sequence */
-	{0x11, 0x0018, 0},
-	{0x12, 0x3101, 0},
-	{0x13, 0x0061, 0},
-	{0x14, 0x547f, 0},
-	{0x10, 0x0800, 10},
-	{0x11, 0x0118, 10},
-	{0x11, 0x0318, 10},
-	{0x11, 0x0718, 10},
-	{0x11, 0x0f18, 20},
-	{0x11, 0x0f38, 30},
-	/* Initialzing sequence */
-	{0x01, 0x0128, 0},
-	{0x02, 0x0100, 0},
-	{0x03, 0x1030, 0},
-	{0x07, 0x0000, 0},
-	{0x08, 0x0808, 0},
-	{0x0c, 0x0000, 0},
-	{0x15, 0x0050, 0},
-	/* Jay, for adding delay after vsync */
-	{0x29, 0x64, 0},
-	{0x30, 0x0000, 0},
-	{0x34, 0x013f, 0},
-	{0x35, 0x0000, 0},
-	{0x36, 0x00ef, 0},
-	{0x37, 0x0000, 0},
-	{0x38, 0x013f, 0},
-	{0x39, 0x0000, 0},
-	{0x50, 0x0301, 0},
-	{0x51, 0x040e, 0},
-	{0x52, 0x0b05, 0},
-	{0x53, 0x0600, 0},
-	{0x54, 0x050b, 0},
-	{0x55, 0x0e04, 0},
-	{0x56, 0x0103, 0},
-	{0x57, 0x0006, 0},
-	{0x58, 0x0f1a, 0},
-	{0x59, 0x001b, 0},
-	{0x07, 0x0012, 40},
-	{0x07, 0x1013, 0},
-};
-
-static struct mddi_table samsung_deinit_tb[] = {
-	{0x07, 0x0012, 40},
-	{0x07, 0x0000, 20},
-} ;
-
-#define GPIOSEL_VWAKEINT (1U << 0)
-#define INTMASK_VWAKEOUT (1U << 0)
-
-static void
-eid_process_mddi_table(struct msm_mddi_client_data *client_data,
-		struct mddi_table *table, ssize_t count)
-
-{
-	int i;
-	uint32_t reg, value, msec;
-
-	BUG_ON(!client_data);
-	BUG_ON(!table);
-	BUG_ON(!count);
-
-	for (i = 0; i < count; i++) {
-		reg = table[i].reg;
-		value = table[i].value;
-		msec = table[i].msec;
-
-		client_data->remote_write(client_data, value, reg);
-		if (msec)
-			mdelay(msec);
-	}
-}
-
-static struct vreg *vreg_lcm_2v85;
-#if defined(CONFIG_MACH_BAHAMAS) || defined(CONFIG_MACH_CLICKC)
-static struct vreg *vreg_lcm_2v6;
-#endif
-
-static void
-eid_mddi_power_client(struct msm_mddi_client_data *cdata, int on)
-{
-	unsigned id, on_off;
-
-	B("KERN_DEBUG %s: enter.\n", __func__);
-	if (on) {
-		on_off = 0;
-		id = PM_VREG_PDOWN_MDDI_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-
-		gpio_set_value(BAHAMAS_V_VDDE2E_VDD2_GPIO, 1);
-
-		msleep(3);
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v6);
-		if (machine_is_bahamas() || machine_is_clickc()) {
-			msleep(1);
-			id = PM_VREG_PDOWN_RFRX2_ID;
-			msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-			vreg_enable(vreg_lcm_2v85);
-		}
-		msleep(3);
-		gpio_set_value(BAHAMAS_MDDI_RSTz, 1);
-		msleep(10);
-	} else {
-		gpio_set_value(BAHAMAS_MDDI_RSTz, 0);
-		msleep(10);
-		on_off = 1;
-		if (machine_is_bahamas() || machine_is_clickc()) {
-			vreg_disable(vreg_lcm_2v6);
-			id = PM_VREG_PDOWN_RFRX2_ID;
-			msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-			msleep(1);
-		}
-		vreg_disable(vreg_lcm_2v85);
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		msleep(5);
-
-		gpio_set_value(BAHAMAS_V_VDDE2E_VDD2_GPIO, 0);
-		msleep(200);
-
-		id = PM_VREG_PDOWN_MDDI_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-	}
-}
-
-enum {
-	PANEL_HITACHI = 0,
-	PANEL_WINTEK,
-	PANEL_SAMSUNG,
-};
-
-#if defined(CONFIG_ARCH_MSM7225)
-#define LCM_ID0 57
-#define LCM_ID1 58
-#else
-#define LCM_ID0 _bad_id()
-#define LCM_ID1 _bad_id()
-#endif
-
-static int
-eid_panel_detect(void)
-{
-	int panel_id = -1 ;
-
-	panel_id = ((gpio_get_value(LCM_ID1) << 1) | gpio_get_value(LCM_ID0));
-
-	switch (panel_id) {
-	case PANEL_HITACHI:
-		break ;
-	case PANEL_WINTEK:
-		break ;
-	case PANEL_SAMSUNG:
-		break ;
-	default:
-		printk("%s: Invalid panel id !\n", __func__);
-		break ;
-	}
-
-	return panel_id ;
-}
-
-static int
-eid_mddi_client_init(struct msm_mddi_bridge_platform_data *bridge_data,
-		     struct msm_mddi_client_data *client_data)
-{
-	int panel_id;
-
-	/* B(KERN_DEBUG "%s: enter.\n", __func__); */
-	client_data->auto_hibernate(client_data, 0);
-	panel_id = eid_panel_detect();
-
-	switch (panel_id) {
-	case PANEL_HITACHI:
-		B(KERN_DEBUG "found hitachi mddi panel\n");
-		eid_process_mddi_table(client_data,
-				hitachi_init_tb,
-				ARRAY_SIZE(hitachi_init_tb));
-		break;
-	case PANEL_WINTEK:
-		B(KERN_DEBUG "found wintek mddi panel\n");
-		eid_process_mddi_table(client_data,
-				wintek_init_tb,
-				ARRAY_SIZE(wintek_init_tb));
-		break;
-	case PANEL_SAMSUNG:
-		B(KERN_DEBUG "found samsung mddi panel\n");
-		eid_process_mddi_table(client_data,
-				samsung_init_tb,
-				ARRAY_SIZE(samsung_init_tb));
-		break;
-	default:
-		B(KERN_DEBUG "unknown panel_id: %d\n", panel_id);
-	};
-	client_data->auto_hibernate(client_data, 1);
-
-	return 0;
-}
-
-static int
-eid_mddi_client_uninit(struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *client_data)
-
-{
-	return 0;
-}
-
-static struct mddi_table hitachi_adjust_tb[] = {
-	{0x36, 0x00EF, 0},
-	{0x37, 0x0000, 0},
-	{0x38, 0x013F, 0},
-	{0x39, 0x0000, 0}, /* wait 2 frames */
-	{0x20, 0x0000, 0},
-	{0x21, 0x0000, 0},
-};
-
-static struct mddi_table wintek_adjust_tb[] = {
-	{0x36, 0x00EF,  0},
-	{0x37, 0x0000,  0},
-	{0x38, 0x013F,  0},
-	{0x39, 0x0000,  0},
-	{0x20, 0x0000,  0},
-	{0x21, 0x0000,  0},
-	{0x22, 0x0000,  0},
-};
-
-static struct mddi_table samsung_adjust_tb[] = {
-	{0x36, 0x00EF, 0},
-	{0x37, 0x0000, 0},
-	{0x38, 0x013F, 0},
-	{0x39, 0x0000, 0},
-	{0x20, 0x0000, 0},
-	{0x21, 0x0000, 0},
-};
-
-static void
-eid_samsung_adjust(struct msm_mddi_client_data *client_data)
-{
-	int panel_id;
-
-	BUG_ON(!client_data);
-
-	panel_id = eid_panel_detect();
-	switch (panel_id) {
-	case PANEL_HITACHI:
-		B(KERN_DEBUG "hitachi panel\n");
-		eid_process_mddi_table(client_data,
-				hitachi_adjust_tb,
-				ARRAY_SIZE(hitachi_adjust_tb));
-		break;
-	case PANEL_WINTEK:
-		B(KERN_DEBUG "wintek panel\n");
-		eid_process_mddi_table(client_data,
-				wintek_adjust_tb,
-				ARRAY_SIZE(wintek_adjust_tb));
-		break;
-	case PANEL_SAMSUNG:
-		B(KERN_DEBUG "samsung panel\n");
-		eid_process_mddi_table(client_data,
-				samsung_adjust_tb,
-				ARRAY_SIZE(samsung_adjust_tb));
-		break;
-	default:
-		break;
-	}
-}
-
-static int panel_inited = 0;
-static int
-eid_panel_unblank(struct msm_mddi_bridge_platform_data *bridge_data,
-		    struct msm_mddi_client_data *client_data)
-{
-	int panel_id;
-
-	BUG_ON(!bridge_data);
-	BUG_ON(!client_data);
-
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-
-	client_data->auto_hibernate(client_data, 0);
-	panel_id = eid_panel_detect();
-
-	if (!panel_inited) {
-		panel_inited = 1;
-	} else {
-		switch (panel_id) {
-		case PANEL_HITACHI:
-			B(KERN_DEBUG "found hitachi mddi panel\n");
-			eid_process_mddi_table(client_data,
-					hitachi_init_tb,
-					ARRAY_SIZE(hitachi_init_tb));
-			break;
-		case PANEL_WINTEK:
-			B(KERN_DEBUG "found wintek mddi panel\n");
-			eid_process_mddi_table(client_data,
-					wintek_init_tb,
-					ARRAY_SIZE(wintek_init_tb));
-			break;
-		case PANEL_SAMSUNG:
-			B(KERN_DEBUG "found samsung mddi panel\n");
-			eid_process_mddi_table(client_data,
-					samsung_init_tb,
-					ARRAY_SIZE(samsung_init_tb));
-			break;
-		default:
-			B(KERN_DEBUG "unknown panel_id: %d\n", panel_id);
-		};
-	}
-	eid_set_backlight(1);
-	client_data->auto_hibernate(client_data, 1);
-	return 0;
-}
-
-static int
-eid_panel_blank(struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	int panel_id = eid_panel_detect();
-
-	eid_set_backlight(0);
-	client_data->auto_hibernate(client_data, 0);
-
-	switch (panel_id) {
-	case PANEL_HITACHI:
-		eid_process_mddi_table(client_data, hitachi_deinit_tb,
-				ARRAY_SIZE(hitachi_deinit_tb));
-		break;
-	case PANEL_WINTEK:
-		eid_process_mddi_table(client_data, wintek_deinit_tb,
-				ARRAY_SIZE(wintek_deinit_tb));
-		break;
-	case PANEL_SAMSUNG:
-		eid_process_mddi_table(client_data, samsung_deinit_tb,
-				ARRAY_SIZE(samsung_deinit_tb));
-		break;
-	default:
-		B("unknown panel_id: %d\n", panel_id);
-	}
-	client_data->auto_hibernate(client_data, 1);
-
-	return 0;
-}
-/* todo: the following is dirty, clean it */
-static spinlock_t g_list_lock = SPIN_LOCK_UNLOCKED;
-static int g_panel_id = -1;
-static ssize_t panel_show(struct kobject *kobj,
-			struct kobj_attribute *attr, char *buf)
-{
-	char *s = buf;
-	unsigned long irqflags;
-
-	spin_lock_irqsave(&g_list_lock, irqflags);
-	switch (g_panel_id) {
-	case PANEL_HITACHI:
-		s += sprintf(s, "verdor:hitachi\n");
-		break ;
-	case PANEL_WINTEK:
-		s += sprintf(s, "vendor:wintek\n");
-		break ;
-	case PANEL_SAMSUNG:
-		s += sprintf(s, "vendor:samsung\n");
-		break ;
-	default:
-		s += sprintf(s, "vendor:unknown\n");
-		break ;
-	}
-	spin_unlock_irqrestore(&g_list_lock, irqflags);
-	return (s - buf);
-}
-
-#define android_display_ro_attr(_name) \
-static struct kobj_attribute _name##_attr = {   \
-	.attr   = {                 \
-		.name = __stringify(_name), \
-		.mode = 0444,           \
-	},                      \
-	.show   = _name##_show,     \
-	.store  = NULL, \
-}
-
-android_display_ro_attr(panel);
-
-static struct attribute *attrs[] = {
-	&panel_attr.attr,
-	NULL ,
-} ;
-
-static struct attribute_group attr_group = {
-	.attrs = attrs,
-};
-
-static struct kobject *android_display_kobj = NULL;
-#define GPIO_BLOCK_BASE         0x150000
-#define GPIODATA                (GPIO_BLOCK_BASE|0x00)
-static int display_sysfs_init(void)
-{
-	int ret ;
-
-	android_display_kobj = kobject_create_and_add("android_display", NULL);
-	if (android_display_kobj == NULL) {
-		printk(KERN_DEBUG \
-			"msmfb_sysfs_init: subsystem_register failed\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-	ret = sysfs_create_group(android_display_kobj, &attr_group);
-	if (ret) {
-		printk(KERN_DEBUG \
-			"msmfb_sysfs_init: sysfs_create_group failed\n");
-		goto err4;
-	}
-
-	g_panel_id = eid_panel_detect() ;
-
-	return 0 ;
-err4:
-	kobject_del(android_display_kobj);
-err:
-	return ret ;
-}
-
-static void
-eid_fixup(uint16_t *mfr_name, uint16_t *product_code)
-{
-	B("%s: enter.\n", __func__);
-	*mfr_name = 0x0101;
-	*product_code = 0x0154;
-}
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct msm_mddi_bridge_platform_data samsung_client_data = {
-	.init = eid_mddi_client_init,
-	.uninit = eid_mddi_client_uninit,
-	.bridge_type = SAMSUNG_D,
-	.blank = eid_panel_blank,
-	.unblank = eid_panel_unblank,
-	.adjust = eid_samsung_adjust,
-	.fb_data = {
-		.xres = 240,
-		.yres = 320,
-		.width = 42,
-		.height = 56,
-		.output_format = 0,
-	},
-};
-
-static struct msm_mddi_platform_data eid_pdata = {
-	/*.clk_rate = 61440000,		default MDDI frequenct*/
-	.clk_rate = 68571000,	/*set MDDI frequency to 68.57Mhz*/
-	.power_client = eid_mddi_power_client,
-	.fixup = eid_fixup,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 1,
-	.client_platform_data = {
-		{
-			.product_id = (0x0101 << 16 | 0x0154),
-			.name = "mddi_c_0101_0154",
-			.id = 0,
-			.client_data = &samsung_client_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-int __init eid_init(void)
-{
-	int rc;
-
-	if (!(machine_is_bahamas() || machine_is_clickc() ||
-				machine_is_memphis()))
-		return 0;
-
-	vreg_lcm_2v85 = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_lcm_2v85))
-		return PTR_ERR(vreg_lcm_2v85);
-	vreg_lcm_2v6 = vreg_get(0, "rfrx2");
-	if (IS_ERR(vreg_lcm_2v6))
-		return PTR_ERR(vreg_lcm_2v6);
-
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-	msm_device_mddi0.dev.platform_data = &eid_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-
-	led_trigger_register_simple("lcd-backlight-gate", &eid_lcd_backlight);
-	if (IS_ERR(eid_lcd_backlight))
-		printk(KERN_ERR
-			"%s: backlight registration failed!\n", __func__);
-	rc = display_sysfs_init() ;
-	if (rc)
-		return rc ;
-	return 0;
-}
-
-device_initcall(eid_init);
-
diff --git a/arch/arm/mach-msm/board-desirec-camsensor.c b/arch/arm/mach-msm/board-desirec-camsensor.c
deleted file mode 100644
index 8aa905f..0000000
--- a/arch/arm/mach-msm/board-desirec-camsensor.c
+++ /dev/null
@@ -1,1871 +0,0 @@
-/*
- * arch/arm/mach-msm/board-desirec-camsensor.c - s5k3e2f sensor driver
- *
- *  Copyright (C) 2008 becker hsieh <becker0213@gmail.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- */
-
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/slab.h>
-#include <linux/irq.h>
-#include <linux/miscdevice.h>
-#include <linux/delay.h>
-#include <linux/input.h>
-#include <linux/workqueue.h>
-#include <linux/freezer.h>
-#include <linux/netlink.h>
-#include <linux/skbuff.h>
-#include <linux/clk.h>
-#include <net/sock.h>
-#include <linux/gpio.h>
-#include <linux/uaccess.h>
-#include <linux/io.h>
-#include <asm/mach-types.h>
-#include <mach/msm_iomap.h>
-#include <mach/s5k3e2fx.h>
-#include "board-desirec.h"
-#include "board-desirec-camsensor.h"
-
-typedef struct {
-  uint8_t pre_pll_clk_div;               /* 0x0305*/
-  uint8_t pll_multiplier_msb;            /* 0x0306*/
-  uint8_t pll_multiplier_lsb;            /* 0x0307*/
-  uint8_t vt_pix_clk_div;                /* 0x0301*/
-  uint8_t vt_sys_clk_div;                /* 0x0303*/
-  uint8_t op_pix_clk_div;                /* 0x0309*/
-  uint8_t op_sys_clk_div;                /* 0x030B*/
-  uint8_t ccp_data_format_msb;           /* 0x0112*/
-  uint8_t ccp_data_format_lsb;           /* 0x0113*/
-  uint8_t x_output_size_msb;             /* 0x034C*/
-  uint8_t x_output_size_lsb;             /* 0x034D*/
-  uint8_t y_output_size_msb;             /* 0x034E*/
-  uint8_t y_output_size_lsb;             /* 0x034F*/
-  uint8_t x_even_inc;                    /* 0x0381*/
-  uint8_t x_odd_inc;                     /* 0x0383 */
-  uint8_t y_even_inc;                    /* 0x0385 */
-  uint8_t y_odd_inc;                     /* 0x0387 */
-  uint8_t binning_enable;                /* 0x3014*/
-  uint8_t frame_length_lines_msb;        /* 0x0340*/
-  uint8_t frame_length_lines_lsb;        /* 0x0341*/
-  uint8_t line_length_pck_msb;           /* 0x0342*/
-  uint8_t line_length_pck_lsb;           /* 0x0343*/
-  uint8_t shade_clk_enable ;             /* 0x30AC*/
-  uint8_t sel_ccp;                       /* 0x30C4*/
-  uint8_t vpix;                          /* 0x3024*/
-  uint8_t clamp_on;                      /* 0x3015*/
-  uint8_t offset;                        /* 0x307E*/
-  uint8_t ld_start;                      /* 0x3000*/
-  uint8_t ld_end;                        /* 0x3001*/
-  uint8_t sl_start;                      /* 0x3002*/
-  uint8_t sl_end;                        /* 0x3003*/
-  uint8_t rx_start;                      /* 0x3004*/
-  uint8_t s1_start;                      /* 0x3005*/
-  uint8_t s1_end;                        /* 0x3006*/
-  uint8_t s1s_start;                     /* 0x3007*/
-  uint8_t s1s_end;                       /* 0x3008*/
-  uint8_t s3_start;                      /* 0x3009*/
-  uint8_t s3_end;                        /* 0x300A*/
-  uint8_t cmp_en_start;                  /* 0x300B*/
-  uint8_t clp_sl_start;                  /* 0x300C*/
-  uint8_t clp_sl_end;                    /* 0x300D*/
-  uint8_t off_start;                     /* 0x300E*/
-  uint8_t rmp_en_start;                  /* 0x300F*/
-  uint8_t tx_start;                      /* 0x3010*/
-  uint8_t tx_end;                        /* 0x3011*/
-  uint8_t stx_width;                     /* 0x3012*/
-  uint8_t reg_3152_reserved;             /* 0x3152*/
-  uint8_t reg_315A_reserved;             /* 0x315A*/
-  uint8_t analogue_gain_code_global_msb; /* 0x0204*/
-  uint8_t analogue_gain_code_global_lsb; /* 0x0205*/
-  uint8_t fine_integration_time;         /* 0x0200*/
-  uint8_t coarse_integration_time;       /* 0x0202*/
-} reg_struct;
-
-
-/***********************************************************
-* global variable
-************************************************************/
-static uint16_t chipid;
-static struct i2c_client *pclient_i2c;
-static struct clk *vfe_clk;
-/* camif clocks */
-static struct clk *vfe_mdc_clk;
-static struct clk *mdc_clk;
-static int mdc_clk_enabled;
-static int vfe_mdc_clk_enabled;
-static int vfe_clk_enabled;
-static int powered;
-static const uint32_t fps_divider = 1;
-
-static reg_struct s5k3e2fx_reg_pattern[2] =
-{
-  {
-    0x06,  /* pre_pll_clk_div               REG=0x0305*/
-    0x00,  /* pll_multiplier_msb            REG=0x0306*/
-    0xA4,  /* pll_multiplier_lsb            REG=0x0307 0x88*/
-    0x0a,  /* vt_pix_clk_div                REG=0x0301*/
-    0x01,  /* vt_sys_clk_div                REG=0x0303*/
-    0x0a,  /* op_pix_clk_div                REG=0x0309*/
-    0x01,  /* op_sys_clk_div                REG=0x030B*/
-    0x0a,  /* ccp_data_format_msb           REG=0x0112*/
-    0x0a,  /* ccp_data_format_lsb           REG=0x0113*/
-    0x05,  /* x_output_size_msb             REG=0x034C*/
-    0x10,  /* x_output_size_lsb             REG=0x034D*/
-    0x03,  /* y_output_size_msb             REG=0x034E*/
-    0xcc,  /* y_output_size_lsb             REG=0x034F*/
-
-    /* enable binning for preview */
-    0x01,  /* x_even_inc                    REG=0x0381*/
-    0x01,  /* x_odd_inc                     REG=0x0383*/
-    0x01,  /* y_even_inc                    REG=0x0385*/
-    0x03,  /* y_odd_inc                     REG=0x0387*/
-    0x06,  /* binning_enable                REG=0x3014*/
-    0x03,  /* frame_length_lines_msb        REG=0x0340*/
-    0xe2,  /* frame_length_lines_lsb        REG=0x0341 0xde*/
-    0x0a,  /* line_length_pck_msb           REG=0x0342*/
-    0xac,  /* line_length_pck_lsb           REG=0x0343*/
-    0x81,  /* shade_clk_enable              REG=0x30AC*/
-    0x01,  /* sel_ccp                       REG=0x30C4*/
-    0x04,  /* vpix                          REG=0x3024*/
-    0x00,  /* clamp_on                      REG=0x3015*/
-    0x02,  /* offset                        REG=0x307E*/
-    0x03,  /* ld_start                      REG=0x3000*/
-    0x94,  /* ld_end                        REG=0x3001 0x9c*/
-    0x02,  /* sl_start                      REG=0x3002*/
-    0x95,  /* sl_end                        REG=0x3003 0x9e*/
-    0x0F,  /* rx_start                      REG=0x3004 0x05*/
-    0x05,  /* s1_start                      REG=0x3005 0x0f*/
-    0x3c,  /* s1_end                        REG=0x3006 0x24*/
-    0x8c,  /* s1s_start                     REG=0x3007 0x7c*/
-    0x93,  /* s1s_end                       REG=0x3008 0x9a*/
-    0x05,  /* s3_start                      REG=0x3009 0x10*/
-    0x3a,  /* s3_end                        REG=0x300A 0x24*/
-    0x10,  /* cmp_en_start                  REG=0x300B*/
-    0x02,  /* clp_sl_start                  REG=0x300C 0x04*/
-    0x3e,  /* clp_sl_end                    REG=0x300D 0x26*/
-    0x02,  /* off_start                     REG=0x300E*/
-    0x0e,  /* rmp_en_start                  REG=0x300F*/
-    0x46,  /* tx_start                      REG=0x3010 0x30*/
-    0x64,  /* tx_end                        REG=0x3011 0x4e*/
-    0x1E,  /* stx_width                     REG=0x3012*/
-    0x08,  /* reg_3152_reserved             REG=0x3152*/
-    0xFF,  /*20,  reg_315A_reserved             REG=0x315A 0x10*/
-    0x00,  /* analogue_gain_code_global_msb REG=0x0204*/
-    0x80,  /* analogue_gain_code_global_lsb REG=0x0205*/
-    0x02,  /* fine_integration_time         REG=0x0200*/
-    0x03   /* coarse_integration_time       REG=0x0202*/
-  },
-  { /*Snapshot*/
-    0x06,  /* pre_pll_clk_div               REG=0x0305*/
-    0x00,  /* pll_multiplier_msb            REG=0x0306*/
-    0xA4,  /* pll_multiplier_lsb            REG=0x0307 0x88*/
-    0x0a,  /* vt_pix_clk_div                REG=0x0301*/
-    0x01,  /* vt_sys_clk_div                REG=0x0303*/
-    0x0a,  /* op_pix_clk_div                REG=0x0309*/
-    0x01,  /* op_sys_clk_div                REG=0x030B*/
-    0x0a,  /* ccp_data_format_msb           REG=0x0112*/
-    0x0a,  /* ccp_data_format_lsb           REG=0x0113*/
-    0x0a,  /* x_output_size_msb             REG=0x034C*/
-    0x30,  /* x_output_size_lsb             REG=0x034D*/
-    0x07,  /* y_output_size_msb             REG=0x034E*/
-    0xa8,  /* y_output_size_lsb             REG=0x034F*/
-    /* disable binning for snapshot */
-    0x01,  /* x_even_inc                    REG=0x0381*/
-    0x01,  /* x_odd_inc                     REG=0x0383*/
-    0x01,  /* y_even_inc                    REG=0x0385*/
-    0x01,  /* y_odd_inc                     REG=0x0387*/
-    0x00,  /* binning_enable                REG=0x3014*/
-    0x07,  /* frame_length_lines_msb        REG=0x0340*/
-    0xb6,  /* frame_length_lines_lsb        REG=0x0341*/
-    0x0a,  /* line_length_pck_msb           REG=0x0342*/
-    0xac,  /* line_length_pck_lsb           REG=0x0343*/
-    0x81,  /* shade_clk_enable              REG=0x30AC*/
-    0x01,  /* sel_ccp                       REG=0x30C4*/
-    0x04,  /* vpix                          REG=0x3024*/
-    0x00,  /* clamp_on                      REG=0x3015*/
-    0x02,  /* offset                        REG=0x307E*/
-    0x03,  /* ld_start                      REG=0x3000*/
-    0x94,  /* ld_end                        REG=0x3001 0x9c*/
-    0x02,  /* sl_start                      REG=0x3002*/
-    0x95,  /* sl_end                        REG=0x3003 0x9e*/
-    0x04,  /* rx_start                      REG=0x3004 0x05*/
-    0x05,  /* s1_start                      REG=0x3005 0x0f*/
-    0x3c,  /* s1_end                        REG=0x3006 0x24*/
-    0x8c,  /* s1s_start                     REG=0x3007 0x7c*/
-    0x93,  /* s1s_end                       REG=0x3008 0x9a*/
-    0x05,  /* s3_start                      REG=0x3009 0x10*/
-    0x3a,  /* s3_end                        REG=0x300A 0x24*/
-    0x10,  /* cmp_en_start                  REG=0x300B*/
-    0x02,  /* clp_sl_start                  REG=0x300C 0x04*/
-    0x3e,  /* clp_sl_end                    REG=0x300D 0x26*/
-    0x02,  /* off_start                     REG=0x300E*/
-    0x0e,  /* rmp_en_start                  REG=0x300F*/
-    0x46,  /* tx_start                      REG=0x3010 0x30*/
-    0x64,  /* tx_end                        REG=0x3011 0x4e*/
-    0x1E,  /* stx_width                     REG=0x3012*/
-    0x08,  /* reg_3152_reserved             REG=0x3152*/
-    0xFF,  /* reg_315A_reserved             REG=0x315A 0x10*/
-    0x00,  /* analogue_gain_code_global_msb REG=0x0204*/
-    0x80,  /* analogue_gain_code_global_lsb REG=0x0205*/
-    0x02,  /* fine_integration_time         REG=0x0200*/
-    0x03   /* coarse_integration_time       REG=0x0202*/
-  }
-};
-/***********************************************************
-* definition
-************************************************************/
-#define S5K3E2FX_SS5M0_RESET_DELAY_MSECS    66
-#define S5K3E2FX_SS5M0_DEFAULT_CLOCK_RATE   24000000
-#define S5K3E2FX_SS5M0_HRZ_FULL_BLK_PIXELS   124
-#define S5K3E2FX_SS5M0_VER_FULL_BLK_LINES     14
-#define S5K3E2FX_SS5M0_HRZ_QTR_BLK_PIXELS   1436
-#define S5K3E2FX_SS5M0_VER_QTR_BLK_LINES      18
-#define S5K3E2FX_SS5M0_OFFSET     4
-#define S5K3E2FX_SS5M0_MAX_SNAPSHOT_EXPOSURE_LINE_COUNT 3961
-
-/***********************************************************
-* sensor register define
-************************************************************/
-#define S5K3E2FX_SS5M0_REG_MODEL_ID   0x0000
-#define S5K3E2FX_SS5M0_MODEL_ID       0x3E2F
-
-/* PLL Registers */
-#define REG_PRE_PLL_CLK_DIV           0x0305
-#define REG_PLL_MULTIPLIER_MSB        0x0306
-#define REG_PLL_MULTIPLIER_LSB        0x0307
-#define REG_VT_PIX_CLK_DIV            0x0301
-#define REG_VT_SYS_CLK_DIV            0x0303
-#define REG_OP_PIX_CLK_DIV            0x0309
-#define REG_OP_SYS_CLK_DIV            0x030B
-
-/* Data Format Registers */
-#define REG_CCP_DATA_FORMAT_MSB       0x0112
-#define REG_CCP_DATA_FORMAT_LSB       0x0113
-
-/* Output Size */
-#define REG_X_OUTPUT_SIZE_MSB         0x034C
-#define REG_X_OUTPUT_SIZE_LSB         0x034D
-#define REG_Y_OUTPUT_SIZE_MSB         0x034E
-#define REG_Y_OUTPUT_SIZE_LSB         0x034F
-
-/* Binning */
-#define REG_X_EVEN_INC                0x0381
-#define REG_X_ODD_INC                 0x0383
-#define REG_Y_EVEN_INC                0x0385
-#define REG_Y_ODD_INC                 0x0387
-/*Reserved register */
-#define REG_BINNING_ENABLE            0x3014
-
-/* Frame Fotmat */
-#define REG_FRAME_LENGTH_LINES_MSB    0x0340
-#define REG_FRAME_LENGTH_LINES_LSB    0x0341
-#define REG_LINE_LENGTH_PCK_MSB       0x0342
-#define REG_LINE_LENGTH_PCK_LSB       0x0343
-
-/* MSR setting */
-/* Reserved registers */
-#define REG_SHADE_CLK_ENABLE          0x30AC
-#define REG_SEL_CCP                   0x30C4
-#define REG_VPIX                      0x3024
-#define REG_CLAMP_ON                  0x3015
-#define REG_OFFSET                    0x307E
-
-/* CDS timing settings */
-/* Reserved registers */
-#define REG_LD_START                  0x3000
-#define REG_LD_END                    0x3001
-#define REG_SL_START                  0x3002
-#define REG_SL_END                    0x3003
-#define REG_RX_START                  0x3004
-#define REG_S1_START                  0x3005
-#define REG_S1_END                    0x3006
-#define REG_S1S_START                 0x3007
-#define REG_S1S_END                   0x3008
-#define REG_S3_START                  0x3009
-#define REG_S3_END                    0x300A
-#define REG_CMP_EN_START              0x300B
-#define REG_CLP_SL_START              0x300C
-#define REG_CLP_SL_END                0x300D
-#define REG_OFF_START                 0x300E
-#define REG_RMP_EN_START              0x300F
-#define REG_TX_START                  0x3010
-#define REG_TX_END                    0x3011
-#define REG_STX_WIDTH                 0x3012
-#define REG_TYPE1_AF_ENABLE           0x3130
-#define DRIVER_ENABLED              0x0001
-#define AUTO_START_ENABLED          0x0010
-#define REG_NEW_POSITION              0x3131
-#define REG_3152_RESERVED             0x3152
-#define REG_315A_RESERVED             0x315A
-#define REG_ANALOGUE_GAIN_CODE_GLOBAL_MSB 0x0204
-#define REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB 0x0205
-#define REG_FINE_INTEGRATION_TIME         0x0200
-#define REG_COARSE_INTEGRATION_TIME       0x0202
-#define REG_COARSE_INTEGRATION_TIME_LSB   0x0203
-
-/* Mode select register */
-#define S5K3E2FX_REG_MODE_SELECT      0x0100
-#define S5K3E2FX_MODE_SELECT_STREAM     0x01   /* start streaming */
-#define S5K3E2FX_MODE_SELECT_SW_STANDBY 0x00   /* software standby */
-#define S5K3E2FX_REG_SOFTWARE_RESET   0x0103
-#define S5K3E2FX_SOFTWARE_RESET         0x01
-#define REG_TEST_PATTERN_MODE         0x0601
-
-static int rc;
-#define CLK_GET(clk) do {						\
-	if (!clk) {							\
-		clk = clk_get(NULL, #clk);				\
-		printk(KERN_INFO 					\
-			"s5k3e2fx: clk_get(%s): %p\n", #clk, clk);	\
-	}								\
-} while (0)
-
-
-#define CLK_DISABLE_AND_PUT(clk) do {					\
-	if (clk) {							\
-		if (clk##_enabled) {					\
-			printk(KERN_INFO "s5k3e2fx: disabling "#clk"\n");\
-			clk_disable(clk);				\
-			clk##_enabled = 0;				\
-		}							\
-		printk(KERN_INFO 					\
-			"s5k3e2fx: clk_put(%s): %p\n", #clk, clk);	\
-		clk_put(clk);						\
-		clk = NULL; 						\
-	}								\
-} while (0)
-
-#define CHECK() ({ 							\
-	if (!mdc_clk_enabled || !vfe_mdc_clk_enabled) { 		\
-		printk(KERN_ERR "s5k3e2fx error: one or more clocks"	\
-			" are NULL.\n"); 				\
-		rc = -EIO; 						\
-	} 								\
-	!rc; })
-
-/***********************************************************
-* VFE CAMIF setting
-************************************************************/
-/*New implement of AXI reset*/
-#define V_SYNC_LENGTH_PEVIEW 990
-#define V_SYNC_LENGTH_SNAPSHOT 1974
-#define HWIO_AXI_RESET_ADDR (MSM_CLK_CTL_BASE + 0x00000208)
-#define HWIO_AXI_RESET_RMSK 0x1fff
-#define HWIO_AXI_RESET_VFE_BMSK 1
-#define HWIO_AXI_RESET_VFE_SHFT 0
-#define HWIO_AXI_RESET_IN \
-	in_dword_masked(HWIO_AXI_RESET_ADDR, HWIO_AXI_RESET_RMSK)
-#define HWIO_AXI_RESET_OUTM(m, v) \
-	out_dword_masked_ns(\
-	HWIO_AXI_RESET_ADDR, m, v, HWIO_AXI_RESET_IN)
-
-
-#define out_dword(addr, val) \
-	(*((volatile unsigned long  *)(addr)) = ((unsigned long)(val)))
-
-#define out_dword_masked_ns(io, mask, val, current_reg_content) \
-  (void) out_dword(io, ((current_reg_content & (uint32_t)(~(mask))) | \
-			 ((uint32_t)((val) & (mask)))))
-
-#define __inpdw(port) (*((volatile uint32_t *) (port)))
-#define in_dword_masked(addr, mask) (__inpdw(addr) & (uint32_t)mask)
-
-#define HWIO_MDDI_CAMIF_CFG_ADDR MSM_MDC_BASE
-#define HWIO_MDDI_CAMIF_CFG_RMSK 0x1fffff
-#define HWIO_MDDI_CAMIF_CFG_IN \
-	in_dword_masked(\
-	HWIO_MDDI_CAMIF_CFG_ADDR, HWIO_MDDI_CAMIF_CFG_RMSK)
-
-#define HWIO_MDDI_CAMIF_CFG_OUTM(m, v) \
-	out_dword_masked_ns(\
-	HWIO_MDDI_CAMIF_CFG_ADDR, m, v, HWIO_MDDI_CAMIF_CFG_IN);
-
-#define __msmhwio_outm(hwiosym, mask, val) \
-	HWIO_##hwiosym##_OUTM(mask, val)
-#define HWIO_OUTM(hwiosym, mask, val) \
-	__msmhwio_outm(hwiosym, mask, val)
-
-#define HWIO_MDDI_CAMIF_CFG_CAM_SEL_BMSK 0x2
-#define HWIO_MDDI_CAMIF_CFG_CAM_PCLK_SRC_SEL_BMSK 0x60000
-#define HWIO_MDDI_CAMIF_CFG_CAM_PCLK_INVERT_BMSK 0x80000
-#define HWIO_MDDI_CAMIF_CFG_CAM_PAD_REG_SW_RESET_BMSK 0x100000
-
-#define HWIO_MDDI_CAMIF_CFG_CAM_SEL_SHFT 0x1
-#define HWIO_MDDI_CAMIF_CFG_CAM_PCLK_SRC_SEL_SHFT 0x11
-#define HWIO_MDDI_CAMIF_CFG_CAM_PCLK_INVERT_SHFT 0x13
-#define HWIO_MDDI_CAMIF_CFG_CAM_PAD_REG_SW_RESET_SHFT 0x14
-
-#define __msmhwio_shft(hwio_regsym, hwio_fldsym) \
-	HWIO_##hwio_regsym##_##hwio_fldsym##_SHFT
-#define HWIO_SHFT(hwio_regsym, hwio_fldsym) \
-	__msmhwio_shft(hwio_regsym, hwio_fldsym)
-
-#define __msmhwio_fmsk(hwio_regsym, hwio_fldsym) \
-	HWIO_##hwio_regsym##_##hwio_fldsym##_BMSK
-#define HWIO_FMSK(hwio_regsym, hwio_fldsym) \
-	__msmhwio_fmsk(hwio_regsym, hwio_fldsym)
-
-#define HWIO_APPS_RESET_ADDR (MSM_CLK_CTL_BASE + 0x00000210)
-#define HWIO_APPS_RESET_RMSK 0x1fff
-#define HWIO_APPS_RESET_VFE_BMSK 1
-#define HWIO_APPS_RESET_VFE_SHFT 0
-#define HWIO_APPS_RESET_IN \
-	in_dword_masked(\
-	HWIO_APPS_RESET_ADDR, HWIO_APPS_RESET_RMSK)
-#define HWIO_APPS_RESET_OUTM(m, v) \
-	out_dword_masked_ns(\
-	HWIO_APPS_RESET_ADDR, m, v, HWIO_APPS_RESET_IN)
-
-
-
-/***********************************************************
-* privite function variable
-************************************************************/
-/***********************************************************
-* I2C read write
-************************************************************/
-static int s5k3e2fx_i2c_rx_data(char *rxData, int length)
-{
-	int rc;
-	struct i2c_msg msgs[] = {
-		{
-			.addr = pclient_i2c->addr,
-			.flags = 0,
-			.len = 2,
-			.buf = rxData,
-		},
-		{
-			.addr = pclient_i2c->addr,
-			.flags = I2C_M_RD,
-			.len = length,
-			.buf = rxData,
-		},
-	};
-
-	rc = i2c_transfer(pclient_i2c->adapter, msgs, 2);
-	if (rc < 0) {
-		printk(KERN_ERR
-			"s5k3e2fx: s5k3e2fx_i2c_rx_data error %d\n", rc);
-		return rc;
-	}
-	return 0;
-}
-
-static int s5k3e2fx_i2c_tx_data(char *txData, int length)
-{
-	int rc;
-	struct i2c_msg msg[] = {
-		{
-			.addr = pclient_i2c->addr,
-			.flags = 0,
-			.len = length,
-			.buf = txData,
-		},
-	};
-	rc = i2c_transfer(pclient_i2c->adapter, msg, 1);
-	if (rc < 0) {
-		printk(KERN_ERR
-			"s5k3e2fx: s5k3e2fx_i2c_tx_data error %d\n", rc);
-		return rc;
-	}
-	return 0;
-}
-
-/***********************************************************
-* sensor i2c write
-************************************************************/
-
-int desirec_s5k3e2fx_i2c_write(unsigned short waddr, unsigned short wdata)
-{
-	int rc, count = 0;
-	unsigned char buf[4];
-	memset(buf, 0, sizeof(buf));
-	buf[0] = (waddr & 0xFF00)>>8;
-	buf[1] = (waddr & 0x00FF);
-	buf[2] = (wdata & 0x00FF);
-retry:
-	rc = s5k3e2fx_i2c_tx_data(buf, 3);
-	if (rc < 0) {
-		printk(KERN_ERR
-			"s5k3e2fx: txdata error %d add:0x%02x data:0x%02x\n",
-			rc, waddr, wdata);
-		printk(KERN_ERR "starting retry policy count:%d\n",count);
-		udelay(10);
-		count++;
-		if (count < 20){
-		if (count > 10)
-			udelay(100);
-		}else
-			return rc;
-		goto retry;
-	}
-	return rc;
-}
-
-/***********************************************************
-* sensor i2c read
-************************************************************/
-int desirec_s5k3e2fx_i2c_read(unsigned short u_addr, unsigned short *pu_data)
-{
-	int rc;
-	unsigned char buf[2];
-
-	buf[0] = (u_addr & 0xFF00)>>8;
-	buf[1] = (u_addr & 0x00FF);
-	rc = s5k3e2fx_i2c_rx_data(buf, 2);
-	if (!rc)
-		*pu_data = buf[0]<<8 | buf[1];
-	else
-		printk(KERN_ERR "s5k3e2fx: i2c read failed\n");
-	return rc;
-}
-
-/***********************************************************
-* sensor probe up init function
-************************************************************/
-static void desirec_s5k3e2fx_sensor_setting_init(void){
-	/*becker add for temp*/
-	desirec_s5k3e2fx_i2c_write(S5K3E2FX_REG_SOFTWARE_RESET,
-		S5K3E2FX_SOFTWARE_RESET);
-	desirec_s5k3e2fx_i2c_write(0x0100, 0x00);
-	/*--------------PLL setting for 80Mhz*/
-	desirec_s5k3e2fx_set_pclk(0, 0);
-	/*--------------output size*/
-	desirec_s5k3e2fx_i2c_write(0x034c, 0x05);
-	desirec_s5k3e2fx_i2c_write(0x034d, 0x10);
-	desirec_s5k3e2fx_i2c_write(0x034e, 0x03);
-	desirec_s5k3e2fx_i2c_write(0x034f, 0xcc);
-	/*--------------frame format (min blanking)*/
-	desirec_s5k3e2fx_i2c_write(0x0340, 0x03);
-	desirec_s5k3e2fx_i2c_write(0x0341, 0xe2);
-	desirec_s5k3e2fx_i2c_write(0x0342, 0x0a);
-	desirec_s5k3e2fx_i2c_write(0x0343, 0xac);
-	/*--------------Binning */
-	desirec_s5k3e2fx_i2c_write(0x0381, 0x01);
-	desirec_s5k3e2fx_i2c_write(0x0383, 0x01);
-	desirec_s5k3e2fx_i2c_write(0x0385, 0x01);
-	desirec_s5k3e2fx_i2c_write(0x0387, 0x03);
-	desirec_s5k3e2fx_i2c_write(0x3014, 0x06);
-	/*--------------MSR setting*/
-	desirec_s5k3e2fx_i2c_write(0x30c4, 0x01);
-	desirec_s5k3e2fx_i2c_write(0x3000, 0x03);
-	desirec_s5k3e2fx_i2c_write(0x3001, 0x94);
-	desirec_s5k3e2fx_i2c_write(0x3002, 0x02);
-	desirec_s5k3e2fx_i2c_write(0x3003, 0x95);
-	desirec_s5k3e2fx_i2c_write(0x3004, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3005, 0x05);
-	desirec_s5k3e2fx_i2c_write(0x3006, 0x3c);
-	desirec_s5k3e2fx_i2c_write(0x3007, 0x8c);
-	desirec_s5k3e2fx_i2c_write(0x3008, 0x93);
-	desirec_s5k3e2fx_i2c_write(0x3009, 0x05);
-	desirec_s5k3e2fx_i2c_write(0x300a, 0x3a);
-	desirec_s5k3e2fx_i2c_write(0x300c, 0x02);
-	desirec_s5k3e2fx_i2c_write(0x300d, 0x3e);
-	desirec_s5k3e2fx_i2c_write(0x300f, 0x0e);
-	desirec_s5k3e2fx_i2c_write(0x3010, 0x46);
-	desirec_s5k3e2fx_i2c_write(0x3011, 0x64);
-	desirec_s5k3e2fx_i2c_write(0x3012, 0x1e);
-	desirec_s5k3e2fx_i2c_write(0x301d, 0x3f);
-	desirec_s5k3e2fx_i2c_write(0x3024, 0x04);
-	desirec_s5k3e2fx_i2c_write(0x3028, 0x40);
-	desirec_s5k3e2fx_i2c_write(0x3070, 0xdf);
-	desirec_s5k3e2fx_i2c_write(0x301b, 0x73);
-	desirec_s5k3e2fx_i2c_write(0x307e, 0x02);
-	desirec_s5k3e2fx_i2c_write(0x30bd, 0x06);
-	desirec_s5k3e2fx_i2c_write(0x30c2, 0x0b);
-	desirec_s5k3e2fx_i2c_write(0x30ac, 0x81);
-	desirec_s5k3e2fx_i2c_write(0x3151, 0xe6);
-	desirec_s5k3e2fx_i2c_write(0x3029, 0x02);
-	/*--------------EVT4 setting*/
-	desirec_s5k3e2fx_i2c_write(0x30bf, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3022, 0x87);
-	/*tune ADC to got batter yield rate in EDS*/
-	desirec_s5k3e2fx_i2c_write(0x3019, 0x60);
-	/*AF driving strength*/
-	desirec_s5k3e2fx_i2c_write(0x3146, 0x3c);
-	desirec_s5k3e2fx_i2c_write(0x3152, 0x08);
-	desirec_s5k3e2fx_i2c_write(0x315a, 0xaa);
-	desirec_s5k3e2fx_i2c_write(0x3159, 0x0a);
-	desirec_s5k3e2fx_i2c_write(0x0205, 0x80);
-	desirec_s5k3e2fx_i2c_write(0x0202, 0x03);
-	desirec_s5k3e2fx_i2c_write(0x0200, 0x02);
-}
-
-
-/***********************************************************
-* enable VFE clk
-************************************************************/
-static int desirec_msm_camio_vfe_clk_enable(void)
-{
-	CLK_GET(vfe_clk);
-	if (vfe_clk && !vfe_clk_enabled) {
-		vfe_clk_enabled = !clk_enable(vfe_clk);
-		printk(KERN_INFO "s5k3e2fx: enable vfe_clk\n");
-	}
-	return vfe_clk_enabled ? 0 : -EIO;
-}
-
-
-
-/***********************************************************
-* Samsung sensor lens sharding setting
-************************************************************/
-static void desirec_s5k3e2fx_i2c_sensor_lens_sharding(void){
-	desirec_s5k3e2fx_i2c_write(0x3200, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3201, 0xbe);
-	desirec_s5k3e2fx_i2c_write(0x3202, 0x4e);
-	desirec_s5k3e2fx_i2c_write(0x3203, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3204, 0xb9);
-	desirec_s5k3e2fx_i2c_write(0x3205, 0x07);
-	desirec_s5k3e2fx_i2c_write(0x3206, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3207, 0x4b);
-	desirec_s5k3e2fx_i2c_write(0x3208, 0xdf);
-	desirec_s5k3e2fx_i2c_write(0x3209, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x320a, 0xc6);
-	desirec_s5k3e2fx_i2c_write(0x320b, 0x39);
-	desirec_s5k3e2fx_i2c_write(0x320c, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x320d, 0x13);
-	desirec_s5k3e2fx_i2c_write(0x320e, 0xee);
-	desirec_s5k3e2fx_i2c_write(0x320f, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3210, 0x14);
-	desirec_s5k3e2fx_i2c_write(0x3211, 0x79);
-	desirec_s5k3e2fx_i2c_write(0x3212, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3213, 0x9d);
-	desirec_s5k3e2fx_i2c_write(0x3214, 0xed);
-	desirec_s5k3e2fx_i2c_write(0x3215, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3216, 0x3d);
-	desirec_s5k3e2fx_i2c_write(0x3217, 0x02);
-	desirec_s5k3e2fx_i2c_write(0x3218, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3219, 0xa8);
-	desirec_s5k3e2fx_i2c_write(0x321a, 0x6a);
-	desirec_s5k3e2fx_i2c_write(0x321b, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x321c, 0x4c);
-	desirec_s5k3e2fx_i2c_write(0x321d, 0x9a);
-	desirec_s5k3e2fx_i2c_write(0x321e, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x321f, 0xfb);
-	desirec_s5k3e2fx_i2c_write(0x3220, 0xdb);
-	desirec_s5k3e2fx_i2c_write(0x3221, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3222, 0xc8);
-	desirec_s5k3e2fx_i2c_write(0x3223, 0x1a);
-	desirec_s5k3e2fx_i2c_write(0x3224, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3225, 0x5b);
-	desirec_s5k3e2fx_i2c_write(0x3226, 0xf3);
-	desirec_s5k3e2fx_i2c_write(0x3227, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3228, 0xae);
-	desirec_s5k3e2fx_i2c_write(0x3229, 0xe3);
-	desirec_s5k3e2fx_i2c_write(0x322a, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x322b, 0x5b);
-	desirec_s5k3e2fx_i2c_write(0x322c, 0xc8);
-	desirec_s5k3e2fx_i2c_write(0x322d, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x322e, 0xc3);
-	desirec_s5k3e2fx_i2c_write(0x322f, 0xf6);
-	desirec_s5k3e2fx_i2c_write(0x3230, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3231, 0xe4);
-	desirec_s5k3e2fx_i2c_write(0x3232, 0xb3);
-	desirec_s5k3e2fx_i2c_write(0x3233, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3234, 0x58);
-	desirec_s5k3e2fx_i2c_write(0x3235, 0xdf);
-	desirec_s5k3e2fx_i2c_write(0x3236, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3237, 0xbf);
-	desirec_s5k3e2fx_i2c_write(0x3238, 0x67);
-	desirec_s5k3e2fx_i2c_write(0x3239, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x323a, 0x3c);
-	desirec_s5k3e2fx_i2c_write(0x323b, 0x8e);
-	desirec_s5k3e2fx_i2c_write(0x323c, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x323d, 0xd0);
-	desirec_s5k3e2fx_i2c_write(0x323e, 0x3d);
-	desirec_s5k3e2fx_i2c_write(0x323f, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3240, 0x11);
-	desirec_s5k3e2fx_i2c_write(0x3241, 0xfd);
-	desirec_s5k3e2fx_i2c_write(0x3242, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3243, 0x1a);
-	desirec_s5k3e2fx_i2c_write(0x3244, 0xf0);
-	desirec_s5k3e2fx_i2c_write(0x3245, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3246, 0xbd);
-	desirec_s5k3e2fx_i2c_write(0x3247, 0x5d);
-	desirec_s5k3e2fx_i2c_write(0x3248, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3249, 0x22);
-	desirec_s5k3e2fx_i2c_write(0x324a, 0x32);
-	desirec_s5k3e2fx_i2c_write(0x324b, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x324c, 0xff);
-	desirec_s5k3e2fx_i2c_write(0x324d, 0x2e);
-	desirec_s5k3e2fx_i2c_write(0x324e, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x324f, 0xeb);
-	desirec_s5k3e2fx_i2c_write(0x3250, 0x0c);
-	desirec_s5k3e2fx_i2c_write(0x3251, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3252, 0x11);
-	desirec_s5k3e2fx_i2c_write(0x3253, 0xbd);
-	desirec_s5k3e2fx_i2c_write(0x3254, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3255, 0x17);
-	desirec_s5k3e2fx_i2c_write(0x3256, 0xda);
-	desirec_s5k3e2fx_i2c_write(0x3257, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3258, 0xeb);
-	desirec_s5k3e2fx_i2c_write(0x3259, 0xf9);
-	desirec_s5k3e2fx_i2c_write(0x325a, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x325b, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x325c, 0x81);
-	desirec_s5k3e2fx_i2c_write(0x325d, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x325e, 0xdf);
-	desirec_s5k3e2fx_i2c_write(0x325f, 0x3e);
-	desirec_s5k3e2fx_i2c_write(0x3260, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3261, 0x2c);
-	desirec_s5k3e2fx_i2c_write(0x3262, 0x9f);
-	desirec_s5k3e2fx_i2c_write(0x3263, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3264, 0xe9);
-	desirec_s5k3e2fx_i2c_write(0x3265, 0xd7);
-	desirec_s5k3e2fx_i2c_write(0x3266, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3267, 0xd1);
-	desirec_s5k3e2fx_i2c_write(0x3268, 0x83);
-	desirec_s5k3e2fx_i2c_write(0x3269, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x326a, 0x3e);
-	desirec_s5k3e2fx_i2c_write(0x326b, 0x18);
-	desirec_s5k3e2fx_i2c_write(0x326c, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x326d, 0xcb);
-	desirec_s5k3e2fx_i2c_write(0x326e, 0x32);
-	desirec_s5k3e2fx_i2c_write(0x326f, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3270, 0xaf);
-	desirec_s5k3e2fx_i2c_write(0x3271, 0xe3);
-	desirec_s5k3e2fx_i2c_write(0x3272, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3273, 0x51);
-	desirec_s5k3e2fx_i2c_write(0x3274, 0xc8);
-	desirec_s5k3e2fx_i2c_write(0x3275, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3276, 0xc5);
-	desirec_s5k3e2fx_i2c_write(0x3277, 0x4c);
-	desirec_s5k3e2fx_i2c_write(0x3278, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3279, 0x13);
-	desirec_s5k3e2fx_i2c_write(0x327a, 0x30);
-	desirec_s5k3e2fx_i2c_write(0x327b, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x327c, 0x15);
-	desirec_s5k3e2fx_i2c_write(0x327d, 0x7b);
-	desirec_s5k3e2fx_i2c_write(0x327e, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x327f, 0x97);
-	desirec_s5k3e2fx_i2c_write(0x3280, 0x3f);
-	desirec_s5k3e2fx_i2c_write(0x3281, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3282, 0x3e);
-	desirec_s5k3e2fx_i2c_write(0x3283, 0x26);
-	desirec_s5k3e2fx_i2c_write(0x3284, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3285, 0xb3);
-	desirec_s5k3e2fx_i2c_write(0x3286, 0x02);
-	desirec_s5k3e2fx_i2c_write(0x3287, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3288, 0x37);
-	desirec_s5k3e2fx_i2c_write(0x3289, 0x73);
-	desirec_s5k3e2fx_i2c_write(0x328a, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x328b, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x328c, 0xd7);
-	desirec_s5k3e2fx_i2c_write(0x328d, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x328e, 0xbf);
-	desirec_s5k3e2fx_i2c_write(0x328f, 0xdc);
-	desirec_s5k3e2fx_i2c_write(0x3290, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3291, 0x5a);
-	desirec_s5k3e2fx_i2c_write(0x3292, 0x9b);
-	desirec_s5k3e2fx_i2c_write(0x3293, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3294, 0xaf);
-	desirec_s5k3e2fx_i2c_write(0x3295, 0x68);
-	desirec_s5k3e2fx_i2c_write(0x3296, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3297, 0x4c);
-	desirec_s5k3e2fx_i2c_write(0x3298, 0xdb);
-	desirec_s5k3e2fx_i2c_write(0x3299, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x329a, 0xdc);
-	desirec_s5k3e2fx_i2c_write(0x329b, 0xb5);
-	desirec_s5k3e2fx_i2c_write(0x329c, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x329d, 0xca);
-	desirec_s5k3e2fx_i2c_write(0x329e, 0x69);
-	desirec_s5k3e2fx_i2c_write(0x329f, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32a0, 0x68);
-	desirec_s5k3e2fx_i2c_write(0x32a1, 0x0a);
-	desirec_s5k3e2fx_i2c_write(0x32a2, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32a3, 0xc9);
-	desirec_s5k3e2fx_i2c_write(0x32a4, 0x6c);
-	desirec_s5k3e2fx_i2c_write(0x32a5, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32a6, 0x37);
-	desirec_s5k3e2fx_i2c_write(0x32a7, 0x6e);
-	desirec_s5k3e2fx_i2c_write(0x32a8, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32a9, 0xe2);
-	desirec_s5k3e2fx_i2c_write(0x32aa, 0x22);
-	desirec_s5k3e2fx_i2c_write(0x32ab, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32ac, 0xfd);
-	desirec_s5k3e2fx_i2c_write(0x32ad, 0x8b);
-	desirec_s5k3e2fx_i2c_write(0x32ae, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32af, 0x36);
-	desirec_s5k3e2fx_i2c_write(0x32b0, 0x33);
-	desirec_s5k3e2fx_i2c_write(0x32b1, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32b2, 0xa3);
-	desirec_s5k3e2fx_i2c_write(0x32b3, 0xf7);
-	desirec_s5k3e2fx_i2c_write(0x32b4, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32b5, 0x1b);
-	desirec_s5k3e2fx_i2c_write(0x32b6, 0xd5);
-	desirec_s5k3e2fx_i2c_write(0x32b7, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32b8, 0x0a);
-	desirec_s5k3e2fx_i2c_write(0x32b9, 0x4f);
-	desirec_s5k3e2fx_i2c_write(0x32ba, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32bb, 0xd6);
-	desirec_s5k3e2fx_i2c_write(0x32bc, 0x4d);
-	desirec_s5k3e2fx_i2c_write(0x32bd, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32be, 0x21);
-	desirec_s5k3e2fx_i2c_write(0x32bf, 0x85);
-	desirec_s5k3e2fx_i2c_write(0x32c0, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32c1, 0xfc);
-	desirec_s5k3e2fx_i2c_write(0x32c2, 0x04);
-	desirec_s5k3e2fx_i2c_write(0x32c3, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32c4, 0x10);
-	desirec_s5k3e2fx_i2c_write(0x32c5, 0x8c);
-	desirec_s5k3e2fx_i2c_write(0x32c6, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32c7, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32c8, 0xf5);
-	desirec_s5k3e2fx_i2c_write(0x32c9, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32ca, 0xd4);
-	desirec_s5k3e2fx_i2c_write(0x32cb, 0xf3);
-	desirec_s5k3e2fx_i2c_write(0x32cc, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32cd, 0x3b);
-	desirec_s5k3e2fx_i2c_write(0x32ce, 0x31);
-	desirec_s5k3e2fx_i2c_write(0x32cf, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32d0, 0xe0);
-	desirec_s5k3e2fx_i2c_write(0x32d1, 0xb3);
-	desirec_s5k3e2fx_i2c_write(0x32d2, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32d3, 0xe4);
-	desirec_s5k3e2fx_i2c_write(0x32d4, 0xa1);
-	desirec_s5k3e2fx_i2c_write(0x32d5, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32d6, 0x22);
-	desirec_s5k3e2fx_i2c_write(0x32d7, 0x10);
-	desirec_s5k3e2fx_i2c_write(0x32d8, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32d9, 0xa7);
-	desirec_s5k3e2fx_i2c_write(0x32da, 0x91);
-	desirec_s5k3e2fx_i2c_write(0x32db, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32dc, 0xc6);
-	desirec_s5k3e2fx_i2c_write(0x32dd, 0xd2);
-	desirec_s5k3e2fx_i2c_write(0x32de, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32df, 0x3a);
-	desirec_s5k3e2fx_i2c_write(0x32e0, 0x5e);
-	desirec_s5k3e2fx_i2c_write(0x32e1, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32e2, 0xd6);
-	desirec_s5k3e2fx_i2c_write(0x32e3, 0xe0);
-	desirec_s5k3e2fx_i2c_write(0x32e4, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32e5, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32e6, 0xa2);
-	desirec_s5k3e2fx_i2c_write(0x32e7, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32e8, 0x0b);
-	desirec_s5k3e2fx_i2c_write(0x32e9, 0x02);
-	desirec_s5k3e2fx_i2c_write(0x32ea, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32eb, 0xb3);
-	desirec_s5k3e2fx_i2c_write(0x32ec, 0xdd);
-	desirec_s5k3e2fx_i2c_write(0x32ed, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32ee, 0x2f);
-	desirec_s5k3e2fx_i2c_write(0x32ef, 0xa2);
-	desirec_s5k3e2fx_i2c_write(0x32f0, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32f1, 0xbb);
-	desirec_s5k3e2fx_i2c_write(0x32f2, 0x1f);
-	desirec_s5k3e2fx_i2c_write(0x32f3, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32f4, 0x38);
-	desirec_s5k3e2fx_i2c_write(0x32f5, 0x09);
-	desirec_s5k3e2fx_i2c_write(0x32f6, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32f7, 0xfc);
-	desirec_s5k3e2fx_i2c_write(0x32f8, 0xc4);
-	desirec_s5k3e2fx_i2c_write(0x32f9, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x32fa, 0xde);
-	desirec_s5k3e2fx_i2c_write(0x32fb, 0x51);
-	desirec_s5k3e2fx_i2c_write(0x32fc, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x32fd, 0x3c);
-	desirec_s5k3e2fx_i2c_write(0x32fe, 0xdb);
-	desirec_s5k3e2fx_i2c_write(0x32ff, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3300, 0xc3);
-	desirec_s5k3e2fx_i2c_write(0x3301, 0x2e);
-	desirec_s5k3e2fx_i2c_write(0x3302, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3303, 0x4a);
-	desirec_s5k3e2fx_i2c_write(0x3304, 0x96);
-	desirec_s5k3e2fx_i2c_write(0x3305, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3306, 0xd7);
-	desirec_s5k3e2fx_i2c_write(0x3307, 0x20);
-	desirec_s5k3e2fx_i2c_write(0x3308, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3309, 0xe3);
-	desirec_s5k3e2fx_i2c_write(0x330a, 0x64);
-	desirec_s5k3e2fx_i2c_write(0x330b, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x330c, 0x3b);
-	desirec_s5k3e2fx_i2c_write(0x330d, 0xde);
-	desirec_s5k3e2fx_i2c_write(0x330e, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x330f, 0xe2);
-	desirec_s5k3e2fx_i2c_write(0x3310, 0xb6);
-	desirec_s5k3e2fx_i2c_write(0x3311, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3312, 0x29);
-	desirec_s5k3e2fx_i2c_write(0x3313, 0xfd);
-	desirec_s5k3e2fx_i2c_write(0x3314, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3315, 0xd3);
-	desirec_s5k3e2fx_i2c_write(0x3316, 0xee);
-	desirec_s5k3e2fx_i2c_write(0x3317, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3318, 0x0c);
-	desirec_s5k3e2fx_i2c_write(0x3319, 0x40);
-	desirec_s5k3e2fx_i2c_write(0x331a, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x331b, 0x1d);
-	desirec_s5k3e2fx_i2c_write(0x331c, 0x96);
-	desirec_s5k3e2fx_i2c_write(0x331d, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x331e, 0xd4);
-	desirec_s5k3e2fx_i2c_write(0x331f, 0xd9);
-	desirec_s5k3e2fx_i2c_write(0x3320, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3321, 0x0e);
-	desirec_s5k3e2fx_i2c_write(0x3322, 0xa8);
-	desirec_s5k3e2fx_i2c_write(0x3323, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3324, 0x02);
-	desirec_s5k3e2fx_i2c_write(0x3325, 0xc6);
-	desirec_s5k3e2fx_i2c_write(0x3326, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3327, 0xf3);
-	desirec_s5k3e2fx_i2c_write(0x3328, 0xc1);
-	desirec_s5k3e2fx_i2c_write(0x3329, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x332a, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x332b, 0xe2);
-	desirec_s5k3e2fx_i2c_write(0x332c, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x332d, 0x03);
-	desirec_s5k3e2fx_i2c_write(0x332e, 0x56);
-	desirec_s5k3e2fx_i2c_write(0x332f, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3330, 0xf4);
-	desirec_s5k3e2fx_i2c_write(0x3331, 0xc0);
-	desirec_s5k3e2fx_i2c_write(0x3332, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3333, 0xfe);
-	desirec_s5k3e2fx_i2c_write(0x3334, 0xc5);
-	desirec_s5k3e2fx_i2c_write(0x3335, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3336, 0xe8);
-	desirec_s5k3e2fx_i2c_write(0x3337, 0xb8);
-	desirec_s5k3e2fx_i2c_write(0x3338, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3339, 0x1e);
-	desirec_s5k3e2fx_i2c_write(0x333a, 0xb0);
-	desirec_s5k3e2fx_i2c_write(0x333b, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x333c, 0xf2);
-	desirec_s5k3e2fx_i2c_write(0x333d, 0x01);
-	desirec_s5k3e2fx_i2c_write(0x333e, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x333f, 0xe4);
-	desirec_s5k3e2fx_i2c_write(0x3340, 0x68);
-	desirec_s5k3e2fx_i2c_write(0x3341, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3342, 0x27);
-	desirec_s5k3e2fx_i2c_write(0x3343, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3344, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3345, 0xc0);
-	desirec_s5k3e2fx_i2c_write(0x3346, 0x46);
-	desirec_s5k3e2fx_i2c_write(0x3347, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3348, 0xbb);
-	desirec_s5k3e2fx_i2c_write(0x3349, 0x8b);
-	desirec_s5k3e2fx_i2c_write(0x334a, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x334b, 0x46);
-	desirec_s5k3e2fx_i2c_write(0x334c, 0xea);
-	desirec_s5k3e2fx_i2c_write(0x334d, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x334e, 0xcc);
-	desirec_s5k3e2fx_i2c_write(0x334f, 0xb7);
-	desirec_s5k3e2fx_i2c_write(0x3350, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3351, 0x10);
-	desirec_s5k3e2fx_i2c_write(0x3352, 0x01);
-	desirec_s5k3e2fx_i2c_write(0x3353, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3354, 0x13);
-	desirec_s5k3e2fx_i2c_write(0x3355, 0xe1);
-	desirec_s5k3e2fx_i2c_write(0x3356, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3357, 0x9f);
-	desirec_s5k3e2fx_i2c_write(0x3358, 0xff);
-	desirec_s5k3e2fx_i2c_write(0x3359, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x335a, 0x3d);
-	desirec_s5k3e2fx_i2c_write(0x335b, 0x6c);
-	desirec_s5k3e2fx_i2c_write(0x335c, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x335d, 0xa7);
-	desirec_s5k3e2fx_i2c_write(0x335e, 0x7b);
-	desirec_s5k3e2fx_i2c_write(0x335f, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3360, 0x4b);
-	desirec_s5k3e2fx_i2c_write(0x3361, 0x91);
-	desirec_s5k3e2fx_i2c_write(0x3362, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3363, 0xfb);
-	desirec_s5k3e2fx_i2c_write(0x3364, 0x99);
-	desirec_s5k3e2fx_i2c_write(0x3365, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3366, 0xcc);
-	desirec_s5k3e2fx_i2c_write(0x3367, 0x52);
-	desirec_s5k3e2fx_i2c_write(0x3368, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3369, 0x53);
-	desirec_s5k3e2fx_i2c_write(0x336a, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x336b, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x336c, 0xaa);
-	desirec_s5k3e2fx_i2c_write(0x336d, 0xa2);
-	desirec_s5k3e2fx_i2c_write(0x336e, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x336f, 0x64);
-	desirec_s5k3e2fx_i2c_write(0x3370, 0xa2);
-	desirec_s5k3e2fx_i2c_write(0x3371, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3372, 0xbe);
-	desirec_s5k3e2fx_i2c_write(0x3373, 0xc4);
-	desirec_s5k3e2fx_i2c_write(0x3374, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3375, 0xe4);
-	desirec_s5k3e2fx_i2c_write(0x3376, 0xbb);
-	desirec_s5k3e2fx_i2c_write(0x3377, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3378, 0x56);
-	desirec_s5k3e2fx_i2c_write(0x3379, 0xd8);
-	desirec_s5k3e2fx_i2c_write(0x337a, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x337b, 0xc8);
-	desirec_s5k3e2fx_i2c_write(0x337c, 0xdc);
-	desirec_s5k3e2fx_i2c_write(0x337d, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x337e, 0x44);
-	desirec_s5k3e2fx_i2c_write(0x337f, 0xa7);
-	desirec_s5k3e2fx_i2c_write(0x3380, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3381, 0xbd);
-	desirec_s5k3e2fx_i2c_write(0x3382, 0xca);
-	desirec_s5k3e2fx_i2c_write(0x3383, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3384, 0x29);
-	desirec_s5k3e2fx_i2c_write(0x3385, 0xf7);
-	desirec_s5k3e2fx_i2c_write(0x3386, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3387, 0x08);
-	desirec_s5k3e2fx_i2c_write(0x3388, 0xf2);
-	desirec_s5k3e2fx_i2c_write(0x3389, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x338a, 0xc6);
-	desirec_s5k3e2fx_i2c_write(0x338b, 0x1c);
-	desirec_s5k3e2fx_i2c_write(0x338c, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x338d, 0x28);
-	desirec_s5k3e2fx_i2c_write(0x338e, 0x3b);
-	desirec_s5k3e2fx_i2c_write(0x338f, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3390, 0xfc);
-	desirec_s5k3e2fx_i2c_write(0x3391, 0x30);
-	desirec_s5k3e2fx_i2c_write(0x3392, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x3393, 0xee);
-	desirec_s5k3e2fx_i2c_write(0x3394, 0x3e);
-	desirec_s5k3e2fx_i2c_write(0x3395, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3396, 0x02);
-	desirec_s5k3e2fx_i2c_write(0x3397, 0x32);
-	desirec_s5k3e2fx_i2c_write(0x3398, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x3399, 0x25);
-	desirec_s5k3e2fx_i2c_write(0x339a, 0xb6);
-	desirec_s5k3e2fx_i2c_write(0x339b, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x339c, 0xe9);
-	desirec_s5k3e2fx_i2c_write(0x339d, 0xd5);
-	desirec_s5k3e2fx_i2c_write(0x339e, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x339f, 0xf3);
-	desirec_s5k3e2fx_i2c_write(0x33a0, 0x80);
-	desirec_s5k3e2fx_i2c_write(0x33a1, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x33a2, 0xda);
-	desirec_s5k3e2fx_i2c_write(0x33a3, 0x56);
-	desirec_s5k3e2fx_i2c_write(0x33a4, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x33a5, 0x3c);
-	desirec_s5k3e2fx_i2c_write(0x33a6, 0x4a);
-	desirec_s5k3e2fx_i2c_write(0x33a7, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x33a8, 0xe0);
-	desirec_s5k3e2fx_i2c_write(0x33a9, 0x9d);
-	desirec_s5k3e2fx_i2c_write(0x33aa, 0x0f);
-	desirec_s5k3e2fx_i2c_write(0x33ab, 0xd9);
-	desirec_s5k3e2fx_i2c_write(0x33ac, 0x7d);
-	desirec_s5k3e2fx_i2c_write(0x33ad, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x33ae, 0x34);
-	desirec_s5k3e2fx_i2c_write(0x33af, 0x54);
-	desirec_s5k3e2fx_i2c_write(0x309D, 0x62);
-	desirec_s5k3e2fx_i2c_write(0x309d, 0x22);
-	desirec_s5k3e2fx_i2c_write(0x309e, 0x52);
-	desirec_s5k3e2fx_i2c_write(0x309f, 0x3e);
-	desirec_s5k3e2fx_i2c_write(0x30a0, 0x03);
-	desirec_s5k3e2fx_i2c_write(0x30a1, 0x1f);
-	desirec_s5k3e2fx_i2c_write(0x30a2, 0x04);
-	desirec_s5k3e2fx_i2c_write(0x30a3, 0x21);
-	desirec_s5k3e2fx_i2c_write(0x30a4, 0x04);
-	desirec_s5k3e2fx_i2c_write(0x30a5, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x30a6, 0x0c);
-	desirec_s5k3e2fx_i2c_write(0x30a7, 0x7c);
-	desirec_s5k3e2fx_i2c_write(0x30a8, 0x04);
-	desirec_s5k3e2fx_i2c_write(0x30a9, 0x00);
-	desirec_s5k3e2fx_i2c_write(0x30aa, 0x10);
-	desirec_s5k3e2fx_i2c_write(0x30ab, 0x84);
-	return;
-}
-
-/***********************************************************
-* disable and pull all clock
-************************************************************/
-static void desirec_msm_camio_disable_put(void){
-	CLK_DISABLE_AND_PUT(mdc_clk);
-	CLK_DISABLE_AND_PUT(vfe_mdc_clk);
-	CLK_DISABLE_AND_PUT(vfe_clk);
-}
-
-/***********************************************************
-* Samsung init sensor sequence
-************************************************************/
-static void desirec_s5k3e2fx_sensor_init(void)
-{
-	int ret;
-	if (!pclient_i2c)
-		return;
-
-	/* enable clk */
-	desirec_msm_camio_clk_enable(CAMIO_VFE_MDC_CLK);
-	desirec_msm_camio_clk_enable(CAMIO_MDC_CLK);
-	/* reset CAMIF */
-	desirec_s5k3e2fx_camif_pad_reg_reset();
-	/* set mclk */
-	ret = desirec_msm_camio_clk_rate_set(24000000);
-	if (ret < 0)
-		printk(KERN_ERR "camio clk rate select error\n");
-	/* enable gpio */
-	config_desirec_camera_on_gpios();
-
-	mdelay(50);
-	/*pull hi reset*/
-	printk(KERN_INFO "s5k3e2fx: s5k3e2fx_register_init\n");
-	ret = gpio_request(DESIREC_GPIO_CAM_RST_N, "s5k3e2fx");
-	if (!ret) {
-		gpio_direction_output(DESIREC_GPIO_CAM_RST_N, 1);
-		printk(KERN_INFO "s5k3e2fx: camera sensor_reset set as 1\n");
-	} else
-		printk(KERN_ERR "s5k3e2fx error: request gpio %d failed: "
-				"%d\n", DESIREC_GPIO_CAM_RST_N, ret);
-	gpio_free(DESIREC_GPIO_CAM_RST_N);
-	printk(KERN_INFO "s5k3e2fx: camera sensor init sequence done\n");
-}
-
-/***********************************************************
-* Samsung sensor suspend
-************************************************************/
-void desirec_s5k3e2fx_sensor_deinit(void)
-{
-	if (!pclient_i2c)
-		return;
-	/*disable clk*/
-	desirec_msm_camio_clk_disable(CAMIO_VFE_CLK);
-	desirec_msm_camio_clk_disable(CAMIO_VFE_MDC_CLK);
-	desirec_msm_camio_clk_disable(CAMIO_MDC_CLK);
-	/*CLK_DISABLE_AND_PUT(vfe_clk);*/ /* this matches clk_select(1) */
-	/* disable gpios */
-	config_desirec_camera_off_gpios();
-}
-
-/***********************************************************
-* Samsung sensor camif app reset2
-************************************************************/
-void desirec_s5k3e2fx_camif_reset2(void){
-	unsigned short stream, hi_z;
-	/*read sensor streaming status*/
-	desirec_s5k3e2fx_i2c_read(0x0100, &stream);
-	desirec_s5k3e2fx_i2c_read(0x3150, &hi_z);
-	if (stream == 0)
-		printk(KERN_INFO "streaming off, might be make system reboot");
-
-	if (CHECK()) {
-		HWIO_OUTM(MDDI_CAMIF_CFG,
-			HWIO_FMSK(MDDI_CAMIF_CFG, CAM_PAD_REG_SW_RESET),
-			1 << HWIO_SHFT(MDDI_CAMIF_CFG, CAM_PAD_REG_SW_RESET));
-		msleep(10);
-		HWIO_OUTM(MDDI_CAMIF_CFG,
-			HWIO_FMSK(MDDI_CAMIF_CFG, CAM_PAD_REG_SW_RESET),
-			0 << HWIO_SHFT(MDDI_CAMIF_CFG, CAM_PAD_REG_SW_RESET));
-		msleep(10);
-		/*add by Qualcomm suggestion*/
-		HWIO_OUTM(AXI_RESET, HWIO_FMSK(APPS_RESET, VFE),
-			1 << HWIO_SHFT(APPS_RESET, VFE));
-		mdelay(10);
-		HWIO_OUTM(AXI_RESET, HWIO_FMSK(APPS_RESET, VFE),
-			0 << HWIO_SHFT(APPS_RESET, VFE));
-		mdelay(10);
-	}
-}
-
-/***********************************************************
-* Samsung sensor camif app reset
-************************************************************/
-
-int desirec_s5k3e2fx_camif_app_reset(void){
-	int rc;
-	/*add fix for ADSP Illigel command fix*/
-	if (CHECK()) {
-		#if 0/*take off by Qualcomm suggestion*/
-		rc = desirec_camif_clk_select(1);
-		if (rc < 0) {
-			printk(KERN_ERR
-				"s5k3e2fx error switching to internal clock\n");
-			return rc;
-		}
-		#endif
-		HWIO_OUTM(APPS_RESET,
-			HWIO_FMSK(APPS_RESET, VFE),
-			1 << HWIO_SHFT(APPS_RESET, VFE));
-			udelay(10);
-		HWIO_OUTM(APPS_RESET,
-			HWIO_FMSK(APPS_RESET, VFE),
-			0 << HWIO_SHFT(APPS_RESET, VFE));
-		udelay(10);
-		/*add by Qualcomm suggestion*/
-		HWIO_OUTM(AXI_RESET, HWIO_FMSK(APPS_RESET, VFE),
-			1 << HWIO_SHFT(APPS_RESET, VFE));
-		mdelay(10);
-		HWIO_OUTM(AXI_RESET, HWIO_FMSK(APPS_RESET, VFE),
-			0 << HWIO_SHFT(APPS_RESET, VFE));
-		mdelay(10);
-		#if 0/*take off by Qualcomm suggestion*/
-		rc = desirec_camif_clk_select(0); /* external */
-		if (rc < 0) {
-			printk(KERN_ERR
-				"s5k3e2fx error switching to external clock\n");
-			return rc;
-		}
-		#endif
-	}
-	return rc;
-}
-
-/***********************************************************
-* Samsung sensor camif reset
-************************************************************/
-
-int desirec_s5k3e2fx_camif_pad_reg_reset(void)
-{
-	int rc = desirec_camif_clk_select(1);
-	if (rc < 0) {
-		printk(KERN_ERR "s5k3e2fx error switching to internal clock\n");
-		return rc;
-	}
-	HWIO_OUTM(MDDI_CAMIF_CFG,
-		HWIO_FMSK(MDDI_CAMIF_CFG, CAM_SEL) |
-		HWIO_FMSK(MDDI_CAMIF_CFG, CAM_PCLK_SRC_SEL) |
-		HWIO_FMSK(MDDI_CAMIF_CFG, CAM_PCLK_INVERT),
-		1 << HWIO_SHFT(MDDI_CAMIF_CFG, CAM_SEL) |
-		3 << HWIO_SHFT(MDDI_CAMIF_CFG, CAM_PCLK_SRC_SEL) |
-		0 << HWIO_SHFT(MDDI_CAMIF_CFG, CAM_PCLK_INVERT));
-	msleep(10);
-	HWIO_OUTM(MDDI_CAMIF_CFG,
-		HWIO_FMSK(MDDI_CAMIF_CFG, CAM_PAD_REG_SW_RESET),
-		1 << HWIO_SHFT(MDDI_CAMIF_CFG,
-		CAM_PAD_REG_SW_RESET));
-	msleep(10);
-	HWIO_OUTM(MDDI_CAMIF_CFG,
-		HWIO_FMSK(MDDI_CAMIF_CFG, CAM_PAD_REG_SW_RESET),
-		0 << HWIO_SHFT(MDDI_CAMIF_CFG,
-		CAM_PAD_REG_SW_RESET));
-	msleep(10);
-	rc = desirec_camif_clk_select(0); /* external */
-	if (rc < 0) {
-		printk(KERN_ERR "s5k3e2fx error switching to external clock\n");
-		return rc;
-	}
-
-	return rc;
-}
-
-
-
-/***********************************************************
-* Select clk source of CAMIF
-************************************************************/
-int desirec_camif_clk_select(int internal)
-{
-	int rc = -EIO;
-	CLK_GET(vfe_clk);
-	if (vfe_clk != NULL) {
-		extern int clk_set_flags(struct clk *clk, unsigned long flags);
-		rc = clk_set_flags(vfe_clk, 0x00000100 << internal);
-		if (!rc && internal)
-			rc = desirec_msm_camio_vfe_clk_enable();
-	}
-	return rc;
-}
-
-/***********************************************************
-* Enable CLK
-************************************************************/
-int desirec_msm_camio_clk_enable(int clk_type)
-{
-	struct clk *clk = NULL;
-	int *enabled = NULL;
-	printk(KERN_INFO "s5k3e2fx(desirec): clk_type:%d\n", clk_type);
-	switch (clk_type) {
-	case CAMIO_VFE_MDC_CLK:
-		CLK_GET(vfe_mdc_clk);
-		clk = vfe_mdc_clk;
-		enabled = &vfe_mdc_clk_enabled;
-		break;
-	case CAMIO_MDC_CLK:
-		CLK_GET(mdc_clk);
-		clk = mdc_clk;
-		enabled = &mdc_clk_enabled;
-		break;
-	default:
-		break;
-	}
-
-	if (clk != NULL && !*enabled) {
-		int rc = clk_enable(clk);
-		*enabled = !rc;
-		return rc;
-	}
-
-	return -EINVAL;
-}
-
-/***********************************************************
-* Disable CLK
-************************************************************/
-int desirec_msm_camio_clk_disable(int clk_type)
-{
-	int rc = 0;
-	struct clk *clk = NULL;
-	int *enabled = NULL;
-	printk(KERN_INFO "s5k3e2fx(desirec): clk_type:%d\n", clk_type);
-	switch (clk_type) {
-	case CAMIO_VFE_MDC_CLK:
-		clk = vfe_mdc_clk;
-		enabled = &vfe_mdc_clk_enabled;
-		break;
-	case CAMIO_MDC_CLK:
-		clk = mdc_clk;
-		enabled = &mdc_clk_enabled;
-		break;
-	case CAMIO_VFE_CLK:
-		clk = vfe_clk;
-		enabled = &vfe_clk_enabled;
-	default:
-		rc = -1;
-		break;
-	}
-
-	if (clk != NULL && *enabled) {
-		clk_disable(clk);
-		*enabled = 0;
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-
-/***********************************************************
-* set VFE clk rate
-************************************************************/
-int desirec_msm_camio_clk_rate_set(int rate)
-{
-	printk(KERN_INFO "s5k3e2fx(desirec): vfe_clk_enabled:%d\n",
-		vfe_clk_enabled);
-	printk(KERN_INFO "s5k3e2fx(desirec): rate:%d\n", rate);
-	int rc = desirec_msm_camio_vfe_clk_enable();
-	if (!rc && vfe_clk_enabled)
-		rc = clk_set_rate(vfe_clk, rate);
-	return rc;
-}
-
-
-/***********************************************************
-* Samsung sensor power up
-************************************************************/
-int desirec_s5k3e2fx_power_up(void)
-{
-	if (powered) {
-		printk(KERN_INFO "s5k3e2fx: already powered up\n");
-		return 0;
-	}
-	/*Kevin add base on Samsung suggested settings 20090413*/
-	desirec_s5k3e2fx_i2c_write(0x3150, 0x50);
-	msleep(2);
-	powered = 1;
-	return 0;
-}
-/***********************************************************
-* Samsung sensor power down
-************************************************************/
-
-int desirec_s5k3e2fx_power_down(void)
-{
-	if (!powered) {
-		printk(KERN_INFO "s5k3e2fx: already powered down\n");
-		return 0;
-	}
-	desirec_s5k3e2fx_i2c_write(0x3130, 0x00);
-	msleep(10);
-	desirec_s5k3e2fx_i2c_write(S5K3E2FX_REG_MODE_SELECT,
-		S5K3E2FX_MODE_SELECT_SW_STANDBY);
-	msleep(10);
-	/*Kevin add base on Samsung suggested settings 20090413*/
-	desirec_s5k3e2fx_i2c_write(0x3150, 0x51);
-	msleep(260);
-	powered  = 0;
-	return 0;
-}
-
-
-/***********************************************************
-* Samsung sensor system suspend
-************************************************************/
-
-int desirec_s5k3e2fx_suspend(void *client, pm_message_t mesg)
-{
-	int ret;
-	ret = gpio_request(DESIREC_GPIO_CAM_RST_N, "s5k3e2fx");
-	if (!ret) {
-		gpio_direction_output(DESIREC_GPIO_CAM_RST_N, 0);
-		printk(KERN_INFO "s5k3e2fx: camera sensor_reset set as 0\n");
-	} else
-		printk(KERN_ERR "s5k3e2fx error: request gpio %d failed: "
-				"%d\n", DESIREC_GPIO_CAM_RST_N, ret);
-	gpio_free(DESIREC_GPIO_CAM_RST_N);
-	return 0;
-}
-
-int desirec_s5k3e2fx_late_resume(struct early_suspend *handler)
-{
-	int rc;
-	msleep(50);
-	desirec_s5k3e2fx_sensor_init();
-	/*read sensor ID*/
-	rc = desirec_s5k3e2fx_i2c_read(
-		S5K3E2FX_SS5M0_REG_MODEL_ID, &chipid);
-	if (rc < 0) {
-		printk(KERN_ERR
-			"s5k3e2fx_probe: could not read chip id, rc:%d\n", rc);
-		desirec_s5k3e2fx_sensor_deinit();
-		return rc;
-	}
-	printk(KERN_INFO "s5k3e2fx_probe: chip id: %d(0x%x)\n", chipid, chipid);
-
-	if (chipid != S5K3E2FX_SS5M0_MODEL_ID) {
-		printk(KERN_INFO
-			"s5k3e2fx_probe: chip id %d(0x%x) is invalid\n",
-			chipid, chipid);
-		desirec_s5k3e2fx_sensor_deinit();
-		return -EINVAL;
-	}
-	/* ------------------------------------------------ */
-	/*becker add for ss initial sequence*/
-	desirec_s5k3e2fx_sensor_setting_init();
-	/*lens sharding settting*/
-	desirec_s5k3e2fx_i2c_sensor_lens_sharding();
-	/*stream on*/
-	desirec_s5k3e2fx_i2c_write(
-		S5K3E2FX_REG_MODE_SELECT,
-		S5K3E2FX_MODE_SELECT_STREAM);
-	/*software standby*/
-	mdelay(25);
-	desirec_s5k3e2fx_i2c_write(0x3130, 0x00);
-	mdelay(1);
-	/*stream off*/
-	desirec_s5k3e2fx_i2c_write(
-		S5K3E2FX_REG_MODE_SELECT,
-		S5K3E2FX_MODE_SELECT_SW_STANDBY);
-	mdelay(1);
-	desirec_s5k3e2fx_i2c_write(0x3150, 0x51);
-	msleep(240);
-	/*pull down RST to low*/
-	desirec_s5k3e2fx_sensor_deinit();
-	return rc;
-}
-
-/***********************************************************
-* Samsung sensor system resume
-************************************************************/
-int desirec_s5k3e2fx_resume(void *client)
-{
-	return 0;
-}
-
-/***********************************************************
-* Samsung init sensor setting
-************************************************************/
-int desirec_s5k3e2fx_sensor_setting(unsigned long arg)
-{
-	uint32_t update = arg & 1;
-	uint32_t rt = (arg & 2) >> 1;
-	if (rt > 1 || update > 1) {
-		printk(KERN_ERR
-			"s5k3e2fx: invalid values %d of rt or %d of update\n",
-			rt, update);
-		return -EINVAL;
-	}
-	printk(KERN_INFO "s5k3e2fx(desirec): update:%d\n", update);
-	switch (update) {
-	case CAMSENSOR_REG_UPDATE_PERIODIC: {
-		uint16_t pclk_div_adj = arg >> 16;
-		printk(KERN_INFO "CAMSENSOR_REG_UPDATE_PERIODIC (rt %d)\n", rt);
-		if (!pclk_div_adj || pclk_div_adj > 2) {
-			printk(KERN_ERR
-				"s5k3e2fx: invalid value %d of pclk_div_adj\n",
-				pclk_div_adj);
-			return -EINVAL;
-		}
-		if (rt == 0) {
-			desirec_s5k3e2fx_i2c_write(0x0100, 0x00);
-			msleep(30);
-			/*---------------PLL setting for 80Mhz*/
-			desirec_s5k3e2fx_set_pclk(rt, pclk_div_adj);
-			/*---------------output size*/
-			desirec_s5k3e2fx_i2c_write(0x034c, 0x05);
-			desirec_s5k3e2fx_i2c_write(0x034d, 0x10);
-			desirec_s5k3e2fx_i2c_write(0x034e, 0x03);
-			desirec_s5k3e2fx_i2c_write(0x034f, 0xcc);
-			/*---------------frame format (min blanking)*/
-			desirec_s5k3e2fx_i2c_write(0x0340, 0x03);
-			desirec_s5k3e2fx_i2c_write(0x0341, 0xe2);
-			desirec_s5k3e2fx_i2c_write(0x0342, 0x0a);
-			desirec_s5k3e2fx_i2c_write(0x0343, 0xac);
-			/*---------------Binning*/
-			desirec_s5k3e2fx_i2c_write(0x0381, 0x01);
-			desirec_s5k3e2fx_i2c_write(0x0383, 0x01);
-			desirec_s5k3e2fx_i2c_write(0x0385, 0x01);
-			desirec_s5k3e2fx_i2c_write(0x0387, 0x03);
-			desirec_s5k3e2fx_i2c_write(0x3014, 0x06);
-			/*----------------EVT4 setting*/
-			desirec_s5k3e2fx_i2c_write(0x30bf, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x3022, 0x87);
-			/*tune ADC to got batter yield rate in EDS*/
-			desirec_s5k3e2fx_i2c_write(0x3019, 0x60);
-			/*AF driving strength*/
-			desirec_s5k3e2fx_i2c_write(0x3146, 0x3c);
-			desirec_s5k3e2fx_i2c_write(0x3152, 0x08);
-			/*data pclk driving strength*/
-			desirec_s5k3e2fx_i2c_write(0x315a, 0x7f);
-			/*h sync v sync driving strength*/
-			desirec_s5k3e2fx_i2c_write(0x3159, 0x0f);
-			/*john0811 Samsung suggest for better signal quality*/
-			desirec_s5k3e2fx_i2c_write(0x3157, 0x03);
-			desirec_s5k3e2fx_i2c_write(0x0204, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x0205, 0x80);
-			desirec_s5k3e2fx_i2c_write(0x0202, 0x03);
-			desirec_s5k3e2fx_i2c_write(0x0203, 0xd9);
-			desirec_s5k3e2fx_i2c_write(0x0200, 0x02);
-			desirec_s5k3e2fx_i2c_write(0x3130, 0x03);
-			/*----------------lens shading setting for preview*/
-			desirec_s5k3e2fx_i2c_write(0x309e, 0x52);
-			desirec_s5k3e2fx_i2c_write(0x309f, 0x3e);
-			desirec_s5k3e2fx_i2c_write(0x30a0, 0x03);
-			desirec_s5k3e2fx_i2c_write(0x30a1, 0x1f);
-			desirec_s5k3e2fx_i2c_write(0x30a2, 0x04);
-			desirec_s5k3e2fx_i2c_write(0x30a3, 0x21);
-			desirec_s5k3e2fx_i2c_write(0x30a4, 0x04);
-			desirec_s5k3e2fx_i2c_write(0x30a5, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x30a6, 0x0c);
-			desirec_s5k3e2fx_i2c_write(0x30a7, 0x7c);
-			desirec_s5k3e2fx_i2c_write(0x30a8, 0x04);
-			desirec_s5k3e2fx_i2c_write(0x30a9, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x30aa, 0x10);
-			desirec_s5k3e2fx_i2c_write(0x30ab, 0x84);
-			desirec_s5k3e2fx_i2c_write(0x0100, 0x01);
-		} else {
-			desirec_s5k3e2fx_i2c_write(0x0100, 0x00);
-			msleep(30);
-			/*--------------PLL setting for 80Mhz*/
-			desirec_s5k3e2fx_set_pclk(rt, pclk_div_adj);
-			/*--------------output size*/
-			desirec_s5k3e2fx_i2c_write(0x034c, 0x0a);
-			desirec_s5k3e2fx_i2c_write(0x034d, 0x30);
-			desirec_s5k3e2fx_i2c_write(0x034e, 0x07);
-			desirec_s5k3e2fx_i2c_write(0x034f, 0xa8);
-			/*--------------frame format (min blanking)*/
-			desirec_s5k3e2fx_i2c_write(0x0340, 0x07);
-			desirec_s5k3e2fx_i2c_write(0x0341, 0xb6);
-			desirec_s5k3e2fx_i2c_write(0x0342, 0x0a);
-			desirec_s5k3e2fx_i2c_write(0x0343, 0xac);
-			/*--------------Binning*/
-			desirec_s5k3e2fx_i2c_write(0x0381, 0x01);
-			desirec_s5k3e2fx_i2c_write(0x0383, 0x01);
-			desirec_s5k3e2fx_i2c_write(0x0385, 0x01);
-			desirec_s5k3e2fx_i2c_write(0x0387, 0x01);
-			desirec_s5k3e2fx_i2c_write(0x3014, 0x00);
-			/*--------------EVT4 setting*/
-			desirec_s5k3e2fx_i2c_write(0x30bf, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x3022, 0x87);
-			/*tune ADC to got batter yield rate in EDS*/
-			desirec_s5k3e2fx_i2c_write(0x3019, 0x60);
-			/*AF driving strength*/
-			desirec_s5k3e2fx_i2c_write(0x3146, 0x3c);
-			desirec_s5k3e2fx_i2c_write(0x3152, 0x08);
-			/*data pclk driving strength*/
-			desirec_s5k3e2fx_i2c_write(0x315a, 0x7f);
-			/*h sync v sync driving strength*/
-			desirec_s5k3e2fx_i2c_write(0x3159, 0x0f);
-			/*john0811 Samsung suggest for better signal quality*/
-			desirec_s5k3e2fx_i2c_write(0x3157, 0x03);
-			desirec_s5k3e2fx_i2c_write(0x0204, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x0205, 0x80);
-			desirec_s5k3e2fx_i2c_write(0x0202, 0x03);
-			desirec_s5k3e2fx_i2c_write(0x0203, 0xd9);
-			desirec_s5k3e2fx_i2c_write(0x0200, 0x02);
-			desirec_s5k3e2fx_i2c_write(0x3130, 0x03);
-			/*--------------lens shading setting for snapshot*/
-			desirec_s5k3e2fx_i2c_write(0x309e, 0x52);
-			desirec_s5k3e2fx_i2c_write(0x309f, 0x7b);
-			desirec_s5k3e2fx_i2c_write(0x30a0, 0x03);
-			desirec_s5k3e2fx_i2c_write(0x30a1, 0x1f);
-			desirec_s5k3e2fx_i2c_write(0x30a2, 0x02);
-			desirec_s5k3e2fx_i2c_write(0x30a3, 0x15);
-			desirec_s5k3e2fx_i2c_write(0x30a4, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x30a5, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x30a6, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x30a7, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x30a8, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x30a9, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x30aa, 0x00);
-			desirec_s5k3e2fx_i2c_write(0x30ab, 0x00);
-			/*--------------*/
-			//desirec_s5k3e2fx_i2c_write(0x0100, 0x01);  /*john0923 to avoid AE lock issue*/
-		}
-		msleep(5);
-		}
-		break;
-	case CAMSENSOR_REG_INIT:
-		printk(KERN_INFO "CAMSENSOR_REG_INIT (rt %d)\n", rt);
-		desirec_s5k3e2fx_i2c_write(0x0100, 0x00);
-		msleep(30);
-		/*--------------PLL setting for 80Mhz*/
-		desirec_s5k3e2fx_set_pclk(rt, 0);
-		/*--------------output size*/
-		desirec_s5k3e2fx_i2c_write(0x034c, 0x05);
-		desirec_s5k3e2fx_i2c_write(0x034d, 0x10);
-		desirec_s5k3e2fx_i2c_write(0x034e, 0x03);
-		desirec_s5k3e2fx_i2c_write(0x034f, 0xcc);
-		/*--------------frame format (min blanking)*/
-		desirec_s5k3e2fx_i2c_write(0x0340, 0x03);
-		desirec_s5k3e2fx_i2c_write(0x0341, 0xe2);
-		desirec_s5k3e2fx_i2c_write(0x0342, 0x0a);
-		desirec_s5k3e2fx_i2c_write(0x0343, 0xac);
-		/*--------------Binning */
-		desirec_s5k3e2fx_i2c_write(0x0381, 0x01);
-		desirec_s5k3e2fx_i2c_write(0x0383, 0x01);
-		desirec_s5k3e2fx_i2c_write(0x0385, 0x01);
-		desirec_s5k3e2fx_i2c_write(0x0387, 0x03);
-		desirec_s5k3e2fx_i2c_write(0x3014, 0x06);
-		/*--------------MSR setting*/
-		desirec_s5k3e2fx_i2c_write(0x30c4, 0x01);
-		desirec_s5k3e2fx_i2c_write(0x3000, 0x03);
-		desirec_s5k3e2fx_i2c_write(0x3001, 0x94);
-		desirec_s5k3e2fx_i2c_write(0x3002, 0x02);
-		desirec_s5k3e2fx_i2c_write(0x3003, 0x95);
-		desirec_s5k3e2fx_i2c_write(0x3004, 0x0f);
-		desirec_s5k3e2fx_i2c_write(0x3005, 0x05);
-		desirec_s5k3e2fx_i2c_write(0x3006, 0x3c);
-		desirec_s5k3e2fx_i2c_write(0x3007, 0x8c);
-		desirec_s5k3e2fx_i2c_write(0x3008, 0x93);
-		desirec_s5k3e2fx_i2c_write(0x3009, 0x05);
-		desirec_s5k3e2fx_i2c_write(0x300a, 0x3a);
-		desirec_s5k3e2fx_i2c_write(0x300c, 0x02);
-		desirec_s5k3e2fx_i2c_write(0x300d, 0x3e);
-		desirec_s5k3e2fx_i2c_write(0x300f, 0x0e);
-		desirec_s5k3e2fx_i2c_write(0x3010, 0x46);
-		desirec_s5k3e2fx_i2c_write(0x3011, 0x64);
-		desirec_s5k3e2fx_i2c_write(0x3012, 0x1e);
-		desirec_s5k3e2fx_i2c_write(0x301d, 0x3f);
-		desirec_s5k3e2fx_i2c_write(0x3024, 0x04);
-		desirec_s5k3e2fx_i2c_write(0x3028, 0x40);
-		desirec_s5k3e2fx_i2c_write(0x3070, 0xdf);
-		desirec_s5k3e2fx_i2c_write(0x301b, 0x73);
-		desirec_s5k3e2fx_i2c_write(0x307e, 0x02);
-		desirec_s5k3e2fx_i2c_write(0x30bd, 0x06);
-		desirec_s5k3e2fx_i2c_write(0x30c2, 0x0b);
-		desirec_s5k3e2fx_i2c_write(0x30ac, 0x81);
-		desirec_s5k3e2fx_i2c_write(0x3151, 0xe6);
-		desirec_s5k3e2fx_i2c_write(0x3029, 0x02);
-		/*--------------EVT4 setting*/
-		desirec_s5k3e2fx_i2c_write(0x30bf, 0x00);
-		desirec_s5k3e2fx_i2c_write(0x3022, 0x87);
-		/*tune ADC to got batter yield rate in EDS*/
-		desirec_s5k3e2fx_i2c_write(0x3019, 0x60);
-		/*AF driving strength*/
-		desirec_s5k3e2fx_i2c_write(0x3146, 0x3c);
-		desirec_s5k3e2fx_i2c_write(0x3152, 0x08);
-		/*data pclk driving strength*/
-		desirec_s5k3e2fx_i2c_write(0x315a, 0x7f);
-		/*h sync v sync driving strength*/
-		desirec_s5k3e2fx_i2c_write(0x3159, 0x0f);
-		/*john0811 Samsung suggest for better signal quality*/
-		desirec_s5k3e2fx_i2c_write(0x3157, 0x03);
-		desirec_s5k3e2fx_i2c_write(0x0204, 0x00);
-		desirec_s5k3e2fx_i2c_write(0x0205, 0x80);
-		desirec_s5k3e2fx_i2c_write(0x0202, 0x03);
-		desirec_s5k3e2fx_i2c_write(0x0203, 0xd9);
-		desirec_s5k3e2fx_i2c_write(0x0200, 0x02);
-		desirec_s5k3e2fx_i2c_write(0x3130, 0x03);
-		desirec_s5k3e2fx_i2c_write(0x0100, 0x01);
-		msleep(5);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-/***********************************************************
-* Samsung set pclk
-************************************************************/
-int desirec_s5k3e2fx_set_pclk(int rt, int div_adj)
-{
-	/* PLL setting */
-	desirec_s5k3e2fx_i2c_write(0x0305, 0x06);
-	desirec_s5k3e2fx_i2c_write(0x0306, 0x00);
-	/*88 54.4Mhz */
-	desirec_s5k3e2fx_i2c_write(0x0307, 0x83);
-	desirec_s5k3e2fx_i2c_write(0x0301, 0x08);
-	desirec_s5k3e2fx_i2c_write(0x0303, 0x01);
-	desirec_s5k3e2fx_i2c_write(0x0309, 0x08);
-	desirec_s5k3e2fx_i2c_write(0x030b, 0x01);
-	return 0;
-}
-
-/***********************************************************
-* Samsung write exposure gain
-************************************************************/
-
-int desirec_s5k3e2fx_write_exposuregain(
-	uint32_t mode, uint16_t line, uint16_t gain,
-	uint16_t linelengthpck, uint16_t framelengthlines)
-{
-	int32_t rc = 0;
-	uint8_t gain_msb, gain_lsb;
-	uint8_t line_msb, line_lsb;
-	uint8_t framelengthline_msb, framelengthline_lsb;
-
-	msleep(10);/*john0923 to avoid AE lock issue*/
-	rc = desirec_s5k3e2fx_i2c_write(0x0104, 0x01);
-	if (rc < 0)
-		return rc;
-	gain_msb = (uint8_t) ((gain & 0xFF00) >> 8);
-	gain_lsb = (uint8_t) (gain & 0x00FF);
-	rc = desirec_s5k3e2fx_i2c_write(
-		REG_ANALOGUE_GAIN_CODE_GLOBAL_MSB,
-		gain_msb);
-	if (rc < 0)
-		return rc;
-	rc = desirec_s5k3e2fx_i2c_write(
-		REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB,
-		gain_lsb);
-	if (rc < 0)
-		return rc;
-	line_msb = (uint8_t) ((line & 0xFF00) >> 8);
-	line_lsb = (uint8_t) (line & 0x00FF);
-	framelengthline_msb = (uint8_t) (((line+4) & 0xFF00) >> 8);
-	framelengthline_lsb = (uint8_t) ((line+4) & 0x00FF);
-	if (mode == 0) {
-		if (line > V_SYNC_LENGTH_PEVIEW) {
-			rc = desirec_s5k3e2fx_i2c_write(
-				REG_FRAME_LENGTH_LINES_MSB,
-				framelengthline_msb);
-			if (rc < 0)
-				return rc;
-			rc = desirec_s5k3e2fx_i2c_write(
-				REG_FRAME_LENGTH_LINES_LSB,
-				framelengthline_lsb);
-			if (rc < 0)
-			return rc;
-		} else if (line <= V_SYNC_LENGTH_PEVIEW) {
-			rc = desirec_s5k3e2fx_i2c_write(
-				REG_FRAME_LENGTH_LINES_MSB,
-				0x03);
-			if (rc < 0)
-				return rc;
-			rc = desirec_s5k3e2fx_i2c_write(
-				REG_FRAME_LENGTH_LINES_LSB,
-				0xe2);
-			if (rc < 0)
-				 return rc;
-		}
-	
-	rc = desirec_s5k3e2fx_i2c_write(              /*john0923 to avoid AE lock issue*/
-		REG_COARSE_INTEGRATION_TIME,
-		line_msb);
-	if (rc < 0)
-		return rc;
-	rc = desirec_s5k3e2fx_i2c_write(             /*john0923 to avoid AE lock issue*/
-		REG_COARSE_INTEGRATION_TIME_LSB,     
-		line_lsb);
-	if (rc < 0)
-		return rc;
-	rc = desirec_s5k3e2fx_i2c_write(0x0104, 0x00);      /*john0923 to avoid AE lock issue*/
-	if (rc < 0)
-		return rc;
-	
-	} else if (mode == 1) {
-		if (line > V_SYNC_LENGTH_SNAPSHOT) {
-			rc = desirec_s5k3e2fx_i2c_write(
-				REG_FRAME_LENGTH_LINES_MSB,
-				framelengthline_msb);
-			if (rc < 0)
-				return rc;
-			rc = desirec_s5k3e2fx_i2c_write(
-				REG_FRAME_LENGTH_LINES_LSB,
-				framelengthline_lsb);
-			if (rc < 0)
-				return rc;
-		} else if (line <= V_SYNC_LENGTH_SNAPSHOT) {
-			rc = desirec_s5k3e2fx_i2c_write(
-				REG_FRAME_LENGTH_LINES_MSB,
-				0x07);
-			if (rc < 0)
-				return rc;
-			rc = desirec_s5k3e2fx_i2c_write(
-				REG_FRAME_LENGTH_LINES_LSB,
-				0xb6);
-			if (rc < 0)
-				return rc;
-		}
-	
-	rc = desirec_s5k3e2fx_i2c_write(        /*john0923 to avoid AE lock issue*/
-		REG_COARSE_INTEGRATION_TIME,
-		line_msb);
-	if (rc < 0)
-		return rc;
-	rc = desirec_s5k3e2fx_i2c_write(        /*john0923 to avoid AE lock issue*/
-		REG_COARSE_INTEGRATION_TIME_LSB,
-		line_lsb);
-	if (rc < 0)
-		return rc;
-	rc = desirec_s5k3e2fx_i2c_write(0x0104, 0x00);      /*john0923 to avoid AE lock issue*/
-	if (rc < 0)  
-		return rc;
-	 
-		rc = desirec_s5k3e2fx_i2c_write(0x0100, 0x01);       /*john0923 to avoid AE lock issue*/
-	if (rc < 0)
-		return rc;
-	
-	}
-	return rc;
-}
-
-/***********************************************************
-* Samsung probe init sequence
-************************************************************/
-
-int desirec_s5k3e2fx_probe_init(void *client)
-{
-	int rc;
-	pclient_i2c = (struct i2c_client *)client;
-	desirec_s5k3e2fx_sensor_init();
-	chipid = 0;
-	rc = desirec_s5k3e2fx_i2c_read(S5K3E2FX_SS5M0_REG_MODEL_ID, &chipid);
-	if (rc < 0) {
-		printk(KERN_ERR
-			"s5k3e2fx_probe: could not read chip id, rc:%d\n", rc);
-		desirec_s5k3e2fx_sensor_deinit();
-		return rc;
-	}
-	printk(KERN_INFO "s5k3e2fx_probe: chip id: %d(0x%x)\n", chipid, chipid);
-
-	if (chipid != S5K3E2FX_SS5M0_MODEL_ID) {
-		printk(KERN_INFO
-				"s5k3e2fx_probe: chip id %d(0x%x) is invalid\n",
-				chipid, chipid);
-		desirec_s5k3e2fx_sensor_deinit();
-		return -EINVAL;
-	}
-	/*add for ss initial sequence*/
-	desirec_s5k3e2fx_sensor_setting_init();
-	/*for AWB auto calibration*/
-	desirec_s5k3e2fx_i2c_write(0x3110, 0x03);
-	desirec_s5k3e2fx_i2c_write(0x3112, 0x0A);
-	msleep(5);
-	desirec_s5k3e2fx_i2c_write(0x3110, 0x03);
-	desirec_s5k3e2fx_i2c_write(0x3112, 0x09);
-	
-	/*lens sharding*/
-	desirec_s5k3e2fx_i2c_sensor_lens_sharding();
-	/*stream on*/
-	desirec_s5k3e2fx_i2c_write(
-		S5K3E2FX_REG_MODE_SELECT,
-		S5K3E2FX_MODE_SELECT_STREAM);
-	/*software standby*/
-	msleep(25);
-	desirec_s5k3e2fx_i2c_write(0x3130, 0x00);/* john sync WS for temp*/
-	msleep(1);
-	/*stream off*/
-	desirec_s5k3e2fx_i2c_write(
-		S5K3E2FX_REG_MODE_SELECT,
-		S5K3E2FX_MODE_SELECT_SW_STANDBY);
-	msleep(1);
-	desirec_s5k3e2fx_i2c_write(0x3150, 0x51);
-	msleep(240);/* john sync WS for temp*/
-	/*pull down RST to low*/
-	desirec_s5k3e2fx_sensor_deinit();
-	return rc;
-}
-
-
-
diff --git a/arch/arm/mach-msm/board-desirec-camsensor.h b/arch/arm/mach-msm/board-desirec-camsensor.h
deleted file mode 100644
index 4340591..0000000
--- a/arch/arm/mach-msm/board-desirec-camsensor.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* linux/arch/arm/mach-msm/board-heroc-camsensor.h
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
- 
-#ifndef _DESIREC_CAMSENSOR_
-#define _DESIREC_CAMSENSOR_
-
-int desirec_s5k3e2fx_i2c_write(unsigned short waddr, unsigned short wdata);
-int desirec_s5k3e2fx_i2c_read(unsigned short u_addr, unsigned short *pu_data);
-int desirec_s5k3e2fx_probe_init(void *client);
-void desirec_s5k3e2fx_sensor_deinit(void);
-int desirec_s5k3e2fx_write_exposuregain(
-	uint32_t mode, uint16_t line, uint16_t gain, 
-	uint16_t linelengthpck, uint16_t framelengthlines);
-int desirec_s5k3e2fx_set_pclk(int rt, int div_adj);
-int desirec_s5k3e2fx_sensor_setting(unsigned long arg);
-int desirec_s5k3e2fx_late_resume(struct early_suspend *handler);
-int desirec_s5k3e2fx_resume(void *client);
-int desirec_s5k3e2fx_suspend(void *client,pm_message_t mesg);
-int desirec_s5k3e2fx_power_down(void);
-int desirec_s5k3e2fx_power_up(void);
-int desirec_msm_camio_clk_rate_set(int rate);
-int desirec_msm_camio_clk_disable(int clk_type);
-int desirec_msm_camio_clk_enable (int clk_type);
-int desirec_s5k3e2fx_camif_pad_reg_reset(void);
-int desirec_s5k3e2fx_camif_app_reset(void);
-void desirec_s5k3e2fx_camif_reset2(void);
-int desirec_camif_clk_select(int internal);
-
-#endif
diff --git a/arch/arm/mach-msm/board-desirec-keypad.c b/arch/arm/mach-msm/board-desirec-keypad.c
deleted file mode 100644
index 62515a3..0000000
--- a/arch/arm/mach-msm/board-desirec-keypad.c
+++ /dev/null
@@ -1,322 +0,0 @@
-/* linux/arch/arm/mach-msm/board-desirec-keypad.c
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <linux/keyreset.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-
-#include "board-desirec.h"
-
-struct desirec_axis_info {
-	struct gpio_event_axis_info info;
-	uint16_t in_state;
-	uint16_t out_state;
-	uint16_t temp_state;
-	uint16_t threshold;
-};
-
-static unsigned int desirec_col_gpios[] = { 35, 34, 33 };
-static unsigned int desirec_row_gpios[] = { 42, 41, 40 };
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(desirec_row_gpios) + (row))
-
-static const unsigned short desirec_keymap_0[ARRAY_SIZE(desirec_col_gpios) * ARRAY_SIZE(desirec_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_BACK,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 2)] = KEY_SEND,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(1, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 2)] = KEY_COMPOSE,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_HOME,
-	[KEYMAP_INDEX(2, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(2, 2)] = MATRIX_KEY(1, BTN_MOUSE),
-};
-
-static const unsigned short desirec_keymap_1[ARRAY_SIZE(desirec_col_gpios) * ARRAY_SIZE(desirec_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_RESERVED,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 2)] = KEY_SEND,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_RESERVED,
-	[KEYMAP_INDEX(1, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 2)] = KEY_RESERVED,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_RESERVED,
-	[KEYMAP_INDEX(2, 1)] = KEY_F13, /* add in XB, for device suspend/resume. in XA is KEY_RESERVED */
-	[KEYMAP_INDEX(2, 2)] = MATRIX_KEY(1, BTN_MOUSE),
-};
-
-static const unsigned short desirec_keymap_2[ARRAY_SIZE(desirec_col_gpios) * ARRAY_SIZE(desirec_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_RESERVED,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 2)] = KEY_SEND,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_RESERVED,
-	[KEYMAP_INDEX(1, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 2)] = KEY_RESERVED,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_RESERVED,
-	[KEYMAP_INDEX(2, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(2, 2)] = MATRIX_KEY(1, BTN_MOUSE),
-};
-
-static struct gpio_event_matrix_info desirec_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = desirec_keymap_2,
-	.output_gpios = desirec_col_gpios,
-	.input_gpios = desirec_row_gpios,
-	.noutputs = ARRAY_SIZE(desirec_col_gpios),
-	.ninputs = ARRAY_SIZE(desirec_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.notintr_gpios = 40,
-	.flags = GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_REMOVE_PHANTOM_KEYS |GPIOKPF_PRINT_UNMAPPED_KEYS /*| GPIOKPF_PRINT_MAPPED_KEYS*/
-};
-
-static struct gpio_event_direct_entry desirec_keypad_nav_map[] = {
-	{
-		.gpio = DESIREC_POWER_KEY,
-		.code = KEY_END
-	},
-};
-
-static struct gpio_event_input_info desirec_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = 0,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = desirec_keypad_nav_map,
-	.keymap_size = ARRAY_SIZE(desirec_keypad_nav_map)
-};
-
-static bool nav_just_on;
-static int nav_on_jiffies;
-
-uint16_t desirec_axis_map(struct gpio_event_axis_info *info, uint16_t in)
-{
-	struct desirec_axis_info *ai =
-			container_of(info, struct desirec_axis_info, info);
-	uint16_t out = ai->out_state;
-
-	if (nav_just_on) {
-		if (jiffies == nav_on_jiffies || jiffies == nav_on_jiffies + 1)
-			goto ignore;
-		nav_just_on = 0;
-	}
-	if ((ai->in_state ^ in) & 1)
-		out--;
-	if ((ai->in_state ^ in) & 2)
-		out++;
-	ai->out_state = out;
-ignore:
-	ai->in_state = in;
-	if (ai->out_state - ai->temp_state == ai->threshold) {
-		ai->temp_state++;
-		ai->out_state = ai->temp_state;
-	} else if (ai->temp_state - ai->out_state == ai->threshold) {
-		ai->temp_state--;
-		ai->out_state = ai->temp_state;
-	} else if (abs(ai->out_state - ai->temp_state) > ai->threshold)
-		ai->temp_state = ai->out_state;
-
-	return ai->temp_state;
-}
-
-static uint32_t desirec_x_axis_gpios[] = {
-	DESIREC_GPIO_BALL_LEFT, DESIREC_GPIO_BALL_RIGHT
-};
-
-static struct desirec_axis_info desirec_x_axis = {
-	.threshold = 1,
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(desirec_x_axis_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_X,
-		.decoded_size = 1U << ARRAY_SIZE(desirec_x_axis_gpios),
-		.map = desirec_axis_map,
-		.gpio = desirec_x_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION
-			/*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT */
-	}
-};
-
-static uint32_t desirec_y_axis_gpios[] = {
-	DESIREC_GPIO_BALL_UP, DESIREC_GPIO_BALL_DOWN
-};
-
-static struct desirec_axis_info desirec_y_axis = {
-	.threshold = 1,
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(desirec_y_axis_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_Y,
-		.decoded_size = 1U << ARRAY_SIZE(desirec_y_axis_gpios),
-		.map = desirec_axis_map,
-		.gpio = desirec_y_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION
-			/*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT  */
-	}
-};
-/*
-static struct gpio_event_direct_entry desirec_fake_key[] = {
-	{ 0, BTN_MOUSE },
-};
-
-static struct gpio_event_input_info desirec_fake_nav_info = {
-	.info.func = fake_gpio_event_input_func,
-	.flags = 0,
-	.type = EV_KEY,
-	.keymap = desirec_fake_key,
-	.keymap_size = ARRAY_SIZE(desirec_fake_key)
-};
-*/
-int desirec_nav_power(const struct gpio_event_platform_data *pdata, bool on)
-{
-	if (on) {
-		gpio_direction_input(desirec_x_axis_gpios[0]);
-		gpio_direction_input(desirec_x_axis_gpios[1]);
-		gpio_direction_input(desirec_y_axis_gpios[0]);
-		gpio_direction_input(desirec_y_axis_gpios[1]);
-		gpio_set_value(DESIREC_JOGBALL_EN, on);
-		nav_just_on = 1;
-		nav_on_jiffies = jiffies;
-	} else {
-		gpio_set_value(DESIREC_JOGBALL_EN, on);
-		gpio_direction_output(desirec_x_axis_gpios[0], 0);
-		gpio_direction_output(desirec_x_axis_gpios[1], 0);
-		gpio_direction_output(desirec_y_axis_gpios[0], 0);
-		gpio_direction_output(desirec_y_axis_gpios[1], 0);
-	}
-	return 0;
-}
-
-/*
-static struct gpio_event_info *desirec_nav_info[] = {
-	&desirec_x_axis.info.info,
-	&desirec_y_axis.info.info,
-	&desirec_fake_nav_info.info,
-};
-
-static struct gpio_event_platform_data desirec_nav_data = {
-	.name = "desirec-nav",
-	.info = desirec_nav_info,
-	.info_count = ARRAY_SIZE(desirec_nav_info),
-	.power = desirec_nav_power,
-};
-
-static struct platform_device desirec_nav_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 2,
-	.dev		= {
-		.platform_data	= &desirec_nav_data,
-	},
-};
-*/
-
-/*
-static struct gpio_event_info *desirec_keypad_info[] = {
-	&desirec_keypad_matrix_info.info,
-	&desirec_keypad_nav_info.info,
-};
-
-static struct gpio_event_platform_data desirec_keypad_data = {
-	.name = "desirec-keypad",
-	.info = desirec_keypad_info,
-	.info_count = ARRAY_SIZE(desirec_keypad_info)
-};
-
-static struct platform_device desirec_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &desirec_keypad_data,
-	},
-};
-
-*/
-static struct gpio_event_info *desirec_input_info[] = {
-	&desirec_keypad_matrix_info.info,
-	&desirec_keypad_nav_info.info,
-	&desirec_x_axis.info.info,
-	&desirec_y_axis.info.info,
-};
-
-static struct gpio_event_platform_data desirec_keypad_data = {
-	.names = {
-		"desirec-keypad",
-		"desirec-nav",
-		NULL,
-	},
-	.info = desirec_input_info,
-	.info_count = ARRAY_SIZE(desirec_input_info),
-	.power = desirec_nav_power,
-};
-
-static struct platform_device desirec_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev = {
-		.platform_data = &desirec_keypad_data,
-	},
-};
-
-static int desirec_reset_keys_up[] = {
-	BTN_MOUSE,
-	0
-};
-
-static struct keyreset_platform_data desirec_reset_keys_pdata = {
-	.keys_up = desirec_reset_keys_up,
-	.keys_down = {
-		KEY_SEND,
-		KEY_VOLUMEUP,
-		KEY_END,
-		0
-	},
-};
-
-static struct platform_device desirec_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &desirec_reset_keys_pdata,
-};
-
-static int __init desirec_init_keypad(void)
-{
-	if (!machine_is_desirec())
-		return 0;
-	if(system_rev == 0)
-		desirec_keypad_matrix_info.keymap = desirec_keymap_0;
-	else if(system_rev == 1)
-		desirec_keypad_matrix_info.keymap = desirec_keymap_1;
-
-	if (platform_device_register(&desirec_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	return platform_device_register(&desirec_keypad_device);
-}
-
-device_initcall(desirec_init_keypad);
diff --git a/arch/arm/mach-msm/board-desirec-mmc.c b/arch/arm/mach-msm/board-desirec-mmc.c
deleted file mode 100644
index a004d84..0000000
--- a/arch/arm/mach-msm/board-desirec-mmc.c
+++ /dev/null
@@ -1,351 +0,0 @@
-/* linux/arch/arm/mach-msm7201a/board-desirec-mmc.c
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-#include "proc_comm.h"
-#include <mach/board.h>
-#include <mach/htc_pwrsink.h>
-
-#include "board-desirec.h"
-
-#define DEBUG_SDSLOT_VDD 1
-
-/* r porting 29 */
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-                        unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init desirec_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_desirec.disable_sdcard=", desirec_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_27_28,	2800 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t desirec_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk("%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		vreg_enable(vreg_sdslot);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-#if DEBUG_SDSLOT_VDD
-			printk("%s: Setting level to %u\n",
-			        __func__, mmc_vdd_table[i].level);
-#endif
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-			return 0;
-		}
-	}
-
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int desirec_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(DESIREC_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define DESIREC_MMC_VDD	MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
-
-static unsigned int desirec_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data desirec_sdslot_data = {
-	.ocr_mask	= DESIREC_MMC_VDD,
-	.status_irq	= MSM_GPIO_TO_INT(DESIREC_GPIO_SDMC_CD_N),
-	.status		= desirec_sdslot_status,
-	.translate_vdd	= desirec_sdslot_switchvdd,
-	.slot_type	= &desirec_sdslot_type,
-};
-
-
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static struct vreg *vreg_wifi_osc;	/* WIFI 32khz oscilator */
-static int desirec_wifi_cd = 0;		/* WIFI virtual 'card detect' status */
-
-static struct sdio_embedded_func wifi_func = {
-	.f_class 	= SDIO_CLASS_WLAN,
-	.f_maxblksize   = 512,
-};
-
-static struct embedded_sdio_data desirec_wifi_emb_data = {
-	.cis	= {
-		.vendor		= 0x104c,
-		.device		= 0x9066,
-		.blksize	= 512,
-		/*.max_dtr	= 24000000,  Max of chip - no worky on Trout */
-		.max_dtr	= 20000000,
-	},
-	.cccr	= {
-		.multi_block	= 0,
-		.low_speed	= 0,
-		.wide_bus	= 1,
-		.high_power	= 0,
-		.high_speed	= 0,
-	},
-	.funcs	= &wifi_func,
-	.num_funcs = 1,
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int desirec_wifi_status_register(void (*callback)(int card_present, void *dev_id), void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int desirec_wifi_status(struct device *dev)
-{
-	return desirec_wifi_cd;
-}
-
-static struct mmc_platform_data desirec_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= desirec_wifi_status,
-	.register_status_notify	= desirec_wifi_status_register,
-	.embedded_sdio		= &desirec_wifi_emb_data,
-};
-
-int desirec_wifi_set_carddetect(int val)
-{
-	printk("%s: %d\n", __func__, val);
-	desirec_wifi_cd = val;
-	if (wifi_status_cb) {
-		wifi_status_cb(val, wifi_status_cb_devid);
-	} else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-
-static int desirec_wifi_power_state;
-static int desirec_bt_power_state;
-
-int desirec_wifi_power(int on)
-{
-	int rc;
-
-	printk("%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		rc = vreg_enable(vreg_wifi_osc);
-		vreg_set_level(vreg_wifi_osc, 1800);
-		mdelay(50);
-		if (rc)
-			return rc;
-		htc_pwrsink_set(PWRSINK_WIFI, 70);
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-		htc_pwrsink_set(PWRSINK_WIFI, 0);
-	}
-
-	gpio_set_value( DESIREC_GPIO_WIFI_EN, on);
-	mdelay(100);
-
-	if (!on) {
-		if(!desirec_bt_power_state)
-		{
-			vreg_disable(vreg_wifi_osc);
-		}
-		else
-			printk("WiFi shouldn't disable vreg_wifi_osc. BT is using it!!\n");
-	}
-	desirec_wifi_power_state = on;
-	return 0;
-}
-
-/* Eenable VREG_MMC pin to turn on fastclock oscillator : colin */
-int desirec_bt_fastclock_power(int on)
-{
-	int rc;
-
-	printk("%s: %d\n", __func__, on);
-
-	if (vreg_wifi_osc) {
-		if (on) {
-			rc = vreg_enable(vreg_wifi_osc);
-			
-			if (rc)
-			{
-				printk("Error turn bt_fastclock_power rc=%d\n",rc);
-				return rc;
-			}
-		} else {
-			if(!desirec_wifi_power_state)
-			{
-				vreg_disable(vreg_wifi_osc);
-			}
-		}
-	}
-	desirec_bt_power_state = on;
-	return 0;
-}
-EXPORT_SYMBOL(desirec_bt_fastclock_power);
-
-static int desirec_wifi_reset_state;
-int desirec_wifi_reset(int on)
-{
-	printk("%s: %d\n", __func__, on);
-	/* HRRO use power off/on instead wifi reset*/
-	desirec_wifi_reset_state = on;
-	//mdelay(50);
-	return 0;
-}
-
-int __init desirec_init_mmc(unsigned int sys_rev)
-{
-	wifi_status_cb = NULL;
-	sdslot_vreg_enabled = 0;
-
-	vreg_wifi_osc = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_wifi_osc))
-		return PTR_ERR(vreg_wifi_osc);
-	vreg_set_level(vreg_wifi_osc, 1800);
-
-	msm_add_sdcc(1, &desirec_wifi_data, 0, 0); /* r porting 29: change func*/
-
-
-	if (opt_disable_sdcard) {
-		printk(KERN_INFO "desirec: SD-Card interface disabled\n");
-		goto done;
-	}
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-
-	set_irq_wake(MSM_GPIO_TO_INT(DESIREC_GPIO_SDMC_CD_N), 1);
-
-	msm_add_sdcc(2, &desirec_sdslot_data, MSM_GPIO_TO_INT(DESIREC_GPIO_SDMC_CD_N),
-		IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE); /* r porting 29 */
-
-done:
-	return 0;
-}
-
-
diff --git a/arch/arm/mach-msm/board-desirec-panel.c b/arch/arm/mach-msm/board-desirec-panel.c
deleted file mode 100644
index 6162dc2..0000000
--- a/arch/arm/mach-msm/board-desirec-panel.c
+++ /dev/null
@@ -1,266 +0,0 @@
-/* linux/arch/arm/mach-msm/board-desirec-panel.c
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/leds.h>
-
-#include <asm/io.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-#include <mach/vreg.h>
-#include <mach/pmic.h>
-#include <mach/board_htc.h>
-#include "proc_comm.h"
-#include "devices.h"
-#include "board-desirec.h"
-
-#if 1
-#define B(s...) printk(s)
-#else
-#define B(s...) do {} while (0)
-#endif
-
-static struct led_trigger *desirec_lcd_backlight;
-static void desirec_set_backlight(int on)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	if (on) {
-		/* vsync back porch is about 17 ms */
-		msleep(40);
-		led_trigger_event(desirec_lcd_backlight, LED_FULL);
-	} else
-		led_trigger_event(desirec_lcd_backlight, LED_OFF);
-}
-
-static struct vreg *vreg_lcm_2v6;
-static struct vreg *vreg_lcm_2v85;
-
-static void 
-desirec_mddi_eid_power(struct msm_mddi_client_data *client_data, int on)
-{
-	unsigned id, on_off = 1;
-
-	B(KERN_DEBUG "%s: power %s.\n", __func__, on ? "on" : "off");
-	if (on) {
-		on_off = 0;
-		/* 2V6(pmic synt) */
-		id = PM_VREG_PDOWN_SYNT_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v6);
-		mdelay(1);
-
-		/* 2V8(pmic gp5) */
-		id = PM_VREG_PDOWN_GP5_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v85);
-		mdelay(2);
-
-		gpio_set_value(DESIREC_GPIO_MDDI_RST_N, 1);
-		mdelay(15);
-	} else {
-		on_off = 1;
-		mdelay(5);
-		gpio_set_value(DESIREC_GPIO_MDDI_RST_N, 0);
-		mdelay(3);
-
-		/* 2V8(pmic gp5) */
-		id = PM_VREG_PDOWN_GP5_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_disable(vreg_lcm_2v85);
-		mdelay(1);
-
-		/* 2V6(pmic synt) */
-		id = PM_VREG_PDOWN_SYNT_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_disable(vreg_lcm_2v6);
-	}
-}
-
-enum {
-	PANEL_SHARP,
-	PANEL_SAMSUNG,
-	PANEL_EID_40pin,
-	PANEL_EID_24pin,
-	PANEL_HEROC_EID_BOTTOM,
-	PANEL_TPO,
-	PANEL_HEROC_TPO,
-	PANEL_ESPRESSO_TPO,
-	PANEL_ESPRESSO_SHARP,
-	PANEL_LIBERTY_TPO,
-	PANEL_LIBERTY_EID_24pin,
-	PANEL_EIDII,
-	PANEL_UNKNOWN,
-};
-
-static int desirec_panel_detect(void)
-{
-	return panel_type;
-}
-
-static int 
-desirec_panel_unblank(struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	desirec_set_backlight(1);
-	return 0;
-}
-
-static int 
-desirec_panel_blank(struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	desirec_set_backlight(0);
-	return 0;
-}
-
-static void panel_eid_fixup(uint16_t * mfr_name, uint16_t * product_code)
-{
-	B("%s: enter.\n", __func__);
-	*mfr_name = 0x0101;
-	*product_code= 0x0;
-}
-
-static int config_vsync(void)
-{
-	int ret;
-	uint32_t config;
-
-	ret = gpio_request(DESIREC_GPIO_VSYNC, "vsync");
-	if (ret)
-		return ret;
-
-	config = PCOM_GPIO_CFG(DESIREC_GPIO_VSYNC, 1, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA);
-	ret = msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &config, 0);
-	if (ret)
-		gpio_free(DESIREC_GPIO_VSYNC);
-	return ret;
-}
-
-static u8 pwm_eid[10] = {30, 34, 45, 61, 81, 108, 145, 182, 219, 255};
-static u8 pwm_tpo[10] = {30, 34, 45, 61, 81, 108, 145, 182, 219, 255};
-
-static struct msm_mddi_bridge_platform_data eid_client_data = {
-	.blank = desirec_panel_blank,
-	.unblank = desirec_panel_unblank,
-	.fb_data = {
-		.xres = 320,
-		.yres = 480,
-		.output_format = 0,
-	},
-};
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct msm_mddi_platform_data desirec_pdata = {
-	.clk_rate = 106000000,
-	.power_client = desirec_mddi_eid_power,
-	.fixup = panel_eid_fixup,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 1,
-	.client_platform_data = {
-		{
-			.product_id = (0x0101 << 16 | 0),
-			.name = "mddi_c_0101_0000",
-			.id = 1,
-			.client_data = &eid_client_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-/*
- * In boot loader, mddi is powered on already.
- * So, we just detect panel here, setting different power function for each
- * panel. Then we did not have to detect panel in each time mddi_client_power
- * or panel_power is called.
- *
- * jay: Nov 20, 08'
- */
-int __init desirec_init_panel(void)
-{
-	int panel, rc;
-	struct panel_data *config = &eid_client_data.panel_conf;
-
-	if (!machine_is_desirec())
-		return -1;
-
-	B(KERN_INFO "%s: enter.\n", __func__);
-
-	vreg_lcm_2v6 = vreg_get(0, "synt");
-	if (IS_ERR(vreg_lcm_2v6))
-		return PTR_ERR(vreg_lcm_2v6);
-
-	vreg_lcm_2v85 = vreg_get(0, "gp5");
-	if (IS_ERR(vreg_lcm_2v85))
-		return PTR_ERR(vreg_lcm_2v85);
-
-	panel = desirec_panel_detect();
-
-	if (panel == PANEL_HEROC_EID_BOTTOM ||
-		panel == PANEL_EIDII ||
-		panel == PANEL_HEROC_TPO) {
-		printk(KERN_INFO "%s: init %s panel\n", __func__,
-			panel == PANEL_HEROC_TPO ? "TPO" : "EID");
-		config->panel_id = panel;
-		config->caps = MSMFB_CAP_CABC;
-		if (panel == PANEL_HEROC_EID_BOTTOM || panel == PANEL_EIDII)
-			config->pwm = pwm_eid;
-		else
-			config->pwm = pwm_tpo;
-		config->shrink = 1;
-		config->min_level = 3;
-	} else {
-		printk(KERN_ERR "unknown panel type!\n");
-		return -EIO;
-	}
-
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-
-	rc = config_vsync();
-	if (rc)
-		return rc;
-
-	msm_device_mddi0.dev.platform_data = &desirec_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-	
-	led_trigger_register_simple("lcd-backlight-gate", &desirec_lcd_backlight);
-	if (IS_ERR(desirec_lcd_backlight))
-		printk(KERN_ERR "%s: backlight registration failed!\n", __func__);
-
-	return 0;
-}
-device_initcall(desirec_init_panel);
-
diff --git a/arch/arm/mach-msm/board-desirec-rfkill.c b/arch/arm/mach-msm/board-desirec-rfkill.c
deleted file mode 100644
index dcc2c1f..0000000
--- a/arch/arm/mach-msm/board-desirec-rfkill.c
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
-*/
-
-/* Control bluetooth power for desirec platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-desirec.h"
-
-extern int desirec_bt_fastclock_power(int on);
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "brf6350";
-
-static int desirec_bt_status;
-
-static uint32_t desirec_bt_init_table[] = {
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_RTS, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_RTS */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_CTS, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_CTS */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_RX, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),		/* BT_RX */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_TX, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_TX */
-	
-	PCOM_GPIO_CFG(DESIREC_GPIO_WB_SHUT_DOWN_N, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_8MA),		/* BT_ENABLE */
-};
-
-static uint32_t desirec_bt_on_table[] = {
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_RTS, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_RTS */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_CTS, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_CTS */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_RX, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),		/* BT_RX */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_TX, 3, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_TX */
-	
-	PCOM_GPIO_CFG(DESIREC_GPIO_WB_SHUT_DOWN_N, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_8MA),		/* BT_ENABLE */
-};
-
-static uint32_t desirec_bt_off_table[] = {
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_RTS, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_RTS */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_CTS, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_CTS */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_RX, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),		/* BT_RX */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_TX, 3, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_TX */
-	
-	PCOM_GPIO_CFG(DESIREC_GPIO_WB_SHUT_DOWN_N, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_8MA),		/* BT_ENABLE */
-};
-
-static uint32_t desirec_bt_disable_active_table[] = {
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_RTS, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_RTS */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_CTS, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_CTS */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_RX, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),		/* BT_RX */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_TX, 3, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_TX */
-};
-
-static uint32_t desirec_bt_disable_sleep_table[] = {
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_RTS, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* O(L) */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_CTS, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* I(PU) */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_RX, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),		/* I(PU) */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART1_TX, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* O(H) */
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for(n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void desirec_config_bt_init(void)
-{
-	desirec_bt_status = 0;
-	config_bt_table(desirec_bt_init_table, ARRAY_SIZE(desirec_bt_init_table));
-	mdelay(5);
-	gpio_configure(DESIREC_GPIO_WB_SHUT_DOWN_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static void desirec_config_bt_on(void)
-{
-	config_bt_table(desirec_bt_on_table, ARRAY_SIZE(desirec_bt_on_table));
-	mdelay(2);
-
-	gpio_configure(DESIREC_GPIO_WB_SHUT_DOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(15);
-	gpio_configure(DESIREC_GPIO_WB_SHUT_DOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(1);
-	gpio_configure(DESIREC_GPIO_WB_SHUT_DOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(1);
-
-	desirec_bt_fastclock_power(1);
-	mdelay(2);
-	desirec_bt_status = 1;
-}
-
-static void desirec_config_bt_off(void)
-{
-	gpio_configure(DESIREC_GPIO_WB_SHUT_DOWN_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	desirec_bt_fastclock_power(0);
-	config_bt_table(desirec_bt_off_table, ARRAY_SIZE(desirec_bt_off_table));
-	mdelay(5);
-	desirec_bt_status = 0;
-}
-
-void desirec_config_bt_disable_active(void)
-{	
-	config_bt_table(desirec_bt_disable_active_table, ARRAY_SIZE(desirec_bt_disable_active_table));
-}
-
-void desirec_config_bt_disable_sleep(void)
-{
-	config_bt_table(desirec_bt_disable_sleep_table, ARRAY_SIZE(desirec_bt_disable_sleep_table));
-	mdelay(5);
-	gpio_configure(DESIREC_GPIO_UART1_RTS, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);	/* O(L) */
-	gpio_configure(DESIREC_GPIO_UART1_TX, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);	/* O(H) */
-}
-
-int desirec_is_bluetooth_off(void)
-{
-	return !desirec_bt_status;	//ON:1, OFF:0
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-			desirec_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-			desirec_config_bt_off();
-		break;
-	default:
-		printk(KERN_ERR "bad bluetooth rfkill state %d\n", state);
-	}
-	return 0;
-}
-
-static int __init desirec_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;  /* off */
-
-	desirec_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;  // user data
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-
-	if (rc)
-		rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int desirec_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver desirec_rfkill_driver = {
-	.probe = desirec_rfkill_probe,
-	.remove = desirec_rfkill_remove,
-	.driver = {
-		.name = "desirec_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init desirec_rfkill_init(void)
-{
-	if (!machine_is_desirec())
-		return 0;
-	return platform_driver_register(&desirec_rfkill_driver);
-}
-
-static void __exit desirec_rfkill_exit(void)
-{
-	platform_driver_unregister(&desirec_rfkill_driver);
-}
-
-module_init(desirec_rfkill_init);
-module_exit(desirec_rfkill_exit);
-MODULE_DESCRIPTION("desirec rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-desirec-wifi.c b/arch/arm/mach-msm/board-desirec-wifi.c
deleted file mode 100644
index 25d0aa2..0000000
--- a/arch/arm/mach-msm/board-desirec-wifi.c
+++ /dev/null
@@ -1,104 +0,0 @@
-/* arch/arm/mach-msm/board-desirec-wifi.c
- *
- * Copyright (C) 2008 Google, Inc.
- * Author: Dmitry Shmidt <dimitrysh@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/vmalloc.h>
-#include <linux/err.h>
-#include <linux/wifi_tiwlan.h>
-
-extern int desirec_wifi_set_carddetect(int val);
-extern int desirec_wifi_power(int on);
-extern int desirec_wifi_reset(int on);
-
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[WMPA_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WMPA_SECTION_SIZE_0 + WMPA_SECTION_HEADER) },
-	{ NULL, (WMPA_SECTION_SIZE_1 + WMPA_SECTION_HEADER) },
-	{ NULL, (WMPA_SECTION_SIZE_2 + WMPA_SECTION_HEADER) }
-};
-
-static void *desirec_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if ((section < 0) || (section >= WMPA_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init desirec_init_wifi_mem (void)
-{
-	int i;
-
-	for (i = 0; (i < WMPA_NUMBER_OF_SECTIONS); i++) {
-		wifi_mem_array[i].mem_ptr = vmalloc(wifi_mem_array[i].size);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-#endif
-
-struct wifi_platform_data desirec_wifi_control = {
-	.set_power		= desirec_wifi_power,
-	.set_reset		= desirec_wifi_reset,
-	.set_carddetect		= desirec_wifi_set_carddetect,
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-	.mem_prealloc		= desirec_wifi_mem_prealloc,
-#else
-	.mem_prealloc		= NULL,
-#endif
-};
-
-static struct platform_device wifi_ctrl_dev = {
-	.name		= "msm_wifi",
-	.id		= 1,
-	.num_resources	= 0,
-	.resource	= NULL,
-	.dev		= {
-		.platform_data = &desirec_wifi_control,
-	},
-};
-
-static int __init desirec_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_desirec())
-		return 0;
-
-	printk("%s: start\n", __func__);
-
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-	desirec_init_wifi_mem();
-#endif
-
-	ret = platform_device_register(&wifi_ctrl_dev);
-	return ret;
-}
-
-
-late_initcall(desirec_wifi_init);
-#endif
-
diff --git a/arch/arm/mach-msm/board-desirec.c b/arch/arm/mach-msm/board-desirec.c
deleted file mode 100644
index 5662a0a..0000000
--- a/arch/arm/mach-msm/board-desirec.c
+++ /dev/null
@@ -1,1222 +0,0 @@
-/* linux/arch/arm/mach-msm/board-desirec.c
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/irq.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/melfas_tsi.h>
-#include <mach/cy8c_i2c.h>
-#include <linux/akm8973.h>
-#include <mach/tpa6130.h>
-#include <linux/bma150.h>
-#include <linux/sysdev.h>
-#include <linux/delay.h>
-#include <mach/drv_callback.h>
-#include <linux/proximity.h>
-#include <linux/gpio.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/setup.h>
-
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/capella_cm3602.h>
-
-#include <mach/system.h>
-#include <mach/vreg.h>
-#include <mach/hardware.h>
-#include <mach/board.h>
-#include <mach/msm_serial_hs.h>
-#include <mach/msm_fb.h>
-#include "proc_comm.h"
-#include "devices.h"
-#include <mach/h2w_v1.h>
-#include <mach/audio_jack.h>
-#include <mach/microp_i2c.h>
-#include <mach/htc_battery.h>
-#include <mach/htc_pwrsink.h>
-#include <mach/perflock.h>
-#include "board-desirec.h"
-#include "board-desirec-camsensor.h"
-#include <mach/board_htc.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/msm_hsusb.h>
-
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-//	.gpio_mbat_in = HERO_GPIO_MBAT_IN,
-//	.gpio_mchg_en_n = HERO_GPIO_MCHG_EN_N,
-//	.gpio_iset = HERO_GPIO_ISET,
-	.guage_driver = GUAGE_MODEM,
-	.charger = LINEAR_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-
-static int touch_reset(void)
-{
-	printk(KERN_INFO"%s: enter\n", __func__);
-	gpio_set_value(DESIREC_GPIO_TP_EN, 0);
-	msleep(2);
-	gpio_set_value(DESIREC_GPIO_TP_EN, 1);
-	msleep(260);
-	gpio_set_value(DESIREC_GPIO_WAKE_UP, 1);
-	msleep(40);
-	gpio_set_value(DESIREC_GPIO_WAKE_UP, 0);
-
-	return 0;
-}
-
-/*
-static struct proximity_platform_data desirec_proximity_data = {
-	.intr = DESIREC_GPIO_PROXIMITY_INT_N,
-	.enable = DESIREC_GPIO_PROXIMITY_POWER_N,
-};
-
-static struct platform_device desirec_proximity_device = {
-	.name = "proximity_sensor",
-	.dev		= {
-		.platform_data	= &desirec_proximity_data,
-	},
-};
-*/
-
-static struct melfas_i2c_rmi_platform_data desirec_melfas_ts_data[] = {
-	{
-		.version = MELFAS_DIAMOND_PATTERN,
-		.wake_up = DESIREC_GPIO_WAKE_UP,
-		.intr = DESIREC_GPIO_TP_ATT_N,
-		.reset = touch_reset,
-	},
-	{
-		.version = MELFAS_TRIANGLE_PATTERN,
-		.wake_up = DESIREC_GPIO_WAKE_UP,
-		.intr = DESIREC_GPIO_TP_ATT_N,
-		.reset = touch_reset,
-	}
-};
-
-static struct synaptics_i2c_rmi_platform_data desirec_ts_data[] = {
-	{
-		.version = 0x0105,
-		.inactive_left = -10 * 0x10000 / 320,
-		.inactive_right = -10 * 0x10000 / 320,
-		.inactive_top = -5 * 0x10000 / 480,
-		.inactive_bottom = -35 * 0x10000 / 480,
-		.dup_threshold = 10,
-	},
-	{
-		.version = 0x0100,
-		.sensitivity_adjust = 8,
-		.inactive_left = -10 * 0x10000 / 320,
-		.inactive_right = -10 * 0x10000 / 320,
-		.inactive_top = -5 * 0x10000 / 480,
-		.inactive_bottom = -35 * 0x10000 / 480,
-		.dup_threshold = 10,
-	},
-};
-
-
-static struct microp_pin_config microp_pins_0[] = {
-	{
-		.name   = "green",
-		.pin    = 3,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name   = "amber",
-		.pin    = 5,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 6,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name	= "button-backlight",
-		.pin	= 7,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name	= "jogball-backlight",
-		.pin	= 8,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name	= "low-power",
-		.pin	= 9,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name = "microp_11pin_mic",
-		.pin = 1,
-		.config = MICROP_PIN_CONFIG_MIC,
-		.init_value = 0,
-	},
-	{
-		.name	= "35mm_adc",
-		.pin	= 16,
-		.adc_pin = 1,
-		.intr_pin = 1,
-		.config = MICROP_PIN_CONFIG_UP_ADC,
-		.levels = { 200, 0x3FF, 0, 33, 38, 82, 95, 167 },
-	},
-	{
-		.name   = "adc",
-		.pin    = 17,
-		.config = MICROP_PIN_CONFIG_ADC,
-		.levels = { 0, 14, 16, 20, 20, 41, 158, 277, 451, 575 },
-	},
-	{
-		.name	= "microp_intrrupt",
-		.pin	= 18,
-		.config  = MICROP_PIN_CONFIG_INTR_ALL,
-		.mask	 = { 0x00, 0x00, 0x00 },
-	},
-	{
-		.pin	= 2,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 4,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 10,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 11,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 12,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 13,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 14,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.pin	= 15,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-};
-
-static struct microp_pin_config microp_pins_2[] = {
-	{
-		.name   = "green",
-		.pin    = 3,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name   = "amber",
-		.pin    = 5,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 6,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name	= "button-backlight",
-		.pin	= 7,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name	= "vtkey-backlight",
-		.pin	= 9,
-		.config = MICROP_PIN_CONFIG_PWM,
-		.freq   = MICROP_PIN_PWM_FREQ_HZ_15600,
-		.dutys = {0, 255, 255, 255, 255, 255, 255, 255, 255, 255},
-	},
-	{
-		.name	= "jogball-backlight",
-		.pin	= 10,
-		.config = MICROP_PIN_CONFIG_PWM,
-		.freq   = MICROP_PIN_PWM_FREQ_HZ_15600,
-		.auto_if_on = 1,
-		.i_am_jogball_function = 1,
-	},
-	{
-		.name = "microp_11pin_mic",
-		.pin = 1,
-		.config = MICROP_PIN_CONFIG_MIC,
-		.init_value = 0,
-	},
-	{
-		.name	= "35mm_adc",
-		.pin	= 16,
-		.adc_pin = 1,
-		.intr_pin = 1,
-		.config = MICROP_PIN_CONFIG_UP_ADC,
-		.levels = { 200, 0x3FF, 0, 33, 38, 82, 95, 167 },
-	},
-	{
-		.name   = "adc",
-		.pin    = 17,
-		.config = MICROP_PIN_CONFIG_ADC,
-		.levels = { 0, 14, 16, 20, 20, 41, 158, 277, 451, 575 },
-	},
-	{
-		.name	= "microp_intrrupt",
-		.pin	= 18,
-		.config  = MICROP_PIN_CONFIG_INTR_ALL,
-		.mask	 = { 0x00, 0x00, 0x00 },
-	},
-	{
-		.pin	= 2,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 4,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 8,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 11,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 12,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 13,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.pin	= 14,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.pin	= 15,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_pins   = ARRAY_SIZE(microp_pins_0),
-	.pin_config = microp_pins_0,
-	.gpio_reset = DESIREC_GPIO_UP_RESET_N,
-	.cabc_backlight_enable = 1,
-	.microp_enable_early_suspend = 1,
-	.microp_enable_reset_button = 1,
-};
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = DESIREC_LAYOUTS,
-	.project_name = DESIREC_PROJECT_NAME,
-	.reset = DESIREC_GPIO_COMPASS_RST_N,
-	.intr = DESIREC_GPIO_COMPASS_INT_N,
-};
-
-static struct bma150_platform_data gsensor_platform_data = {
-	.intr = DESIREC_GPIO_GSENSOR_INT_N,
-};
-
-static struct tpa6130_platform_data headset_amp_platform_data = {
-	.gpio_hp_sd = DESIREC_GPIO_HTC_HP_SD,
-	.enable_rpc_server = 1,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x20),
-		.platform_data = &desirec_ts_data,
-		.irq = DESIREC_GPIO_TO_INT(DESIREC_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(MELFAS_I2C_NAME, 0x22),
-		.platform_data = &desirec_melfas_ts_data,
-		.irq = DESIREC_GPIO_TO_INT(DESIREC_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = DESIREC_GPIO_TO_INT(DESIREC_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = DESIREC_GPIO_TO_INT(DESIREC_GPIO_COMPASS_INT_N),
-	},
-	{
-		I2C_BOARD_INFO(BMA150_I2C_NAME, 0x38),
-		.platform_data = &gsensor_platform_data,
-		.irq = DESIREC_GPIO_TO_INT(DESIREC_GPIO_GSENSOR_INT_N),
-	},
-	{
-		I2C_BOARD_INFO(TPA6130_I2C_NAME, 0xC0 >> 1),
-		.platform_data = &headset_amp_platform_data,
-	},
-	{
-		I2C_BOARD_INFO("s5k3e2fx", 0x20 >> 1)
-	}
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_desirec_camera_on_gpios,
-	.camera_gpio_off = config_desirec_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_s5k3e2fx_data = {
-	.sensor_name    = "s5k3e2fx",
-	.sensor_reset   = DESIREC_GPIO_CAM_RST_N,
-	.sensor_pwd     = DESIREC_CAM_PWDN,
-	.vcm_pwd        = DESIREC_GPIO_VCM_PWDN,
-	.pdata          = &msm_camera_device_data,
-	.flash_type     = MSM_CAMERA_FLASH_NONE,
-	.need_suspend   = 1,
-};
-
-static struct platform_device msm_camera_sensor_s5k3e2fx = {
-	.name      = "msm_camera_s5k3e2fx",
-	.dev        = {
-		.platform_data = &msm_camera_sensor_s5k3e2fx_data,
-	},
-};
-
-static void desirec_phy_reset(void)
-{
-	printk("desirec_phy_reset\n");
-	gpio_set_value(DESIREC_GPIO_USB_PHY_RST_N, 0);
-	mdelay(10);
-	gpio_set_value(DESIREC_GPIO_USB_PHY_RST_N, 1);
-	mdelay(10);
-}
-
-static void desirec_phy_shutdown(void)
-{
-	printk("desirec_phy_shutdown\n");
-	gpio_set_value(DESIREC_GPIO_USB_PHY_RST_N, 0);
-}
-
-static struct pwr_sink desirec_pwrsink_table[] = {
-	{
-		.id	= PWRSINK_AUDIO,
-		.ua_max	= 100000,
-	},
-	{
-		.id	= PWRSINK_BACKLIGHT,
-		.ua_max	= 125000,
-	},
-	{
-		.id	= PWRSINK_LED_BUTTON,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_LED_KEYBOARD,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_GP_CLK,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_BLUETOOTH,
-		.ua_max	= 15000,
-	},
-	{
-		.id	= PWRSINK_CAMERA,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_SDCARD,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_VIDEO,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id	= PWRSINK_SYSTEM_LOAD,
-		.ua_max	= 100000,
-		.percent_util = 38,
-	},
-};
-
-static int desirec_pwrsink_resume_early(struct platform_device *pdev)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-	return 0;
-}
-
-static void desirec_pwrsink_resume_late(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 38);
-}
-
-static void desirec_pwrsink_suspend_early(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-}
-
-static int desirec_pwrsink_suspend_late(struct platform_device *pdev, pm_message_t state)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 1);
-	return 0;
-}
-
-static struct pwr_sink_platform_data desirec_pwrsink_data = {
-	.num_sinks	= ARRAY_SIZE(desirec_pwrsink_table),
-	.sinks		= desirec_pwrsink_table,
-	.suspend_late	= desirec_pwrsink_suspend_late,
-	.resume_early	= desirec_pwrsink_resume_early,
-	.suspend_early	= desirec_pwrsink_suspend_early,
-	.resume_late	= desirec_pwrsink_resume_late,
-};
-
-static struct platform_device desirec_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev	= {
-		.platform_data = &desirec_pwrsink_data,
-	},
-};
-/* Switch between UART3 and GPIO */
-static uint32_t uart3_on_gpio_table[] = {
-	/* RX */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART3_RX, 1, GPIO_INPUT, GPIO_NO_PULL, 0),
-	/* TX */
-	PCOM_GPIO_CFG(DESIREC_GPIO_UART3_TX, 1, GPIO_OUTPUT, GPIO_NO_PULL, 0),
-};
-
-/* default TX,RX to GPI */
-static uint32_t uart3_off_gpi_table[] = {
-	/* RX, H2W DATA */
-	PCOM_GPIO_CFG(DESIREC_GPIO_H2W_DATA, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),
-	/* TX, H2W CLK */
-	PCOM_GPIO_CFG(DESIREC_GPIO_H2W_CLK, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),
-};
-
-/* set TX,RX to GPO */
-static uint32_t uart3_off_gpo_table[] = {
-	/* RX, H2W DATA */
-	PCOM_GPIO_CFG(DESIREC_GPIO_H2W_DATA, 0,
-		      GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	/* TX, H2W CLK */
-	PCOM_GPIO_CFG(DESIREC_GPIO_H2W_CLK, 0,
-		      GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-};
-
-static int desirec_h2w_path = H2W_GPIO;
-
-static void h2w_configure(int route)
-{
-	printk(KERN_INFO "H2W route = %d \n", route);
-	switch (route) {
-	case H2W_UART3:
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_on_gpio_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_on_gpio_table+1, 0);
-		desirec_h2w_path = H2W_UART3;
-		printk(KERN_INFO "H2W -> UART3\n");
-		break;
-	case H2W_GPIO:
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table+1, 0);
-		desirec_h2w_path = H2W_GPIO;
-		printk(KERN_INFO "H2W -> GPIO\n");
-		break;
-	}
-}
-
-static void h2w_defconfig(void)
-{
-	h2w_configure(H2W_GPIO);
-}
-
-static void set_h2w_dat(int n)
-{
-	gpio_set_value(DESIREC_GPIO_H2W_DATA, n);
-}
-
-static void set_h2w_clk(int n)
-{
-	gpio_set_value(DESIREC_GPIO_H2W_CLK, n);
-}
-
-static void set_h2w_dat_dir(int n)
-{
-#if 0
-	if (n == 0) /* input */
-		gpio_direction_input(DESIREC_GPIO_H2W_DATA);
-	else
-		gpio_configure(DESIREC_GPIO_H2W_DATA, GPIOF_DRIVE_OUTPUT);
-#else
-	if (n == 0) /* input */
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table+0, 0);
-	else
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpo_table+0, 0);
-#endif
-}
-
-static void set_h2w_clk_dir(int n)
-{
-#if 0
-	if (n == 0) /* input */
-		gpio_direction_input(DESIREC_GPIO_H2W_CLK);
-	else
-		gpio_configure(DESIREC_GPIO_H2W_CLK, GPIOF_DRIVE_OUTPUT);
-#else
-	if (n == 0) /* input */
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table+1, 0);
-	else
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpo_table+1, 0);
-#endif
-}
-
-static int get_h2w_dat(void)
-{
-	return gpio_get_value(DESIREC_GPIO_H2W_DATA);
-}
-
-static int get_h2w_clk(void)
-{
-	return gpio_get_value(DESIREC_GPIO_H2W_CLK);
-}
-
-#ifdef CONFIG_HTC_HEADSET_V1
-static int set_h2w_path(const char *val, struct kernel_param *kp)
-{
-	int ret = -EINVAL;
-	int enable;
-
-	ret = param_set_int(val, kp);
-	if (ret)
-		return ret;
-
-	switch (desirec_h2w_path) {
-	case H2W_GPIO:
-		enable = 1;
-		cnf_driver_event("H2W_enable_irq", &enable);
-		break;
-	case H2W_UART3:
-		enable = 0;
-		cnf_driver_event("H2W_enable_irq", &enable);
-		break;
-	default:
-		desirec_h2w_path = -1;
-		return -EINVAL;
-	}
-
-	h2w_configure(desirec_h2w_path);
-	return ret;
-}
-
-module_param_call(h2w_path, set_h2w_path, param_get_int,
-		&desirec_h2w_path, S_IWUSR | S_IRUGO);
-
-#endif
-static struct h2w_platform_data desirec_h2w_data = {
-	.h2w_power		= DESIREC_GPIO_H2W_POWER,
-	.cable_in1		= DESIREC_GPIO_CABLE_IN1,
-	.cable_in2		= DESIREC_GPIO_CABLE_IN2,
-	.h2w_clk		= DESIREC_GPIO_H2W_CLK,
-	.h2w_data		= DESIREC_GPIO_H2W_DATA,
-	.ext_mic_sel		= DESIREC_GPIO_AUD_EXTMIC_SEL,
-	.debug_uart 		= H2W_UART3,
-	.config 		= h2w_configure,
-	.defconfig 		= h2w_defconfig,
-	.set_dat		= set_h2w_dat,
-	.set_clk		= set_h2w_clk,
-	.set_dat_dir		= set_h2w_dat_dir,
-	.set_clk_dir		= set_h2w_clk_dir,
-	.get_dat		= get_h2w_dat,
-	.get_clk		= get_h2w_clk,
-};
-
-static struct platform_device desirec_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &desirec_h2w_data,
-	},
-};
-
-static struct audio_jack_platform_data desirec_jack_data = {
-	.gpio	= DESIREC_GPIO_35MM_HEADSET_DET,
-};
-
-static struct platform_device desirec_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &desirec_jack_data,
-	},
-};
-
-static int desirec_phy_init_seq[] = {0x40, 0x31, 0x1, 0x0D, 0x1, 0x10, -1};
-static struct msm_hsusb_product desirec_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c98,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-
-static struct platform_device desirec_rfkill = {
-	.name = "desirec_rfkill",
-	.id = -1,
-};
-
-/* Proximity Sensor (Capella_CM3502)*/
-static int __capella_cm3602_power(int on)
-{
-	int rc;
-	struct vreg *vreg = vreg_get(0, "ruim");
-	if (!vreg) {
-		printk(KERN_ERR "%s: vreg error\n", __func__);
-		return -EIO;
-	}
-	rc = vreg_set_level(vreg, 2800);
-
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on) {
-		gpio_direction_output(DESIREC_GPIO_PROXIMITY_EN, 1);
-		rc = vreg_enable(vreg);
-		if (rc < 0)
-			printk(KERN_ERR "%s: vreg enable failed\n", __func__);
-	} else {
-		rc = vreg_disable(vreg);
-		if (rc < 0)
-			printk(KERN_ERR "%s: vreg disable failed\n", __func__);
-		gpio_direction_output(DESIREC_GPIO_PROXIMITY_EN, 0);
-	}
-
-	return rc;
-}
-
-static DEFINE_SPINLOCK(capella_cm3602_lock);
-static int capella_cm3602_open_cnt;
-
-static int capella_cm3602_power(int on)
-{
-	int rc = 0;
-	unsigned long flags;
-	spin_lock_irqsave(&capella_cm3602_lock, flags);
-
-	if (on) {
-		if (!capella_cm3602_open_cnt++)
-			rc = __capella_cm3602_power(1);
-	} else if (capella_cm3602_open_cnt)
-		if (!--capella_cm3602_open_cnt)
-			rc = __capella_cm3602_power(0);
-
-	spin_unlock_irqrestore(&capella_cm3602_lock, flags);
-	return rc;
-}
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.power = capella_cm3602_power,
-	.p_en = DESIREC_GPIO_PROXIMITY_EN,
-	.p_out = DESIREC_GPIO_PROXIMITY_INT_N
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.id = -1,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-/* End Proximity Sensor (Capella_CM3502)*/
-
-static struct msm_pmem_setting pmem_dual_die_setting = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_gpu0_start = MSM_PMEM_GPU0_BASE,
-	.pmem_gpu0_size = MSM_PMEM_GPU0_SIZE,
-	.pmem_gpu1_start = MSM_PMEM_GPU1_BASE,
-	.pmem_gpu1_size = MSM_PMEM_GPU1_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-#ifdef CONFIG_BUILD_CIQ
-	.pmem_ciq_start = MSM_PMEM_CIQ_BASE,
-	.pmem_ciq_size = MSM_PMEM_CIQ_SIZE,
-	.pmem_ciq1_start = MSM_PMEM_CIQ1_BASE,
-	.pmem_ciq1_size = MSM_PMEM_CIQ1_SIZE,
-	.pmem_ciq2_start = MSM_PMEM_CIQ2_BASE,
-	.pmem_ciq2_size = MSM_PMEM_CIQ2_SIZE,
-	.pmem_ciq3_start = MSM_PMEM_CIQ3_BASE,
-	.pmem_ciq3_size = MSM_PMEM_CIQ3_SIZE,
-/*
-	.pmem_ciq4_start = MSM_PMEM_CIQ4_BASE,
-	.pmem_ciq4_size = MSM_PMEM_CIQ4_SIZE,
-*/
-#endif
-};
-
-#define MONO_DIE_PMEM_SHIFT  0x8000000
-
-static struct msm_pmem_setting pmem_mono_die_setting = {
-	.pmem_start = MSM_PMEM_MDP_BASE - MONO_DIE_PMEM_SHIFT,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE - MONO_DIE_PMEM_SHIFT,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_gpu0_start = MSM_PMEM_GPU0_BASE,
-	.pmem_gpu0_size = MSM_PMEM_GPU0_SIZE,
-	.pmem_gpu1_start = MSM_PMEM_GPU1_BASE - MONO_DIE_PMEM_SHIFT,
-	.pmem_gpu1_size = MSM_PMEM_GPU1_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE - MONO_DIE_PMEM_SHIFT,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-#ifdef CONFIG_BUILD_CIQ
-	.pmem_ciq_start = MSM_PMEM_CIQ_BASE,
-	.pmem_ciq_size = MSM_PMEM_CIQ_SIZE,
-	.pmem_ciq1_start = MSM_PMEM_CIQ1_BASE,
-	.pmem_ciq1_size = MSM_PMEM_CIQ1_SIZE,
-	.pmem_ciq2_start = MSM_PMEM_CIQ2_BASE,
-	.pmem_ciq2_size = MSM_PMEM_CIQ2_SIZE,
-	.pmem_ciq3_start = MSM_PMEM_CIQ3_BASE,
-	.pmem_ciq3_size = MSM_PMEM_CIQ3_SIZE,
-/*
-	.pmem_ciq4_start = MSM_PMEM_CIQ4_BASE,
-	.pmem_ciq4_size = MSM_PMEM_CIQ4_SIZE,
-*/
-#endif
-};
-
-static struct msm_i2c_device_platform_data desirec_i2c_device_data = {
-	.i2c_clock = 100000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_i2c,
-	&desirec_h2w,
-	&htc_battery_pdev,
-	&desirec_audio_jack,
-	&desirec_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&desirec_pwr_sink,
-#endif
-	&capella_cm3602,
-	&msm_camera_sensor_s5k3e2fx
-};
-
-static struct platform_device *devices0[] __initdata = {
-	&msm_device_i2c,
-	&desirec_h2w,
-	&htc_battery_pdev,
-	&desirec_audio_jack,
-	&desirec_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&desirec_pwr_sink,
-#endif
-	&msm_camera_sensor_s5k3e2fx
-};
-
-extern struct sys_timer msm_timer;
-
-static void __init desirec_init_irq(void)
-{
-	printk("desirec_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint opt_disable_uart3;
-
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-
-static void clear_bluetooth_rx_irq_status(void)
-{
-	#define GPIO_INT_CLEAR_2 (MSM_GPIO1_BASE + 0x800 + 0x94)
-	writel((1U << (DESIREC_GPIO_UART1_RX-43)), GPIO_INT_CLEAR_2);
-}
-
-static char bt_chip_id[10] = "brfxxxx";
-module_param_string(bt_chip_id, bt_chip_id, sizeof(bt_chip_id), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_chip_id, "BT's chip id");
-
-static char bt_fw_version[10] = "v2.0.38";
-module_param_string(bt_fw_version, bt_fw_version, sizeof(bt_fw_version), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_fw_version, "BT's fw version");
-
-static void desirec_reset(void)
-{
-	gpio_set_value(DESIREC_GPIO_PS_HOLD, 0);
-}
-
-static uint32_t gpio_table[] = {
-	/* I2C */
-	PCOM_GPIO_CFG(DESIREC_GPIO_I2C_CLK, 1, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),
-	PCOM_GPIO_CFG(DESIREC_GPIO_I2C_DAT , 1, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),
-};
-
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-/*	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_16MA),*/ /* MCLK */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* MCLK */
-	/*steven yeh: modify MCLK driving strength to avoid overshot issue*/
-};
-
-void config_desirec_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void config_desirec_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-static void __init config_gpios(void)
-{
-	config_gpio_table(gpio_table, ARRAY_SIZE(gpio_table));
-}
-
-static struct msm_acpu_clock_platform_data desirec_clock_data = {
-	.acpu_switch_time_us = 20,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200,
-#if defined(CONFIG_TURBO_MODE)
-	.wait_for_irq_khz = 176000,
-#else
-	.wait_for_irq_khz = 128000,
-#endif
-};
-
-static unsigned desirec_perf_acpu_table[] = {
-	245760000,
-	480000000,
-	528000000,
-};
-
-static struct perflock_platform_data desirec_perflock_data = {
-	.perf_acpu_table = desirec_perf_acpu_table,
-	.table_size = ARRAY_SIZE(desirec_perf_acpu_table),
-};
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(DESIREC_GPIO_UART1_RX),
-	.inject_rx_on_wakeup = 1,
-	.rx_to_inject = 0x32,
-	.cpu_lock_supported = 1,
-};
-#endif
-
-static ssize_t desirec_virtual_keys_show(struct kobject *kobj,
-			struct kobj_attribute *attr, char *buf)
-{
-	/* center: x: home: 30, menu: 112, back: 215, search 295, y: 490*/
-	return sprintf(buf,
-			__stringify(EV_KEY) ":" __stringify(KEY_HOME)   ":30:490:58:2"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":112:490:94:2"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":215:490:78:2"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":295:490:48:2"
-			"\n");
-}
-
-static struct kobj_attribute desirec_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.melfas-tsi-ts",
-		.mode = S_IRUGO,
-	},
-	.show = &desirec_virtual_keys_show,
-};
-
-static ssize_t desirec_synaptics_virtual_keys_show(struct kobject *kobj,
-			       struct kobj_attribute *attr, char *buf)
-{
-	/* center: x: home: 30, menu: 110, back: 205, search 285, y: 510 */
-	return sprintf(buf,
-		__stringify(EV_KEY) ":" __stringify(KEY_HOME)  ":30:510:60:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":110:510:100:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":205:510:90:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":285:510:70:55"
-	   "\n");
-}
-
-static struct kobj_attribute desirec_synaptics_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.synaptics-rmi-touchscreen",
-		.mode = S_IRUGO,
-	},
-	.show = &desirec_synaptics_virtual_keys_show,
-};
-
-static struct attribute *desirec_properties_attrs[] = {
-	&desirec_virtual_keys_attr.attr,
-	&desirec_synaptics_virtual_keys_attr.attr,
-	NULL
-};
-
-static struct attribute_group desirec_properties_attr_group = {
-	.attrs = desirec_properties_attrs,
-};
-
-static void __init desirec_init(void)
-{
-	int rc;
-	struct kobject *properties_kobj;
-	printk(KERN_INFO "%s() revision = %d\n", __func__, system_rev);
-
-	config_gpios();
-
-	if (system_rev > 0) {
-		/* We need to set this pin to 0 only once on power-up; we will
-		 * not actually enable the chip until we apply power to it via
-		 * vreg.
-		 */
-		gpio_direction_output(DESIREC_GPIO_CM3602_EN, 0);
-		/* disable power for cm3602 chip */
-		__capella_cm3602_power(0);
-	}
-
-	msm_hw_reset_hook = desirec_reset;
-
-	msm_acpu_clock_init(&desirec_clock_data);
-	perflock_init(&desirec_perflock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-				      &msm_device_uart3.dev, 1, INT_UART3_RX);
-#endif
-
-	msm_add_devices();
-
-	clear_bluetooth_rx_irq_status();
-
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_add_serial_devices(MSM_SERIAL_UART1DM);
-#else
-	msm_add_serial_devices(MSM_SERIAL_UART1);
-#endif
-
-	msm_add_serial_devices(MSM_SERIAL_UART3);
-
-	msm_register_usb_phy_init_seq(desirec_phy_init_seq);
-	msm_hsusb_set_product(desirec_usb_products,
-		ARRAY_SIZE(desirec_usb_products));
-
-	msm_add_usb_devices(desirec_phy_reset, desirec_phy_shutdown);
-
-	if (board_mcp_monodie())
-		msm_add_mem_devices(&pmem_mono_die_setting);
-	else
-		msm_add_mem_devices(&pmem_dual_die_setting);
-
-	msm_init_pmic_vibrator();
-
-	rc = desirec_init_mmc(system_rev);
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-
-	properties_kobj = kobject_create_and_add("board_properties", NULL);
-	if (properties_kobj)
-		rc = sysfs_create_group(properties_kobj,
-						&desirec_properties_attr_group);
-	if (!properties_kobj || rc)
-		pr_err("failed to create board_properties\n");
-
-	msm_device_i2c.dev.platform_data = &desirec_i2c_device_data;
-
-	if (system_rev > 0) /*Aobve XB*/
-		platform_add_devices(devices, ARRAY_SIZE(devices));
-	else /* XA */
-		platform_add_devices(devices0, ARRAY_SIZE(devices0));
-
-	if (system_rev > 0) {
-		microp_data.ls_power = capella_cm3602_power;
-		if (system_rev >= 2) {
-			microp_data.num_pins = ARRAY_SIZE(microp_pins_2);
-			microp_data.pin_config = microp_pins_2;
-		}
-	}
-
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-/* r porting*///	i2c_register_board_info(0, &i2c_s5k3e2fx, 1);
-}
-
-static void __init desirec_fixup(struct machine_desc *desc, struct tag *tags,
-			      char **cmdline, struct meminfo *mi)
-{
-	parse_tag_monodie((const struct tag *)tags);
-
-	mi->nr_banks = 1;
-	mi->bank[0].start = MSM_LINUX_BASE1;
-	mi->bank[0].node = PHYS_TO_NID(MSM_LINUX_BASE1);
-	if (board_mcp_monodie()) {
-		mi->bank[0].size = MSM_LINUX_SIZE1 + MSM_LINUX_SIZE2;
-	} else {
-		mi->nr_banks = 2;
-		mi->bank[0].size = MSM_LINUX_SIZE1;
-		mi->bank[1].start = MSM_LINUX_BASE2;
-		mi->bank[1].node = PHYS_TO_NID(MSM_LINUX_BASE2);
-		mi->bank[1].size = MSM_LINUX_SIZE2;
-	}
-}
-
-static void __init desirec_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-MACHINE_START(DESIREC, "desirec")
-/* Maintainer: Kant Kang <kant_kang@htc.com> */
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params    = 0x11200100,
-	.fixup          = desirec_fixup,
-	.map_io         = desirec_map_io,
-	.init_irq       = desirec_init_irq,
-	.init_machine   = desirec_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-desirec.h b/arch/arm/mach-msm/board-desirec.h
deleted file mode 100644
index 5cd46fa..0000000
--- a/arch/arm/mach-msm/board-desirec.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/* linux/arch/arm/mach-msm/board-desirec.h
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_DESIREC_H
-#define __ARCH_ARM_MACH_MSM_BOARD_DESIREC_H
-
-#include <mach/board.h>
-
-#define MSM_LINUX_BASE         0x19200000
-#define MSM_LINUX_SIZE         0xC600000
-
-#define MSM_LINUX_BASE1         0x11200000
-#define MSM_LINUX_SIZE1         0x6E00000
-#define MSM_LINUX_BASE2         0x20000000
-#define MSM_LINUX_SIZE2         0x5800000
-
-#define MSM_PMEM_GPU0_BASE      0x00000000
-#define MSM_PMEM_GPU0_SIZE      0x00700000
-
-#define MSM_FB_BASE             0x00700000
-#define MSM_FB_SIZE             0x9b000
-
-#define MSM_RAM_CONSOLE_BASE    0x007A0000
-#define MSM_RAM_CONSOLE_SIZE    128 * SZ_1K
-
-#ifdef CONFIG_BUILD_CIQ
-#define MSM_PMEM_CIQ_BASE		MSM_RAM_CONSOLE_BASE + MSM_RAM_CONSOLE_SIZE
-#define MSM_PMEM_CIQ_SIZE		64 * SZ_1K
-#define MSM_PMEM_CIQ1_BASE		MSM_PMEM_CIQ_BASE
-#define MSM_PMEM_CIQ1_SIZE		MSM_PMEM_CIQ_SIZE
-#define MSM_PMEM_CIQ2_BASE		MSM_PMEM_CIQ_BASE
-#define MSM_PMEM_CIQ2_SIZE		MSM_PMEM_CIQ_SIZE
-#define MSM_PMEM_CIQ3_BASE		MSM_PMEM_CIQ_BASE
-#define MSM_PMEM_CIQ3_SIZE		MSM_PMEM_CIQ_SIZE
-#define MSM_PMEM_CIQ4_BASE		MSM_PMEM_CIQ_BASE
-#define MSM_PMEM_CIQ4_SIZE		MSM_PMEM_CIQ_SIZE
-#endif
-
-#define MSM_PMEM_GPU1_BASE      0x25800000
-#define MSM_PMEM_GPU1_SIZE      0x00800000
-
-#define MSM_PMEM_MDP_BASE       0x26000000
-#define MSM_PMEM_MDP_SIZE       0x00800000
-
-#define MSM_PMEM_ADSP_BASE      0x26800000
-#define MSM_PMEM_ADSP_SIZE      0x00800000
-
-#define MSM_PMEM_CAMERA_BASE	0x27000000
-#define MSM_PMEM_CAMERA_SIZE    0x01000000
-
-#define DECLARE_MSM_IOMAP
-#include <mach/msm_iomap.h>
-
-#define DESIREC_GPIO_BALL_UP     (94)
-#define DESIREC_GPIO_BALL_LEFT   (39)
-#define DESIREC_GPIO_BALL_DOWN   (90)
-#define DESIREC_GPIO_BALL_RIGHT  (37)
-#define DESIREC_JOGBALL_EN           (88)
-#define DESIREC_JOGBALL_EN_XA      (110)
-
-#define DESIREC_GPIO_PROXIMITY_INT_N    (17)
-#define DESIREC_GPIO_GSENSOR_INT_N         (18)
-#define DESIREC_POWER_KEY                  		(20)
-#define DESIREC_GPIO_UP_INT_N              (21)
-#define DESIREC_GPIO_PS_HOLD             		(25)
-#define DESIREC_GPIO_MDDI_RST_N            (26)
-#define DESIREC_GPIO_TP_ATT_N              (36)
-#define DESIREC_GPIO_SDMC_CD_N             (38)
-
-/* BT */
-#define DESIREC_GPIO_UART1_RTS             (43)
-#define DESIREC_GPIO_UART1_CTS             (44)
-#define DESIREC_GPIO_UART1_RX              (45)
-#define DESIREC_GPIO_UART1_TX              (46)
-#define DESIREC_GPIO_WB_SHUT_DOWN_N        (101)
-
-#define DESIREC_GPIO_PROXIMITY_EN          (47)
-#define DESIREC_GPIO_CM3602_EN             (48)
-#define DESIREC_GPIO_I2C_CLK               (60)
-#define DESIREC_GPIO_I2C_DAT               (61)
-
-#define DESIREC_GPIO_UP_RESET_N            (76)
-#define DESIREC_GPIO_WAKE_UP              (80)
-#define DESIREC_GPIO_COMPASS_INT_N         (83)
-#define DESIREC_GPIO_COMPASS_RST_N         (84)
-#define DESIREC_PROJECT_NAME          "desirec"
-#define DESIREC_LAYOUTS             { \
-		{ {  0,  1, 0}, { -1,  0, 0}, {0, 0, 1} }, \
-		{ {  0, -1, 0}, { -1,  0, 0}, {0, 0, 1} }, \
-		{ { -1,  0, 0}, {  0, -1, 0}, {0, 0, 1} }, \
-		{ {  1,  0, 0}, {  0,  0, 1}, {0, 1, 0} }  \
-					}
-
-#define DESIREC_GPIO_HTC_HP_SD             (89)
-
-#define DESIREC_GPIO_VCM_PWDN              (91)
-#define DESIREC_GPIO_CAM_RST_N             (92)
-#define DESIREC_GPIO_USB_PHY_RST_N         (100)
-#define DESIREC_GPIO_WIFI_EN               (102)
-#define DESIREC_CAM_PWDN                   (107)
-#define DESIREC_TP_LS_EN                   (108)
-#define DESIREC_GPIO_TP_EN                 (109)
-
-#define DESIREC_GPIO_TO_INT(x)             (x+64)/*from gpio_to_irq*/
-
-
-/* H2W */
-#define DESIREC_GPIO_CABLE_IN1             (49)
-#define DESIREC_GPIO_CABLE_IN2             (31)
-#define DESIREC_GPIO_UART3_RX              (86)
-#define DESIREC_GPIO_UART3_TX              (87)
-#define DESIREC_GPIO_H2W_DATA              (86)
-#define DESIREC_GPIO_H2W_CLK               (87)
-#define DESIREC_GPIO_HEADSET_MIC           (17)
-#define DESIREC_GPIO_35MM_HEADSET_DET      (27)
-#define DESIREC_GPIO_AUD_EXTMIC_SEL        (82)
-#define DESIREC_GPIO_H2W_POWER             (93)
-
-#define DESIREC_GPIO_VSYNC	(97)
-
-int desirec_init_mmc(unsigned int sys_rev);
-void config_desirec_camera_on_gpios(void);
-void config_desirec_camera_off_gpios(void);
-unsigned int camera_is_micron_5M(void);
-#endif /* GUARD */
diff --git a/arch/arm/mach-msm/board-firestone-keypad.c b/arch/arm/mach-msm/board-firestone-keypad.c
deleted file mode 100644
index 7faa328..0000000
--- a/arch/arm/mach-msm/board-firestone-keypad.c
+++ /dev/null
@@ -1,97 +0,0 @@
-/* arch/arm/mach-msm/board-firestone-keypad.c
- *
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Haley Teng <haley_teng@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/gpio_event.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-
-#include <asm/mach-types.h>
-
-#include "board-firestone.h"
-
-static unsigned int firestone_col_gpios[] = { 33, 32, 31 };
-static unsigned int firestone_row_gpios[] = { 42, 41, 40 };
-
-#define KEYMAP_INDEX(col, row)	((col)*ARRAY_SIZE(firestone_row_gpios) + (row))
-#define KEYMAP_SIZE		(ARRAY_SIZE(firestone_col_gpios) * \
-				 ARRAY_SIZE(firestone_row_gpios))
-
-static const unsigned short firestone_keymap[KEYMAP_SIZE] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEDOWN,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(1, 1)] = KEY_HOME,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_BACK,
-};
-
-static struct gpio_event_matrix_info firestone_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = firestone_keymap,
-	.output_gpios = firestone_col_gpios,
-	.input_gpios = firestone_row_gpios,
-	.noutputs = ARRAY_SIZE(firestone_col_gpios),
-	.ninputs = ARRAY_SIZE(firestone_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		  GPIOKPF_REMOVE_PHANTOM_KEYS |
-		  GPIOKPF_PRINT_UNMAPPED_KEYS),
-};
-
-static struct gpio_event_direct_entry firestone_keypad_nav_map[] = {
-	{
-		.gpio	= FIRESTONE_GPIO_POWER_KEY,
-		.code	= KEY_END,
-	},
-};
-
-static struct gpio_event_input_info firestone_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.flags = 0,
-	.type = EV_KEY,
-	.keymap = firestone_keypad_nav_map,
-	.keymap_size = ARRAY_SIZE(firestone_keypad_nav_map)
-};
-
-static struct gpio_event_info *firestone_keypad_info[] = {
-	&firestone_keypad_matrix_info.info,
-	&firestone_keypad_nav_info.info,
-};
-
-static struct gpio_event_platform_data firestone_keypad_data = {
-	.name = "firestone-keypad",
-	.info = firestone_keypad_info,
-	.info_count = ARRAY_SIZE(firestone_keypad_info)
-};
-
-static struct platform_device firestone_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev = {
-		.platform_data = &firestone_keypad_data,
-	},
-};
-
-static int __init firestone_init_keypad(void)
-{
-	if (!machine_is_firestone())
-		return 0;
-	return platform_device_register(&firestone_keypad_device);
-}
-
-device_initcall(firestone_init_keypad);
diff --git a/arch/arm/mach-msm/board-firestone-mmc.c b/arch/arm/mach-msm/board-firestone-mmc.c
deleted file mode 100644
index 001c99a..0000000
--- a/arch/arm/mach-msm/board-firestone-mmc.c
+++ /dev/null
@@ -1,412 +0,0 @@
-/* linux/arch/arm/mach-msm/board-firestone-mmc.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/debugfs.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-
-#include <asm/mach/mmc.h>
-#include <mach/vreg.h>
-#include <mach/htc_pwrsink.h>
-
-#include "proc_comm.h"
-#include "devices.h"
-#include "board-firestone.h"
-
-#undef FIRESTONE_DEBUG_MMC
-
-#undef FIRESTONE_DO_WIFI
-
-static struct vreg *vreg_wifi_batpa;	/* WIFI main power */
-static int firestone_wifi_cd = 0;	/* WIFI virtual 'card detect' status */
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA), /* CLK */
-	PCOM_GPIO_CFG(63, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA), /* CMD */
-	PCOM_GPIO_CFG(64, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init firestone_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_firestone.disable_sdcard=", firestone_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_165_195,	1800 },
-	{ MMC_VDD_20_21,	2050 },
-	{ MMC_VDD_21_22,	2150 },
-	{ MMC_VDD_22_23,	2250 },
-	{ MMC_VDD_23_24,	2350 },
-	{ MMC_VDD_24_25,	2450 },
-	{ MMC_VDD_25_26,	2550 },
-	{ MMC_VDD_26_27,	2650 },
-	{ MMC_VDD_27_28,	2750 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2950 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t firestone_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-		pr_info("%s: Disabling SD slot power\n", __func__);
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		vreg_enable(vreg_sdslot);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		vreg_enable(vreg_wifi_batpa);
-		vreg_set_level(vreg_wifi_batpa, 2850);
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-			pr_info("%s: Setting level to %u\n", __func__,
-				mmc_vdd_table[i].level);
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-			return 0;
-		}
-	}
-
-	pr_err("%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int firestone_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(FIRESTONE_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define FIRESTONE_MMC_VDD MMC_VDD_165_195 | MMC_VDD_20_21 | MMC_VDD_21_22 \
-			  | MMC_VDD_22_23 | MMC_VDD_23_24 | MMC_VDD_24_25 \
-			  | MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 \
-			  | MMC_VDD_28_29 | MMC_VDD_29_30
-
-static struct mmc_platform_data firestone_sdslot_data = {
-	.ocr_mask	= FIRESTONE_MMC_VDD,
-	.status		= firestone_sdslot_status,
-	.translate_vdd	= firestone_sdslot_switchvdd,
-};
-
-/* ---- WIFI ---- */
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int firestone_wifi_status_register(
-			void (*callback)(int card_present, void *dev_id),
-			void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int firestone_wifi_status(struct device *dev)
-{
-	return firestone_wifi_cd;
-}
-
-static struct mmc_platform_data firestone_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= firestone_wifi_status,
-	.register_status_notify	= firestone_wifi_status_register,
-	.embedded_sdio		= NULL,
-};
-
-int firestone_wifi_set_carddetect(int val)
-{
-	pr_info("%s: %d\n", __func__, val);
-	firestone_wifi_cd = val;
-	if (wifi_status_cb) {
-		wifi_status_cb(val, wifi_status_cb_devid);
-	} else
-		pr_warning("%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(firestone_wifi_set_carddetect);
-
-static int firestone_wifi_power_state;
-
-int firestone_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk("%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		htc_pwrsink_set(PWRSINK_WIFI, 70);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-		htc_pwrsink_set(PWRSINK_WIFI, 0);
-	}
-
-	mdelay(100);
-	gpio_set_value(129, on); /* WIFI_SHUTDOWN */
-	mdelay(100);
-
-	firestone_wifi_power_state = on;
-	return 0;
-}
-EXPORT_SYMBOL(firestone_wifi_power);
-
-static int firestone_wifi_reset_state;
-int firestone_wifi_reset(int on)
-{
-	firestone_wifi_reset_state = on;
-#if 1
-	printk("%s: do nothing\n", __func__);
-#else
-	printk("%s: %d\n", __func__, on);
-	gpio_set_value( TROUT_GPIO_WIFI_PA_RESETX, !on );
-	mdelay(50);
-#endif
-	return 0;
-}
-
-int __init firestone_init_mmc(unsigned int sys_rev)
-{
-	uint32_t id;
-
-	wifi_status_cb = NULL;
-
-	/* initial WIFI_SHUTDOWN# */
-	id = PCOM_GPIO_CFG(129, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	sdslot_vreg_enabled = 0;
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-
-	printk("%s\n", __func__);
-
-	/* vreg_wifi_batpa is always on in Q8K */
-	vreg_wifi_batpa = vreg_get(0, "wlan");
-	if (IS_ERR(vreg_wifi_batpa))
-		return PTR_ERR(vreg_wifi_batpa);
-
-#ifdef FIRESTONE_DO_WIFI
-	msm_add_sdcc(1, &firestone_wifi_data, 0, 0);
-#endif
-
-	set_irq_wake(MSM_GPIO_TO_INT(FIRESTONE_GPIO_SDMC_CD_N), 1);
-
-	if (!opt_disable_sdcard)
-		msm_add_sdcc(2, &firestone_sdslot_data,
-			     MSM_GPIO_TO_INT(FIRESTONE_GPIO_SDMC_CD_N),
-			     IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-	else
-		pr_info("firestone: SD-Card interface disabled\n");
-	return 0;
-}
-
-
-#if defined(FIRESTONE_DEBUG_MMC) && defined(CONFIG_DEBUG_FS)
-
-static int firestonemmc_dbg_wifi_reset_set(void *data, u64 val)
-{
-	firestone_wifi_reset((int) val);
-	return 0;
-}
-
-static int firestonemmc_dbg_wifi_reset_get(void *data, u64 *val)
-{
-	*val = firestone_wifi_reset_state;
-	return 0;
-}
-
-static int firestonemmc_dbg_wifi_cd_set(void *data, u64 val)
-{
-	firestone_wifi_set_carddetect((int) val);
-	return 0;
-}
-
-static int firestonemmc_dbg_wifi_cd_get(void *data, u64 *val)
-{
-	*val = firestone_wifi_cd;
-	return 0;
-}
-
-static int firestonemmc_dbg_wifi_pwr_set(void *data, u64 val)
-{
-	firestone_wifi_power((int) val);
-	return 0;
-}
-
-static int firestonemmc_dbg_wifi_pwr_get(void *data, u64 *val)
-{
-	*val = firestone_wifi_power_state;
-	return 0;
-}
-
-static int firestonemmc_dbg_sd_pwr_set(void *data, u64 val)
-{
-	firestone_sdslot_switchvdd(NULL, (unsigned int) val);
-	return 0;
-}
-
-static int firestonemmc_dbg_sd_pwr_get(void *data, u64 *val)
-{
-	*val = sdslot_vdd;
-	return 0;
-}
-
-static int firestonemmc_dbg_sd_cd_set(void *data, u64 val)
-{
-	return -ENOSYS;
-}
-
-static int firestonemmc_dbg_sd_cd_get(void *data, u64 *val)
-{
-	*val = firestone_sdslot_status(NULL);
-	return 0;
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(firestonemmc_dbg_wifi_reset_fops,
-			firestonemmc_dbg_wifi_reset_get,
-			firestonemmc_dbg_wifi_reset_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(firestonemmc_dbg_wifi_cd_fops,
-			firestonemmc_dbg_wifi_cd_get,
-			firestonemmc_dbg_wifi_cd_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(firestonemmc_dbg_wifi_pwr_fops,
-			firestonemmc_dbg_wifi_pwr_get,
-			firestonemmc_dbg_wifi_pwr_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(firestonemmc_dbg_sd_pwr_fops,
-			firestonemmc_dbg_sd_pwr_get,
-			firestonemmc_dbg_sd_pwr_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(firestonemmc_dbg_sd_cd_fops,
-			firestonemmc_dbg_sd_cd_get,
-			firestonemmc_dbg_sd_cd_set, "%llu\n");
-
-static int __init firestonemmc_dbg_init(void)
-{
-	struct dentry *dent;
-
-	if (!machine_is_firestone())
-		return 0;
-
-	dent = debugfs_create_dir("firestone_mmc_dbg", 0);
-	if (IS_ERR(dent))
-		return PTR_ERR(dent);
-
-	debugfs_create_file("wifi_reset", 0644, dent, NULL,
-			    &firestonemmc_dbg_wifi_reset_fops);
-	debugfs_create_file("wifi_cd", 0644, dent, NULL,
-			    &firestonemmc_dbg_wifi_cd_fops);
-	debugfs_create_file("wifi_pwr", 0644, dent, NULL,
-			    &firestonemmc_dbg_wifi_pwr_fops);
-	debugfs_create_file("sd_pwr", 0644, dent, NULL,
-			    &firestonemmc_dbg_sd_pwr_fops);
-	debugfs_create_file("sd_cd", 0644, dent, NULL,
-			    &firestonemmc_dbg_sd_cd_fops);
-	return 0;
-}
-
-device_initcall(firestonemmc_dbg_init);
-#endif
diff --git a/arch/arm/mach-msm/board-firestone-panel.c b/arch/arm/mach-msm/board-firestone-panel.c
deleted file mode 100644
index c071fac..0000000
--- a/arch/arm/mach-msm/board-firestone-panel.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/* linux/arch/arm/mach-msm/board-firestone-panel.c
- *
- * Copyright (c) 2009 Google Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * Author: Dima Zavin <dima@android.com>
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/i2c.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-
-#include "board-firestone.h"
-#include "devices.h"
-
-#define CLK_NS_TO_RATE(ns)			(1000000000UL / (ns))
-
-#define MICROP_CMD_SPI_INTERFACE		0x21
-#define MICROP_CMD_VERSION			0x29
-#define MICROP_WRITE_LCM_DATA_1BYTE		0x70
-
-#define MICROP_NUM_I2C_RETRIES			100
-#define MICROP_I2C_WRITE_BLOCK_SIZE		21
-
-static struct i2c_client *microp_client;
-
-static int microp_read_buf(uint8_t addr, void *data, int length)
-
-{
-	struct i2c_msg msgs[2];
-	int cnt = MICROP_NUM_I2C_RETRIES;
-	int ret = 0;
-
-	msgs[0].addr = microp_client->addr;
-	msgs[0].flags = 0;
-	msgs[0].len = 1;
-	msgs[0].buf = &addr;
-	msgs[1].addr = microp_client->addr;
-	msgs[1].flags = I2C_M_RD;
-	msgs[1].len = length;
-	msgs[1].buf = data;
-
-	while (cnt--) {
-		ret = i2c_transfer(microp_client->adapter, msgs, 2);
-		if (ret == 2)
-			goto done;
-		mdelay(10);
-	}
-
-	dev_err(&microp_client->dev, "%s: failed to read buf\n", __func__);
-	return -EIO;
-
-done:
-	return 0;
-}
-
-static int microp_write_buf(uint8_t addr, void *data, int length)
-{
-	uint8_t buf[MICROP_I2C_WRITE_BLOCK_SIZE];
-	int retry = MICROP_NUM_I2C_RETRIES;
-	int ret;
-	struct i2c_msg msg;
-
-	if (length >= MICROP_I2C_WRITE_BLOCK_SIZE) {
-		dev_err(&microp_client->dev, "%s: length (%d) too long\n",
-			__func__, length);
-		return -EINVAL;
-	}
-
-	msg.addr = microp_client->addr,
-	msg.flags = 0,
-	msg.len = length + 1,
-	msg.buf = buf;
-
-	buf[0] = addr;
-	memcpy(&buf[1], data, length);
-
-	do {
-		ret = i2c_transfer(microp_client->adapter, &msg, 1);
-		if (ret == 1)
-			goto done;
-		mdelay(10);
-	} while (retry--);
-
-	dev_err(&microp_client->dev, "%s: Could not write data (%d bytes).\n",
-		__func__, length);
-	return -EIO;
-
-done:
-	return 0;
-}
-
-static int lcm_writeb(uint16_t reg, uint8_t val)
-{
-	uint8_t buf[3];
-	int ret;
-
-	buf[0] = (reg >> 8) & 0xff;
-	buf[1] = reg & 0xff;
-	buf[2] = val;
-
-	ret = microp_write_buf(MICROP_WRITE_LCM_DATA_1BYTE, buf, 3);
-	if (ret) {
-		pr_err("%s: failed lcm_writeb\n", __func__);
-		goto done;
-	}
-	udelay(100);
-
-done:
-	return ret;
-}
-
-static int samsung_oled_panel_blank(struct msm_lcdc_panel_ops *ops)
-{
-	pr_info("%s: +()\n", __func__);
-	lcm_writeb(0x14, 0x1);
-	msleep(200);
-	lcm_writeb(0x1d, 0xa1);
-	msleep(300);
-	pr_info("%s: -()\n", __func__);
-	return 0;
-}
-
-static int samsung_oled_panel_unblank(struct msm_lcdc_panel_ops *ops)
-{
-	pr_info("%s: +()\n", __func__);
-	lcm_writeb(0x1d, 0xa0);
-	msleep(200);
-	lcm_writeb(0x14, 0x03);
-	msleep(100);
-	pr_info("%s: -()\n", __func__);
-	return 0;
-}
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct {
-	uint8_t		reg;
-	uint8_t		val;
-	uint16_t	delay;
-} samsung_oled_init_table[] = {
-	{0x31, 0x08, 0},
-	{0x32, 0x14, 0},
-	{0x30, 0x2 , 0},
-	{0x27, 0x1 , 0},
-	{0x12, 0x8 , 0},
-	{0x13, 0x8 , 0},
-	{0x15, 0x0 , 0},
-	{0x16, 0x02, 0},
-	{0x39, 0x44, 0},
-	{0x17, 0x22, 0},
-	{0x18, 0x33, 0},
-	{0x19, 0x3 , 0},
-	{0x1A, 0x1 , 0},
-	{0x22, 0xA4, 0},
-	{0x23, 0x0 , 0},
-	{0x26, 0xA0, 0},
-	{0x1D, 0xA0, 250},
-};
-
-static int samsung_oled_panel_init(struct msm_lcdc_panel_ops *ops)
-{
-	int i;
-
-	pr_info("%s: +()\n", __func__);
-	for (i = 0; i< ARRAY_SIZE(samsung_oled_init_table); i++) {
-		lcm_writeb(samsung_oled_init_table[i].reg,
-			   samsung_oled_init_table[i].val);
-		if (samsung_oled_init_table[i].delay)
-			mdelay(samsung_oled_init_table[i].delay);
-	}
-
-	lcm_writeb(0x14, 0x3);
-	pr_info("%s: -()\n", __func__);
-
-	return 0;
-}
-
-static struct msm_lcdc_panel_ops firestone_lcdc_panel_ops = {
-	.init			= samsung_oled_panel_init,
-	.blank			= samsung_oled_panel_blank,
-	.unblank			= samsung_oled_panel_unblank,
-};
-
-static struct msm_lcdc_timing firestone_lcdc_timing = {
-		.clk_rate		= CLK_NS_TO_RATE(26),
-		.hsync_pulse_width	= 4,
-		.hsync_back_porch	= 4,
-		.hsync_front_porch	= 8,
-		.hsync_skew		= 0,
-		.vsync_pulse_width	= 2,
-		.vsync_back_porch	= 6,
-		.vsync_front_porch	= 8,
-		.vsync_act_low		= 1,
-		.hsync_act_low		= 1,
-		.den_act_low		= 1,
-};
-
-static struct msm_fb_data firestone_lcdc_fb_data = {
-		.xres		= 480,
-		.yres		= 800,
-		.width		= 48,
-		.height		= 80,
-		.output_format	= 0,
-};
-
-static struct msm_lcdc_platform_data firestone_lcdc_platform_data = {
-	.panel_ops	= &firestone_lcdc_panel_ops,
-	.timing		= &firestone_lcdc_timing,
-	.fb_id		= 0,
-	.fb_data	= &firestone_lcdc_fb_data,
-	.fb_resource	= &resources_msm_fb[0],
-};
-
-static struct platform_device firestone_lcdc_device = {
-	.name	= "msm_mdp_lcdc",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &firestone_lcdc_platform_data,
-	},
-};
-
-static int microp_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
-{
-	int ret = 0;
-	uint16_t ver;
-
-	microp_client = client;
-	ret = microp_read_buf(MICROP_CMD_VERSION, &ver, 2);
-	if (ret || ver == 0) {
-		ret = -ENODEV;
-		dev_err(&client->dev, "failed to get microp version\n");
-		goto err;
-	}
-
-	ret = platform_device_register(&firestone_lcdc_device);
-	if (ret) {
-		ret = -ENODEV;
-		dev_err(&client->dev, "failed to register lcdc device\n");
-		goto err;
-	}
-	pr_info("%s: microp ver=%0x registered\n", __func__, ver);
-
-	return 0;
-
-err:
-	microp_client = NULL;
-	return ret;
-}
-
-static struct i2c_device_id microp_id[] = {
-	{ "microp-i2c", 0},
-	{ }
-};
-
-static struct i2c_driver microp_driver = {
-	.probe		= microp_probe,
-	.id_table	= microp_id,
-	.driver = {
-		.name	= "microp-i2c",
-		.owner	= THIS_MODULE,
-	},
-};
-
-int __init firestone_init_panel(void)
-{
-	int rc;
-	if (!machine_is_firestone())
-		return 0;
-
-	if ((rc = platform_device_register(&msm_device_mdp)) != 0)
-		return rc;
-
-	rc = i2c_add_driver(&microp_driver);
-	if (rc != 0)
-		return rc;
-
-	return 0;
-}
-
-late_initcall(firestone_init_panel);
diff --git a/arch/arm/mach-msm/board-firestone-rfkill.c b/arch/arm/mach-msm/board-firestone-rfkill.c
deleted file mode 100644
index f523037..0000000
--- a/arch/arm/mach-msm/board-firestone-rfkill.c
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for firestone platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include "board-firestone.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		gpio_configure(FIRESTONE_GPIO_BT_RESET_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-		gpio_configure(FIRESTONE_GPIO_BT_SHUTDOWN_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		gpio_configure(FIRESTONE_GPIO_BT_SHUTDOWN_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-		gpio_configure(FIRESTONE_GPIO_BT_RESET_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-		break;
-	default:
-		printk(KERN_ERR "bad bluetooth rfkill state %d\n", state);
-	}
-	return 0;
-}
-
-static int firestone_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;  /* off */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;  // user data
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-
-	if (rc)
-		rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int firestone_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver firestone_rfkill_driver = {
-	.probe = firestone_rfkill_probe,
-	.remove = firestone_rfkill_remove,
-	.driver = {
-		.name = "firestone_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init firestone_rfkill_init(void)
-{
-	if (!machine_is_firestone())
-		return 0;
-	return platform_driver_register(&firestone_rfkill_driver);
-}
-
-static void __exit firestone_rfkill_exit(void)
-{
-	platform_driver_unregister(&firestone_rfkill_driver);
-}
-
-module_init(firestone_rfkill_init);
-module_exit(firestone_rfkill_exit);
-MODULE_DESCRIPTION("firestone rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-firestone.c b/arch/arm/mach-msm/board-firestone.c
deleted file mode 100644
index 3bb8701..0000000
--- a/arch/arm/mach-msm/board-firestone.c
+++ /dev/null
@@ -1,364 +0,0 @@
-/* linux/arch/arm/mach-msm/board-firestone.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Author: Brian Swetland <swetland@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/delay.h>
-#include <linux/cy8c_tmg_ts.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/android_pmem.h>
-
-#include <mach/hardware.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/setup.h>
-
-#include <mach/board.h>
-#include <mach/msm_iomap.h>
-#include <mach/msm_hsusb.h>
-#include <mach/msm_ts.h>
-
-#include "proc_comm.h"
-
-#ifdef CONFIG_USB_FUNCTION_MASS_STORAGE
-#include <linux/usb/mass_storage_function.h>
-#endif
-
-#ifdef CONFIG_USB_ANDROID
-#include <linux/usb/android.h>
-#endif
-
-#include "board-firestone.h"
-#include "devices.h"
-
-extern int firestone_init_mmc(unsigned int);
-
-#ifdef CONFIG_USB_FUNCTION
-static char *firestone_usb_functions[] = {
-#if defined(CONFIG_USB_FUNCTION_MASS_STORAGE)
-	"usb_mass_storage",
-#endif
-#ifdef CONFIG_USB_FUNCTION_ADB
-	"adb",
-#endif
-};
-
-static struct msm_hsusb_product firestone_usb_products[] = {
-	{
-		.product_id     = 0x0d01,
-		.functions      = 0x00000001, /* "usb_mass_storage" only */
-	},
-	{
-		.product_id     = 0x0d02,
-		.functions      = 0x00000003, /* "usb_mass_storage" and "adb" */
-	},
-};
-#endif
-
-static int firestone_phy_init_seq[] = { 0x1D, 0x0D, 0x1D, 0x10, -1 };
-
-static struct msm_hsusb_platform_data msm_hsusb_pdata = {
-	.phy_init_seq		= firestone_phy_init_seq,
-#ifdef CONFIG_USB_FUNCTION
-	.vendor_id		= 0x18d1,
-	.product_id		= 0x0d02,
-	.version		= 0x0100,
-	.product_name		= "Firestone",
-	.serial_number		= "42",
-	.manufacturer_name	= "HTC",
-
-	.functions		= firestone_usb_functions,
-	.num_functions		= ARRAY_SIZE(firestone_usb_functions),
-	.products		= firestone_usb_products,
-	.num_products		= ARRAY_SIZE(firestone_usb_products),
-#endif
-};
-
-#ifdef CONFIG_USB_FUNCTION_MASS_STORAGE
-static struct usb_mass_storage_platform_data mass_storage_pdata = {
-	.nluns		= 1,
-	.buf_size	= 16384,
-	.vendor		= "Qualcomm",
-	.product	= "HTC",
-	.release	= 0x0100,
-};
-
-static struct platform_device usb_mass_storage_device = {
-	.name	= "usb_mass_storage",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &mass_storage_pdata,
-	},
-};
-#endif
-
-#ifdef CONFIG_USB_ANDROID
-static struct android_usb_platform_data android_usb_pdata = {
-	.vendor_id= 0x18d1,
-	.product_id= 0x0d01,
-	.adb_product_id= 0x0d02,
-	.version= 0x0100,
-	.serial_number= "42",
-	.product_name= "Firestonedroid",
-	.manufacturer_name = "Qualcomm",
-	.nluns = 1,
-};
-
-static struct platform_device android_usb_device = {
-	.name	= "android_usb",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &android_usb_pdata,
-	},
-};
-#endif
-
-static int firestone_cy8c_ts_power(int on)
-{
-	pr_info("%s: power %d\n", __func__, on);
-
-	if (on) {
-		/* level shifter should be off */
-		gpio_set_value(FIRESTONE_GPIO_TP_EN, 1);
-		msleep(120);
-		/* enable touch panel level shift */
-		gpio_set_value(FIRESTONE_GPIO_TP_LS_EN, 1);
-		msleep(3);
-	} else {
-		gpio_set_value(FIRESTONE_GPIO_TP_LS_EN, 0);
-		gpio_set_value(FIRESTONE_GPIO_TP_EN, 0);
-		udelay(50);
-	}
-
-	return 0;
-}
-
-struct cy8c_i2c_platform_data firestone_cy8c_ts_data = {
-	.version = 0x0001,
-	.abs_x_min = 0,
-	.abs_x_max = 479,
-	.abs_y_min = 0,
-	.abs_y_max = 799,
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-	.abs_width_min = 0,
-	.abs_width_max = 10,
-	.power = firestone_cy8c_ts_power,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO("cy8c-tmg-ts", 0x34),
-		.platform_data = &firestone_cy8c_ts_data,
-		.irq = MSM_GPIO_TO_INT(FIRESTONE_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO("microp-i2c", 0xCC >> 1),
-		.platform_data = NULL,
-		.irq = MSM_GPIO_TO_INT(FIRESTONE_GPIO_UP_INT_N),
-	},
-};
-
-static struct platform_device firestone_rfkill = {
-	.name = "firestone_rfkill",
-	.id = -1,
-};
-
-static struct resource msm_kgsl_resources[] = {
-	{
-		.name	= "kgsl_reg_memory",
-		.start	= MSM_GPU_REG_PHYS,
-		.end	= MSM_GPU_REG_PHYS + MSM_GPU_REG_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "kgsl_phys_memory",
-		.start	= MSM_GPU_MEM_BASE,
-		.end	= MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_GRAPHICS,
-		.end	= INT_GRAPHICS,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device msm_kgsl_device = {
-	.name		= "kgsl",
-	.id		= -1,
-	.resource	= msm_kgsl_resources,
-	.num_resources	= ARRAY_SIZE(msm_kgsl_resources),
-};
-
-static struct android_pmem_platform_data mdp_pmem_pdata = {
-	.name		= "pmem",
-	.start		= MSM_PMEM_MDP_BASE,
-	.size		= MSM_PMEM_MDP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu0_pdata = {
-	.name		= "pmem_gpu0",
-	.start		= MSM_PMEM_GPU0_BASE,
-	.size		= MSM_PMEM_GPU0_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu1_pdata = {
-	.name		= "pmem_gpu1",
-	.start		= MSM_PMEM_GPU1_BASE,
-	.size		= MSM_PMEM_GPU1_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct platform_device android_pmem_mdp_device = {
-	.name		= "android_pmem",
-	.id		= 0,
-	.dev		= {
-		.platform_data = &mdp_pmem_pdata
-	},
-};
-
-static struct platform_device android_pmem_gpu0_device = {
-	.name		= "android_pmem",
-	.id		= 2,
-	.dev		= {
-		.platform_data = &android_pmem_gpu0_pdata,
-	},
-};
-
-static struct platform_device android_pmem_gpu1_device = {
-	.name		= "android_pmem",
-	.id		= 3,
-	.dev		= {
-		.platform_data = &android_pmem_gpu1_pdata,
-	},
-};
-
-static struct platform_device *devices[] __initdata = {
-#if !defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	&msm_device_uart1,
-#endif
-#ifdef CONFIG_SERIAL_MSM_HS
-	&msm_device_uart_dm1,
-#endif
-	&firestone_rfkill,
-	&msm_device_smd,
-	&msm_device_i2c,
-	&msm_device_nand,
-	&msm_device_hsusb,
-#ifdef CONFIG_USB_FUNCTION_MASS_STORAGE
-	&usb_mass_storage_device,
-#endif
-#ifdef CONFIG_USB_ANDROID
-	&android_usb_device,
-#endif
-	&android_pmem_mdp_device,
-	&android_pmem_gpu0_device,
-	&android_pmem_gpu1_device,
-	&msm_kgsl_device,
-#ifdef CONFIG_ARCH_QSD8X50
-	&msm_audio_device,
-#endif
-};
-
-extern struct sys_timer msm_timer;
-
-static struct msm_acpu_clock_platform_data firestone_clock_data = {
-	.acpu_switch_time_us	= 20,
-	.max_speed_delta_khz	= 256000,
-	.vdd_switch_time_us	= 62,
-	.power_collapse_khz	= 128000000,
-	.wait_for_irq_khz	= 128000000,
-};
-
-static uint32_t bt_gpio_table[] = {
-	PCOM_GPIO_CFG(FIRESTONE_GPIO_BT_UART1_RTS, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(FIRESTONE_GPIO_BT_UART1_CTS, 2, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(FIRESTONE_GPIO_BT_UART1_RX, 2, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(FIRESTONE_GPIO_BT_UART1_TX, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-
-	PCOM_GPIO_CFG(FIRESTONE_GPIO_BT_RESET_N, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA),
-	PCOM_GPIO_CFG(FIRESTONE_GPIO_BT_SHUTDOWN_N, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA),
-};
-
-void msm_serial_debug_init(unsigned int base, int irq,
-			   struct device *clk_device, int signal_irq);
-
-static void __init firestone_init(void)
-{
-	int rc;
-
-	printk("firestone_init() revision=%d\n", system_rev);
-
-	config_gpio_table(bt_gpio_table, ARRAY_SIZE(bt_gpio_table));
-
-	gpio_direction_output(FIRESTONE_GPIO_TP_LS_EN, 0);
-	gpio_direction_output(FIRESTONE_GPIO_TP_EN, 0);
-
-	msm_acpu_clock_init(&firestone_clock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	msm_serial_debug_init(MSM_UART1_PHYS, INT_UART1,
-			      &msm_device_uart1.dev, 1);
-#endif
-
-	msm_device_hsusb.dev.platform_data = &msm_hsusb_pdata;
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-	msm_hsusb_set_vbus_state(1);
-
-	rc = firestone_init_mmc(system_rev);
-	if (rc)
-		pr_crit("%s: MMC init failure (%d)\n", __func__, rc);
-}
-
-static void __init firestone_fixup(struct machine_desc *desc, struct tag *tags,
-				 char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 1;
-	mi->bank[0].start = PHYS_OFFSET;
-	mi->bank[0].node = PHYS_TO_NID(PHYS_OFFSET);
-	mi->bank[0].size = (101*1024*1024);
-}
-
-static void __init firestone_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-	qsd_audio_device_init();
-}
-
-MACHINE_START(FIRESTONE, "Firestone")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params	= 0x12000100,
-	.fixup		= firestone_fixup,
-	.map_io		= firestone_map_io,
-	.init_irq	= msm_init_irq,
-	.init_machine	= firestone_init,
-	.timer		= &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-firestone.h b/arch/arm/mach-msm/board-firestone.h
deleted file mode 100644
index 5fa6d0c..0000000
--- a/arch/arm/mach-msm/board-firestone.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* arch/arm/mach-msm/board-firestone.h
-
- * Copyright (C) 2009 HTC Corporation.
- * Author: Haley Teng <Haley_Teng@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_FIRESTONE_H
-#define __ARCH_ARM_MACH_MSM_BOARD_FIRESTONE_H
-
-#include <mach/board.h>
-
-#define MSM_SMI_BASE		0x02B00000
-#define MSM_SMI_SIZE		0x01500000
-
-#define MSM_PMEM_MDP_BASE	0x03000000
-#define MSM_PMEM_MDP_SIZE	0x01000000
-
-#define MSM_EBI1_BASE		0x12000000
-#define MSM_EBI1_SIZE		0x0E000000
-
-#define MSM_PMEM_GPU0_BASE	0x1E400000
-#define MSM_PMEM_GPU0_SIZE	0x01000000
-
-#define MSM_PMEM_GPU1_BASE	0x1F400000
-#define MSM_PMEM_GPU1_SIZE	0x00800000
-
-#define MSM_GPU_MEM_BASE	0x1FC00000
-#define MSM_GPU_MEM_SIZE	0x00200000
-
-#define MSM_FB_BASE		0x1FE00000
-#define MSM_FB_SIZE		0x00200000
-
-#define FIRESTONE_GPIO_UP_INT_N		90
-
-#define FIRESTONE_GPIO_TP_ATT_N		92
-#define FIRESTONE_GPIO_TP_LS_EN		93
-#define FIRESTONE_GPIO_TP_EN		160
-
-#define FIRESTONE_GPIO_POWER_KEY	94
-
-#define FIRESTONE_GPIO_SDMC_CD_N	153
-
-/* BT */
-#define FIRESTONE_GPIO_BT_UART1_RTS	43
-#define FIRESTONE_GPIO_BT_UART1_CTS	44
-#define FIRESTONE_GPIO_BT_UART1_RX	45
-#define FIRESTONE_GPIO_BT_UART1_TX	46
-#define FIRESTONE_GPIO_BT_RESET_N	146
-#define FIRESTONE_GPIO_BT_SHUTDOWN_N	128
-
-/*Audio */
-#define FIRESTONE_AUD_JACKHP_EN		157
-#define FIRESTONE_AUD_2V5_EN		158
-#define FIRESTONE_AUD_SPK_EN		-1 /* Not support */
-
-#endif /* __ARCH_ARM_MACH_MSM_BOARD_FIRESTONE_H */
diff --git a/arch/arm/mach-msm/board-hero-keypad.c b/arch/arm/mach-msm/board-hero-keypad.c
deleted file mode 100644
index f65c362..0000000
--- a/arch/arm/mach-msm/board-hero-keypad.c
+++ /dev/null
@@ -1,321 +0,0 @@
-/* linux/arch/arm/mach-msm7201a/board-hero-keypad.c
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <linux/keyreset.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-
-#include "board-hero.h"
-
-static int opt_x_axis_threshold = 1, opt_y_axis_threshold = 1;
-
-struct hero_axis_info {
-	struct gpio_event_axis_info info;
-	uint16_t in_state;
-	uint16_t out_state;
-	uint16_t temp_state;
-};
-
-static bool nav_just_on;
-static int nav_on_jiffies;
-
-static unsigned int hero_col_gpios[] = { 35, 34, 33 };
-static unsigned int hero_row_gpios[] = { 42, 41, 40 };
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(hero_row_gpios) + (row))
-
-static const unsigned short hero_keymap0[ARRAY_SIZE(hero_col_gpios) * ARRAY_SIZE(hero_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_HOME,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 2)] = KEY_RESERVED,
-	//[KEYMAP_INDEX(0, 3)] = KEY_RESERVED, // XA, XB unuse, XC remove
-
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(1, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 2)] = KEY_RESERVED,
-	//[KEYMAP_INDEX(1, 3)] = KEY_RESERVED, // XA, XB unuse, XC remove
-
-	[KEYMAP_INDEX(2, 0)] = KEY_BACK,
-	[KEYMAP_INDEX(2, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(2, 2)] = KEY_RESERVED,
-	//[KEYMAP_INDEX(2, 3)] = KEY_RESERVED, // XA, XB unuse, XC remove
-
-};
-
-static const unsigned short hero_keymap1[ARRAY_SIZE(hero_col_gpios) * ARRAY_SIZE(hero_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_BACK,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 2)] = KEY_SEND,
-	//[KEYMAP_INDEX(0, 3)] = KEY_RESERVED, // XA, XB unuse, XC remove
-
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(1, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 2)] = KEY_RESERVED,
-	//[KEYMAP_INDEX(1, 3)] = KEY_RESERVED, // XA, XB unuse, XC remove
-
-	[KEYMAP_INDEX(2, 0)] = KEY_HOME,
-	[KEYMAP_INDEX(2, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(2, 2)] = KEY_RESERVED,
-	//[KEYMAP_INDEX(2, 3)] = KEY_RESERVED, // XA, XB unuse, XC remove
-};
-
-static const unsigned short hero_keymap2[ARRAY_SIZE(hero_col_gpios) * ARRAY_SIZE(hero_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_SEARCH,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 2)] = KEY_SEND,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(1, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 2)] = KEY_BACK,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_HOME,
-	[KEYMAP_INDEX(2, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(2, 2)] = MATRIX_KEY(1, BTN_MOUSE),
-};
-
-static const unsigned short hero_keymap2_engin3[ARRAY_SIZE(hero_col_gpios) * ARRAY_SIZE(hero_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_BACK,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 2)] = KEY_SEND,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_HOME,
-	[KEYMAP_INDEX(1, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 2)] = KEY_MENU,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_SEARCH,
-	[KEYMAP_INDEX(2, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(2, 2)] = MATRIX_KEY(1, BTN_MOUSE),
-};
-
-static struct gpio_event_matrix_info hero_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = hero_keymap2,
-	.output_gpios = hero_col_gpios,
-	.input_gpios = hero_row_gpios,
-	.noutputs = ARRAY_SIZE(hero_col_gpios),
-	.ninputs = ARRAY_SIZE(hero_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,	
-	.flags = GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_REMOVE_PHANTOM_KEYS |GPIOKPF_PRINT_UNMAPPED_KEYS /*| GPIOKPF_PRINT_MAPPED_KEYS*/
-};
-
-static struct gpio_event_direct_entry hero_keypad_nav_map[] = {
-	{
-		.gpio	= HERO_POWER_KEY,
-		.code	= KEY_END
-	},
-};
-
-static struct gpio_event_input_info hero_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = 0,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = hero_keypad_nav_map,
-	.keymap_size = ARRAY_SIZE(hero_keypad_nav_map)
-};
-
-uint16_t hero_x_axis_map(struct gpio_event_axis_info *info, uint16_t in)
-{
-	struct hero_axis_info *ai =
-			container_of(info, struct hero_axis_info, info);
-	uint16_t out = ai->out_state;
-
-	if (nav_just_on) {
-		if (jiffies == nav_on_jiffies || jiffies == nav_on_jiffies + 1)
-			goto ignore;
-		nav_just_on = 0;
-	}
-	if ((ai->in_state ^ in) & 1)
-		out--;
-	if ((ai->in_state ^ in) & 2)
-		out++;
-	ai->out_state = out;
-ignore:
-	ai->in_state = in;
-	if (ai->out_state - ai->temp_state == opt_x_axis_threshold) {
-		ai->temp_state++;
-		ai->out_state = ai->temp_state;
-	} else if (ai->temp_state - ai->out_state == opt_x_axis_threshold) {
-		ai->temp_state--;
-		ai->out_state = ai->temp_state;
-	} else if (abs(ai->out_state - ai->temp_state) > opt_x_axis_threshold)
-		ai->temp_state = ai->out_state;
-
-	return ai->temp_state;
-}
-
-uint16_t hero_y_axis_map(struct gpio_event_axis_info *info, uint16_t in)
-{
-	struct hero_axis_info *ai =
-			container_of(info, struct hero_axis_info, info);
-	uint16_t out = ai->out_state;
-
-	if (nav_just_on) {
-		if (jiffies == nav_on_jiffies || jiffies == nav_on_jiffies + 1)
-			goto ignore;
-		nav_just_on = 0;
-	}
-	if ((ai->in_state ^ in) & 1)
-		out--;
-	if ((ai->in_state ^ in) & 2)
-		out++;
-	ai->out_state = out;
-ignore:
-	ai->in_state = in;
-	if (ai->out_state - ai->temp_state == opt_y_axis_threshold) {
-		ai->temp_state++;
-		ai->out_state = ai->temp_state;
-	} else if (ai->temp_state - ai->out_state == opt_y_axis_threshold) {
-		ai->temp_state--;
-		ai->out_state = ai->temp_state;
-	} else if (abs(ai->out_state - ai->temp_state) > opt_y_axis_threshold)
-		ai->temp_state = ai->out_state;
-
-	return ai->temp_state;
-}
-
-
-int hero_nav_power(const struct gpio_event_platform_data *pdata, bool on)
-{
-	gpio_set_value(HERO_GPIO_JOGBALL_EN, on);
-	if (on) {
-		nav_just_on = 1;
-		nav_on_jiffies = jiffies;
-	}
-	return 0;
-}
-
-static uint32_t hero_x_axis_gpios[] = {
-	HERO_GPIO_JOGBALL_LEFT_0, HERO_GPIO_JOGBALL_RIGHT_0
-};
-
-static struct hero_axis_info hero_x_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(hero_x_axis_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_X,
-		.decoded_size = 1U << ARRAY_SIZE(hero_x_axis_gpios),
-		.map = hero_x_axis_map,
-		.gpio = hero_x_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION
-			/*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT */,
-		.enable_emc_protect_delay = 1 * NSEC_PER_MSEC,
-	}
-};
-
-static uint32_t hero_y_axis_gpios[] = {
-	HERO_GPIO_JOGBALL_UP_0, HERO_GPIO_JOGBALL_DOWN_0
-};
-
-static struct hero_axis_info hero_y_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(hero_y_axis_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_Y,
-		.decoded_size = 1U << ARRAY_SIZE(hero_y_axis_gpios),
-		.map = hero_y_axis_map,
-		.gpio = hero_y_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION
-			/*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT  */,
-		.enable_emc_protect_delay = 1 * NSEC_PER_MSEC,
-	}
-};
-
-static struct gpio_event_info *hero_input_info[] = {
-	&hero_keypad_matrix_info.info,
-	&hero_keypad_nav_info.info,
-	&hero_x_axis.info.info,
-	&hero_y_axis.info.info,
-};
-
-static struct gpio_event_platform_data hero_keypad_data = {
-	.names = {
-		"hero-keypad",
-		"hero-nav",
-		NULL,
-	},
-	.info = hero_input_info,
-	.info_count = ARRAY_SIZE(hero_input_info),
-	.power = hero_nav_power,
-};
-
-static struct platform_device hero_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &hero_keypad_data,
-	},
-};
-
-module_param_named(x_axis_sens, opt_x_axis_threshold, int,
-						S_IRUGO|S_IWUSR|S_IWGRP);
-module_param_named(y_axis_sens, opt_y_axis_threshold, int,
-						S_IRUGO|S_IWUSR|S_IWGRP);
-
-static int hero_reset_keys_up[] = {
-	BTN_MOUSE,
-	0
-};
-
-static struct keyreset_platform_data hero_reset_keys_pdata = {
-	.keys_up = hero_reset_keys_up,
-	.keys_down = {
-		KEY_SEND,
-		KEY_MENU,
-		KEY_END,
-		0
-	},
-};
-
-static struct platform_device hero_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &hero_reset_keys_pdata,
-};
-
-static int __init hero_init_keypad(void)
-{
-	if (!machine_is_hero())
-		return 0;
-
-	if (system_rev == 0) { /* XA */
-		hero_keypad_matrix_info.keymap = hero_keymap0;
-		hero_reset_keys_pdata.keys_down[0] = KEY_HOME;
-		hero_reset_keys_pdata.keys_down[2] = KEY_POWER;
-	} else
-	if (system_rev == 1) { /* XB */
-		hero_keypad_matrix_info.keymap = hero_keymap1;
-	}
-
-	if (hero_get_engineerid() == 3)
-		hero_keypad_matrix_info.keymap = hero_keymap2_engin3;
-
-	if (platform_device_register(&hero_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	return platform_device_register(&hero_keypad_device);
-}
-
-device_initcall(hero_init_keypad);
diff --git a/arch/arm/mach-msm/board-hero-mmc.c b/arch/arm/mach-msm/board-hero-mmc.c
deleted file mode 100644
index 3b1638f..0000000
--- a/arch/arm/mach-msm/board-hero-mmc.c
+++ /dev/null
@@ -1,359 +0,0 @@
-/* linux/arch/arm/mach-msm7201a/board-hero-mmc.c
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-#include <mach/board_htc.h>
-#include <mach/htc_pwrsink.h>
-
-#include "proc_comm.h"
-#include "board-hero.h"
-
-#define DEBUG_SDSLOT_VDD 1
-
-/* r porting 29 */
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init hero_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_hero.disable_sdcard=", hero_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_27_28,	2800 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t hero_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk("%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		vreg_enable(vreg_sdslot);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-#if DEBUG_SDSLOT_VDD
-			printk("%s: Setting level to %u\n",
-			        __func__, mmc_vdd_table[i].level);
-#endif
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-			return 0;
-		}
-	}
-
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int hero_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(HERO_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define HERO_MMC_VDD	MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
-
-static unsigned int hero_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data hero_sdslot_data = {
-	.ocr_mask	= HERO_MMC_VDD,
-	.status_irq	= MSM_GPIO_TO_INT(HERO_GPIO_SDMC_CD_N),
-	.status		= hero_sdslot_status,
-	.translate_vdd	= hero_sdslot_switchvdd,
-	.slot_type	= &hero_sdslot_type,
-};
-
-
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static struct vreg *vreg_wifi_osc;	/* WIFI 32khz oscilator */
-static int hero_wifi_cd = 0;		/* WIFI virtual 'card detect' status */
-static struct vreg *vreg_wifi_batpa;	/* WIFI main power */
-
-static struct sdio_embedded_func wifi_func = {
-	.f_class 	= SDIO_CLASS_WLAN,
-	.f_maxblksize   = 512,
-};
-
-static struct embedded_sdio_data hero_wifi_emb_data = {
-	.cis	= {
-		.vendor		= 0x104c,
-		.device		= 0x9066,
-		.blksize	= 512,
-		/*.max_dtr	= 24000000,  Max of chip - no worky on Trout */
-		.max_dtr	= 20000000,
-	},
-	.cccr	= {
-		.multi_block	= 0,
-		.low_speed	= 0,
-		.wide_bus	= 1,
-		.high_power	= 0,
-		.high_speed	= 0,
-	},
-	.funcs	= &wifi_func,
-	.num_funcs = 1,
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int hero_wifi_status_register(void (*callback)(int card_present, void *dev_id), void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int hero_wifi_status(struct device *dev)
-{
-	return hero_wifi_cd;
-}
-
-static struct mmc_platform_data hero_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= hero_wifi_status,
-	.register_status_notify	= hero_wifi_status_register,
-	.embedded_sdio		= &hero_wifi_emb_data,
-};
-
-int hero_wifi_set_carddetect(int val)
-{
-	printk("%s: %d\n", __func__, val);
-	hero_wifi_cd = val;
-	if (wifi_status_cb) {
-		wifi_status_cb(val, wifi_status_cb_devid);
-	} else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-
-int hero_wifi_power_state=0;
-int hero_bt_power_state=0;
-
-int hero_wifi_power(int on)
-{
-	int rc;
-
-	printk("%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		vreg_enable(vreg_wifi_batpa);
-		vreg_set_level(vreg_wifi_batpa, 3000);
-		mdelay(50);
-		rc = vreg_enable(vreg_wifi_osc);
-		vreg_set_level(vreg_wifi_osc, 1800);
-		mdelay(50);
-		if (rc)
-			return rc;
-		htc_pwrsink_set(PWRSINK_WIFI, 70);
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-		htc_pwrsink_set(PWRSINK_WIFI, 0);
-	}
-
-	gpio_set_value( HERO_GPIO_WIFI_EN, on);
-	mdelay(100);
-
-	if (!on) {
-		if(!hero_bt_power_state)
-		{
-			vreg_disable(vreg_wifi_osc);
-			vreg_disable(vreg_wifi_batpa);
-		}
-		else
-			printk("WiFi shouldn't disable vreg_wifi_osc. BT is using it!!\n");
-	}
-	hero_wifi_power_state = on;
-	return 0;
-}
-
-/* Eenable VREG_MMC pin to turn on fastclock oscillator : colin */
-int hero_bt_fastclock_power(int on)
-{
-	int rc;
-
-	printk("%s: %d\n", __func__, on);
-
-	if (vreg_wifi_osc) {
-		if (on) {
-			rc = vreg_enable(vreg_wifi_osc);
-			
-			if (rc)
-			{
-				printk("Error turn bt_fastclock_power rc=%d\n",rc);
-				return rc;
-			}
-		} else {
-			if(!hero_wifi_power_state)
-			{
-				vreg_disable(vreg_wifi_osc);
-			}
-		}
-	}
-	hero_bt_power_state = on;
-	return 0;
-}
-EXPORT_SYMBOL(hero_bt_fastclock_power);
-
-static int hero_wifi_reset_state;
-int hero_wifi_reset(int on)
-{
-	printk("%s: %d\n", __func__, on);
-	/* HRRO use power off/on instead wifi reset*/
-	hero_wifi_reset_state = on;
-	//mdelay(50);
-	return 0;
-}
-
-int __init hero_init_mmc(unsigned int sys_rev)
-{
-	wifi_status_cb = NULL;
-
-	vreg_wifi_osc = vreg_get(0, "rftx");
-	if (IS_ERR(vreg_wifi_osc))
-		return PTR_ERR(vreg_wifi_osc);
-	vreg_set_level(vreg_wifi_osc, 1800);
-
-	vreg_wifi_batpa = vreg_get(0, "wlan");
-	if (IS_ERR(vreg_wifi_batpa))
-		return PTR_ERR(vreg_wifi_batpa);
-
-	msm_add_sdcc(1, &hero_wifi_data, 0, 0); /* r porting 29: change func*/
-
-	if (opt_disable_sdcard) {
-		printk(KERN_INFO "%s: SD-Card interface disabled\n", __func__);
-		goto done;
-	}
-
-	sdslot_vreg_enabled = 0;
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-
-	set_irq_wake(MSM_GPIO_TO_INT(HERO_GPIO_SDMC_CD_N), 1);
-
-	msm_add_sdcc(2, &hero_sdslot_data, HERO_GPIO_TO_INT(HERO_GPIO_SDMC_CD_N),
-		IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE); /* r porting 29 */
-
-done:
-	return 0;
-}
-
-
diff --git a/arch/arm/mach-msm/board-hero-panel.c b/arch/arm/mach-msm/board-hero-panel.c
deleted file mode 100644
index 414d362..0000000
--- a/arch/arm/mach-msm/board-hero-panel.c
+++ /dev/null
@@ -1,745 +0,0 @@
-/* linux/arch/arm/mach-msm7201a/board-hero-panel.c
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/leds.h>
-
-#include <asm/io.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-#include <mach/vreg.h>
-#include <mach/board.h>
-#include <mach/board_htc.h>
-#include <mach/pmic.h>
-
-#include "proc_comm.h"
-#include "board-hero.h"
-#include "devices.h"
-
-#if 0
-#define B(s...) printk(s)
-#else
-#define B(s...) do {} while(0)
-#endif
-
-#define SHARP_POWER 1
-
-static struct led_trigger *hero_lcd_backlight;
-static void hero_set_backlight(int on)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	
-	if (on) {
-		/* vsync back porch is about 17 ms */
-		msleep(40);
-		led_trigger_event(hero_lcd_backlight, LED_FULL);
-	} else
-		led_trigger_event(hero_lcd_backlight, LED_OFF);
-}
-
-#define MDDI_CLIENT_CORE_BASE  0x108000
-#define LCD_CONTROL_BLOCK_BASE 0x110000
-#define SPI_BLOCK_BASE         0x120000
-#define I2C_BLOCK_BASE         0x130000
-#define PWM_BLOCK_BASE         0x140000
-#define GPIO_BLOCK_BASE        0x150000
-#define SYSTEM_BLOCK1_BASE     0x160000
-#define SYSTEM_BLOCK2_BASE     0x170000
-
-#define	DPSUS       (MDDI_CLIENT_CORE_BASE|0x24)
-#define	SYSCLKENA   (MDDI_CLIENT_CORE_BASE|0x2C)
-#define	PWM0OFF	    (PWM_BLOCK_BASE|0x1C)
-
-#define	MDDICAP0    (MDDI_CLIENT_CORE_BASE|0x00)
-#define	MDDICAP1    (MDDI_CLIENT_CORE_BASE|0x04)
-#define	MDDICAP2    (MDDI_CLIENT_CORE_BASE|0x08)
-#define	MDDICAP3    (MDDI_CLIENT_CORE_BASE|0x0C)
-#define	MDCAPCHG    (MDDI_CLIENT_CORE_BASE|0x10)
-#define	MDCRCERC    (MDDI_CLIENT_CORE_BASE|0x14)
-#define	TTBUSSEL    (MDDI_CLIENT_CORE_BASE|0x18)
-#define	DPSET0      (MDDI_CLIENT_CORE_BASE|0x1C)
-#define	DPSET1      (MDDI_CLIENT_CORE_BASE|0x20)
-#define	DPSUS       (MDDI_CLIENT_CORE_BASE|0x24)
-#define	DPRUN       (MDDI_CLIENT_CORE_BASE|0x28)
-#define	SYSCKENA    (MDDI_CLIENT_CORE_BASE|0x2C)
-#define	TESTMODE    (MDDI_CLIENT_CORE_BASE|0x30)
-#define	FIFOMONI    (MDDI_CLIENT_CORE_BASE|0x34)
-#define	INTMONI     (MDDI_CLIENT_CORE_BASE|0x38)
-#define	MDIOBIST    (MDDI_CLIENT_CORE_BASE|0x3C)
-#define	MDIOPSET    (MDDI_CLIENT_CORE_BASE|0x40)
-#define	BITMAP0     (MDDI_CLIENT_CORE_BASE|0x44)
-#define	BITMAP1     (MDDI_CLIENT_CORE_BASE|0x48)
-#define	BITMAP2     (MDDI_CLIENT_CORE_BASE|0x4C)
-#define	BITMAP3     (MDDI_CLIENT_CORE_BASE|0x50)
-#define	BITMAP4     (MDDI_CLIENT_CORE_BASE|0x54)
-
-#define	SRST        (LCD_CONTROL_BLOCK_BASE|0x00)
-#define	PORT_ENB    (LCD_CONTROL_BLOCK_BASE|0x04)
-#define	START       (LCD_CONTROL_BLOCK_BASE|0x08)
-#define	PORT        (LCD_CONTROL_BLOCK_BASE|0x0C)
-#define	CMN         (LCD_CONTROL_BLOCK_BASE|0x10)
-#define	GAMMA       (LCD_CONTROL_BLOCK_BASE|0x14)
-#define	INTFLG      (LCD_CONTROL_BLOCK_BASE|0x18)
-#define	INTMSK      (LCD_CONTROL_BLOCK_BASE|0x1C)
-#define	MPLFBUF     (LCD_CONTROL_BLOCK_BASE|0x20)
-#define	HDE_LEFT    (LCD_CONTROL_BLOCK_BASE|0x24)
-#define	VDE_TOP     (LCD_CONTROL_BLOCK_BASE|0x28)
-#define	PXL         (LCD_CONTROL_BLOCK_BASE|0x30)
-#define	HCYCLE      (LCD_CONTROL_BLOCK_BASE|0x34)
-#define	HSW         (LCD_CONTROL_BLOCK_BASE|0x38)
-#define	HDE_START   (LCD_CONTROL_BLOCK_BASE|0x3C)
-#define	HDE_SIZE    (LCD_CONTROL_BLOCK_BASE|0x40)
-#define	VCYCLE      (LCD_CONTROL_BLOCK_BASE|0x44)
-#define	VSW         (LCD_CONTROL_BLOCK_BASE|0x48)
-#define	VDE_START   (LCD_CONTROL_BLOCK_BASE|0x4C)
-#define	VDE_SIZE    (LCD_CONTROL_BLOCK_BASE|0x50)
-#define	WAKEUP      (LCD_CONTROL_BLOCK_BASE|0x54)
-#define	WSYN_DLY    (LCD_CONTROL_BLOCK_BASE|0x58)
-#define	REGENB      (LCD_CONTROL_BLOCK_BASE|0x5C)
-#define	VSYNIF      (LCD_CONTROL_BLOCK_BASE|0x60)
-#define	WRSTB       (LCD_CONTROL_BLOCK_BASE|0x64)
-#define	RDSTB       (LCD_CONTROL_BLOCK_BASE|0x68)
-#define	ASY_DATA    (LCD_CONTROL_BLOCK_BASE|0x6C)
-#define	ASY_DATB    (LCD_CONTROL_BLOCK_BASE|0x70)
-#define	ASY_DATC    (LCD_CONTROL_BLOCK_BASE|0x74)
-#define	ASY_DATD    (LCD_CONTROL_BLOCK_BASE|0x78)
-#define	ASY_DATE    (LCD_CONTROL_BLOCK_BASE|0x7C)
-#define	ASY_DATF    (LCD_CONTROL_BLOCK_BASE|0x80)
-#define	ASY_DATG    (LCD_CONTROL_BLOCK_BASE|0x84)
-#define	ASY_DATH    (LCD_CONTROL_BLOCK_BASE|0x88)
-#define	ASY_CMDSET  (LCD_CONTROL_BLOCK_BASE|0x8C)
-
-#define	SSICTL      (SPI_BLOCK_BASE|0x00)
-#define	SSITIME     (SPI_BLOCK_BASE|0x04)
-#define	SSITX       (SPI_BLOCK_BASE|0x08)
-#define	SSIRX       (SPI_BLOCK_BASE|0x0C)
-#define	SSIINTC     (SPI_BLOCK_BASE|0x10)
-#define	SSIINTS     (SPI_BLOCK_BASE|0x14)
-#define	SSIDBG1     (SPI_BLOCK_BASE|0x18)
-#define	SSIDBG2     (SPI_BLOCK_BASE|0x1C)
-#define	SSIID       (SPI_BLOCK_BASE|0x20)
-
-#define	WKREQ       (SYSTEM_BLOCK1_BASE|0x00)
-#define	CLKENB      (SYSTEM_BLOCK1_BASE|0x04)
-#define	DRAMPWR     (SYSTEM_BLOCK1_BASE|0x08)
-#define	INTMASK     (SYSTEM_BLOCK1_BASE|0x0C)
-#define	GPIOSEL     (SYSTEM_BLOCK2_BASE|0x00)
-
-#define	GPIODATA    (GPIO_BLOCK_BASE|0x00)
-#define	GPIODIR     (GPIO_BLOCK_BASE|0x04)
-#define	GPIOIS      (GPIO_BLOCK_BASE|0x08)
-#define	GPIOIBE     (GPIO_BLOCK_BASE|0x0C)
-#define	GPIOIEV     (GPIO_BLOCK_BASE|0x10)
-#define	GPIOIE      (GPIO_BLOCK_BASE|0x14)
-#define	GPIORIS     (GPIO_BLOCK_BASE|0x18)
-#define	GPIOMIS     (GPIO_BLOCK_BASE|0x1C)
-#define	GPIOIC      (GPIO_BLOCK_BASE|0x20)
-#define	GPIOOMS     (GPIO_BLOCK_BASE|0x24)
-#define	GPIOPC      (GPIO_BLOCK_BASE|0x28)
-#define	GPIOID      (GPIO_BLOCK_BASE|0x30)
-
-#define SPI_WRITE(reg, val) \
-	{ SSITX,        0x00010000 | (((reg) & 0xff) << 8) | ((val) & 0xff) }, \
-	{ 0, 5 },
-
-#define SPI_WRITE1(reg) \
-	{ SSITX,        (reg) & 0xff }, \
-	{ 0, 5 },
-
-struct mddi_table {
-	uint32_t reg;
-	uint32_t value;
-};
-static struct mddi_table mddi_toshiba_init_table[] = {
-	{ DPSET0,       0x09e90046 },
-	{ DPSET1,       0x00000118 },
-	{ DPSUS,        0x00000000 },
-	{ DPRUN,        0x00000001 },
-	{ 1,            14         }, /* msleep 14 */
-	{ SYSCKENA,     0x00000001 },
-	//{ CLKENB,       0x000000EF },
-	{ CLKENB,       0x0000A1EF },  /*    # SYS.CLKENB  # Enable clocks for each module (without DCLK , i2cCLK) */
-	//{ CLKENB,       0x000025CB }, /* Clock enable register */
-
-	{ GPIODATA,     0x02000200 },  /*   # GPI .GPIODATA  # GPIO2(RESET_LCD_N) set to 0 , GPIO3(eDRAM_Power) set to 0 */
-	{ GPIODIR,      0x000030D  },  /* 24D   # GPI .GPIODIR  # Select direction of GPIO port (0,2,3,6,9 output) */
-	{ GPIOSEL,      0/*0x00000173*/},  /*   # SYS.GPIOSEL  # GPIO port multiplexing control */
-	{ GPIOPC,       0x03C300C0 },  /*   # GPI .GPIOPC  # GPIO2,3 PD cut */
-	{ WKREQ,        0x00000000 },  /*   # SYS.WKREQ  # Wake-up request event is VSYNC alignment */
-
-	{ GPIOIBE,      0x000003FF },
-	{ GPIOIS,       0x00000000 },
-	{ GPIOIC,       0x000003FF },
-	{ GPIOIE,       0x00000000 },
-
-	{ GPIODATA,     0x00040004 },  /*   # GPI .GPIODATA  # eDRAM VD supply */
-	{ 1,            1          }, /* msleep 1 */
-	{ GPIODATA,     0x02040004 },  /*   # GPI .GPIODATA  # eDRAM VD supply */
-	{ DRAMPWR,      0x00000001 }, /* eDRAM power */
-};
-
-static struct mddi_table mddi_toshiba_panel_init_table[] = {
-	{ SRST,         0x00000003 }, /* FIFO/LCDC not reset */
-	{ PORT_ENB,     0x00000001 }, /* Enable sync. Port */
-	{ START,        0x00000000 }, /* To stop operation */
-	//{ START,        0x00000001 }, /* To start operation */
-	{ PORT,         0x00000004 }, /* Polarity of VS/HS/DE. */
-	{ CMN,          0x00000000 },
-	{ GAMMA,        0x00000000 }, /* No Gamma correction */
-	{ INTFLG,       0x00000000 }, /* VSYNC interrupt flag clear/status */
-	{ INTMSK,       0x00000000 }, /* VSYNC interrupt mask is off. */
-	{ MPLFBUF,      0x00000000 }, /* Select frame buffer's base address. */
-	{ HDE_LEFT,     0x00000000 }, /* The value of HDE_LEFT. */
-	{ VDE_TOP,      0x00000000 }, /* The value of VDE_TPO. */
-	{ PXL,          0x00000001 }, /* 1. RGB666 */
-	                              /* 2. Data is valid from 1st frame of beginning. */
-	{ HDE_START,    0x00000006 }, /* HDE_START= 14 PCLK */
-	{ HDE_SIZE,     0x0000009F }, /* HDE_SIZE=320 PCLK */
-	{ HSW,          0x00000004 }, /* HSW= 10 PCLK */
-	{ VSW,          0x00000001 }, /* VSW=2 HCYCLE */
-	{ VDE_START,    0x00000003 }, /* VDE_START=4 HCYCLE */
-	{ VDE_SIZE,     0x000001DF }, /* VDE_SIZE=480 HCYCLE */
-	{ WAKEUP,       0x000001e2 }, /* Wakeup position in VSYNC mode. */
-	{ WSYN_DLY,     0x00000000 }, /* Wakeup position in VSIN mode. */
-	{ REGENB,       0x00000001 }, /* Set 1 to enable to change the value of registers. */
-	{ CLKENB,       0x000025CB }, /* Clock enable register */
-
-	{ SSICTL,       0x00000170 }, /* SSI control register */
-	{ SSITIME,      0x00000250 }, /* SSI timing control register */
-	{ SSICTL,       0x00000172 }, /* SSI control register */
-};
-
-
-static struct mddi_table mddi_sharp_init_table[] = {
-	{ VCYCLE,       0x000001eb },
-	{ HCYCLE,       0x000000ae },
-	{ REGENB,       0x00000001 }, /* Set 1 to enable to change the value of registers. */
-	{ GPIODATA,     0x00040000 }, /* GPIO2 low */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ 1,            1          }, /* msleep 1 */
-	{ GPIODATA,     0x00040004 }, /* GPIO2 high */
-	{ 1,            10         }, /* msleep 10 */
-	SPI_WRITE(0x5f, 0x01)
-	SPI_WRITE1(0x11)
-	{ 1,            200        }, /* msleep 200 */
-	SPI_WRITE1(0x29)
-	SPI_WRITE1(0xde)
-	{ START,        0x00000001 }, /* To start operation */
-};
-
-static struct mddi_table mddi_sharp_deinit_table[] = {
-	{ 1,            200        }, /* msleep 200 */
-	SPI_WRITE(0x10, 0x1)
-	{ 1,            100        }, /* msleep 100 */
-	{ GPIODATA,     0x00040004 }, /* GPIO2 high */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ GPIODATA,     0x00040000 }, /* GPIO2 low */
-	{ 1,            10         }, /* msleep 10 */
-};
-
-static struct mddi_table mddi_tpo_init_table[] = {
-	{ VCYCLE,       0x000001e5 },
-	{ HCYCLE,       0x000000ac },
-	{ REGENB,       0x00000001 }, /* Set 1 to enable to change the value of registers. */
-	{ 0,            20         }, /* udelay 20 */
-	{ GPIODATA,     0x00000004 }, /* GPIO2 high */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ 0,            20         }, /* udelay 20 */
-
-	SPI_WRITE(0x08, 0x01)
-	{ 0,            500        }, /* udelay 500 */
-	SPI_WRITE(0x08, 0x00)
-	SPI_WRITE(0x02, 0x00)
-	SPI_WRITE(0x03, 0x04)
-	SPI_WRITE(0x04, 0x0e)
-	SPI_WRITE(0x09, 0x02)
-	SPI_WRITE(0x0b, 0x08)
-	SPI_WRITE(0x0c, 0x53)
-	SPI_WRITE(0x0d, 0x01)
-	SPI_WRITE(0x0e, 0xe0)
-	SPI_WRITE(0x0f, 0x01)
-	SPI_WRITE(0x10, 0x58)
-	SPI_WRITE(0x20, 0x1e)
-	SPI_WRITE(0x21, 0x0a)
-	SPI_WRITE(0x22, 0x0a)
-	SPI_WRITE(0x23, 0x1e)
-	SPI_WRITE(0x25, 0x32)
-	SPI_WRITE(0x26, 0x00)
-	SPI_WRITE(0x27, 0xac)
-	SPI_WRITE(0x29, 0x06)
-	SPI_WRITE(0x2a, 0xa4)
-	SPI_WRITE(0x2b, 0x45)
-	SPI_WRITE(0x2c, 0x45)
-	SPI_WRITE(0x2d, 0x15)
-	SPI_WRITE(0x2e, 0x5a)
-	SPI_WRITE(0x2f, 0xff)
-	SPI_WRITE(0x30, 0x6b)
-	SPI_WRITE(0x31, 0x0d)
-	SPI_WRITE(0x32, 0x48)
-	SPI_WRITE(0x33, 0x82)
-	SPI_WRITE(0x34, 0xbd)
-	SPI_WRITE(0x35, 0xe7)
-	SPI_WRITE(0x36, 0x18)
-	SPI_WRITE(0x37, 0x94)
-	SPI_WRITE(0x38, 0x01)
-	SPI_WRITE(0x39, 0x5d)
-	SPI_WRITE(0x3a, 0xae)
-	SPI_WRITE(0x3b, 0xff)
-	SPI_WRITE(0x07, 0x09)
-	{ 0,            10         }, /* udelay 10 */
-	{ START,        0x00000001 }, /* To start operation */
-};
-
-static struct mddi_table mddi_tpo_deinit_table[] = {
-	SPI_WRITE(0x07, 0x19)
-	{ START,        0x00000000 }, /* To stop operation */
-	{ GPIODATA,     0x00040004 }, /* GPIO2 high */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ GPIODATA,     0x00040000 }, /* GPIO2 low */
-	{ 0,            5        }, /* usleep 5 */
-};
-
-
-#define GPIOSEL_VWAKEINT (1U << 0)
-#define INTMASK_VWAKEOUT (1U << 0)
-
-static void hero_process_mddi_table(struct msm_mddi_client_data *client_data,
-				     struct mddi_table *table, size_t count)
-{
-	int i;
-	for(i = 0; i < count; i++) {
-		uint32_t reg = table[i].reg;
-		uint32_t value = table[i].value;
-
-		if (reg == 0)
-			udelay(value);
-		else if (reg == 1)
-			msleep(value);
-		else
-			client_data->remote_write(client_data, value, reg);
-	}
-}
-
-static struct vreg *vreg_lcm_2v6;
-static struct vreg *vreg_lcm_2v85;
-
-#define GP_NS_REG (0x005c)
-#define LCD_RSTz_ID1 58
-
-static void 
-hero_mddi_eid_power(struct msm_mddi_client_data *client_data, int on)
-{
-	unsigned id, on_off = 1;
-
-	B(KERN_DEBUG "%s: power %s.\n", __func__, on ? "on" : "off");
-	if (on) {
-		on_off = 0;
-		/* 2V6(pmic gp4) */
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v6);
-		mdelay(1);
-
-		/* 2V8(pmic rfrx2) */
-		id = PM_VREG_PDOWN_RFRX2_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v85);
-		mdelay(2);
-
-		gpio_set_value(LCD_RSTz_ID1, 1);
-		mdelay(15);
-	} else {
-		on_off = 1;
-		mdelay(5);
-		gpio_set_value(LCD_RSTz_ID1, 0);
-		mdelay(3);
-
-		/* 2V8(pmic rfrx2) */
-		id = PM_VREG_PDOWN_RFRX2_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_disable(vreg_lcm_2v85);
-		mdelay(1);
-
-		/* 2V6(pmic gp4) */
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_disable(vreg_lcm_2v6);
-	}
-}
-
-static void 
-hero_mddi_sharp_power(struct msm_mddi_client_data *client_data, int on)
-{
-#if SHARP_POWER 	
-	unsigned id, on_off;
-
-	if(on) {
-		writel(0xa06, MSM_CLK_CTL_BASE + GP_NS_REG);
-		on_off = 0;
-		/* 1V5 */
-		gpio_set_value(HERO_GPIO_MDDI_1V5_EN, 1);
-		msleep(5);
-		/* 2V6(pmic gp4), 1V8 */
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v6);
-		gpio_set_value(HERO_GPIO_MDDI_1V8_EN, 1);
-		msleep(5);
-		/* 2V85(pmic rfrx2) */
-		id = PM_VREG_PDOWN_RFRX2_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v85);
-		msleep(1);
-		gpio_set_value(HERO_GPIO_MDDI_RST_N, 1);
-		msleep(10);
-	} else {
-		writel(0x006, MSM_CLK_CTL_BASE + GP_NS_REG);
-		on_off = 1;
-		gpio_set_value(HERO_GPIO_MDDI_RST_N, 0);
-		msleep(10);
-		/* 2V85(pmic rfrx2) */
-		id = PM_VREG_PDOWN_RFRX2_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v85);
-		msleep(5);
-		/* 2V6(pmic gp4), 1V8 */
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v6);
-		gpio_set_value(HERO_GPIO_MDDI_1V8_EN, 0);
-		msleep(200);
-		gpio_set_value(HERO_GPIO_MDDI_1V5_EN, 0);
-	}
-#endif	
-}
-
-enum {
-	PANEL_SHARP,
-	PANEL_SAMSUNG,
-	PANEL_EID_40pin,
-	PANEL_EID_24pin,
-	PANEL_HEROC_EID_BOTTOM,
-	PANEL_TPO,
-	PANEL_HEROC_TPO,
-	PANEL_ESPRESSO_TPO,
-	PANEL_ESPRESSO_SHARP,
-	PANEL_LIBERTY_TPO,
-	PANEL_LIBERTY_EID_24pin,
-	PANEL_EIDII,
-	PANEL_UNKNOWN,
-};
-
-static int hero_panel_detect(void)
-{
-	return panel_type;
-}
-
-static int mddi_toshiba_client_init(
-		struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-#if SHARP_POWER	
-	int panel_id;
-
-	client_data->auto_hibernate(client_data, 0);
-	hero_process_mddi_table(client_data, mddi_toshiba_init_table,
-				 ARRAY_SIZE(mddi_toshiba_init_table));
-	client_data->auto_hibernate(client_data, 1);
-	panel_id = (client_data->remote_read(client_data, GPIODATA) >> 4) & 3;
-	if (panel_id > 1) {
-		printk("unknown panel id at mddi_enable\n");
-		return -1;
-	}
-#endif	
-	return 0;
-}
-
-static int 
-mddi_toshiba_client_uninit(struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *cdata)
-{
-	return 0;
-}
-
-static int 
-hero_panel_unblank(struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	hero_set_backlight(1);
-	return 0;
-}
-
-static int 
-hero_panel_blank(struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	hero_set_backlight(0);
-	return 0;
-}
-
-static int 
-panel_sharp_unblank(struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-#if SHARP_POWER       
-	int panel_id, ret = 0;
-
-	hero_set_backlight(0);
-	client_data->auto_hibernate(client_data, 0);
-	hero_process_mddi_table(client_data, mddi_toshiba_panel_init_table,
-		ARRAY_SIZE(mddi_toshiba_panel_init_table));
-	panel_id = (client_data->remote_read(client_data, GPIODATA) >> 4) & 3;
-	switch(panel_id) {
-	 case 0:
-		B("init sharp panel\n");
-		hero_process_mddi_table(client_data,
-					 mddi_sharp_init_table,
-					 ARRAY_SIZE(mddi_sharp_init_table));
-		break;
-	case 1:
-		B("init tpo panel\n");
-		hero_process_mddi_table(client_data,
-					 mddi_tpo_init_table,
-					 ARRAY_SIZE(mddi_tpo_init_table));
-		break;
-	default:
-		B("unknown panel_id: %d\n", panel_id);
-		ret = -1;
-	};
-	hero_set_backlight(1);
-	client_data->auto_hibernate(client_data, 1);
-	// reenable vsync
-	client_data->remote_write(client_data, GPIOSEL_VWAKEINT,
-				  GPIOSEL);
-	client_data->remote_write(client_data, INTMASK_VWAKEOUT,
-				  INTMASK);
-	return ret;
-#else
-	return 0;
-#endif
-}
-
-static int 
-panel_sharp_blank(struct msm_mddi_bridge_platform_data *bridge,
-		struct msm_mddi_client_data *client_data)
-{
-#if SHARP_POWER	
-	int panel_id, ret = 0;
-
-	panel_id = (client_data->remote_read(client_data, GPIODATA) >> 4) & 3;
-	client_data->auto_hibernate(client_data, 0);
-	switch(panel_id) {
-	case 0:
-		B("deinit sharp panel\n");
-		hero_process_mddi_table(client_data,
-					 mddi_sharp_deinit_table,
-					 ARRAY_SIZE(mddi_sharp_deinit_table));
-		break;
-	case 1:
-		B("deinit tpo panel\n");
-		hero_process_mddi_table(client_data,
-					 mddi_tpo_deinit_table,
-					 ARRAY_SIZE(mddi_tpo_deinit_table));
-		break;
-	default:
-		B("unknown panel_id: %d\n", panel_id);
-		ret = -1;
-	};
-	client_data->auto_hibernate(client_data,1);
-	hero_set_backlight(0);
-	client_data->remote_write(client_data, 0, SYSCLKENA);
-	client_data->remote_write(client_data, 1, DPSUS);
-
-	return ret;
-#else
-	return 0;
-#endif
-}
-
-
-static void panel_eid_fixup(uint16_t *mfr_name, uint16_t *product_code)
-{
-	B("%s: enter.\n", __func__);
-	*mfr_name = 0x0101;
-	*product_code= 0x0;
-}
-
-static int config_vsync(void)
-{
-	int ret;
-	uint32_t config;
-
-	ret = gpio_request(HERO_GPIO_VSYNC, "vsync");
-	if (ret)
-		return ret;
-
-	config = PCOM_GPIO_CFG(HERO_GPIO_VSYNC, 1, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA);
-	ret = msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &config, 0);
-	if (ret)
-		gpio_free(HERO_GPIO_VSYNC);
-	return ret;
-}
-
-static struct msm_mddi_bridge_platform_data toshiba_client_data = {
-	.init = mddi_toshiba_client_init,
-	.uninit = mddi_toshiba_client_uninit,
-	.blank = panel_sharp_blank,
-	.unblank = panel_sharp_unblank,
-	.fb_data = {
-		.xres = 320,
-		.yres = 480,
-		.width = 45,
-		.height = 68,
-		.output_format = 0,
-	},
-};
-
-static u8 pwm_eid[] = {8, 16, 34, 61, 96, 138, 167, 195, 227, 255};
-static struct msm_mddi_bridge_platform_data eid_client_data = {
-	.blank = hero_panel_blank,
-	.unblank = hero_panel_unblank,
-	.fb_data = {
-		.xres = 320,
-		.yres = 480,
-		.width = 45,
-		.height = 68,
-		.output_format = 0,
-	},
-	.panel_conf = {
-		.panel_id = PANEL_EID_24pin,
-		.caps = 0x0,
-		.pwm = pwm_eid,
-	},
-};
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct msm_mddi_platform_data hero_pdata = {
-	.clk_rate = 122880000,
-	.power_client = hero_mddi_sharp_power,
-	.fixup = panel_eid_fixup,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 2,
-	.client_platform_data = {
-		{
-			.product_id = (0xd263 << 16 | 0),
-			.name = "mddi_c_d263_0000",
-			.id = 0,
-			.client_data = &toshiba_client_data,
-			.clk_rate = 0,
-		},
-		{
-			.product_id = (0x0101 << 16 | 0),
-			.name = "mddi_c_0101_0000",
-			.id = 1,
-			.client_data = &eid_client_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-/*
- * In boot loader, mddi is powered on already.
- * So, we just detect panel here, setting different power function for each panel.
- * Then we did not have to detect panel in each time mddi_client_power or panel_power
- * is called.
- *
- * jay: Nov 20, 08'
- */
-int __init hero_init_panel(void)
-{
-	int panel, rc;
-	struct panel_data *panel_data = &eid_client_data.panel_conf;
-
-	if(!machine_is_hero())
-		return -1;
-	
-	B(KERN_INFO "%s: enter.\n", __func__);
-
-	vreg_lcm_2v6 = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_lcm_2v6))
-		return PTR_ERR(vreg_lcm_2v6);
-
-	vreg_lcm_2v85 = vreg_get(0, "rfrx2");
-	if (IS_ERR(vreg_lcm_2v85))
-		return PTR_ERR(vreg_lcm_2v85);
-
-	panel = hero_panel_detect();
-
-	if (panel == PANEL_SHARP) {
-		printk(KERN_INFO "%s: init sharp panel\n", __func__);
-		hero_pdata.power_client = hero_mddi_sharp_power;
-	} else if ((panel == PANEL_EID_24pin) ||
-			(panel == PANEL_EID_40pin) ||
-			(panel == PANEL_EIDII) ||
-			(panel == PANEL_SAMSUNG)) {
-		if (panel != PANEL_SAMSUNG)
-			printk(KERN_INFO "init EID panel\n");
-		else
-			printk(KERN_INFO "init Samsung panel\n");
-		hero_pdata.power_client = hero_mddi_eid_power;
-		panel_data->panel_id = panel;
-
-		/* Hero enable CABC criteria:
-		 * engineer id > 0, board > XC */
-		if (engineer_id || system_rev > 2) {
-			panel_data->caps |= MSMFB_CAP_CABC;
-		} else {
-			printk(KERN_DEBUG "CABC will not work on older board, "
-					"engineer_id = %d\n", engineer_id);
-		}
-	} else {
-		printk(KERN_ERR "unknown panel type!\n");
-		return -EIO;
-	}
-
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-
-	rc = config_vsync();
-	if (rc)
-		return rc;
-
-	msm_device_mddi0.dev.platform_data = &hero_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-	
-	led_trigger_register_simple("lcd-backlight-gate", &hero_lcd_backlight);
-	if (IS_ERR(hero_lcd_backlight))
-		printk(KERN_ERR "%s: backlight registration failed!\n", __func__);
-
-	return 0;
-}
-device_initcall(hero_init_panel);
-
diff --git a/arch/arm/mach-msm/board-hero-rfkill.c b/arch/arm/mach-msm/board-hero-rfkill.c
deleted file mode 100644
index 38b9260..0000000
--- a/arch/arm/mach-msm/board-hero-rfkill.c
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
-*/
-
-/* Control bluetooth power for hero platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-hero.h"
-
-extern int hero_bt_fastclock_power(int on);
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "brf6350";
-
-static int hero_bt_status;
-
-static uint32_t hero_bt_init_table[] = {
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_RTS, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_RTS */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_CTS, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_CTS */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_RX, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),		/* BT_RX */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_TX, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_TX */
-	
-	PCOM_GPIO_CFG(HERO_GPIO_WB_SHUT_DOWN_N, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_8MA),		/* BT_ENABLE */
-};
-
-static uint32_t hero_bt_on_table[] = {
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_RTS, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_RTS */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_CTS, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_CTS */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_RX, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),		/* BT_RX */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_TX, 3, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_TX */
-	
-	PCOM_GPIO_CFG(HERO_GPIO_WB_SHUT_DOWN_N, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_8MA),		/* BT_ENABLE */
-};
-
-static uint32_t hero_bt_off_table[] = {
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_RTS, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_RTS */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_CTS, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_CTS */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_RX, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),		/* BT_RX */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_TX, 3, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_TX */
-	
-	PCOM_GPIO_CFG(HERO_GPIO_WB_SHUT_DOWN_N, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_8MA),		/* BT_ENABLE */
-};
-
-static uint32_t hero_bt_disable_active_table[] = {
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_RTS, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_RTS */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_CTS, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_CTS */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_RX, 2, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),		/* BT_RX */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_TX, 3, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_TX */
-};
-
-static uint32_t hero_bt_disable_sleep_table[] = {
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_RTS, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* O(L) */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_CTS, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* I(PU) */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_RX, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),		/* I(PU) */
-	PCOM_GPIO_CFG(HERO_GPIO_UART1_TX, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* O(H) */
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for(n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void hero_config_bt_init(void)
-{
-	hero_bt_status = 0;
-	config_bt_table(hero_bt_init_table, ARRAY_SIZE(hero_bt_init_table));
-	mdelay(5);
-	gpio_configure(HERO_GPIO_WB_SHUT_DOWN_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static void hero_config_bt_on(void)
-{
-	config_bt_table(hero_bt_on_table, ARRAY_SIZE(hero_bt_on_table));
-	mdelay(2);
-
-	gpio_configure(HERO_GPIO_WB_SHUT_DOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(15);
-	gpio_configure(HERO_GPIO_WB_SHUT_DOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(1);
-	gpio_configure(HERO_GPIO_WB_SHUT_DOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(1);
-
-	hero_bt_fastclock_power(1);
-	mdelay(2);
-	hero_bt_status = 1;
-}
-
-static void hero_config_bt_off(void)
-{
-	gpio_configure(HERO_GPIO_WB_SHUT_DOWN_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	hero_bt_fastclock_power(0);
-	config_bt_table(hero_bt_off_table, ARRAY_SIZE(hero_bt_off_table));
-	mdelay(5);
-	hero_bt_status = 0;
-}
-
-void hero_config_bt_disable_active(void)
-{	
-	config_bt_table(hero_bt_disable_active_table, ARRAY_SIZE(hero_bt_disable_active_table));
-}
-
-void hero_config_bt_disable_sleep(void)
-{
-	config_bt_table(hero_bt_disable_sleep_table, ARRAY_SIZE(hero_bt_disable_sleep_table));
-	mdelay(5);
-	gpio_configure(HERO_GPIO_UART1_RTS, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);	/* O(L) */
-	gpio_configure(HERO_GPIO_UART1_TX, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);	/* O(H) */
-}
-
-int hero_is_bluetooth_off(void)
-{
-	return !hero_bt_status;	//ON:1, OFF:0
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-			hero_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-			hero_config_bt_off();
-		break;
-	default:
-		printk(KERN_ERR "bad bluetooth rfkill state %d\n", state);
-	}
-	return 0;
-}
-
-static int __init hero_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;  /* off */
-
-	hero_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;  // user data
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-
-	if (rc)
-		rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int hero_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver hero_rfkill_driver = {
-	.probe = hero_rfkill_probe,
-	.remove = hero_rfkill_remove,
-	.driver = {
-		.name = "hero_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init hero_rfkill_init(void)
-{
-	if (!machine_is_hero())
-		return 0;
-	return platform_driver_register(&hero_rfkill_driver);
-}
-
-static void __exit hero_rfkill_exit(void)
-{
-	platform_driver_unregister(&hero_rfkill_driver);
-}
-
-module_init(hero_rfkill_init);
-module_exit(hero_rfkill_exit);
-MODULE_DESCRIPTION("hero rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-hero-wifi.c b/arch/arm/mach-msm/board-hero-wifi.c
deleted file mode 100644
index d96741b..0000000
--- a/arch/arm/mach-msm/board-hero-wifi.c
+++ /dev/null
@@ -1,104 +0,0 @@
-/* arch/arm/mach-msm/board-hero-wifi.c
- *
- * Copyright (C) 2008 Google, Inc.
- * Author: Dmitry Shmidt <dimitrysh@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/vmalloc.h>
-#include <linux/err.h>
-#include <linux/wifi_tiwlan.h>
-
-extern int hero_wifi_set_carddetect(int val);
-extern int hero_wifi_power(int on);
-extern int hero_wifi_reset(int on);
-
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[WMPA_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WMPA_SECTION_SIZE_0 + WMPA_SECTION_HEADER) },
-	{ NULL, (WMPA_SECTION_SIZE_1 + WMPA_SECTION_HEADER) },
-	{ NULL, (WMPA_SECTION_SIZE_2 + WMPA_SECTION_HEADER) }
-};
-
-static void *hero_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if ((section < 0) || (section >= WMPA_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init hero_init_wifi_mem (void)
-{
-	int i;
-
-	for (i = 0; (i < WMPA_NUMBER_OF_SECTIONS); i++) {
-		wifi_mem_array[i].mem_ptr = vmalloc(wifi_mem_array[i].size);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-#endif
-
-struct wifi_platform_data hero_wifi_control = {
-	.set_power		= hero_wifi_power,
-	.set_reset		= hero_wifi_reset,
-	.set_carddetect		= hero_wifi_set_carddetect,
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-	.mem_prealloc		= hero_wifi_mem_prealloc,
-#else
-	.mem_prealloc		= NULL,
-#endif
-};
-
-static struct platform_device wifi_ctrl_dev = {
-	.name		= "msm_wifi",
-	.id		= 1,
-	.num_resources	= 0,
-	.resource	= NULL,
-	.dev		= {
-		.platform_data = &hero_wifi_control,
-	},
-};
-
-static int __init hero_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_hero())
-		return 0;
-
-	printk("%s: start\n", __func__);
-
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-	hero_init_wifi_mem();
-#endif
-
-	ret = platform_device_register(&wifi_ctrl_dev);
-	return ret;
-}
-
-
-late_initcall(hero_wifi_init);
-#endif
-
diff --git a/arch/arm/mach-msm/board-hero.c b/arch/arm/mach-msm/board-hero.c
deleted file mode 100644
index 94a4145..0000000
--- a/arch/arm/mach-msm/board-hero.c
+++ /dev/null
@@ -1,1257 +0,0 @@
-/* linux/arch/arm/mach-msm7201a/board-hero.c
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/irq.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <linux/sysdev.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/setup.h>
-
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-#include <linux/mmc/sdio_ids.h>
-
-#include <mach/system.h>
-#include <mach/vreg.h>
-#include <mach/hardware.h>
-#include <mach/board_htc.h>
-#include <mach/msm_serial_hs.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/msm_fb.h>
-#include <mach/h2w_v1.h>
-#include <mach/microp_i2c.h>
-#include <mach/htc_battery.h>
-#include <mach/htc_pwrsink.h>
-#include <mach/perflock.h>
-#include <mach/drv_callback.h>
-#include <mach/cy8c_i2c.h>
-#include <mach/htc_battery.h>
-#include <mach/msm_hsusb.h>
-
-#include "proc_comm.h"
-#include "devices.h"
-#include "board-hero.h"
-static unsigned int hwid = 0;
-static unsigned int skuid = 0;
-static unsigned int engineerid = 0;
-
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-/*	.gpio_mbat_in = HERO_GPIO_MBAT_IN,*/
-/*	.gpio_mchg_en_n = HERO_GPIO_MCHG_EN_N,*/
-/*	.gpio_iset = HERO_GPIO_ISET,*/
-	.guage_driver = GUAGE_MODEM,
-	.charger = LINEAR_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-
-unsigned int hero_get_hwid(void)
-{
-	return hwid;
-}
-
-unsigned int hero_get_skuid(void)
-{
-	return skuid;
-}
-
-unsigned hero_get_engineerid(void)
-{
-	return engineerid;
-}
-
-static int hero_ts_power(int on)
-{
-	printk(KERN_INFO "hero_ts_power:%d\n", on);
-	if (on) {
-		gpio_set_value(HERO_GPIO_TP_EN, 1);
-		msleep(250);
-		/* enable touch panel level shift */
-		gpio_set_value(HERO_TP_LS_EN, 1);
-		msleep(2);
-	} else {
-		gpio_set_value(HERO_TP_LS_EN, 0);
-		udelay(50);
-		gpio_set_value(HERO_GPIO_TP_EN, 0);
-	}
-	return 0;
-}
-
-static struct cy8c_i2c_platform_data hero_cypress_ts_data = {
-	.version = 0x0001,
-	.abs_x_min = 0,
-	.abs_x_max = 319,
-	.abs_y_min = 0,
-	.abs_y_max = 479,
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-	.abs_width_min = 0,
-	.abs_width_max = 15,
-	.power = hero_ts_power,
-};
-
-static struct synaptics_i2c_rmi_platform_data hero_ts_data[] = {
-	{
-		.version = 0x0101,
-		.power = hero_ts_power,
-		.sensitivity_adjust = 7,
-		.flags = SYNAPTICS_FLIP_Y | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = -50 * 0x10000 / 4334,
-		.inactive_right = -50 * 0x10000 / 4334,
-		.inactive_top = -40 * 0x10000 / 6696,
-		.inactive_bottom = -40 * 0x10000 / 6696,
-		.snap_left_on = 50 * 0x10000 / 4334,
-		.snap_left_off = 60 * 0x10000 / 4334,
-		.snap_right_on = 50 * 0x10000 / 4334,
-		.snap_right_off = 60 * 0x10000 / 4334,
-		.snap_top_on = 100 * 0x10000 / 6696,
-		.snap_top_off = 110 * 0x10000 / 6696,
-		.snap_bottom_on = 100 * 0x10000 / 6696,
-		.snap_bottom_off = 110 * 0x10000 / 6696,
-		.display_width = 320,
-		.display_height = 480,
-		.dup_threshold = 10,
-	},
-	{
-		.flags = SYNAPTICS_FLIP_Y | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = ((4674 - 4334) / 2 + 200) * 0x10000 / 4334,
-		.inactive_right = ((4674 - 4334) / 2 + 200) * 0x10000 / 4334,
-		.inactive_top = ((6946 - 6696) / 2) * 0x10000 / 6696,
-		.inactive_bottom = ((6946 - 6696) / 2) * 0x10000 / 6696,
-		.display_width = 320,
-		.display_height = 480,
-	}
-};
-
-static int hero_microp_intr_debounce(uint8_t *pin_status);
-static void hero_microp_intr_function(uint8_t *pin_status);
-
-static struct microp_pin_config microp_pins_skuid_0[] = {
-	MICROP_PIN(23, MICROP_PIN_CONFIG_PULL_UP),
-	MICROP_PIN(0, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(1, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(2, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(4, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(9, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(10, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(11, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(12, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(13, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(14, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(15, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(16, MICROP_PIN_CONFIG_GPO),
-	{	.name = "microp-pullup",
-		.pin = 23,
-		.config = MICROP_PIN_CONFIG_PULL_UP1,
-		.mask = { 0x00, 0x00, 0x01 },
-	},
-	{
-		.name   = "green",
-		.pin    = 3,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "amber",
-		.pin    = 5,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "lcd-backlight",
-		.pin    = 6,
-		.config = MICROP_PIN_CONFIG_PWM,
-		.freq   = MICROP_PIN_PWM_FREQ_HZ_15600,
-		.levels = { 30, 48, 66, 84, 102, 133, 163, 194, 224, 255 },
-		.dutys	= {  8, 16, 34, 61,  96, 138, 167, 195, 227, 255 },
-	},
-	{
-		.name	= "button-backlight",
-		.pin	= 7,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name   = "adc",
-		.pin    = 24,
-		.config = MICROP_PIN_CONFIG_ADC,
-		.levels = { 0, 0, 0, 6, 24, 60, 425, 497, 569, 638 },
-	},
-	{
-		.pin	 = 17,
-		.config  = MICROP_PIN_CONFIG_INTR_ALL,
-		.mask 	 = { 0x00, 0x01, 0x00 },
-		.intr_debounce = hero_microp_intr_debounce,
-		.intr_function = hero_microp_intr_function,
-		.init_intr_function = 1,
-	}
-};
-
-/* XC and enable LABC */
-static struct microp_pin_config microp_pins_skuid_1[] = {
-	MICROP_PIN(23, MICROP_PIN_CONFIG_PULL_UP),
-	MICROP_PIN(0, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(1, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(2, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(4, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(9, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(10, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(11, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(12, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(13, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(14, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(15, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(16, MICROP_PIN_CONFIG_GPO_INV),
-	{	.name = "microp-pullup",
-		.pin = 23,
-		.config = MICROP_PIN_CONFIG_PULL_UP1,
-		.mask = { 0x00, 0x00, 0x01 },
-	},
-	{
-		.name   = "green",
-		.pin    = 3,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "amber",
-		.pin    = 5,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name	= "button-backlight",
-		.pin	= 7,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name   = "adc",
-		.pin    = 24,
-		.config = MICROP_PIN_CONFIG_ADC,
-		.levels = { 0, 0, 0, 6, 24, 60, 425, 497, 569, 638 },
-	},
-	{
-		.name	= "35mm_adc",
-		.pin	= 25,
-		.adc_pin = 7,
-		.config = MICROP_PIN_CONFIG_ADC_READ,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.pin	 = 17,
-		.config  = MICROP_PIN_CONFIG_INTR_ALL,
-		.mask 	 = { 0x00, 0x01, 0x00 },
-		.intr_debounce = hero_microp_intr_debounce,
-		.intr_function = hero_microp_intr_function,
-		.init_intr_function = 1,
-	}
-};
-
-/* XD, add jogball backlight function*/
-static struct microp_pin_config microp_pins_skuid_2[] = {
-	MICROP_PIN(23, MICROP_PIN_CONFIG_PULL_UP),
-	MICROP_PIN(0, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(1, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(2, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(4, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(9, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(11, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(12, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(13, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(14, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(15, MICROP_PIN_CONFIG_GPO),
-	{	.name = "microp-pullup",
-		.pin = 23,
-		.config = MICROP_PIN_CONFIG_PULL_UP1,
-		.mask = { 0x00, 0x00, 0x03 },
-	},
-	{
-		.name   = "green",
-		.pin    = 3,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "amber",
-		.pin    = 5,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name	= "button-backlight",
-		.pin	= 7,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name	= "jogball-backlight",
-		.pin	= 10,
-		.config = MICROP_PIN_CONFIG_PWM,
-		.auto_if_on = 1,
-		.i_am_jogball_function = 1,
-	},
-	{
-		.name   = "adc",
-		.pin    = 24,
-		.config = MICROP_PIN_CONFIG_ADC,
-		.levels = { 0, 0, 0, 6, 24, 60, 425, 497, 569, 638 },
-	},
-	{
-		.name	= "35mm_adc",
-		.pin	= 25,
-		.adc_pin = 7,
-		.config = MICROP_PIN_CONFIG_ADC_READ,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.pin	 = 17,
-		.config  = MICROP_PIN_CONFIG_INTR_ALL,
-		.mask 	 = { 0x00, 0x01, 0x00 },
-		.intr_debounce = hero_microp_intr_debounce,
-		.intr_function = hero_microp_intr_function,
-		.init_intr_function = 1,
-	}
-};
-
-/* XE, 11pin mic function*/
-static struct microp_pin_config microp_pins_skuid_3[] = {
-	MICROP_PIN(23, MICROP_PIN_CONFIG_PULL_UP),
-	MICROP_PIN(0, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(1, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(2, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(4, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(9, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(11, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(12, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(13, MICROP_PIN_CONFIG_GPO),
-	MICROP_PIN(14, MICROP_PIN_CONFIG_GPO_INV),
-	MICROP_PIN(15, MICROP_PIN_CONFIG_GPO),
-	{	.name = "microp-pullup",
-		.pin = 23,
-		.config = MICROP_PIN_CONFIG_PULL_UP1,
-		.mask = { 0x00, 0x00, 0x03 },
-	},
-	{
-		.name   = "green",
-		.pin    = 3,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name   = "amber",
-		.pin    = 5,
-		.config = MICROP_PIN_CONFIG_GPO_INV,
-	},
-	{
-		.name	= "button-backlight",
-		.pin	= 7,
-		.config = MICROP_PIN_CONFIG_GPO,
-	},
-	{
-		.name	= "jogball-backlight",
-		.pin	= 10,
-		.config = MICROP_PIN_CONFIG_PWM,
-		.auto_if_on = 1,
-		.i_am_jogball_function = 1,
-	},
-	{
-		.name = "microp_11pin_mic",
-		.pin = 16,
-		.config = MICROP_PIN_CONFIG_MIC,
-		.init_value = 1,
-	},
-	{
-		.name   = "adc",
-		.pin    = 24,
-		.config = MICROP_PIN_CONFIG_ADC,
-		.levels = { 0, 0, 0, 6, 24, 60, 425, 497, 569, 638 },
-	},
-	{
-		.name	= "35mm_adc",
-		.pin	= 25,
-		.adc_pin = 7,
-		.config = MICROP_PIN_CONFIG_ADC_READ,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.pin	 = 17,
-		.config  = MICROP_PIN_CONFIG_INTR_ALL,
-		.mask 	 = { 0x00, 0x01, 0x00 },
-		.intr_debounce = hero_microp_intr_debounce,
-		.intr_function = hero_microp_intr_function,
-		.init_intr_function = 1,
-	}
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_pins   = ARRAY_SIZE(microp_pins_skuid_0),
-	.pin_config = microp_pins_skuid_0,
-	.gpio_reset = HERO_GPIO_UP_RESET_N,
-	.cabc_backlight_enable = 0,
-	.microp_enable_early_suspend = 1,
-	.microp_enable_reset_button = 1,
-};
-
-#define DEBOUNCE_LENGTH 4
-static int hero_microp_intr_debounce(uint8_t *pin_status)
-{
-/*Per HW RD's request, wait 300 mill-seconds.*/
-#if 1
-	mdelay(300);
-	return 0;
-#else
-	static int count;
-	static uint8_t data[DEBOUNCE_LENGTH];
-
-	if (pin_status[0] == 0 && pin_status[1] == 0 && pin_status[2] == 0) {
-		mdelay(5);
-		return 1;
-	}
-	/*
-	printk(KERN_INFO "hero_microp_intr_debounce : %02X %02X %02X\n",
-		pin_status[0], pin_status[1], pin_status[2]);
-	*/
-	if (count < DEBOUNCE_LENGTH - 1) {
-		data[count] = pin_status[1] & 0x01;
-		count++;
-	} else {
-		data[DEBOUNCE_LENGTH - 1] = pin_status[1] & 0x01;
-		for (count = 0; count < DEBOUNCE_LENGTH - 1; count++)
-			if (data[count] != data[count + 1])
-				break;
-		if (count == DEBOUNCE_LENGTH - 1) {
-			count = 0;
-			return 0;
-		}
-		for (count = 0; count < DEBOUNCE_LENGTH - 1; count++)
-			data[count] = data[count + 1];
-	}
-
-	mdelay(20);
-
-	return 1;
-#endif
-}
-
-void hero_headset_mic_select(uint8_t select)
-{
-	microp_i2c_set_pin_mode(4, select, microp_data.dev_id);
-}
-
-static void hero_microp_intr_function(uint8_t *pin_status)
-{
-	static int last_insert = 0;
-	int insert;
-	/*
-	printk(KERN_INFO "hero_microp_intr_function : %02X %02X %02X\n",
-		pin_status[0], pin_status[1], pin_status[2]);
-	*/
-	if (pin_status[1] & 0x01) {
-		insert = 0;
-	} else {
-		insert = 1;
-	}
-
-	if (last_insert != insert) {
-		printk(KERN_INFO "hero_microp_intr_function : %s\n", insert ? "inserted" : "not inserted");
-		microp_i2c_set_pin_mode(4, insert, microp_data.dev_id);
-#ifdef CONFIG_HTC_HEADSET_V1
-		cnf_driver_event("H2W_extend_headset", &insert);
-#endif
-		last_insert = insert;
-	}
-}
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = HERO_LAYOUTS,
-	.project_name = HERO_PROJECT_NAME,
-	.reset = HERO_GPIO_COMPASS_RST_N,
-	.intr = HERO_GPIO_COMPASS_INT_N,
-};
-
-static struct bma150_platform_data gsensor_platform_data = {
-	.intr = HERO_GPIO_GSENSOR_INT_N,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x20),
-		.platform_data = &hero_ts_data,
-		.irq = HERO_GPIO_TO_INT(HERO_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(CY8C_I2C_NAME, 0x13),
-		.platform_data = &hero_cypress_ts_data,
-		.irq = HERO_GPIO_TO_INT(HERO_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = HERO_GPIO_TO_INT(HERO_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = HERO_GPIO_TO_INT(HERO_GPIO_COMPASS_INT_N),
-	},
-	{
-		I2C_BOARD_INFO("mt9p012", 0x6c >> 1)
-	},
-};
-
-static struct i2c_board_info i2c_bma150 = {
-	I2C_BOARD_INFO(BMA150_I2C_NAME, 0x38),
-	.platform_data = &gsensor_platform_data,
-	.irq = HERO_GPIO_TO_INT(HERO_GPIO_GSENSOR_INT_N),
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_hero_camera_on_gpios,
-	.camera_gpio_off = config_hero_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_mt9p012_data = {
-	.sensor_name    = "mt9p012",
-	.sensor_reset   = HERO_GPIO_CAM_RST_N,
-	.sensor_pwd     = HERO_CAM_PWDN,
-	.vcm_pwd        = HERO_GPIO_VCM_PWDN,
-	.pdata          = &msm_camera_device_data,
-	.flash_type    = MSM_CAMERA_FLASH_NONE,
-};
-
-static struct platform_device msm_camera_sensor_mt9p012 = {
-	.name      = "msm_camera_mt9p012",
-	.dev        = {
-		.platform_data = &msm_camera_sensor_mt9p012_data,
-	},
-};
-
-static void hero_phy_reset(void)
-{
-	printk(KERN_INFO "%s\n", __func__);
-	gpio_set_value(HERO_GPIO_USB_PHY_RST_N, 0);
-	mdelay(10);
-	gpio_set_value(HERO_GPIO_USB_PHY_RST_N, 1);
-	mdelay(10);
-}
-
-static void hero_phy_shutdown(void)
-{
-	printk(KERN_INFO "%s\n", __func__);
-}
-
-static struct pwr_sink hero_pwrsink_table[] = {
-	{
-		.id	= PWRSINK_AUDIO,
-		.ua_max	= 100000,
-	},
-	{
-		.id	= PWRSINK_BACKLIGHT,
-		.ua_max	= 125000,
-	},
-	{
-		.id	= PWRSINK_LED_BUTTON,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_LED_KEYBOARD,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_GP_CLK,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_BLUETOOTH,
-		.ua_max	= 15000,
-	},
-	{
-		.id	= PWRSINK_CAMERA,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_SDCARD,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_VIDEO,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id	= PWRSINK_SYSTEM_LOAD,
-		.ua_max	= 100000,
-		.percent_util = 38,
-	},
-};
-
-static int hero_pwrsink_resume_early(struct platform_device *pdev)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-	return 0;
-}
-
-static void hero_pwrsink_resume_late(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 38);
-}
-
-static void hero_pwrsink_suspend_early(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-}
-
-static int hero_pwrsink_suspend_late(struct platform_device *pdev, pm_message_t state)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 1);
-	return 0;
-}
-
-static struct pwr_sink_platform_data hero_pwrsink_data = {
-	.num_sinks	= ARRAY_SIZE(hero_pwrsink_table),
-	.sinks		= hero_pwrsink_table,
-	.suspend_late	= hero_pwrsink_suspend_late,
-	.resume_early	= hero_pwrsink_resume_early,
-	.suspend_early	= hero_pwrsink_suspend_early,
-	.resume_late	= hero_pwrsink_resume_late,
-};
-
-static struct platform_device hero_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev	= {
-		.platform_data = &hero_pwrsink_data,
-	},
-};
-/* Switch between UART3 and GPIO */
-static uint32_t uart3_on_gpio_table[] = {
-	/* RX */
-	PCOM_GPIO_CFG(HERO_GPIO_UART3_RX, 1, GPIO_INPUT, GPIO_NO_PULL, 0),
-	/* TX */
-	PCOM_GPIO_CFG(HERO_GPIO_UART3_TX, 1, GPIO_OUTPUT, GPIO_NO_PULL, 0),
-};
-
-/* default TX,RX to GPI */
-static uint32_t uart3_off_gpio_table[] = {
-	/* RX, H2W DATA */
-	PCOM_GPIO_CFG(HERO_GPIO_H2W_DATA, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),
-	/* TX, H2W CLK */
-	PCOM_GPIO_CFG(HERO_GPIO_H2W_CLK, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),
-};
-
-static int hero_h2w_path = H2W_GPIO;
-
-static void h2w_configure(int route)
-{
-	printk(KERN_INFO "H2W route = %d \n", route);
-	switch (route) {
-	case H2W_UART3:
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_on_gpio_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_on_gpio_table+1, 0);
-		hero_h2w_path = H2W_UART3;
-		printk(KERN_INFO "H2W -> UART3\n");
-		break;
-	case H2W_GPIO:
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpio_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpio_table+1, 0);
-		hero_h2w_path = H2W_GPIO;
-		printk(KERN_INFO "H2W -> GPIO\n");
-		break;
-	}
-}
-
-static void h2w_defconfig(void)
-{
-	h2w_configure(H2W_GPIO);
-}
-
-static void set_h2w_dat(int n)
-{
-	gpio_set_value(HERO_GPIO_H2W_DATA, n);
-}
-
-static void set_h2w_clk(int n)
-{
-	gpio_set_value(HERO_GPIO_H2W_CLK, n);
-}
-
-static void set_h2w_dat_dir(int n)
-{
-	if (n == 0) /* input */
-		gpio_direction_input(HERO_GPIO_H2W_DATA);
-	else
-		gpio_configure(HERO_GPIO_H2W_DATA, GPIOF_DRIVE_OUTPUT);
-}
-
-static void set_h2w_clk_dir(int n)
-{
-	if (n == 0) /* input */
-		gpio_direction_input(HERO_GPIO_H2W_CLK);
-	else
-		gpio_configure(HERO_GPIO_H2W_CLK, GPIOF_DRIVE_OUTPUT);
-}
-
-static int get_h2w_dat(void)
-{
-	return gpio_get_value(HERO_GPIO_H2W_DATA);
-}
-
-static int get_h2w_clk(void)
-{
-	return gpio_get_value(HERO_GPIO_H2W_CLK);
-}
-
-#ifdef CONFIG_HTC_HEADSET_V1
-static int set_h2w_path(const char *val, struct kernel_param *kp)
-{
-	int ret = -EINVAL;
-	int enable;
-
-	ret = param_set_int(val, kp);
-	if (ret)
-		return ret;
-
-	switch (hero_h2w_path) {
-	case H2W_GPIO:
-		enable = 1;
-		cnf_driver_event("H2W_enable_irq", &enable);
-		break;
-	case H2W_UART3:
-		enable = 0;
-		cnf_driver_event("H2W_enable_irq", &enable);
-		break;
-	default:
-		hero_h2w_path = -1;
-		return -EINVAL;
-	}
-
-	h2w_configure(hero_h2w_path);
-	return ret;
-}
-
-module_param_call(h2w_path, set_h2w_path, param_get_int,
-		&hero_h2w_path, S_IWUSR | S_IRUGO);
-
-#endif
-static struct h2w_platform_data hero_h2w_data = {
-	.h2w_power		= HERO_GPIO_EXT_3V_EN,
-	.cable_in1		= HERO_GPIO_CABLE_IN1_XAXB,
-	.cable_in2		= HERO_GPIO_CABLE_IN2,
-	.h2w_clk		= HERO_GPIO_H2W_CLK,
-	.h2w_data		= HERO_GPIO_H2W_DATA,
-	.headset_mic_35mm	= HERO_GPIO_HEADSET_MIC,
-/*	.ext_mic_sel		= HERO_GPIO_AUD_EXTMIC_SEL, */
-	.debug_uart 		= H2W_UART3,
-	.config 		= h2w_configure,
-	.defconfig 		= h2w_defconfig,
-	.set_dat		= set_h2w_dat,
-	.set_clk		= set_h2w_clk,
-	.set_dat_dir		= set_h2w_dat_dir,
-	.set_clk_dir		= set_h2w_clk_dir,
-	.get_dat		= get_h2w_dat,
-	.get_clk		= get_h2w_clk,
-	.headset_mic_sel	= hero_headset_mic_select,
-	.flags	= HTC_11PIN_HEADSET_SUPPORT | HTC_H2W_SUPPORT,
-};
-
-static struct h2w_platform_data hero_h2w_data_xc = {
-	.h2w_power		= HERO_GPIO_EXT_3V_EN,
-	.cable_in1		= HERO_GPIO_CABLE_IN1,
-	.cable_in2		= HERO_GPIO_CABLE_IN2,
-	.h2w_clk		= HERO_GPIO_H2W_CLK,
-	.h2w_data		= HERO_GPIO_H2W_DATA,
-	.headset_mic_35mm	= HERO_GPIO_HEADSET_MIC,
-	.ext_mic_sel		= HERO_GPIO_AUD_EXTMIC_SEL,
-	.debug_uart 		= H2W_UART3,
-	.config 		= h2w_configure,
-	.defconfig 		= h2w_defconfig,
-	.set_dat		= set_h2w_dat,
-	.set_clk		= set_h2w_clk,
-	.set_dat_dir		= set_h2w_dat_dir,
-	.set_clk_dir		= set_h2w_clk_dir,
-	.get_dat		= get_h2w_dat,
-	.get_clk		= get_h2w_clk,
-	.flags	= HTC_11PIN_HEADSET_SUPPORT | HTC_H2W_SUPPORT,
-/*	.headset_mic_sel	= hero_headset_mic_select, */
-};
-
-static struct h2w_platform_data hero_h2w_data_xe = {
-	.h2w_power		= HERO_GPIO_EXT_3V_EN,
-	.cable_in1		= HERO_GPIO_CABLE_IN1,
-	.cable_in2		= HERO_GPIO_CABLE_IN2,
-	.h2w_clk		= HERO_GPIO_H2W_CLK,
-	.h2w_data		= HERO_GPIO_H2W_DATA,
-	.headset_mic_35mm	= HERO_GPIO_HEADSET_MIC,
-	.ext_mic_sel		= HERO_GPIO_AUD_EXTMIC_SEL,
-	.debug_uart 		= H2W_UART3,
-	.config 		= h2w_configure,
-	.defconfig 		= h2w_defconfig,
-	.set_dat		= set_h2w_dat,
-	.set_clk		= set_h2w_clk,
-	.set_dat_dir		= set_h2w_dat_dir,
-	.set_clk_dir		= set_h2w_clk_dir,
-	.get_dat		= get_h2w_dat,
-	.get_clk		= get_h2w_clk,
-/*	.headset_mic_sel	= hero_headset_mic_select, */
-	.flags	= _35MM_MIC_DET_L2H | HTC_11PIN_HEADSET_SUPPORT |
-				HTC_H2W_SUPPORT,
-};
-
-static struct platform_device hero_h2w = {
-	.name		= "h2w",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &hero_h2w_data,
-	},
-};
-
-static struct platform_device hero_h2w_xc = {
-	.name		= "h2w",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &hero_h2w_data_xc,
-	},
-};
-
-static struct platform_device hero_h2w_xe = {
-	.name		= "h2w",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &hero_h2w_data_xe,
-	},
-};
-
-static int hero_phy_init_seq[] = {0x40, 0x31, 0x1, 0x0D, 0x1, 0x10, -1};
-static struct msm_hsusb_product hero_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c99,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-
-static struct platform_device hero_rfkill = {
-	.name = "hero_rfkill",
-	.id = -1,
-};
-
-static struct msm_pmem_setting pmem_setting = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_gpu0_start = MSM_PMEM_GPU0_BASE,
-	.pmem_gpu0_size = MSM_PMEM_GPU0_SIZE,
-	.pmem_gpu1_start = MSM_PMEM_GPU1_BASE,
-	.pmem_gpu1_size = MSM_PMEM_GPU1_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-};
-
-static struct msm_i2c_device_platform_data hero_i2c_device_data = {
-	.i2c_clock = 100000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-static struct platform_device *devices2[] __initdata = {
-	&msm_device_i2c,
-	&htc_battery_pdev,
-	&hero_h2w_xe,
-	&hero_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&hero_pwr_sink,
-#endif
-	&msm_camera_sensor_mt9p012,
-};
-
-static struct platform_device *devices1[] __initdata = {
-	&msm_device_i2c,
-	&htc_battery_pdev,
-	&hero_h2w_xc,
-	&hero_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&hero_pwr_sink,
-#endif
-	&msm_camera_sensor_mt9p012,
-};
-
-static struct platform_device *devices0[] __initdata = {
-	&msm_device_i2c,
-	&htc_battery_pdev,
-	&hero_h2w,
-	&hero_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&hero_pwr_sink,
-#endif
-	&msm_camera_sensor_mt9p012,
-
-};
-
-
-extern struct sys_timer msm_timer;
-
-static void __init hero_init_irq(void)
-{
-	printk("hero_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint opt_disable_uart3;
-
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-
-#if 0	/*allenou, bt test, no need this one, 12/15*/
-static int hero_bluetooth_power_on;
-extern int hero_bt_fastclock_power(int on);
-
-static void bluetooth_set_power(int on)
-{
-	if (on) {
-		hero_bt_fastclock_power(1);
-		udelay(10);
-		gpio_configure(HERO_GPIO_WB_SHUT_DOWN_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	} else {
-		gpio_configure(HERO_GPIO_WB_SHUT_DOWN_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-		hero_bt_fastclock_power(0);
-	}
-}
-
-static int bluetooth_set_power_on(const char *val, struct kernel_param *kp)
-{
-	int ret;
-	ret = param_set_bool(val, kp);
-	if (!ret)
-		bluetooth_set_power(hero_bluetooth_power_on);
-	return ret;
-}
-
-module_param_call(bluetooth_power_on, bluetooth_set_power_on, param_get_bool,
-		  &hero_bluetooth_power_on, S_IWUSR | S_IRUGO);
-#endif
-
-static char bt_chip_id[10] = "brfxxxx";
-module_param_string(bt_chip_id, bt_chip_id, sizeof(bt_chip_id), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_chip_id, "BT's chip id");
-
-static char bt_fw_version[10] = "v2.0.38";
-module_param_string(bt_fw_version, bt_fw_version, sizeof(bt_fw_version), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_fw_version, "BT's fw version");
-
-static void hero_reset(void)
-{
-	gpio_set_value(HERO_GPIO_PS_HOLD, 0);
-}
-
-static uint32_t gpio_table[] = {
-	PCOM_GPIO_CFG(HERO_GPIO_I2C_CLK, 1, GPIO_INPUT, GPIO_NO_PULL, GPIO_8MA),
-	PCOM_GPIO_CFG(HERO_GPIO_I2C_DAT , 1, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),
-};
-
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-void config_hero_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void config_hero_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-static void __init config_gpios(void)
-{
-	config_gpio_table(gpio_table, ARRAY_SIZE(gpio_table));
-	config_hero_camera_off_gpios();
-}
-
-static struct msm_acpu_clock_platform_data hero_clock_data = {
-	.acpu_switch_time_us = 20,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200,
-#if defined(CONFIG_TURBO_MODE)
-	.wait_for_irq_khz = 176000,
-#else
-	.wait_for_irq_khz = 128000,
-#endif
-};
-
-static unsigned hero_perf_acpu_table[] = {
-	245760000,
-	480000000,
-	528000000,
-};
-
-
-static struct perflock_platform_data hero_perflock_data = {
-	.perf_acpu_table = hero_perf_acpu_table,
-	.table_size = ARRAY_SIZE(hero_perf_acpu_table),
-};
-
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(HERO_GPIO_UART1_RX),
-	.inject_rx_on_wakeup = 1,
-	.rx_to_inject = 0x32,
-	.cpu_lock_supported = 1,
-};
-#endif
-
-static void __init hero_init(void)
-{
-	int rc;
-	printk(KERN_INFO "hero_init() revision: 0x%X\n", system_rev);
-	config_gpios();
-	printk(KERN_INFO "%s: skuid: 0x%X, hwid: 0x%X, enginner_id: 0x%X\n",
-		__func__, hero_get_skuid(), hero_get_hwid(), hero_get_engineerid());
-
-	msm_hw_reset_hook = hero_reset;
-
-	gpio_direction_output(HERO_TP_LS_EN, 0);
-
-	msm_acpu_clock_init(&hero_clock_data);
-	perflock_init(&hero_perflock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-				      &msm_device_uart3.dev, 1, INT_UART3_RX);
-#endif
-#if 0
-	config_gpios();
-	gpio_direction_output(HERO_TP_LS_EN, 0);
-#endif
-	/* Init bluetooth clock and shutdown pin */
-
-	/*allenou, bt test, no need this one, 12/15*/
-	/*bluetooth_set_power(hero_bluetooth_power_on);*/
-	msm_add_devices();
-
-	#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_add_serial_devices(MSM_SERIAL_UART1DM);
-	#else
-	msm_add_serial_devices(MSM_SERIAL_UART1);
-	#endif
-
-	msm_add_serial_devices(MSM_SERIAL_UART3);
-
-	msm_register_usb_phy_init_seq(hero_phy_init_seq);
-	msm_hsusb_set_product(hero_usb_products,
-		ARRAY_SIZE(hero_usb_products));
-
-	msm_add_usb_devices(hero_phy_reset, hero_phy_shutdown);
-
-	msm_add_mem_devices(&pmem_setting);
-
-	msm_init_pmic_vibrator();
-
-	rc = hero_init_mmc(system_rev);
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-
-	msm_device_i2c.dev.platform_data = &hero_i2c_device_data;
-
-	if (system_rev == 0 || system_rev == 1) {
-		platform_add_devices(devices0, ARRAY_SIZE(devices0));
-		for (rc = 0; rc < ARRAY_SIZE(i2c_devices); rc++) {
-			if (!strcmp(i2c_devices[rc].type, MICROP_I2C_NAME))
-				i2c_devices[rc].irq = HERO_GPIO_TO_INT(HERO_GPIO_UP_INT_N_XAXB);
-			if (!strcmp(i2c_devices[rc].type, AKM8973_I2C_NAME))
-				i2c_devices[rc].irq = HERO_GPIO_TO_INT(HERO_GPIO_COMPASS_INT_N_XAXB);
-		}
-	} else if (system_rev == 2 || system_rev == 3) /*XC and XD*/
-		platform_add_devices(devices1, ARRAY_SIZE(devices1));
-	else /*above XE*/
-		platform_add_devices(devices2, ARRAY_SIZE(devices2));
-
-	i2c_register_board_info(0, &i2c_bma150, 1);
-
-	if (hero_get_engineerid() || system_rev > 2) {
-		if (system_rev >= 4) {
-			microp_data.num_pins = ARRAY_SIZE(microp_pins_skuid_3);
-			microp_data.pin_config = microp_pins_skuid_3;
-		} else if (system_rev >= 3) {
-			microp_data.num_pins = ARRAY_SIZE(microp_pins_skuid_2);
-			microp_data.pin_config = microp_pins_skuid_2;
-		} else {
-			microp_data.num_pins = ARRAY_SIZE(microp_pins_skuid_1);
-			microp_data.pin_config = microp_pins_skuid_1;
-		}
-		microp_data.cabc_backlight_enable = 1;
-	}
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-}
-
-static void __init hero_fixup(struct machine_desc *desc, struct tag *tags,
-			      char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 1;
-	mi->bank[0].start = PHYS_OFFSET;
-	mi->bank[0].node = PHYS_TO_NID(PHYS_OFFSET);
-	mi->bank[0].size = MSM_LINUX_SIZE;
-
-	hwid = parse_tag_hwid((const struct tag *)tags);
-	skuid = parse_tag_skuid((const struct tag *)tags);
-	engineerid = parse_tag_engineerid((const struct tag *)tags);
-
-}
-
-static void __init hero_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-MACHINE_START(HERO, "hero")
-/* Maintainer: Kant Kang <kant_kang@htc.com> */
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params    = 0x19200100,
-	.fixup          = hero_fixup,
-	.map_io         = hero_map_io,
-	.init_irq       = hero_init_irq,
-	.init_machine   = hero_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-hero.h b/arch/arm/mach-msm/board-hero.h
deleted file mode 100644
index cff6e46..0000000
--- a/arch/arm/mach-msm/board-hero.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/* linux/arch/arm/mach-msm/board-hero.h
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_HERO_H
-#define __ARCH_ARM_MACH_MSM_BOARD_HERO_H
-
-#include <mach/board.h>
-
-#define MSM_LINUX_BASE         0x19200000
-#define MSM_LINUX_SIZE         0xC600000
-
-#define MSM_PMEM_GPU0_BASE      0x00000000
-#define MSM_PMEM_GPU0_SIZE      0x00700000
-
-#define MSM_FB_BASE             0x00700000
-#define MSM_FB_SIZE             0x9b000
-
-#define MSM_RAM_CONSOLE_BASE    0x007A0000
-#define MSM_RAM_CONSOLE_SIZE    128 * SZ_1K
-
-#define MSM_PMEM_GPU1_BASE      0x25800000
-#define MSM_PMEM_GPU1_SIZE      0x800000
-
-#define MSM_PMEM_MDP_BASE       0x26000000
-#define MSM_PMEM_MDP_SIZE       0x800000
-
-#define MSM_PMEM_ADSP_BASE      0x26800000
-#define MSM_PMEM_ADSP_SIZE      0x800000
-
-#define MSM_PMEM_CAMERA_BASE	0x27000000
-#define MSM_PMEM_CAMERA_SIZE    0x1000000
-
-#define DECLARE_MSM_IOMAP
-#include <mach/msm_iomap.h>
-
-#define HERO_POWER_KEY                  (20)
-#define HERO_GPIO_PS_HOLD               (25)
-#define HERO_GPIO_MDDI_1V8_EN           (26)
-#define HERO_GPIO_UP_INT_N		(27)
-#define HERO_GPIO_COMPASS_INT_N   (36)
-#define HERO_GPIO_SDMC_CD_N             (38)
-#define HERO_GPIO_GSENSOR_INT_N         (49)
-
-/* BT */
-#define HERO_GPIO_UART1_RTS             (43)
-#define HERO_GPIO_UART1_CTS             (44)
-#define HERO_GPIO_UART1_RX              (45)
-#define HERO_GPIO_UART1_TX              (46)
-#define HERO_GPIO_WB_SHUT_DOWN_N        (101)
-
-#define HERO_GPIO_I2C_CLK			(60)
-#define HERO_GPIO_I2C_DAT			(61)
-#define HERO_GPIO_UP_RESET_N            (76)
-#define HERO_GPIO_COMPASS_INT_N_XAXB   (83)/*for XA,XB*/
-#define HERO_GPIO_COMPASS_RST_N         (84)
-#define HERO_PROJECT_NAME        "hero"
-#define HERO_LAYOUTS			{ \
-			{ {  0,  1, 0}, {-1,  0, 0}, {0, 0, 1} }, \
-			{ {  0, -1, 0}, {-1,  0, 0}, {0, 0, 1} }, \
-			{ { -1,  0, 0}, { 0, -1, 0}, {0, 0, 1} }, \
-			{ {  1,  0, 0}, { 0,  0, 1}, {0, 1, 0} }  \
-								}
-#define HERO_GPIO_MDDI_BRIDGE_ID        (85)
-#define HERO_GPIO_TP_ATT_N              (90)
-#define HERO_GPIO_VCM_PWDN              (91)
-#define HERO_GPIO_CAM_RST_N             (92)
-#define HERO_GPIO_EXT_3V_EN             (93)
-#define HERO_GPIO_UP_INT_N_XAXB              (94) /*for XA,XB*/
-#define HERO_GPIO_MDDI_1V5_EN           (98)
-#define HERO_GPIO_MDDI_RST_N            (99)
-#define HERO_GPIO_USB_PHY_RST_N         (100)
-#define HERO_GPIO_WIFI_EN               (102)
-#define HERO_CAM_PWDN                   (107)
-#define HERO_TP_LS_EN                   (108)
-#define HERO_GPIO_TP_EN                 (109)
-
-#define HERO_GPIO_TO_INT(x)             (x+64)/*from gpio_to_irq*/
-
-/* JogBall, exist in XC */
-#define HERO_GPIO_JOGBALL_EN		(98)
-#define HERO_GPIO_JOGBALL_UP_0		(94)
-#define HERO_GPIO_JOGBALL_LEFT_0	(39)
-#define HERO_GPIO_JOGBALL_DOWN_0	(83)
-#define HERO_GPIO_JOGBALL_RIGHT_0	(37)
-
-/* H2W */
-#define HERO_GPIO_CABLE_IN1_XAXB        (18)
-#define HERO_GPIO_CABLE_IN1             (49)
-#define HERO_GPIO_CABLE_IN2             (31)
-#define HERO_GPIO_UART3_RX              (86)
-#define HERO_GPIO_UART3_TX              (87)
-#define HERO_GPIO_H2W_DATA              (86)
-#define HERO_GPIO_H2W_CLK               (87)
-#define HERO_GPIO_HEADSET_MIC           (17)
-#define HERO_GPIO_AUD_EXTMIC_SEL        (82)
-
-#define HERO_GPIO_VSYNC			(97)
-
-int hero_init_mmc(unsigned int sys_rev);
-void config_hero_camera_on_gpios(void);
-void config_hero_camera_off_gpios(void);
-unsigned int camera_is_micron_5M(void);
-unsigned int hero_get_hwid(void);
-unsigned int hero_get_skuid(void);
-unsigned int hero_get_engineerid(void);
-#endif /* GUARD */
diff --git a/arch/arm/mach-msm/board-incredible-audio.c b/arch/arm/mach-msm/board-incredible-audio.c
deleted file mode 100644
index 76fb978..0000000
--- a/arch/arm/mach-msm/board-incredible-audio.c
+++ /dev/null
@@ -1,194 +0,0 @@
-/* arch/arm/mach-msm/board-incredible-audio.c
- *
- * Copyright (C) 2009 HTC Corporation
- * Copyright (C) 2009 Google Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/gpio.h>
-#include <linux/err.h>
-#include <mach/pmic.h>
-#include <mach/msm_qdsp6_audio.h>
-#include <mach/htc_acoustic_qsd.h>
-#include <mach/tpa6130.h>
-#include <mach/vreg.h>
-
-#include "board-incredible.h"
-#include "proc_comm.h"
-
-#if 1
-#define D(fmt, args...) printk(KERN_INFO "Audio: "fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-static struct mutex ext_mic_lock;
-static struct vreg * vreg_mic_bias;
-
-void incredible_analog_init(void)
-{
-	D("%s\n", __func__);
-	/* stereo pmic init */
-	pmic_spkr_set_gain(LEFT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_set_gain(RIGHT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_en_right_chan(OFF_CMD);
-	pmic_spkr_en_left_chan(ON_CMD);
-	pmic_spkr_add_right_left_chan(OFF_CMD);
-	pmic_spkr_en_stereo(OFF_CMD);
-	pmic_spkr_select_usb_with_hpf_20hz(OFF_CMD);
-	pmic_spkr_bypass_mux(OFF_CMD);
-	pmic_spkr_en_hpf(ON_CMD);
-	pmic_spkr_en_sink_curr_from_ref_volt_cir(OFF_CMD);
-	pmic_spkr_set_mux_hpf_corner_freq(SPKR_FREQ_0_73KHZ);
-	pmic_mic_set_volt(MIC_VOLT_1_80V);
-
-	gpio_direction_output(INCREDIBLE_AUD_JACKHP_EN, 1);
-	gpio_set_value(INCREDIBLE_AUD_JACKHP_EN, 0);
-}
-
-void incredible_headset_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	/* enable audio amp */
-	gpio_set_value(INCREDIBLE_AUD_JACKHP_EN, !!en);
-#ifdef CONFIG_AMP_TPA6130A
-	set_headset_amp(en);
-#endif
-}
-
-void incredible_speaker_enable(int en)
-{
-	struct spkr_config_mode scm;
-	memset(&scm, 0, sizeof(scm));
-
-	D("%s %d\n", __func__, en);
-	if (en) {
-		scm.is_right_chan_en = 1;
-		scm.is_left_chan_en = 1;
-		scm.is_stereo_en = 1;
-		scm.is_hpf_en = 1;
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-		pmic_spkr_en_mute(RIGHT_SPKR, 0);
-		pmic_set_spkr_configuration(&scm);
-		pmic_spkr_en(LEFT_SPKR, 1);
-		pmic_spkr_en(RIGHT_SPKR, 1);
-
-		/* unmute */
-		pmic_spkr_en_mute(LEFT_SPKR, 1);
-		pmic_spkr_en_mute(RIGHT_SPKR, 1);
-	} else {
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-		pmic_spkr_en_mute(RIGHT_SPKR, 0);
-
-		pmic_spkr_en(LEFT_SPKR, 0);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		pmic_set_spkr_configuration(&scm);
-	}
-}
-
-void incredible_receiver_enable(int en)
-{
-	/* Do nothing for incredible. */
-}
-
-static uint32_t bt_sco_enable[] = {
-	PCOM_GPIO_CFG(INCREDIBLE_BT_PCM_OUT, 1, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLE_BT_PCM_IN, 1, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLE_BT_PCM_SYNC, 2, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLE_BT_PCM_CLK, 2, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-};
-
-static uint32_t bt_sco_disable[] = {
-	PCOM_GPIO_CFG(INCREDIBLE_BT_PCM_OUT, 0, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLE_BT_PCM_IN, 0, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLE_BT_PCM_SYNC, 0, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLE_BT_PCM_CLK, 0, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-};
-
-void incredible_bt_sco_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	if (en)
-		config_gpio_table(bt_sco_enable, ARRAY_SIZE(bt_sco_enable));
-	else
-		config_gpio_table(bt_sco_disable, ARRAY_SIZE(bt_sco_disable));
-}
-
-void incredible_int_mic_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	if (en)
-		pmic_mic_en(ON_CMD);
-	else
-		pmic_mic_en(OFF_CMD);
-}
-
-void incredible_ext_mic_enable(int en)
-{
-	static int old_state = 0, new_state = 0;
-
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&ext_mic_lock);
-	if (!!en)
-		new_state++;
-	else
-		new_state--;
-
-	if (new_state == 1 && old_state == 0) {
-		vreg_enable(vreg_mic_bias);
-		vreg_set_level(vreg_mic_bias, 2500);
-	} else if (new_state == 0 && old_state == 1)
-		vreg_disable(vreg_mic_bias);
-	else
-		D("%s: do nothing %d %d\n", __func__, old_state, new_state);
-
-	old_state = new_state;
-	mutex_unlock(&ext_mic_lock);
-}
-
-static struct qsd_acoustic_ops acoustic = {
-	.enable_mic_bias = incredible_ext_mic_enable,
-};
-
-static struct q6audio_analog_ops ops = {
-	.init = incredible_analog_init,
-	.speaker_enable = incredible_speaker_enable,
-	.headset_enable = incredible_headset_enable,
-	.receiver_enable = incredible_receiver_enable,
-	.bt_sco_enable = incredible_bt_sco_enable,
-	.int_mic_enable = incredible_int_mic_enable,
-	.ext_mic_enable = incredible_ext_mic_enable,
-};
-
-int __init incredible_audio_init(void)
-{
-	vreg_mic_bias = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_mic_bias))
-		return PTR_ERR(vreg_mic_bias);
-
-	mutex_init(&ext_mic_lock);
-#if defined(CONFIG_QSD_AUDIO)
-	q6audio_register_analog_ops(&ops);
-#endif
-	acoustic_register_ops(&acoustic);
-	return 0;
-}
-
diff --git a/arch/arm/mach-msm/board-incredible-keypad.c b/arch/arm/mach-msm/board-incredible-keypad.c
deleted file mode 100644
index d793bf2..0000000
--- a/arch/arm/mach-msm/board-incredible-keypad.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/* arch/arm/mach-msm/board-incredible-keypad.c
- *
- * Copyright (C) 2009 Google, Inc
- * Copyright (C) 2009 HTC Corporation.
- *
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/gpio_event.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <mach/vreg.h>
-
-#include <asm/mach-types.h>
-
-#include "board-incredible.h"
-
-
-static struct gpio_event_direct_entry incredible_keypad_nav_map[] = {
-	{ INCREDIBLE_POWER_KEY,              KEY_END        },
-	{ INCREDIBLE_VOLUME_UP,              KEY_VOLUMEUP   },
-	{ INCREDIBLE_VOLUME_DOWN,            KEY_VOLUMEDOWN },
-	{ INCREDIBLE_MENU_KEY,            KEY_MENU },
-};
-
-static struct gpio_event_input_info incredible_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.flags = 0,
-	.type = EV_KEY,
-	.keymap = incredible_keypad_nav_map,
-	.debounce_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.keymap_size = ARRAY_SIZE(incredible_keypad_nav_map)
-};
-
-static struct gpio_event_info *incredible_keypad_info[] = {
-	&incredible_keypad_nav_info.info,
-};
-
-static struct gpio_event_platform_data incredible_keypad_data = {
-	.name = "incredible-keypad",
-	.info = incredible_keypad_info,
-	.info_count = ARRAY_SIZE(incredible_keypad_info)
-};
-
-static struct platform_device incredible_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &incredible_keypad_data,
-	},
-};
-
-static int __init incredible_init_keypad(void)
-{
-	int ret;
-
-	if (!machine_is_incredible())
-		return 0;
-
-	ret = platform_device_register(&incredible_keypad_device);
-	if (ret != 0)
-		return ret;
-
-	return 0;
-}
-
-device_initcall(incredible_init_keypad);
-
-
diff --git a/arch/arm/mach-msm/board-incredible-mmc.c b/arch/arm/mach-msm/board-incredible-mmc.c
deleted file mode 100644
index 4dd1c85..0000000
--- a/arch/arm/mach-msm/board-incredible-mmc.c
+++ /dev/null
@@ -1,288 +0,0 @@
-/* linux/arch/arm/mach-msm/board-incredible-mmc.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-
-#include "board-incredible.h"
-#include "devices.h"
-#include "proc_comm.h"
-
-#define DEBUG_SDSLOT_VDD 1
-
-static bool opt_disable_sdcard;
-static int __init incredible_disablesdcard_setup(char *str)
-{
-	opt_disable_sdcard = (bool)simple_strtol(str, NULL, 0);
-	return 1;
-}
-
-__setup("board_incredible.disable_sdcard=", incredible_disablesdcard_setup);
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static struct vreg	*sdslot_vreg;
-static uint32_t		sdslot_vdd = 0xffffffff;
-static uint32_t		sdslot_vreg_enabled;
-
-static struct {
-	int mask;
-	int level;
-} mmc_vdd_table[] = {
-	{ MMC_VDD_27_28,	2800 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static uint32_t incredible_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-	int ret;
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(sdslot_vreg);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		ret = vreg_enable(sdslot_vreg);
-		if (ret)
-			pr_err("%s: Error enabling vreg (%d)\n", __func__, ret);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask != (1 << vdd))
-			continue;
-		ret = vreg_set_level(sdslot_vreg, mmc_vdd_table[i].level);
-		if (ret)
-			pr_err("%s: Error setting level (%d)\n", __func__, ret);
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Setting level to %u (%s)\n",
-					__func__, mmc_vdd_table[i].level,
-				ret?"Failed":"Success");
-#endif
-		return 0;
-	}
-
-	pr_err("%s: Invalid VDD (%d) specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int incredible_sdslot_status(struct device *dev)
-{
-	return !gpio_get_value(INCREDIBLE_GPIO_SDMC_CD_N);
-}
-
-#define INCREDIBLE_MMC_VDD	(MMC_VDD_27_28 | MMC_VDD_28_29 | \
-				 MMC_VDD_29_30)
-
-static struct mmc_platform_data incredible_sdslot_data = {
-	.ocr_mask	= INCREDIBLE_MMC_VDD,
-	.status		= incredible_sdslot_status,
-	.translate_vdd	= incredible_sdslot_switchvdd,
-};
-
-int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-		 unsigned int stat_irq, unsigned long stat_irq_flags);
-
-
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data incredible_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-incredible_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static int incredible_wifi_cd;	/* WiFi virtual 'card detect' status */
-
-static unsigned int incredible_wifi_status(struct device *dev)
-{
-	return incredible_wifi_cd;
-}
-
-static struct mmc_platform_data incredible_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= incredible_wifi_status,
-	.register_status_notify	= incredible_wifi_status_register,
-	.embedded_sdio		= &incredible_wifi_emb_data,
-};
-
-int incredible_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	incredible_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(incredible_wifi_set_carddetect);
-
-int incredible_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-
-	mdelay(100);
-	gpio_set_value(127, on); /* WIFI_SHUTDOWN */
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(incredible_wifi_power);
-
-int incredible_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-
-int __init incredible_init_mmc(unsigned int sys_rev)
-{
-	uint32_t id;
-
-	wifi_status_cb = NULL;
-
-	printk(KERN_INFO "%s()+\n", __func__);
-
-	/* initial WIFI_SHUTDOWN# */
-	id = PCOM_GPIO_CFG(127, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	msm_add_sdcc(1, &incredible_wifi_data, 0, 0);
-
-	if (opt_disable_sdcard) {
-		pr_info("%s: sdcard disabled on cmdline\n", __func__);
-		goto done;
-	}
-
-	sdslot_vreg_enabled = 0;
-
-	sdslot_vreg = vreg_get(0, "gp6");
-	if (IS_ERR(sdslot_vreg))
-		return PTR_ERR(sdslot_vreg);
-
-	set_irq_wake(MSM_GPIO_TO_INT(INCREDIBLE_GPIO_SDMC_CD_N), 1);
-
-	msm_add_sdcc(2, &incredible_sdslot_data,
-		     MSM_GPIO_TO_INT(INCREDIBLE_GPIO_SDMC_CD_N),
-		     IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-
-done:
-	printk(KERN_INFO "%s()-\n", __func__);
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-incredible-panel.c b/arch/arm/mach-msm/board-incredible-panel.c
deleted file mode 100644
index 763f9e2..0000000
--- a/arch/arm/mach-msm/board-incredible-panel.c
+++ /dev/null
@@ -1,671 +0,0 @@
-/* linux/arch/arm/mach-msm/board-incredible-panel.c
- *
- * Copyright (c) 2009 Google Inc.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/wakelock.h>
-#include <linux/leds.h>
-#include <linux/workqueue.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <mach/msm_fb.h>
-
-#include "board-incredible.h"
-#include "devices.h"
-
-#define CLK_NS_TO_RATE(ns)			(1000000000UL / (ns))
-#define lcm_writeb(x...)			do {} while (0)
-
-int qspi_send(unsigned char id, unsigned char data);
-
-static struct wake_lock backlight_wakelock;
-static struct work_struct work_set_brightness;
-static int g_brightness_level;
-
-struct lcd_init_table {
-        uint32_t reg, value, delay;
-};
-#define LCD_OLED_REG struct lcd_init_table
-
-#if 0
-static struct lcd_init_table samsung_init_tb[] = {
-};
-
-static struct lcd_init_table samsung_deinit_tb[] = {
-};
-#endif
-
-static const LCD_OLED_REG LCD_OLED_INIT_TABLE[]={
-        { 0x31, 0x08, 0 },
-        { 0x32, 0x14, 0 },
-        { 0x30, 0x2 , 0 },
-        { 0x27, 0x1 , 0 },
-        { 0x12, 0x8 , 0 },
-        { 0x13, 0x8 , 0 },
-        { 0x15, 0x0 , 0 },
-        { 0x16, 0x02, 0 },
-        { 0x39, 0x44, 0 },
-        { 0x17, 0x22, 0 },
-        { 0x18, 0x33, 0 },
-        { 0x19, 0x3 , 0 },
-        { 0x1A, 0x1 , 0 },
-        { 0x22, 0xA4, 0 },
-        { 0x23, 0x0 , 0 },
-        { 0x26, 0xA0, 0 },
-        { 0x1D, 0xA0, 250},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_10_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x3f, 0},
-        { 0x43,0x35, 0},
-        { 0x44,0x30, 0},
-        { 0x45,0x2c, 0},
-        { 0x46,0x13, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x0 , 0},
-        { 0x53,0x0 , 0},
-        { 0x54,0x27, 0},
-        { 0x55,0x2b, 0},
-        { 0x56,0x12, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x3f, 0},
-        { 0x63,0x34, 0},
-        { 0x64,0x2f, 0},
-        { 0x65,0x2b, 0},
-        { 0x66,0x1b, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_40_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x3e, 0},
-        { 0x43,0x2e, 0},
-        { 0x44,0x2d, 0},
-        { 0x45,0x28, 0},
-        { 0x46,0x21, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x0 , 0},
-        { 0x53,0x21, 0},
-        { 0x54,0x2a, 0},
-        { 0x55,0x28, 0},
-        { 0x56,0x20, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x3e, 0},
-        { 0x63,0x2d, 0},
-        { 0x64,0x2b, 0},
-        { 0x65,0x26, 0},
-        { 0x66,0x2d, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_70_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x35, 0},
-        { 0x43,0x2c, 0},
-        { 0x44,0x2b, 0},
-        { 0x45,0x26, 0},
-        { 0x46,0x29, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x0 , 0},
-        { 0x53,0x25, 0},
-        { 0x54,0x29, 0},
-        { 0x55,0x26, 0},
-        { 0x56,0x28, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x34, 0},
-        { 0x63,0x2b, 0},
-        { 0x64,0x2a, 0},
-        { 0x65,0x23, 0},
-        { 0x66,0x37, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_100_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x30, 0},
-        { 0x43,0x2a, 0},
-        { 0x44,0x2b, 0},
-        { 0x45,0x24, 0},
-        { 0x46,0x2f, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x0 , 0},
-        { 0x53,0x25, 0},
-        { 0x54,0x29, 0},
-        { 0x55,0x24, 0},
-        { 0x56,0x2e, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x2f, 0},
-        { 0x63,0x29, 0},
-        { 0x64,0x29, 0},
-        { 0x65,0x21, 0},
-        { 0x66,0x3f, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_130_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x2e, 0},
-        { 0x43,0x29, 0},
-        { 0x44,0x2a, 0},
-        { 0x45,0x23, 0},
-        { 0x46,0x34, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0xa , 0},
-        { 0x53,0x25, 0},
-        { 0x54,0x28, 0},
-        { 0x55,0x23, 0},
-        { 0x56,0x33, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f , 0},
-        { 0x62,0x2d, 0},
-        { 0x63,0x28, 0},
-        { 0x64,0x27, 0},
-        { 0x65,0x20, 0},
-        { 0x66,0x46, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_160_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x2b, 0},
-        { 0x43,0x29, 0},
-        { 0x44,0x28, 0},
-        { 0x45,0x23, 0},
-        { 0x46,0x38, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0xb , 0},
-        { 0x53,0x25, 0},
-        { 0x54,0x27, 0},
-        { 0x55,0x23, 0},
-        { 0x56,0x37, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f , 0},
-        { 0x62,0x29, 0},
-        { 0x63,0x28, 0},
-        { 0x64,0x25, 0},
-        { 0x65,0x20, 0},
-        { 0x66,0x4b, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_190_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x29, 0},
-        { 0x43,0x29, 0},
-        { 0x44,0x27, 0},
-        { 0x45,0x22, 0},
-        { 0x46,0x3c, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x10, 0},
-        { 0x53,0x26, 0},
-        { 0x54,0x26, 0},
-        { 0x55,0x22, 0},
-        { 0x56,0x3b, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x28, 0},
-        { 0x63,0x28, 0},
-        { 0x64,0x24, 0},
-        { 0x65,0x1f, 0},
-        { 0x66,0x50, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_220_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x28, 0},
-        { 0x43,0x28, 0},
-        { 0x44,0x28, 0},
-        { 0x45,0x20, 0},
-        { 0x46,0x40, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x11, 0},
-        { 0x53,0x25, 0},
-        { 0x54,0x27, 0},
-        { 0x55,0x20, 0},
-        { 0x56,0x3f, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x27, 0},
-        { 0x63,0x26, 0},
-        { 0x64,0x26, 0},
-        { 0x65,0x1c, 0},
-        { 0x66,0x56, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_250_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x2a, 0},
-        { 0x43,0x27, 0},
-        { 0x44,0x27, 0},
-        { 0x45,0x1f, 0},
-        { 0x46,0x44, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x17, 0},
-        { 0x53,0x24, 0},
-        { 0x54,0x26, 0},
-        { 0x55,0x1f, 0},
-        { 0x56,0x43, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x2a, 0},
-        { 0x63,0x25, 0},
-        { 0x64,0x24, 0},
-        { 0x65,0x1b, 0},
-        { 0x66,0x5c, 0},
-};
-
-static LCD_OLED_REG *gamma_level_table[] = {
-        LCD_OLED_GAMMA_10_TABLE,
-        LCD_OLED_GAMMA_40_TABLE,
-        LCD_OLED_GAMMA_70_TABLE,
-        LCD_OLED_GAMMA_100_TABLE,
-        LCD_OLED_GAMMA_130_TABLE,
-        LCD_OLED_GAMMA_160_TABLE,
-        LCD_OLED_GAMMA_190_TABLE,
-        LCD_OLED_GAMMA_220_TABLE,
-        LCD_OLED_GAMMA_250_TABLE
-};
-
-static int spi_write_via_i2c(unsigned char id, unsigned char data)
-{
-        qspi_send(0x0, id);
-        qspi_send(0x1, data);
-
-        return 0;
-}
-
-static int spi_write_seq_via_i2c(LCD_OLED_REG init_table[], unsigned size)
-{
-        int i;
-
-        for ( i=0; i<size; i++) {
-                spi_write_via_i2c(init_table[i].reg,
-                        init_table[i].value);
-                if (init_table[i].delay)
-                        mdelay(init_table[i].delay);
-        }
-
-        return 0 ;
-}
-
-#define INCREDIBLE_BRIGHTNESS_MAX_LEVEL            9
-
-int incredible_set_backlight_level(int level)
-{
-        static int toggle = 0;
-        int value[2] = {0x43, 0x34};
-        static int first = 1;
-
-        if(level < 0 || level > INCREDIBLE_BRIGHTNESS_MAX_LEVEL - 1)
-                return -1;
-        printk("incredible_set_backlight_level:%d\n", level);
-
-        if(first) {
-                spi_write_via_i2c(0x39, value[toggle]);
-                first = 0;
-        }
-        toggle = !toggle;
-        spi_write_seq_via_i2c(gamma_level_table[level],
-                ARRAY_SIZE(LCD_OLED_GAMMA_10_TABLE));
-        spi_write_via_i2c(0x39, value[toggle]);
-
-        return 0;
-}
-
-static DEFINE_MUTEX(led_value_set_lock);
-static void display_wake_up()
-{
-        mutex_lock(&led_value_set_lock);
-
-        qspi_send(0x0, 0x1d);
-        qspi_send(0x1, 0xa0);
-        msleep(200);
-        qspi_send(0x0, 0x14);
-        qspi_send(0x1, 0x3);
-        msleep(100);
-
-        mutex_unlock(&led_value_set_lock);
-}
-
-static void display_stand_by()
-{
-        mutex_lock(&led_value_set_lock);
-
-        qspi_send(0x0, 0x14);
-        qspi_send(0x1, 0x0);
-        msleep(100);
-        qspi_send(0x0, 0x1d);
-        qspi_send(0x1, 0xa1);
-        msleep(200);
-
-        mutex_unlock(&led_value_set_lock);
-}
-
-static int incredible_panel_unblank(struct msm_panel_data *panel_data)
-{
-/*
-        struct msm_mddi_panel_info *panel = container_of(panel_data,
-                struct msm_mddi_panel_info, panel_data);
-        struct msm_mddi_client_data *cdata;
-*/
-        printk("+%s()\n", __FUNCTION__);
-        display_wake_up();
-        printk("-%s()\n", __FUNCTION__);
-        return 0 ;
-}
-
-static int incredible_panel_blank(struct msm_panel_data *panel_data)
-{
-        printk("+%s()\n", __FUNCTION__);
-        display_stand_by();
-        printk("-%s()\n", __FUNCTION__);
-        return 0 ;
-}
-
-/*----------------------------------------------------------------------------*/
-#if 0
-static int samsung_oled_panel_blank(struct msm_lcdc_panel_ops *ops)
-{
-	pr_info("%s: +()\n", __func__);
-	lcm_writeb(0x14, 0x1);
-	msleep(200);
-	lcm_writeb(0x1d, 0xa1);
-	msleep(300);
-	pr_info("%s: -()\n", __func__);
-	return 0;
-}
-
-static int samsung_oled_panel_unblank(struct msm_lcdc_panel_ops *ops)
-{
-	pr_info("%s: +()\n", __func__);
-	lcm_writeb(0x1d, 0xa0);
-	msleep(200);
-	lcm_writeb(0x14, 0x03);
-	msleep(100);
-	pr_info("%s: -()\n", __func__);
-	return 0;
-}
-#endif
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-#if 0
-static struct {
-	uint8_t		reg;
-	uint8_t		val;
-	uint16_t	delay;
-} samsung_oled_init_table[] = {
-	{0x31, 0x08, 0},
-	{0x32, 0x14, 0},
-	{0x30, 0x2 , 0},
-	{0x27, 0x1 , 0},
-	{0x12, 0x8 , 0},
-	{0x13, 0x8 , 0},
-	{0x15, 0x0 , 0},
-	{0x16, 0x02, 0},
-	{0x39, 0x44, 0},
-	{0x17, 0x22, 0},
-	{0x18, 0x33, 0},
-	{0x19, 0x3 , 0},
-	{0x1A, 0x1 , 0},
-	{0x22, 0xA4, 0},
-	{0x23, 0x0 , 0},
-	{0x26, 0xA0, 0},
-	{0x1D, 0xA0, 250},
-};
-#endif
-
-static int samsung_oled_panel_init(struct msm_lcdc_panel_ops *ops)
-{
-	int i;
-
-#if 0
-	pr_info("%s: +()\n", __func__);
-	for (i = 0; i< ARRAY_SIZE(samsung_oled_init_table); i++) {
-		lcm_writeb(samsung_oled_init_table[i].reg,
-			   samsung_oled_init_table[i].val);
-		if (samsung_oled_init_table[i].delay)
-			mdelay(samsung_oled_init_table[i].delay);
-	}
-
-	lcm_writeb(0x14, 0x3);
-	pr_info("%s: -()\n", __func__);
-#endif
-
-	return 0;
-}
-
-static struct msm_lcdc_panel_ops incredible_lcdc_panel_ops = {
-	.init		= samsung_oled_panel_init,
-//	.blank		= samsung_oled_panel_blank,
-	.blank		= incredible_panel_blank,
-//	.unblank	= samsung_oled_panel_unblank,
-	.unblank	= incredible_panel_unblank,
-};
-
-static struct msm_lcdc_timing incredible_lcdc_timing = {
-		.clk_rate		= CLK_NS_TO_RATE(26),
-		.hsync_pulse_width	= 4,
-		.hsync_back_porch	= 8,
-		.hsync_front_porch	= 8,
-		.hsync_skew		= 0,
-		.vsync_pulse_width	= 2,
-		.vsync_back_porch	= 8,
-		.vsync_front_porch	= 8,
-		.vsync_act_low		= 1,
-		.hsync_act_low		= 1,
-		.den_act_low		= 1,
-};
-
-static struct msm_fb_data incredible_lcdc_fb_data = {
-		.xres		= 480,
-		.yres		= 800,
-		.width		= 48,
-		.height		= 80,
-		.output_format	= 0,
-};
-
-static struct msm_lcdc_platform_data incredible_lcdc_platform_data = {
-	.panel_ops	= &incredible_lcdc_panel_ops,
-	.timing		= &incredible_lcdc_timing,
-	.fb_id		= 0,
-	.fb_data	= &incredible_lcdc_fb_data,
-	.fb_resource	= &resources_msm_fb[0],
-};
-
-static struct platform_device incredible_lcdc_device = {
-	.name	= "msm_mdp_lcdc",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &incredible_lcdc_platform_data,
-	},
-};
-
-/*----------------------------------------------------------------------------*/
-static void set_brightness_work_func(struct work_struct *work)
-{
-        mutex_lock(&led_value_set_lock);
-        incredible_set_backlight_level(g_brightness_level);
-        mutex_unlock(&led_value_set_lock);
-        wake_unlock(&backlight_wakelock);
-}
-
-/*
-static struct msm_mdp_platform_data incredible_mdp_platform_data = {
-        .lcdc_data = &incredible_lcdc_platform_data,
-};
-*/
-
-void incredible_brightness_set(
-                struct led_classdev *led_cdev,
-                enum led_brightness value)
-{
-        static uint8_t last_level = INCREDIBLE_BRIGHTNESS_MAX_LEVEL;
-        uint8_t level = value * (INCREDIBLE_BRIGHTNESS_MAX_LEVEL - 1) / LED_FULL;
-
-        printk("+%s()\n", __FUNCTION__ );
-        mutex_lock(&led_value_set_lock);
-
-        if (level == last_level) {
-                mutex_unlock(&led_value_set_lock);
-                return;
-        }
-        wake_lock(&backlight_wakelock);
-        g_brightness_level = level;
-        last_level = level;
-        schedule_work(&work_set_brightness);
-
-        mutex_unlock(&led_value_set_lock);
-}
-
-static struct led_classdev incredible_backlight_led = {
-        .name = "lcd-backlight",
-        .brightness = LED_FULL,
-        .brightness_set = incredible_brightness_set,
-};
-
-static int incredible_backlight_probe(struct platform_device *pdev)
-{
-	int rc;
-
-	printk("+%s()\n", __FUNCTION__ );
-	rc = led_classdev_register(&pdev->dev, &incredible_backlight_led);
-	if(rc){
-		printk("backlight: failure on register led_classdev\n");
-	}
-	INIT_WORK(&work_set_brightness, set_brightness_work_func);
-	printk("-%s()\n", __FUNCTION__ );
-	return 0;
-}
-
-static int incredible_backlight_remove(struct platform_device *pdev)
-{
-        led_classdev_unregister(&incredible_backlight_led);
-        return 0;
-}
-
-static struct platform_device incredible_backlight = {
-        .name = "incredible-backlight",
-};
-
-static struct platform_driver incredible_backlight_driver = {
-        .probe          = incredible_backlight_probe,
-        .remove         = incredible_backlight_remove,
-        .driver         = {
-                .name           = "incredible-backlight",
-                .owner          = THIS_MODULE,
-        },
-};
-
-int __init incredible_init_panel(void)
-{
-	int ret;
-
-	if (!machine_is_incredible())
-		return 0;
-        wake_lock_init(&backlight_wakelock, WAKE_LOCK_SUSPEND,
-                "backlight_present");
-
-	//init mdp in device_initcall()
-	//ret = platform_device_register(&msm_device_mdp);
-	//if (ret != 0)
-	//	return ret;
-
-	ret = platform_device_register(&incredible_lcdc_device);
-	if (ret != 0)
-		return ret;
-        platform_device_register(&incredible_backlight);
-        ret = platform_driver_register(&incredible_backlight_driver);
-        if (ret)
-                return ret;
-
-	return 0;
-}
-
-/* we have to init mdp device followed by fb init,
- *  init mdp lately would cause some mdp operation malfunction  */
-int __init incredible_init_mdp(void)
-{
-        int ret;
-
-        if (!machine_is_incredible())
-                return 0;
-
-        ret = platform_device_register(&msm_device_mdp);
-        if (ret != 0)
-                return ret;
-
-        return 0;
-}
-
-
-device_initcall(incredible_init_mdp);
-
-late_initcall(incredible_init_panel);
diff --git a/arch/arm/mach-msm/board-incredible-rfkill.c b/arch/arm/mach-msm/board-incredible-rfkill.c
deleted file mode 100644
index 30aaf1e..0000000
--- a/arch/arm/mach-msm/board-incredible-rfkill.c
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for incredible platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-incredible.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-/* bt initial configuration */
-static uint32_t incredible_bt_init_table[] = {
-
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt on configuration */
-static uint32_t incredible_bt_on_table[] = {
-
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_RX, /* BT_RX */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt off configuration */
-static uint32_t incredible_bt_off_table[] = {
-
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_RTS, /* BT_RTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_UART1_TX, /* BT_TX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void incredible_config_bt_init(void)
-{
-	/* set bt initial configuration*/
-	config_bt_table(incredible_bt_init_table,
-				ARRAY_SIZE(incredible_bt_init_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(INCREDIBLE_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(INCREDIBLE_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(INCREDIBLE_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-
-}
-
-static void incredible_config_bt_on(void)
-{
-	/* set bt on configuration*/
-	config_bt_table(incredible_bt_on_table,
-				ARRAY_SIZE(incredible_bt_on_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(INCREDIBLE_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(INCREDIBLE_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-}
-
-static void incredible_config_bt_off(void)
-{
-	/* BT_SHUTDOWN_N */
-	gpio_configure(INCREDIBLE_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_RESET_N */
-	gpio_configure(INCREDIBLE_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(incredible_bt_off_table,
-				ARRAY_SIZE(incredible_bt_off_table));
-	mdelay(5);
-
-	/* BT_RTS */
-	gpio_configure(INCREDIBLE_GPIO_BT_UART1_RTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CTS */
-	gpio_configure(INCREDIBLE_GPIO_BT_UART1_CTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_TX */
-	gpio_configure(INCREDIBLE_GPIO_BT_UART1_TX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_RX */
-	gpio_configure(INCREDIBLE_GPIO_BT_UART1_RX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-
-	/* BT_HOST_WAKE */
-	gpio_configure(INCREDIBLE_GPIO_BT_HOST_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CHIP_WAKE */
-	gpio_configure(INCREDIBLE_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		incredible_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		incredible_config_bt_off();
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int incredible_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	incredible_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int incredible_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver incredible_rfkill_driver = {
-	.probe = incredible_rfkill_probe,
-	.remove = incredible_rfkill_remove,
-	.driver = {
-		.name = "incredible_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init incredible_rfkill_init(void)
-{
-	if (!machine_is_incredible())
-		return 0;
-
-	return platform_driver_register(&incredible_rfkill_driver);
-}
-
-static void __exit incredible_rfkill_exit(void)
-{
-	platform_driver_unregister(&incredible_rfkill_driver);
-}
-
-module_init(incredible_rfkill_init);
-module_exit(incredible_rfkill_exit);
-MODULE_DESCRIPTION("incredible rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-incredible.c b/arch/arm/mach-msm/board-incredible.c
deleted file mode 100644
index 2e75759..0000000
--- a/arch/arm/mach-msm/board-incredible.c
+++ /dev/null
@@ -1,942 +0,0 @@
-/* linux/arch/arm/mach-msm/board-incredible.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/cy8c_tmg_ts.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/usb/mass_storage_function.h>
-#include <linux/android_pmem.h>
-#include <linux/synaptics_t1007.h>
-#include <linux/input.h>
-#include <mach/h2w.h>
-#include <mach/audio_jack.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/setup.h>
-
-#include <mach/board.h>
-#include <mach/hardware.h>
-#include <mach/atmega_microp.h>
-#include <mach/camera.h>
-#include <mach/msm_hsusb.h>
-#include <mach/msm_iomap.h>
-#include <mach/htc_battery.h>
-#include <linux/spi/spi.h>
-
-#include "board-incredible.h"
-#include "devices.h"
-#include "proc_comm.h"
-#include <mach/msm_serial_hs.h>
-#include <mach/tpa6130.h>
-#include <mach/flashlight.h>
-#include <linux/proximity.h>
-
-void msm_init_pmic_vibrator(void);
-extern void __init incredible_audio_init(void);
-
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.gpio_mbat_in = INCREDIBLE_GPIO_MBAT_IN,
-	.gpio_mchg_en_n = INCREDIBLE_GPIO_MCHG_EN_N,
-	.gpio_iset = INCREDIBLE_GPIO_ISET,
-	.guage_driver = GUAGE_MODEM,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = 0,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0x005, 0x00A, 0x00F, 0x01E, 0x03C, 0x121, 0x205, 0x2BA, 0x26E, 0x3FF },
-		.channel = 3,
-		.int_pin = 1 << 9,
-		.mask_w = {0x00, 0x00, 0x04},
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 0, 0, 19, 51<<8 | 98, 141<<8 | 196},
-		.channel = 1,
-		.int_pin = 1 << 5,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "reset-int",
-		.category = MICROP_FUNCTION_RESET_INT,
-		.int_pin = 1 << 8,
-	},
-	{
-		.name   = "oj",
-		.category = MICROP_FUNCTION_OJ,
-		.int_pin = 1 << 12,
-	},
-	{
-		.name   = "proximity",
-		.category = MICROP_FUNCTION_P,
-		.int_pin = 1 << 11,
-		.mask_r = {0x00, 0x00, 0x10},
-		.mask_w = {0x00, 0x00, 0x04},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.gpio_reset = INCREDIBLE_GPIO_UP_RESET_N,
-	.microp_ls_on = LS_PWR_ON | PS_PWR_ON,
-	.spi_devices = SPI_OJ | SPI_GSENSOR,
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct platform_device microp_leds = {
-	.name		= "leds-microp",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &microp_leds_data,
-	},
-};
-
-#ifdef CONFIG_USB_FUNCTION
-static char *incredible_usb_functions[] = {
-#if defined(CONFIG_USB_FUNCTION_MASS_STORAGE) || defined(CONFIG_USB_FUNCTION_UMS)
-	"usb_mass_storage",
-#endif
-#ifdef CONFIG_USB_FUNCTION_ADB
-	"adb",
-#endif
-#if defined(CONFIG_USB_FUNCTION_DIAG)
-	"diag",
-#endif
-#if defined(CONFIG_USB_FUNCTION_ETHER)
-	"ether",
-#endif
-
-
-};
-
-static struct msm_hsusb_product incredible_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c9d,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id = 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id = 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-	
-};
-#endif
-
-static int incredible_phy_init_seq[] = { 0x1D, 0x0D, 0x1D, 0x10, -1 };
-
-static struct msm_hsusb_platform_data msm_hsusb_pdata = {
-	.phy_init_seq		= incredible_phy_init_seq,
-	.vendor_id		= 0x0bb4,
-	.product_id		= 0x0c02,
-	.version		= 0x0100,
-	.product_name		= "Android Phone",
-	.serial_number		= "42",
-	.manufacturer_name	= "HTC",
-
-	.functions		= incredible_usb_functions,
-	.num_functions		= ARRAY_SIZE(incredible_usb_functions),
-	.products		= incredible_usb_products,
-	.num_products		= ARRAY_SIZE(incredible_usb_products),
-};
-
-static struct usb_mass_storage_platform_data mass_storage_pdata = {
-	.nluns		= 1,
-	.buf_size	= 16384,
-	.vendor		= "Google",
-	.product	= "incredible",
-	.release	= 0x0100,
-};
-
-static struct platform_device usb_mass_storage_device = {
-	.name	= "usb_mass_storage",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &mass_storage_pdata,
-	},
-};
-
-static struct platform_device incredible_rfkill = {
-	.name = "incredible_rfkill",
-	.id = -1,
-};
-
-static struct resource qsd_spi_resources[] = {
-	{
-		.name   = "spi_irq_in",
-		.start  = INT_SPI_INPUT,
-		.end    = INT_SPI_INPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_out",
-		.start  = INT_SPI_OUTPUT,
-		.end    = INT_SPI_OUTPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_err",
-		.start  = INT_SPI_ERROR,
-		.end    = INT_SPI_ERROR,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_base",
-		.start  = 0xA1200000,
-		.end    = 0xA1200000 + SZ_4K - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.name   = "spi_clk",
-		.start  = 17,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_mosi",
-		.start  = 18,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_miso",
-		.start  = 19,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_cs0",
-		.start  = 20,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_pwr",
-		.start  = 21,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_cs0",
-		.start  = 22,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device qsd_device_spi = {
-	.name           = "spi_qsd",
-	.id             = 0,
-	.num_resources  = ARRAY_SIZE(qsd_spi_resources),
-	.resource       = qsd_spi_resources,
-};
-
-static struct resource msm_kgsl_resources[] = {
-	{
-		.name	= "kgsl_reg_memory",
-		.start	= MSM_GPU_REG_PHYS,
-		.end	= MSM_GPU_REG_PHYS + MSM_GPU_REG_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "kgsl_phys_memory",
-		.start	= MSM_GPU_MEM_BASE,
-		.end	= MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_GRAPHICS,
-		.end	= INT_GRAPHICS,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device msm_kgsl_device = {
-	.name		= "kgsl",
-	.id		= -1,
-	.resource	= msm_kgsl_resources,
-	.num_resources	= ARRAY_SIZE(msm_kgsl_resources),
-};
-
-static struct android_pmem_platform_data mdp_pmem_pdata = {
-	.name		= "pmem",
-	.start		= MSM_PMEM_MDP_BASE,
-	.size		= MSM_PMEM_MDP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu0_pdata = {
-	.name		= "pmem_gpu0",
-	.start		= MSM_PMEM_GPU0_BASE,
-	.size		= MSM_PMEM_GPU0_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu1_pdata = {
-	.name		= "pmem_gpu1",
-	.start		= MSM_PMEM_GPU1_BASE,
-	.size		= MSM_PMEM_GPU1_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct android_pmem_platform_data android_pmem_adsp_pdata = {
-	.name		= "pmem_adsp",
-	.start		= MSM_PMEM_ADSP_BASE,
-	.size		= MSM_PMEM_ADSP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-
-static struct android_pmem_platform_data android_pmem_camera_pdata = {
-	.name		= "pmem_camera",
-	.start		= MSM_PMEM_CAMERA_BASE,
-	.size		= MSM_PMEM_CAMERA_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct platform_device android_pmem_mdp_device = {
-	.name		= "android_pmem",
-	.id		= 0,
-	.dev		= {
-		.platform_data = &mdp_pmem_pdata
-	},
-};
-
-static struct platform_device android_pmem_gpu0_device = {
-	.name		= "android_pmem",
-	.id		= 2,
-	.dev		= {
-		.platform_data = &android_pmem_gpu0_pdata,
-	},
-};
-
-static struct platform_device android_pmem_gpu1_device = {
-	.name		= "android_pmem",
-	.id		= 3,
-	.dev		= {
-		.platform_data = &android_pmem_gpu1_pdata,
-	},
-};
-
-static struct platform_device android_pmem_adsp_device = {
-	.name		= "android_pmem",
-	.id		= 4,
-	.dev		= {
-		.platform_data = &android_pmem_adsp_pdata,
-	},
-};
-
-static struct platform_device android_pmem_camera_device = {
-	.name		= "android_pmem",
-	.id		= 5,
-	.dev		= {
-		.platform_data = &android_pmem_camera_pdata,
-	},
-};
-
-static struct synaptics_virtual_key synaptics_virt_keys[] = {
-	{
-		.keycode = KEY_HOME,
-		.range_min = 50,
-		.range_max = 700,
-	},
-	{
-		.keycode = KEY_MENU,
-		.range_min = 1250,
-		.range_max = 1900,
-	},
-	{
-		.keycode = KEY_BACK,
-		.range_min = 2350,
-		.range_max = 3000,
-	},
-	{
-		.keycode = KEY_COMPOSE,
-		.range_min = 3350,
-		.range_max = 4000,
-	},
-};
-
-static struct resource ram_console_resources[] = {
-	{
-		.start	= MSM_RAM_CONSOLE_BASE,
-		.end	= MSM_RAM_CONSOLE_BASE + MSM_RAM_CONSOLE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device ram_console_device = {
-	.name		= "ram_console",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(ram_console_resources),
-	.resource	= ram_console_resources,
-};
-
-static int incredible_ts_power(int on)
-{
-	pr_info("%s: power %d\n", __func__, on);
-
-	if (on) {
-		/* level shifter should be off */
-		gpio_set_value(INCREDIBLE_GPIO_TP_EN, 1);
-		msleep(120);
-		/* enable touch panel level shift */
-		//gpio_set_value(INCREDIBLE_GPIO_TP_LS_EN, 1);
-		msleep(3);
-	} else {
-		//gpio_set_value(INCREDIBLE_GPIO_TP_LS_EN, 0);
-		gpio_set_value(INCREDIBLE_GPIO_TP_EN, 0);
-		udelay(50);
-	}
-
-	return 0;
-}
-
-static int incredible_atmel_ts_power(int on)
-{
-	printk(KERN_INFO "incredible_atmel_ts_power(%d)\n", on);
-	if (on) {
-		//gpio_set_value(FIRESTONE_TP_LS_EN, 0);
-		//gpio_set_value(93, 1);
-		//gpio_set_value(98, 0);
-		//msleep(120);
-		gpio_set_value(98, 1);
-		msleep(200);
-		/* enable touch panel level shift */
-		//gpio_set_value(FIRESTONE_TP_LS_EN, 1);
-		gpio_set_value(34, 1);
-		msleep(200);
-		gpio_set_value(145, 1);
-		msleep(100);		
-		gpio_set_value(98, 0);
-		msleep(100);		
-		gpio_set_value(98, 1);
-		msleep(300);
-	} else {
-		//gpio_set_value(FIRESTONE_TP_LS_EN, 0);
-		gpio_set_value(98, 0);
-		msleep(200);
-	}
-	return 0;
-}
-
-static struct synaptics_i2c_rmi_platform_data incredible_ts_data[] = {
-	{
-		.version = 0x0100,
-		.power = incredible_ts_power,
-		.virtual_key = synaptics_virt_keys,
-		.virtual_key_num = ARRAY_SIZE(synaptics_virt_keys),
-		.sensitivity = 10,
-		.gap_area = 280 * 0x10000 / 8040,
-		.key_area = 120 * 0x10000 / 8040,
-		.flags = SYNAPTICS_FLIP_Y  | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = -80 * 0x10000 / 4824,
-		.inactive_right = -80 * 0x10000 / 4824,
-		.inactive_top = -100 * 0x10000 / 8040,
-		.inactive_bottom = -10 * 0x10000 / 8040,
-		.snap_left_on = 80 * 0x10000 / 4824,
-		.snap_left_off = 90 * 0x10000 / 4824,
-		.snap_right_on = 80 * 0x10000 / 4824,
-		.snap_right_off = 90 * 0x10000 / 4824,
-		.snap_top_on = 100 * 0x10000 / 8040,
-		.snap_top_off = 110 * 0x10000 / 8040,
-		.snap_bottom_on = 120 * 0x10000 / 8040,
-		.snap_bottom_off = 140 * 0x10000 / 8040,
-	},
-};
-
-struct cy8c_i2c_platform_data incredible_cy8c_ts_data = {
-	.version = 0x0001,
-	.abs_x_min = 0,
-	.abs_x_max = 479,
-	.abs_y_min = 0,
-	.abs_y_max = 799,
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-	.abs_width_min = 0,
-	.abs_width_max = 10,
-	.power = incredible_ts_power,
-};
-
-struct cy8c_i2c_platform_data incredible_atmel_ts_data = {
-	.version = 0x0001,
-	.abs_x_min = 0,
-	//.abs_x_max = 255,
-	.abs_x_max = 1023,
-	.abs_y_min = 0,
-	//.abs_y_max = 255,
-	.abs_y_max = 1023,
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-	.abs_width_min = 0,
-	.abs_width_max = 10,
-	.power = incredible_atmel_ts_power,
-};
-
-static struct h2w_platform_data incredible_h2w_data = {
-
-};
-
-static struct platform_device incredible_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &incredible_h2w_data,
-	},
-};
-
-#if 0
-
-static struct audio_jack_platform_data incredible_jack_data = {
-	.gpio	= INCREDIBLE_GPIO_35MM_HEADSET_DET,
-};
-
-static struct platform_device incredible_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &incredible_jack_data,
-	},
-};
-#endif
-
-static struct akm8973_platform_data compass_platform_data = {
-	.reset = INCREDIBLE_GPIO_COMPASS_RST_N,
-	.intr = INCREDIBLE_GPIO_COMPASS_INT_N,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(SYNAPTICS_T1007_NAME, 0x40),
-		.platform_data = &incredible_ts_data,
-		.irq = MSM_GPIO_TO_INT(INCREDIBLE_GPIO_TP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = MSM_GPIO_TO_INT(INCREDIBLE_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO("ds2482", 0x30 >> 1),
-		//.platform_data = &microp_data,
-		//.irq = MSM_GPIO_TO_INT(PASSION_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO("cy8c-tmg-ts", 0x34),
-		.platform_data = &incredible_cy8c_ts_data,
-		.irq = MSM_GPIO_TO_INT(INCREDIBLE_GPIO_TP_INT_N),
-	},
-	{
-		I2C_BOARD_INFO("akm8973", 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = MSM_GPIO_TO_INT(INCREDIBLE_GPIO_COMPASS_INT_N),
-	},
-#ifdef CONFIG_MSM_CAMERA
-#ifdef CONFIG_S5K3E2FX
-	{
-		I2C_BOARD_INFO("s5k3e2fx", 0x20 >> 1),
-	},
-#endif
-#endif/*CONIFIG_MSM_CAMERA*/
-
-	{
-		I2C_BOARD_INFO("ATMEL_QT602240", 0x4a),
-		.platform_data = &incredible_atmel_ts_data,
-		.irq = MSM_GPIO_TO_INT(145)
-	},
-	{
-		I2C_BOARD_INFO(TPA6130_I2C_NAME, 0xC0 >> 1),
-	},
-
-};
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_16MA), /* MCLK */
-};
-
-static void config_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-static void config_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		 INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_camera_on_gpios,
-	.camera_gpio_off = config_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-
-static struct msm_camera_sensor_info msm_camera_sensor_s5k3e2fx_data = {
-	.sensor_name    = "s5k3e2fx",
-	.sensor_reset	= 144, /* CAM1_RST */
-	.sensor_pwd	= 143,  /* CAM1_PWDN, enabled in a9 */
-	/*.vcm_pwd      = 31, */  /* CAM1_VCM_EN, enabled in a9 */
-	.pdata		= &msm_camera_device_data,
-	.resource = msm_camera_resources,
-	.num_resources = ARRAY_SIZE(msm_camera_resources),
-	.camera_flash = flashlight_control,
-	.num_flash_levels = FLASHLIGHT_NUM,
-};
-
-static struct platform_device msm_camera_sensor_s5k3e2fx = {
-	.name		= "msm_camera_s5k3e2fx",
-	.dev		= {
-	.platform_data = &msm_camera_sensor_s5k3e2fx_data,
-	},
-};
-
-
-static uint32_t flashlight_gpio_table[] = {
-	PCOM_GPIO_CFG(INCREDIBLE_FLASHLIGHT_TORCH_EN, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLE_FLASHLIGHT_FLASH_EN, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-
-};
-
-static int config_incredible_flashlight_gpios(void)
-{
-	config_gpio_table(flashlight_gpio_table,
-		ARRAY_SIZE(flashlight_gpio_table));
-	return 0;
-}
-
-static struct flashlight_platform_data incredible_flashlight_data = {
-	.gpio_init  = config_incredible_flashlight_gpios,
-	.torch = INCREDIBLE_FLASHLIGHT_TORCH_EN,
-	.flash = INCREDIBLE_FLASHLIGHT_FLASH_EN,
-	.flash_duration_ms = 600,
-};
-
-static struct platform_device incredible_flashlight_device = {
-	.name = FLASHLIGHT_NAME,
-	.dev		= {
-		.platform_data	= &incredible_flashlight_data,
-	},
-};
-
-static struct platform_device incredible_g_sensor = {
-	.name		= BMA150_G_SENSOR_NAME,
-};
-
-static struct proximity_platform_data passion_proximity_data = {
-	.intr = PASSION_PROXIMITY_INT_N,
-	.enable = PASSION_PROXIMITY_POWER_N,
-};
-
-static struct platform_device passion_proximity_device = {
-	.name = "proximity_sensor",
-	.dev		= {
-		.platform_data	= &passion_proximity_data,
-	},
-};
-static struct platform_device *devices[] __initdata = {
-#if !defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	&msm_device_uart1,
-#endif
-#ifdef CONFIG_SERIAL_MSM_HS
-	&msm_device_uart_dm1,
-#endif
-	&incredible_h2w,
-	&htc_battery_pdev,
-	//&passion_audio_jack,
-	&ram_console_device,
-	&incredible_rfkill,
-	&msm_device_smd,
-	&msm_device_nand,
-	&msm_device_hsusb,
-	&usb_mass_storage_device,
-	&android_pmem_mdp_device,
-	&android_pmem_gpu0_device,
-	&android_pmem_gpu1_device,
-	&android_pmem_adsp_device,
-	&android_pmem_camera_device,
-	&incredible_g_sensor,
-#ifdef CONFIG_MSM_CAMERA
-#ifdef CONFIG_S5K3E2FX
-	&msm_camera_sensor_s5k3e2fx,
-#endif
-#endif
-	&msm_kgsl_device,
-	&msm_device_i2c,
-#ifdef CONFIG_ARCH_QSD8X50
-	&msm_audio_device,
-#endif
-	&incredible_flashlight_device,
-
-#if defined(CONFIG_SPI_QSD)
-	&qsd_device_spi,
-#endif
-	&passion_proximity_device,
-	&microp_leds,
-};
-
-
-static uint32_t incredible_serial_debug_table[] = {
-	/* for uart debugger. It should be removed when support usb to serial function */
-	/* RX */
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_UART3_RX, 3, GPIO_INPUT, GPIO_NO_PULL,
-		      GPIO_4MA),
-	/* TX , note here set GPIO to input!!! */
-	PCOM_GPIO_CFG(INCREDIBLE_GPIO_UART3_TX, 3, GPIO_INPUT, GPIO_NO_PULL,
-		      GPIO_4MA),
-};
-
-static void incredible_config_serial_debug_gpios(void)
-{
-	config_gpio_table(incredible_serial_debug_table, ARRAY_SIZE(incredible_serial_debug_table));
-}
-
-#ifdef CONFIG_QSD_SVS
-#define TPS65023_MAX_DCDC1	1600
-#else
-#define TPS65023_MAX_DCDC1	CONFIG_QSD_PMIC_DEFAULT_DCDC1
-#endif
-extern int tps65023_set_dcdc1_level(int mvolts);
-
-static int qsd8x50_tps65023_set_dcdc1(int mVolts)
-{
-	int rc = 0;
-#ifdef CONFIG_QSD_SVS
-	rc = tps65023_set_dcdc1_level(mVolts);
-	/* By default the TPS65023 will be initialized to 1.225V.
-	 * So we can safely switch to any frequency within this
-	 * voltage even if the device is not probed/ready.
-	 */
-	if (rc == -ENODEV && mVolts <= CONFIG_QSD_PMIC_DEFAULT_DCDC1)
-		rc = 0;
-#else
-	/* Disallow frequencies not supported in the default PMIC
-	 * output voltage.
-	 */
-	if (mVolts > CONFIG_QSD_PMIC_DEFAULT_DCDC1)
-		rc = -EFAULT;
-#endif
-	return rc;
-}
-
-static struct msm_acpu_clock_platform_data incredible_clock_data = {
-	.acpu_switch_time_us	= 20,
-	.max_speed_delta_khz	= 256000,
-	.vdd_switch_time_us	= 62,
-	.power_collapse_khz	= 128000000,
-	.wait_for_irq_khz	= 128000000,
-	.max_vdd = TPS65023_MAX_DCDC1,
-	.acpu_set_vdd = qsd8x50_tps65023_set_dcdc1,
-};
-
-int incredible_init_mmc(int sysrev);
-void msm_serial_debug_init(unsigned int base, int irq,
-			   struct device *clk_device, int signal_irq);
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	/* Chip to Device */
-	.wakeup_irq = MSM_GPIO_TO_INT(INCREDIBLE_GPIO_BT_HOST_WAKE),
-	.inject_rx_on_wakeup = 0,
-	.cpu_lock_supported = 0,
-
-	/* for bcm */
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = INCREDIBLE_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = INCREDIBLE_GPIO_BT_HOST_WAKE,
-
-};
-#endif
-
-static void __init incredible_init(void)
-{
-	int ret;
-
-	printk("incredible_init() revision=%d\n", system_rev);
-
-	msm_acpu_clock_init(&incredible_clock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	msm_serial_debug_init(MSM_UART1_PHYS, INT_UART1,
-			      &msm_device_uart1.dev, 1);
-#endif
-
-	#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_device_uart_dm1.name = "msm_serial_hs_bcm";	/* for bcm */
-	#endif
-
-	incredible_config_serial_debug_gpios();
-
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-	//gpio_direction_output(INCREDIBLE_GPIO_TP_LS_EN, 0);
-	gpio_direction_output(INCREDIBLE_GPIO_TP_EN, 0);
-
-	incredible_audio_init();
-
-	msm_device_hsusb.dev.platform_data = &msm_hsusb_pdata;
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	msm_hsusb_set_vbus_state(1);
-
-	ret = incredible_init_mmc(system_rev);
-	if (ret != 0)
-		pr_crit("%s: Unable to initialize MMC\n", __func__);
-
-	msm_init_pmic_vibrator();
-}
-
-static void __init incredible_fixup(struct machine_desc *desc, struct tag *tags,
-				 char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 1;
-	mi->bank[0].start = PHYS_OFFSET;
-	mi->bank[0].node = PHYS_TO_NID(PHYS_OFFSET);
-	mi->bank[0].size = (101*1024*1024);
-}
-
-static void __init incredible_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-	qsd_audio_device_init();
-}
-
-extern struct sys_timer msm_timer;
-
-MACHINE_START(INCREDIBLE, "incredible")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params	= 0x20000100,
-	.fixup		= incredible_fixup,
-	.map_io		= incredible_map_io,
-	.init_irq	= msm_init_irq,
-	.init_machine	= incredible_init,
-	.timer		= &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-incredible.h b/arch/arm/mach-msm/board-incredible.h
deleted file mode 100644
index 4322dcf..0000000
--- a/arch/arm/mach-msm/board-incredible.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/* arch/arm/mach-msm/board-incredible.h
- *
- * Copyright (C) 2009 HTC Corporation.
- * Author: Haley Teng <Haley_Teng@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_INCREDIBLE_H
-#define __ARCH_ARM_MACH_MSM_BOARD_INCREDIBLE_H
-
-#include <mach/board.h>
-
-#define MSM_SMI_BASE		0x02B00000
-#define MSM_SMI_SIZE		0x01500000
-
-#define MSM_PMEM_MDP_BASE	0x03000000
-#define MSM_PMEM_MDP_SIZE	0x01000000
-
-#define MSM_EBI1_BASE		0x20000000
-#define MSM_EBI1_SIZE		0x0E000000
-
-#define MSM_PMEM_GPU0_BASE	0x2C300000
-#define MSM_PMEM_GPU0_SIZE	0x01000000
-
-#define MSM_PMEM_GPU1_BASE	0x2D300000
-#define MSM_PMEM_GPU1_SIZE	0x00800000
-
-#define MSM_GPU_MEM_BASE	0x2DB00000
-#define MSM_GPU_MEM_SIZE	0x00200000
-
-#define MSM_RAM_CONSOLE_BASE	0x2DD00000
-#define MSM_RAM_CONSOLE_SIZE	0x00040000
-
-#define MSM_FB_BASE		0x2DE00000
-#define MSM_FB_SIZE		0x00200000
-
-#define MSM_PMEM_CAMERA_SIZE	0x01000000
-#define MSM_PMEM_CAMERA_BASE	MSM_PMEM_GPU0_BASE - MSM_PMEM_CAMERA_SIZE
-
-#define MSM_PMEM_ADSP_SIZE	0x00800000
-#define MSM_PMEM_ADSP_BASE  MSM_PMEM_CAMERA_BASE - MSM_PMEM_ADSP_SIZE
-
-
-#define INCREDIBLE_GPIO_UP_INT_N		35
-#define INCREDIBLE_GPIO_UP_RESET_N	108
-
-#define INCREDIBLE_GPIO_TP_INT_N		145
-//#define INCREDIBLE_GPIO_TP_LS_EN		93
-#define INCREDIBLE_GPIO_TP_EN			98
-
-#define INCREDIBLE_GPIO_POWER_KEY		94
-#define INCREDIBLE_GPIO_SDMC_CD_N		141
-
-#define INCREDIBLE_GPIO_BT_UART1_RTS	43
-#define INCREDIBLE_GPIO_BT_UART1_CTS	44
-#define INCREDIBLE_GPIO_BT_UART1_RX	45
-#define INCREDIBLE_GPIO_BT_UART1_TX	46
-#define INCREDIBLE_GPIO_BT_RESET_N	146
-#define INCREDIBLE_GPIO_BT_SHUTDOWN_N	128
-#define INCREDIBLE_GPIO_BT_HOST_WAKE	86
-#define INCREDIBLE_GPIO_BT_CHIP_WAKE	87
-
-/* serial debugger */
-#define INCREDIBLE_GPIO_UART3_RX 139
-#define INCREDIBLE_GPIO_UART3_TX 140
-
-#define INCREDIBLE_GPIO_COMPASS_RST_N	107
-#define INCREDIBLE_GPIO_COMPASS_INT_N	36
-
-/* Battery */
-#define INCREDIBLE_GPIO_MBAT_IN		39
-#define INCREDIBLE_GPIO_MCHG_EN_N	22
-#define INCREDIBLE_GPIO_ISET		16
-
-/*Audio */
-#define INCREDIBLE_AUD_JACKHP_EN	157
-
-/* Bluetooth PCM */
-#define INCREDIBLE_BT_PCM_OUT		68
-#define INCREDIBLE_BT_PCM_IN		69
-#define INCREDIBLE_BT_PCM_SYNC		70
-#define INCREDIBLE_BT_PCM_CLK		71
-
-#define INCREDIBLE_MENU_KEY   40
-#define INCREDIBLE_VOLUME_UP     41
-#define INCREDIBLE_VOLUME_DOWN   42
-#define INCREDIBLE_POWER_KEY     94
-
-/* flashlight */
-#define INCREDIBLE_FLASHLIGHT_TORCH_EN	(85)
-#define INCREDIBLE_FLASHLIGHT_FLASH_EN	(84)
-#define INCREDIBLE_FLASHLIGHT_FLASH_ADJ	(31)
-
-#endif /* __ARCH_ARM_MACH_MSM_BOARD_INCREDIBLE_H */
diff --git a/arch/arm/mach-msm/board-incrediblec-audio.c b/arch/arm/mach-msm/board-incrediblec-audio.c
deleted file mode 100644
index 60b0c55..0000000
--- a/arch/arm/mach-msm/board-incrediblec-audio.c
+++ /dev/null
@@ -1,294 +0,0 @@
-/* arch/arm/mach-msm/board-incrediblec-audio.c
- *
- * Copyright (C) 2009 HTC Corporation
- * Copyright (C) 2009 Google Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/gpio.h>
-#include <linux/delay.h>
-#include <mach/msm_qdsp6_audio.h>
-#include <mach/htc_acoustic_qsd.h>
-#include <mach/tpa6130.h>
-
-#include "board-incrediblec.h"
-#include "proc_comm.h"
-#include "pmic.h"
-
-#if 1
-#define D(fmt, args...) printk(KERN_INFO "Audio: "fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-static struct mutex mic_lock;
-static struct mutex bt_sco_lock;
-static int headset_status = 0;
-
-struct q6_gain_info {
-        int max_step;
-        int gain[10];
-};
-
-static struct q6_gain_info q6_audio_hw[Q6_HW_COUNT] = {
-	[Q6_HW_HANDSET] = {
-		.max_step = 6,
-		.gain = {-1600, -1300, -1000, -600, -300, 0, 0, 0, 0, 0},
-	},
-	[Q6_HW_HEADSET] = {
-		.max_step = 6,
-		.gain = {-2000, -1600, -1200, -800, -400, 0, 0, 0, 0, 0},
-	},
-	[Q6_HW_SPEAKER] = {
-		.max_step = 6,
-		.gain = {-1500, -1200, -900, -600, -300, 0, 0, 0, 0, 0},
-	},
-	[Q6_HW_TTY] = {
-		.max_step = 6,
-		.gain = {-2000, -1600, -1200, -800, -400, 0, 0, 0, 0, 0},
-	},
-	[Q6_HW_BT_SCO] = {
-		.max_step = 6,
-		.gain = {-2000, -1600, -1200, -800, -400, 0, 0, 0, 0, 0},
-	},
-	[Q6_HW_BT_A2DP] = {
-		.max_step = 6,
-		.gain = {-2000, -1600, -1200, -800, -400, 0, 0, 0, 0, 0},
-	},
-};
-
-void incrediblec_headset_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-        /* enable audio amp */
-	if (en != headset_status) {
-		headset_status = en;
-		if(en) {
-			gpio_set_value(INCREDIBLEC_AUD_JACKHP_EN, 1);
-			mdelay(10);
-			set_headset_amp(1);
-		} else {
-			set_headset_amp(0);
-			gpio_set_value(INCREDIBLEC_AUD_JACKHP_EN, 0);
-		}
-	}
-}
-
-void incrediblec_speaker_enable(int en)
-{
-	struct spkr_config_mode scm;
-	memset(&scm, 0, sizeof(scm));
-
-	D("%s %d\n", __func__, en);
-	if (en) {
-		mdelay(30);
-		scm.is_right_chan_en = 0;
-		scm.is_left_chan_en = 1;
-		scm.is_stereo_en = 0;
-		scm.is_hpf_en = 1;
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-		pmic_spkr_en_mute(RIGHT_SPKR, 0);
-		pmic_set_spkr_configuration(&scm);
-		pmic_spkr_en(LEFT_SPKR, 1);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		/* unmute */
-		pmic_spkr_en_mute(LEFT_SPKR, 1);
-	} else {
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-
-		pmic_spkr_en(LEFT_SPKR, 0);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		pmic_set_spkr_configuration(&scm);
-	}
-	mdelay(10);
-}
-
-void incrediblec_receiver_enable(int en)
-{
-	/* After XC */
-	if (system_rev >= 2) {
-		struct spkr_config_mode scm;
-		memset(&scm, 0, sizeof(scm));
-
-		D("%s %d\n", __func__, en);
-		if (en) {
-			mdelay(30);
-			scm.is_right_chan_en = 1;
-			scm.is_left_chan_en = 0;
-			scm.is_stereo_en = 0;
-			scm.is_hpf_en = 1;
-			pmic_spkr_en_mute(LEFT_SPKR, 0);
-			pmic_spkr_en_mute(RIGHT_SPKR, 0);
-			pmic_set_spkr_configuration(&scm);
-			pmic_spkr_en(LEFT_SPKR, 0);
-			pmic_spkr_en(RIGHT_SPKR, 1);
-
-			/* unmute */
-			pmic_spkr_en_mute(RIGHT_SPKR, 1);
-		} else {
-			pmic_spkr_en_mute(RIGHT_SPKR, 0);
-
-			pmic_spkr_en(LEFT_SPKR, 0);
-			pmic_spkr_en(RIGHT_SPKR, 0);
-
-			pmic_set_spkr_configuration(&scm);
-		}
-		mdelay(10);
-	}
-}
-
-static uint32_t bt_sco_enable[] = {
-	PCOM_GPIO_CFG(INCREDIBLEC_BT_PCM_OUT, 1, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_BT_PCM_IN, 1, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_BT_PCM_SYNC, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_BT_PCM_CLK, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-static uint32_t bt_sco_disable[] = {
-	PCOM_GPIO_CFG(INCREDIBLEC_BT_PCM_OUT, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_BT_PCM_IN, 0, GPIO_INPUT,
-			GPIO_PULL_UP, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_BT_PCM_SYNC, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_BT_PCM_CLK, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-void incrediblec_bt_sco_enable(int en)
-{
-	static int bt_sco_refcount;
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&bt_sco_lock);
-	if (en) {
-		if (++bt_sco_refcount == 1)
-			config_gpio_table(bt_sco_enable,
-					ARRAY_SIZE(bt_sco_enable));
-	} else {
-		if (--bt_sco_refcount == 0) {
-			config_gpio_table(bt_sco_disable,
-					ARRAY_SIZE(bt_sco_disable));
-			gpio_set_value(INCREDIBLEC_BT_PCM_OUT, 0);
-			gpio_set_value(INCREDIBLEC_BT_PCM_SYNC, 0);
-			gpio_set_value(INCREDIBLEC_BT_PCM_CLK, 0);
-		}
-	}
-	mutex_unlock(&bt_sco_lock);
-}
-
-void incrediblec_int_mic_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	if (en)
-		pmic_mic_en(ON_CMD);
-	else
-		pmic_mic_en(OFF_CMD);
-}
-
-void incrediblec_ext_mic_enable(int en)
-{
-	static int old_state = 0, new_state = 0;
-
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&mic_lock);
-	if (!!en)
-		new_state++;
-	else
-		new_state--;
-
-	if (new_state == 1 && old_state == 0)
-		gpio_set_value(INCREDIBLEC_AUD_2V5_EN, 1);
-	else if (new_state == 0 && old_state == 1)
-		gpio_set_value(INCREDIBLEC_AUD_2V5_EN, 0);
-	else
-		D("%s: do nothing %d %d\n", __func__, old_state, new_state);
-
-	old_state = new_state;
-	mutex_unlock(&mic_lock);
-}
-
-void incrediblec_analog_init(void)
-{
-	D("%s\n", __func__);
-	/* stereo pmic init */
-	pmic_spkr_set_gain(LEFT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_set_gain(RIGHT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_en_right_chan(OFF_CMD);
-	pmic_spkr_en_left_chan(OFF_CMD);
-	pmic_spkr_add_right_left_chan(OFF_CMD);
-	pmic_spkr_en_stereo(OFF_CMD);
-	pmic_spkr_select_usb_with_hpf_20hz(OFF_CMD);
-	pmic_spkr_bypass_mux(OFF_CMD);
-	pmic_spkr_en_hpf(ON_CMD);
-	pmic_spkr_en_sink_curr_from_ref_volt_cir(OFF_CMD);
-	pmic_spkr_set_mux_hpf_corner_freq(SPKR_FREQ_0_73KHZ);
-	pmic_mic_set_volt(MIC_VOLT_1_80V);
-	pmic_set_speaker_delay(SPKR_DLY_100MS);
-
-	gpio_direction_output(INCREDIBLEC_AUD_JACKHP_EN, 1);
-	gpio_set_value(INCREDIBLEC_AUD_JACKHP_EN, 0);
-
-	mutex_lock(&bt_sco_lock);
-	config_gpio_table(bt_sco_disable,
-			ARRAY_SIZE(bt_sco_disable));
-	gpio_set_value(INCREDIBLEC_BT_PCM_OUT, 0);
-	mutex_unlock(&bt_sco_lock);
-}
-
-int incrediblec_get_rx_vol(uint8_t hw, int level)
-{
-	struct q6_gain_info *info;
-	int vol;
-
-	info = &q6_audio_hw[hw];
-
-	level = (level > 100)? 100 : ((level < 0) ? 0 : level);
-	vol = info->gain[(uint32_t)((info->max_step - 1) * level / 100)];
-
-	D("%s %d\n", __func__, vol);
-	return vol;
-}
-
-static struct qsd_acoustic_ops acoustic = {
-	.enable_mic_bias = incrediblec_ext_mic_enable,
-};
-
-static struct q6audio_analog_ops ops = {
-	.init = incrediblec_analog_init,
-	.speaker_enable = incrediblec_speaker_enable,
-	.headset_enable = incrediblec_headset_enable,
-	.receiver_enable = incrediblec_receiver_enable,
-	.bt_sco_enable = incrediblec_bt_sco_enable,
-	.int_mic_enable = incrediblec_int_mic_enable,
-	.ext_mic_enable = incrediblec_ext_mic_enable,
-	.get_rx_vol = incrediblec_get_rx_vol,
-};
-
-void __init incrediblec_audio_init(void)
-{
-	mutex_init(&mic_lock);
-	mutex_init(&bt_sco_lock);
-#if defined(CONFIG_QSD_AUDIO)
-	q6audio_register_analog_ops(&ops);
-#endif
-	acoustic_register_ops(&acoustic);
-	if (system_rev == 2 && incrediblec_get_engineerid() < 4)
-		q6audio_set_acdb_file("default_PMIC.acdb");
-}
diff --git a/arch/arm/mach-msm/board-incrediblec-keypad.c b/arch/arm/mach-msm/board-incrediblec-keypad.c
deleted file mode 100644
index 6769380..0000000
--- a/arch/arm/mach-msm/board-incrediblec-keypad.c
+++ /dev/null
@@ -1,136 +0,0 @@
-/* arch/arm/mach-msm/board-incrediblec-keypad.c
- *
- * Copyright (C) 2009 Google, Inc
- * Copyright (C) 2009 HTC Corporation.
- *
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/gpio_event.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/keyreset.h>
-#include <mach/vreg.h>
-
-#include <asm/mach-types.h>
-
-#include "board-incrediblec.h"
-
-
-const struct gpio_event_direct_entry incrediblec_keypad_nav_map_x0[] = {
-	{
-		.gpio = INCREDIBLEC_GPIO_POWER_KEY,
-		.code = KEY_POWER
-	},
-	{
-		.gpio = INCREDIBLEC_GPIO_VOLUME_UP,
-		.code = KEY_VOLUMEUP
-	},
-	{
-		.gpio = INCREDIBLEC_GPIO_VOLUME_DOWN,
-		.code = KEY_VOLUMEDOWN
-	},
-};
-
-const struct gpio_event_direct_entry incrediblec_keypad_nav_map_x1[] = {
-	{
-		.gpio = INCREDIBLEC_GPIO_POWER_KEY,
-		.code = KEY_POWER
-	},
-	{
-		.gpio = INCREDIBLEC_GPIO_VOLUME_UP,
-		.code = KEY_VOLUMEUP
-	},
-	{
-		.gpio = INCREDIBLEC_GPIO_VOLUME_DOWN,
-		.code = KEY_VOLUMEDOWN
-	},
-	{
-		.gpio = INCREDIBLEC_GPIO_OJ_ACTION_XB,
-		.code = BTN_MOUSE
-	},
-};
-
-static struct gpio_event_input_info incrediblec_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.flags = GPIOEDF_PRINT_KEYS,
-	.type = EV_KEY,
-	.keymap = incrediblec_keypad_nav_map_x1,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap_size = ARRAY_SIZE(incrediblec_keypad_nav_map_x1)
-};
-
-static struct gpio_event_info *incrediblec_keypad_info[] = {
-	&incrediblec_keypad_nav_info.info,
-};
-
-static struct gpio_event_platform_data incrediblec_keypad_data = {
-	.name = "incrediblec-keypad",
-	.info = incrediblec_keypad_info,
-	.info_count = ARRAY_SIZE(incrediblec_keypad_info)
-};
-
-static struct platform_device incrediblec_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &incrediblec_keypad_data,
-	},
-};
-
-static int incrediblec_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0
-};
-
-static struct keyreset_platform_data incrediblec_reset_keys_pdata = {
-	.keys_up = incrediblec_reset_keys_up,
-	.keys_down = {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-static struct platform_device incrediblec_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &incrediblec_reset_keys_pdata,
-};
-static int __init incrediblec_init_keypad(void)
-{
-	int ret;
-
-	if (!machine_is_incrediblec())
-		return 0;
-
-	if (system_rev < 2) {
-		incrediblec_keypad_nav_info.keymap =
-						incrediblec_keypad_nav_map_x0;
-		incrediblec_keypad_nav_info.keymap_size =
-				ARRAY_SIZE(incrediblec_keypad_nav_map_x0);
-	}
-
-	if (platform_device_register(&incrediblec_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	ret = platform_device_register(&incrediblec_keypad_device);
-	if (ret != 0)
-		return ret;
-
-	return 0;
-}
-
-device_initcall(incrediblec_init_keypad);
-
-
diff --git a/arch/arm/mach-msm/board-incrediblec-microp.c b/arch/arm/mach-msm/board-incrediblec-microp.c
deleted file mode 100644
index 6d97e1a..0000000
--- a/arch/arm/mach-msm/board-incrediblec-microp.c
+++ /dev/null
@@ -1,633 +0,0 @@
-/* arch/arm/mach-msm/board-incrediblec-microp.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <asm/mach-types.h>
-#include <mach/atmega_microp.h>
-#include <linux/capella_cm3602.h>
-#include <linux/input.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/workqueue.h>
-#include <linux/wakelock.h>
-
-#include "board-incrediblec.h"
-
-
-#define INT_PSENSOR	(1<<11)
-
-static int misc_opened;
-static struct i2c_client *incrediblec_microp_client;
-
-static void p_sensor_do_work(struct work_struct *w);
-static DECLARE_WORK(p_sensor_work, p_sensor_do_work);
-
-/*
-static struct led_trigger incrediblec_als_level_trigger = {
-	.name     = "auto-backlight-trigger",
-};
-*/
-/*
-static void incrediblec_ap_key_led_delay(struct work_struct *work);
-static DECLARE_DELAYED_WORK(incrediblec_notifier_delay_work,
-		incrediblec_ap_key_led_delay);
-*/
-struct wake_lock proximity_wake_lock;
-
-static struct capella_cm3602_data {
-	struct input_dev *input_dev;
-	struct capella_cm3602_platform_data *pdata;
-	int enabled;
-	struct workqueue_struct *p_sensor_wq;
-} the_data;
-/*
-
-static int incrediblec_als_intr_enable(struct i2c_client *client,
-		uint32_t als_func, uint8_t enable)
-{
-
-	struct microp_i2c_client_data *cdata;
-
-	cdata = i2c_get_clientdata(client);
-
-	return microp_write_interrupt(client,
-		cdata->int_pin.int_lsensor, enable);
-*/
-/*
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[2];
-	int ret = 0;
-
-	cdata = i2c_get_clientdata(client);
-	mutex_lock(&cdata->microp_i2c_mutex);
-	cdata->als_func = enable ? (cdata->als_func |= als_func)
-				: (cdata->als_func &= ~als_func);
-
-	data[0] = 0;
-	if (cdata->als_func)
-		data[1] = 1;
-	else
-		data[1] = 0;
-
-	ret = microp_i2c_write(MICROP_I2C_WCMD_AUTO_BL_CTL, data, 2);
-	if (ret != 0)
-		printk(KERN_ERR "%s: set auto light sensor fail\n", __func__);
-
-	mutex_unlock(&cdata->microp_i2c_mutex);
-
-	return ret;
-*/
-
-/*
-}
-*/
-
-static int psensor_intr_enable(uint8_t enable)
-{
-	int ret;
-	uint8_t addr, data[2];
-
-	if (enable)
-		addr = MICROP_I2C_WCMD_GPI_INT_CTL_EN;
-	else
-		addr = MICROP_I2C_WCMD_GPI_INT_CTL_DIS;
-
-	data[0] = INT_PSENSOR >> 8;
-	data[1] = INT_PSENSOR & 0xFF;
-	ret = microp_i2c_write(addr, data, 2);
-	if (ret < 0)
-		pr_err("%s: %s p-sensor interrupt failed\n",
-			__func__, (enable ? "enable" : "disable"));
-
-	return ret;
-}
-
-/*
-static int incrediblec_als_table_init(struct i2c_client *client,
-			int i, uint32_t kadc, uint32_t gadc)
-{
-	struct microp_i2c_platform_data *pdata;
-	uint8_t data[20];
-	int j;
-
-	pdata = client->dev.platform_data;
-
-	for (j = 0; j < 10; j++) {
-		data[j] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc >> 8);
-		data[j + 10] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc);
-	}
-
-	return microp_i2c_write(MICROP_I2C_WCMD_ADC_TABLE, data, 20);
-}
-*/
-/*
-static void incrediblec_vkey_led_enable(int on)
-{
-	int ret;
-
-	ret = gpio_direction_output(INCREDIBLEC_AP_KEY_LED_EN, on);
-	if (ret < 0)
-		pr_err("%s: failed on set AP Key LED=%d\n", __func__, on);
-}
-
-static void incrediblec_vkey_led_control(struct microp_led_data *ldata)
-{
-	incrediblec_vkey_led_enable((int)ldata->mode);
-}
-*/
-/*
-static void incrediblec_als_level_change(struct i2c_client *client,
-		uint8_t *data)
-{
-	struct microp_i2c_client_data *cdata  = i2c_get_clientdata(client);
-	int on = -1;
-
-	if (cdata->als_func & ALS_VKEY_LED) {
-		if (data[2] >= 4)
-			on = 0;
-		else if (data[2] <= 2)
-			on = 1;
-
-		if (on >= 0)
-			incrediblec_vkey_led_enable(on);
-	}
-}
-
-static void incrediblec_ap_key_led_delay(struct work_struct *work)
-{
-	struct i2c_client *client = incrediblec_microp_client;
-	struct microp_led_data *ldata = incrediblec_vkey_backlight;
-	uint8_t data[2];
-	int ret = 0;
-
-	data[0] = 0;
-	data[1] = 0;
-	ret = microp_i2c_write(MICROP_I2C_WCMD_AUTO_BL_CTL, data, 2);
-	if (ret != 0)
-		printk(KERN_ERR "%s: set auto light sensor disable fail\n",
-			__func__);
-
-	if (ldata->mode == 0)
-		return;
-
-	ret = incrediblec_als_intr_enable(client, ALS_VKEY_LED, 1);
-	if (ret != 0)
-		printk(KERN_ERR "%s: set auto light sensor enable fail\n",
-			__func__);
-}
-
-static void incrediblec_notifier_func(struct i2c_client *client,
-			struct microp_led_data *ldata)
-{
-	struct microp_i2c_client_data *cdata;
-	unsigned long delay_time;
-	int on;
-
-	cdata = i2c_get_clientdata(client);
-	incrediblec_vkey_backlight = ldata;
-	cancel_delayed_work(&incrediblec_notifier_delay_work);
-
-	on = ldata->ldev.brightness ? 1 : 0;
-	incrediblec_vkey_led_enable(on);
-	cdata->als_func &= ~ALS_VKEY_LED;
-
-	if (ldata->mode)
-		delay_time = HZ * 10;
-	else
-		delay_time = 0;
-	queue_delayed_work(cdata->microp_queue,
-			&incrediblec_notifier_delay_work, delay_time);
-}
-*/
-/*
-static int incrediblec_als_power_init(void)
-{
-	return incrediblec_als_power(LS_PWR_ON, 1);
-}
-*/
-static int incrediblec_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	incrediblec_microp_client = client;
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Light sensor */
-/*
-	ret = microp_function_check(client, MICROP_FUNCTION_LSENSOR);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_LSENSOR] = i;
-		cdata->int_pin.int_lsensor = pdata->microp_function[i].int_pin;
-		microp_get_als_kvalue(i);
-
-		ret = incrediblec_als_table_init(client, i,
-				cdata->als_kadc, cdata->als_gadc);
-		if (ret < 0)
-			goto exit;
-
-		incrediblec_als_power_init();
-	}
-*/
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-				pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	data[0] = 0x08;
-	ret = microp_i2c_write(MICROP_I2C_WCMD_MISC, data, 1);
-	if (ret)
-		goto exit;
-
-	/* OJ interrupt */
-	ret = microp_function_check(client, MICROP_FUNCTION_OJ);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_oj = pdata->microp_function[i].int_pin;
-
-		ret = microp_write_interrupt(client, cdata->int_pin.int_oj, 1);
-		if (ret)
-			goto exit;
-	}
-
-	/* Proximity interrupt */
-	ret = microp_function_check(client, MICROP_FUNCTION_P);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_psensor = pdata->microp_function[i].int_pin;
-		cdata->gpio.psensor = pdata->microp_function[i].mask_r[0] << 16
-				| pdata->microp_function[i].mask_r[1] << 8
-				| pdata->microp_function[i].mask_r[2];
-				cdata->fnode.psensor = i;
-	}
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static int report_psensor_data(void)
-{
-	int ret, ps_data = 0;
-	uint8_t data[3] = {0, 0, 0};
-
-	ret = microp_i2c_read(MICROP_I2C_RCMD_GPIO_STATUS, data, 3);
-	if (ret < 0)
-		pr_err("%s: read data failed\n", __func__);
-	else {
-		ps_data = (data[2] & 0x10) ? 1 : 0;
-		pr_info("proximity %s\n", ps_data ? "FAR" : "NEAR");
-
-		/* 0 is close, 1 is far */
-		input_report_abs(the_data.input_dev, ABS_DISTANCE, ps_data);
-		input_sync(the_data.input_dev);
-
-		wake_lock_timeout(&proximity_wake_lock, 2*HZ);
-	}
-
-	return ret;
-}
-
-static int capella_cm3602_enable(struct capella_cm3602_data *data)
-{
-	int rc;
-	pr_info("%s\n", __func__);
-	if (data->enabled) {
-		pr_info("%s: already enabled\n", __func__);
-		return 0;
-	}
-
-	/* dummy report */
-	input_report_abs(data->input_dev, ABS_DISTANCE, -1);
-	input_sync(data->input_dev);
-
-	rc = data->pdata->power(PS_PWR_ON, 1);
-	if (rc < 0)
-		return -EIO;
-
-	rc = gpio_direction_output(data->pdata->p_en, 0);
-	if (rc < 0) {
-		pr_err("%s: set psesnor enable failed!!",
-			__func__);
-		return -EIO;
-	}
-	msleep(220);
-	rc = psensor_intr_enable(1);
-	if (rc < 0)
-		return -EIO;
-
-	data->enabled = 1;
-	report_psensor_data();
-
-	return rc;
-}
-
-static int capella_cm3602_disable(struct capella_cm3602_data *data)
-{
-	int rc = -EIO;
-	pr_info("%s\n", __func__);
-	if (!data->enabled) {
-		pr_info("%s: already disabled\n", __func__);
-		return 0;
-	}
-
-	rc = psensor_intr_enable(0);
-	if (rc < 0)
-		return -EIO;
-
-	rc = gpio_direction_output(data->pdata->p_en, 1);
-	if (rc < 0) {
-		pr_err("%s: set GPIO failed!!", __func__);
-		return -EIO;
-	}
-
-	rc = data->pdata->power(PS_PWR_ON, 0);
-	if (rc < 0)
-		return -EIO;
-
-	data->enabled = 0;
-	return rc;
-}
-
-static ssize_t capella_cm3602_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
-{
-	int ret;
-
-	ret = sprintf(buf, "proximity enabled = %d\n", the_data.enabled);
-
-	return ret;
-}
-
-static ssize_t capella_cm3602_store(struct device *dev,
-			struct device_attribute *attr,
-			const char              *buf,
-			size_t                  count
-			)
-{
-	ssize_t val;
-
-	val = -1;
-	sscanf(buf, "%u", &val);
-	if (val < 0 || val > 1)
-		return -EINVAL;
-
-	/* Enable capella_cm3602*/
-	if (val == 1)
-		capella_cm3602_enable(&the_data);
-
-	/* Disable capella_cm3602*/
-	if (val == 0)
-		capella_cm3602_disable(&the_data);
-
-	return count;
-}
-
-static DEVICE_ATTR(proximity, 0644, capella_cm3602_show, capella_cm3602_store);
-
-static int capella_cm3602_open(struct inode *inode, struct file *file)
-{
-	pr_info("%s\n", __func__);
-	if (misc_opened)
-		return -EBUSY;
-	misc_opened = 1;
-	return 0;
-}
-
-static int capella_cm3602_release(struct inode *inode, struct file *file)
-{
-	pr_info("%s\n", __func__);
-	misc_opened = 0;
-	return capella_cm3602_disable(&the_data);
-}
-
-static long capella_cm3602_ioctl(struct file *file,
-			unsigned int cmd, unsigned long arg)
-{
-	int val;
-	pr_info("%s cmd %d\n", __func__, _IOC_NR(cmd));
-	switch (cmd) {
-	case CAPELLA_CM3602_IOCTL_ENABLE:
-		if (get_user(val, (unsigned long __user *)arg))
-			return -EFAULT;
-		if (val)
-			return capella_cm3602_enable(&the_data);
-		else
-			return capella_cm3602_disable(&the_data);
-		break;
-	case CAPELLA_CM3602_IOCTL_GET_ENABLED:
-		return put_user(the_data.enabled, (unsigned long __user *)arg);
-		break;
-	default:
-		pr_err("%s: invalid cmd %d\n", __func__, _IOC_NR(cmd));
-		return -EINVAL;
-	}
-}
-static void p_sensor_do_work(struct work_struct *w)
-{
-	report_psensor_data();
-}
-
-static irqreturn_t p_sensor_irq_handler(int irq, void *data)
-{
-	struct capella_cm3602_data *ip = data;
-	queue_work(ip->p_sensor_wq, &p_sensor_work);
-
-	return IRQ_HANDLED;
-}
-
-static struct file_operations capella_cm3602_fops = {
-	.owner = THIS_MODULE,
-	.open = capella_cm3602_open,
-	.release = capella_cm3602_release,
-	.unlocked_ioctl = capella_cm3602_ioctl
-};
-
-static struct miscdevice capella_cm3602_misc = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "cm3602",
-	.fops = &capella_cm3602_fops
-};
-
-static int capella_cm3602_probe(struct platform_device *pdev)
-{
-	int rc = -1;
-	struct input_dev *input_dev;
-	struct capella_cm3602_data *ip;
-	struct capella_cm3602_platform_data *pdata;
-
-	struct class  *proximity_attr_class;
-	struct device *proximity_attr_dev;
-
-	pr_info("%s: probe\n", __func__);
-
-	pdata = pdev->dev.platform_data;
-
-	ip = &the_data;
-	platform_set_drvdata(pdev, ip);
-
-	input_dev = input_allocate_device();
-	if (!input_dev) {
-		pr_err("%s: could not allocate input device\n", __func__);
-		rc = -ENOMEM;
-		goto done;
-	}
-	ip->input_dev = input_dev;
-	ip->pdata = pdata;
-	input_set_drvdata(input_dev, ip);
-
-	input_dev->name = "proximity";
-
-	set_bit(EV_ABS, input_dev->evbit);
-	input_set_abs_params(input_dev, ABS_DISTANCE, 0, 1, 0, 0);
-
-	rc = input_register_device(input_dev);
-	if (rc < 0) {
-		pr_err("%s: could not register input device\n", __func__);
-		goto err_free_input_device;
-	}
-
-	rc = misc_register(&capella_cm3602_misc);
-	if (rc < 0) {
-		pr_err("%s: could not register misc device\n", __func__);
-		goto err_unregister_input_device;
-	}
-
-	wake_lock_init(&proximity_wake_lock, WAKE_LOCK_SUSPEND, "proximity");
-
-	proximity_attr_class = class_create(THIS_MODULE, "sensors");
-	if (IS_ERR(proximity_attr_class)) {
-		pr_err("%s: class_create failed\n", __func__);
-		rc = PTR_ERR(proximity_attr_class);
-		proximity_attr_class = NULL;
-		goto err_create_class;
-	}
-
-	proximity_attr_dev = device_create(proximity_attr_class,
-					NULL, 0, "%s", "proximity_sensor");
-	if (unlikely(IS_ERR(proximity_attr_dev))) {
-		pr_err("%s: device create failed\n", __func__);
-		rc = PTR_ERR(proximity_attr_dev);
-		proximity_attr_dev = NULL;
-		goto err_create_proximity_attr_device;
-	}
-
-	rc = device_create_file(proximity_attr_dev, &dev_attr_proximity);
-	if (rc) {
-		pr_err("%s: device_create_file failed\n", __func__);
-		goto err_create_proximity_device_file;
-	}
-
-	ip->p_sensor_wq = create_workqueue("p-sensor_microp_wq");
-	if (ip->p_sensor_wq == NULL) {
-		pr_err("%s: create_workqueue failed\n", __func__);
-		goto err_create_workqueue;
-	}
-
-	rc = gpio_request(pdata->p_en, "gpio_proximity_en");
-	if (rc < 0) {
-		pr_err("%s: gpio %d request failed (%d)\n",
-			__func__, pdata->p_en, rc);
-		goto err_request_proximity_en;
-	}
-
-	rc = request_irq(pdata->p_out, p_sensor_irq_handler,
-					IRQF_TRIGGER_NONE, "p-sensor_microp", ip);
-	if (rc < 0) {
-		pr_err("%s: request_irq(%d) failed for (%d)\n",
-				__func__, pdata->p_out, rc);
-		goto err_request_proximity_irq;
-	}
-
-
-	goto done;
-
-err_request_proximity_irq:
-	gpio_free(pdata->p_en);
-err_request_proximity_en:
-	destroy_workqueue(ip->p_sensor_wq);
-err_create_workqueue:
-	device_remove_file(proximity_attr_dev, &dev_attr_proximity);
-err_create_proximity_device_file:
-	device_unregister(proximity_attr_dev);
-err_create_proximity_attr_device:
-	class_destroy(proximity_attr_class);
-err_create_class:
-	misc_deregister(&capella_cm3602_misc);
-err_unregister_input_device:
-	input_unregister_device(input_dev);
-err_free_input_device:
-	input_free_device(input_dev);
-done:
-	return rc;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = incrediblec_microp_function_init,
-	/*.als_pwr_enable = incrediblec_als_power,*/
-	/*.als_level_change = incrediblec_als_level_change,*/
-	/*.als_intr_enable = incrediblec_als_intr_enable,*/
-	/*.notifier_func = incrediblec_notifier_func,*/
-	/*.led_gpio_set = incrediblec_vkey_led_control,*/
-};
-
-void __init incrediblec_microp_init(void)
-{
-	/*led_trigger_register(&incrediblec_als_level_trigger);*/
-	microp_register_ops(&ops);
-}
-
-static struct platform_driver capella_cm3602_driver = {
-	.probe = capella_cm3602_probe,
-	.driver = {
-		.name = "incrediblec_proximity",
-		.owner = THIS_MODULE
-	},
-};
-
-static int __init incrediblec_capella_cm3602_init(void)
-{
-	if (!machine_is_incrediblec())
-		return 0;
-
-	return platform_driver_register(&capella_cm3602_driver);
-}
-
-device_initcall(incrediblec_capella_cm3602_init);
-#endif
diff --git a/arch/arm/mach-msm/board-incrediblec-mmc.c b/arch/arm/mach-msm/board-incrediblec-mmc.c
deleted file mode 100644
index 28ea37a..0000000
--- a/arch/arm/mach-msm/board-incrediblec-mmc.c
+++ /dev/null
@@ -1,315 +0,0 @@
-/* linux/arch/arm/mach-msm/board-incrediblec-mmc.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-
-#include "board-incrediblec.h"
-#include "devices.h"
-#include "proc_comm.h"
-
-#define DEBUG_SDSLOT_VDD 1
-
-static bool opt_disable_sdcard;
-static int __init incrediblec_disablesdcard_setup(char *str)
-{
-	opt_disable_sdcard = (bool)simple_strtol(str, NULL, 0);
-	return 1;
-}
-
-__setup("board_incrediblec.disable_sdcard=", incrediblec_disablesdcard_setup);
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t movinand_on_gpio_table[] = {
-	PCOM_GPIO_CFG(88, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(89, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(90, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(91, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(92, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(93, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT0 */
-	PCOM_GPIO_CFG(158, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT4 */
-	PCOM_GPIO_CFG(159, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT5 */
-	PCOM_GPIO_CFG(160, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT6 */
-	PCOM_GPIO_CFG(161, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT7 */
-};
-
-static struct vreg	*sdslot_vreg;
-static uint32_t		sdslot_vdd = 0xffffffff;
-static uint32_t		sdslot_vreg_enabled;
-
-static struct {
-	int mask;
-	int level;
-} mmc_vdd_table[] = {
-	{ MMC_VDD_27_28,	2800 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static uint32_t incrediblec_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-	int ret;
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(sdslot_vreg);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		ret = vreg_enable(sdslot_vreg);
-		if (ret)
-			pr_err("%s: Error enabling vreg (%d)\n", __func__, ret);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask != (1 << vdd))
-			continue;
-		ret = vreg_set_level(sdslot_vreg, mmc_vdd_table[i].level);
-		if (ret)
-			pr_err("%s: Error setting level (%d)\n", __func__, ret);
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Setting level to %u (%s)\n",
-					__func__, mmc_vdd_table[i].level,
-				ret?"Failed":"Success");
-#endif
-		return 0;
-	}
-
-	pr_err("%s: Invalid VDD (%d) specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int incrediblec_sdslot_status(struct device *dev)
-{
-	return !gpio_get_value(INCREDIBLEC_GPIO_SDMC_CD_N);
-}
-
-#define INCREDIBLEC_MMC_VDD	(MMC_VDD_27_28 | MMC_VDD_28_29 | \
-				 MMC_VDD_29_30)
-
-static unsigned int incrediblec_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data incrediblec_sdslot_data = {
-	.ocr_mask	= INCREDIBLEC_MMC_VDD,
-	.status		= incrediblec_sdslot_status,
-	.translate_vdd	= incrediblec_sdslot_switchvdd,
-	.slot_type	= &incrediblec_sdslot_type,
-};
-
-static unsigned int incrediblec_mmc_type = MMC_TYPE_MMC;
-
-static struct mmc_platform_data incrediblec_movinand_data = {
-	.ocr_mask	= INCREDIBLEC_MMC_VDD,
-	.slot_type	= &incrediblec_mmc_type,
-};
-
-int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-		 unsigned int stat_irq, unsigned long stat_irq_flags);
-
-
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data incrediblec_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-incrediblec_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static int incrediblec_wifi_cd;	/* WiFi virtual 'card detect' status */
-
-static unsigned int incrediblec_wifi_status(struct device *dev)
-{
-	return incrediblec_wifi_cd;
-}
-
-static struct mmc_platform_data incrediblec_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= incrediblec_wifi_status,
-	.register_status_notify	= incrediblec_wifi_status_register,
-	.embedded_sdio		= &incrediblec_wifi_emb_data,
-};
-
-int incrediblec_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	incrediblec_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(incrediblec_wifi_set_carddetect);
-
-int incrediblec_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-
-	mdelay(100);
-	gpio_set_value(INCREDIBLEC_GPIO_WIFI_SHUTDOWN_N, on); /* WIFI_SHUTDOWN */
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(incrediblec_wifi_power);
-
-int incrediblec_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-
-int __init incrediblec_init_mmc(unsigned int sys_rev)
-{
-	uint32_t id;
-
-	wifi_status_cb = NULL;
-
-	printk(KERN_INFO "%s()+\n", __func__);
-
-	/* initial WIFI_SHUTDOWN# */
-	id = PCOM_GPIO_CFG(INCREDIBLEC_GPIO_WIFI_SHUTDOWN_N, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	msm_add_sdcc(1, &incrediblec_wifi_data, 0, 0);
-
-	if (opt_disable_sdcard) {
-		pr_info("%s: sdcard disabled on cmdline\n", __func__);
-		goto done;
-	}
-
-	sdslot_vreg_enabled = 0;
-
-	sdslot_vreg = vreg_get(0, "gp6");
-	if (IS_ERR(sdslot_vreg))
-		return PTR_ERR(sdslot_vreg);
-
-	set_irq_wake(MSM_GPIO_TO_INT(INCREDIBLEC_GPIO_SDMC_CD_N), 1);
-
-	msm_add_sdcc(2, &incrediblec_sdslot_data,
-		     MSM_GPIO_TO_INT(INCREDIBLEC_GPIO_SDMC_CD_N),
-		     IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-
-done:
-	config_gpio_table(movinand_on_gpio_table,
-			  ARRAY_SIZE(movinand_on_gpio_table));
-	msm_add_sdcc(3, &incrediblec_movinand_data, 0, 0); /* SDC3: MoviNAND */
-
-	printk(KERN_INFO "%s()-\n", __func__);
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-incrediblec-rfkill.c b/arch/arm/mach-msm/board-incrediblec-rfkill.c
deleted file mode 100644
index 92a883f..0000000
--- a/arch/arm/mach-msm/board-incrediblec-rfkill.c
+++ /dev/null
@@ -1,333 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for incrediblec platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-incrediblec.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-/* bt initial configuration */
-static uint32_t incrediblec_bt_init_table[] = {
-
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt on configuration */
-static uint32_t incrediblec_bt_on_table[] = {
-
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_RX, /* BT_RX */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt off configuration */
-static uint32_t incrediblec_bt_off_table[] = {
-
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_UART1_TX, /* BT_TX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void incrediblec_config_bt_init(void)
-{
-	/* set bt initial configuration*/
-	config_bt_table(incrediblec_bt_init_table,
-				ARRAY_SIZE(incrediblec_bt_init_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(INCREDIBLEC_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(INCREDIBLEC_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(INCREDIBLEC_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-
-}
-
-static void incrediblec_config_bt_on(void)
-{
-	/* set bt on configuration*/
-	config_bt_table(incrediblec_bt_on_table,
-				ARRAY_SIZE(incrediblec_bt_on_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(INCREDIBLEC_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(INCREDIBLEC_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-}
-
-static void incrediblec_config_bt_off(void)
-{
-	/* BT_SHUTDOWN_N */
-	gpio_configure(INCREDIBLEC_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_RESET_N */
-	gpio_configure(INCREDIBLEC_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(incrediblec_bt_off_table,
-				ARRAY_SIZE(incrediblec_bt_off_table));
-	mdelay(5);
-
-	/* BT_RTS */
-	gpio_configure(INCREDIBLEC_GPIO_BT_UART1_RTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_TX */
-	gpio_configure(INCREDIBLEC_GPIO_BT_UART1_TX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CHIP_WAKE */
-	gpio_configure(INCREDIBLEC_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		incrediblec_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		incrediblec_config_bt_off();
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int incrediblec_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	incrediblec_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int incrediblec_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver incrediblec_rfkill_driver = {
-	.probe = incrediblec_rfkill_probe,
-	.remove = incrediblec_rfkill_remove,
-	.driver = {
-		.name = "incrediblec_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init incrediblec_rfkill_init(void)
-{
-	if (!machine_is_incrediblec())
-		return 0;
-
-	return platform_driver_register(&incrediblec_rfkill_driver);
-}
-
-static void __exit incrediblec_rfkill_exit(void)
-{
-	platform_driver_unregister(&incrediblec_rfkill_driver);
-}
-
-module_init(incrediblec_rfkill_init);
-module_exit(incrediblec_rfkill_exit);
-MODULE_DESCRIPTION("incrediblec rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-incrediblec-tv.c b/arch/arm/mach-msm/board-incrediblec-tv.c
deleted file mode 100644
index 8cb9197..0000000
--- a/arch/arm/mach-msm/board-incrediblec-tv.c
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/wakelock.h>
-#include <linux/leds.h>
-#include <linux/workqueue.h>
-#include <linux/gpio.h>
-#include <linux/msm_mdp.h>
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <mach/msm_fb.h>
-#include <mach/msm_iomap.h>
-#include <mach/vreg.h>
-
-#include "board-incrediblec.h"
-#include "devices.h"
-#include "proc_comm.h"
-
-static struct resource msm_tvenc_resources[] = {
-	{
-		.name   = "msm_tv",
-		.start  = 0xaa400000,
-		.end    = 0xaa400000 + 0x1000 - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.start	= MSM_TV_FB_BASE,
-		.end	= MSM_TV_FB_BASE + MSM_TV_FB_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct msm_fb_data incrediblec_tvenc_fb_data = {
-	.xres           = 480,
-	.yres           = 720,
-	/* Typical geometry of 17" CRT */
-	.width          = 338,
-	.height         = 270,
-	.output_format  = MDP_YCRYCB_H2V1,
-};
-
-static int incrediblec_tv_video_relay(int on_off)
-{
-	pr_info("[tv]: %s(%d)\n", __func__, on_off);
-	on_off = !!on_off;
-	gpio_set_value(INCREDIBLEC_VIDEO_SHDN_N, on_off);
-	if (system_rev < 2)
-		gpio_set_value(INCREDIBLEC_AV_SWITCH, on_off);
-
-	return 0;
-}
-
-static struct msm_tvenc_platform_data incrediblec_tvenc_platform_data = {
-	.fb_id          = 1,
-	.fb_data        = &incrediblec_tvenc_fb_data,
-	.fb_resource    = &msm_tvenc_resources[1],
-	.video_relay	= &incrediblec_tv_video_relay,
-};
-
-static struct platform_device msm_tvenc_device = {
-	.name   	= "msm_tv",
-	.id     	= 0,
-	.num_resources  = ARRAY_SIZE(msm_tvenc_resources),
-	.resource       = msm_tvenc_resources,
-	.dev    = {
-		.platform_data = &incrediblec_tvenc_platform_data,
-	},
-};
-
-int __init incrediblec_init_tv(void)
-{
-	int ret, engid;
-	uint32_t config;
-
-	if (!machine_is_incrediblec())
-		return 0;
-
-	engid = incrediblec_get_engineerid();
-	if (0 == engid || 0xF == engid) {
-		msm_tvenc_resources[1].start = MSM_TV_FB_XA_BASE;
-		msm_tvenc_resources[1].end = msm_tvenc_resources[1].start +
-			MSM_TV_FB_SIZE - 1;
-	} else if (engid >= 3) {
-		msm_tvenc_resources[1].start =
-			MSM_TV_FB_BASE + MSM_MEM_128MB_OFFSET;
-		msm_tvenc_resources[1].end = msm_tvenc_resources[1].start +
-			MSM_TV_FB_SIZE - 1;
-	}
-
-	config = PCOM_GPIO_CFG(INCREDIBLEC_VIDEO_SHDN_N, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_16MA);
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &config, 0);
-	gpio_set_value(INCREDIBLEC_VIDEO_SHDN_N, 1);
-	config = PCOM_GPIO_CFG(INCREDIBLEC_TV_LOAD_DET, 0, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_16MA);
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &config, 0);
-
-	if (system_rev < 2) {
-		config = PCOM_GPIO_CFG(INCREDIBLEC_AV_SWITCH, 0, GPIO_OUTPUT,
-				GPIO_NO_PULL, GPIO_16MA);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &config, 0);
-	}
-
-	if ((ret = platform_device_register(&msm_tvenc_device)) != 0)
-		return ret;
-
-	return 0;
-}
-
-device_initcall(incrediblec_init_tv);
diff --git a/arch/arm/mach-msm/board-incrediblec-wifi.c b/arch/arm/mach-msm/board-incrediblec-wifi.c
deleted file mode 100644
index e061795..0000000
--- a/arch/arm/mach-msm/board-incrediblec-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-incrediblec-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-incrediblec.h"
-
-int incrediblec_wifi_power(int on);
-int incrediblec_wifi_reset(int on);
-int incrediblec_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *incrediblec_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init incrediblec_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource incrediblec_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(INCREDIBLEC_GPIO_WIFI_IRQ),
-		.end		= MSM_GPIO_TO_INT(INCREDIBLEC_GPIO_WIFI_IRQ),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data incrediblec_wifi_control = {
-	.set_power      = incrediblec_wifi_power,
-	.set_reset      = incrediblec_wifi_reset,
-	.set_carddetect = incrediblec_wifi_set_carddetect,
-	.mem_prealloc   = incrediblec_wifi_mem_prealloc,
-};
-
-static struct platform_device incrediblec_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(incrediblec_wifi_resources),
-        .resource       = incrediblec_wifi_resources,
-        .dev            = {
-                .platform_data = &incrediblec_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned incrediblec_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init incrediblec_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_incrediblec())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	incrediblec_wifi_update_nvs("sd_oobonly=1\n");
-	incrediblec_init_wifi_mem();
-	ret = platform_device_register(&incrediblec_wifi_device);
-        return ret;
-}
-
-device_initcall(incrediblec_wifi_init);
diff --git a/arch/arm/mach-msm/board-incrediblec.c b/arch/arm/mach-msm/board-incrediblec.c
deleted file mode 100644
index 3610174..0000000
--- a/arch/arm/mach-msm/board-incrediblec.c
+++ /dev/null
@@ -1,1606 +0,0 @@
-/* linux/arch/arm/mach-msm/board-incrediblec.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/android_pmem.h>
-#include <linux/input.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/regulator/machine.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/setup.h>
-
-#include <mach/board.h>
-#include <mach/board_htc.h>
-#include <mach/hardware.h>
-#include <mach/atmega_microp.h>
-#include <mach/camera.h>
-#include <mach/msm_iomap.h>
-#include <mach/htc_battery.h>
-#include <mach/perflock.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/system.h>
-#include <linux/spi/spi.h>
-#include <linux/curcial_oj.h>
-#include <mach/msm_panel.h>
-#include "board-incrediblec.h"
-#include "devices.h"
-#include "proc_comm.h"
-#include "smd_private.h"
-#if 1	/*allenou, bt for bcm, 2009/7/8 */
-#include <mach/msm_serial_hs.h>
-#endif
-#include <mach/tpa6130.h>
-#include <mach/msm_flashlight.h>
-#include <linux/atmel_qt602240.h>
-#include <mach/vreg.h>
-#include <mach/pmic.h>
-#include <mach/msm_hsusb.h>
-
-#define SMEM_SPINLOCK_I2C      6
-#define INCREDIBLEC_MICROP_VER		0x04
-
-#ifdef CONFIG_ARCH_QSD8X50
-extern unsigned char *get_bt_bd_ram(void);
-#endif
-
-void msm_init_pmic_vibrator(void);
-extern void __init incrediblec_audio_init(void);
-#ifdef CONFIG_MICROP_COMMON
-void __init incrediblec_microp_init(void);
-#endif
-
-unsigned int engineerid;
-
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-/*	.gpio_mbat_in = INCREDIBLEC_GPIO_MBAT_IN,*/
-/*	.gpio_mchg_en_n = INCREDIBLEC_GPIO_MCHG_EN_N,*/
-/*	.gpio_iset = INCREDIBLEC_GPIO_ISET,*/
-	.guage_driver = GUAGE_MODEM,
-	.m2a_cable_detect = 1,
-	.charger = SWITCH_CHARGER,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-/*XA, XB*/
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0, 10, 16, 22, 75, 186, 320, 373, 550, 0x3FF },
-		.channel = 3,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xD2,
-		.mask_w = {0x00, 0x00, 0x04},
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 50, 110, 160, 220},
-		.channel = 1,
-		.int_pin = 1 << 5,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "reset-int",
-		.category = MICROP_FUNCTION_RESET_INT,
-		.int_pin = 1 << 8,
-	},
-	{
-		.name   = "oj",
-		.category = MICROP_FUNCTION_OJ,
-		.int_pin = 1 << 12,
-	},
-	{
-		.name   = "proximity",
-		.category = MICROP_FUNCTION_P,
-		.int_pin = 1 << 11,
-		.mask_r = {0x00, 0x00, 0x10},
-		.mask_w = {0x00, 0x00, 0x04},
-	},
-};
-
-/*For XC: Change ALS chip from CM3602 to CM3605*/
-static struct microp_function_config microp_functions_1[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0, 11, 16, 22, 75, 209, 362, 488, 560, 0x3FF },
-		.channel = 3,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xD2,
-		.mask_w = {0x00, 0x00, 0x04},
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 50, 110, 160, 220},
-		.channel = 1,
-		.int_pin = 1 << 5,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "reset-int",
-		.category = MICROP_FUNCTION_RESET_INT,
-		.int_pin = 1 << 8,
-	},
-	{
-		.name   = "oj",
-		.category = MICROP_FUNCTION_OJ,
-		.int_pin = 1 << 12,
-	},
-	{
-		.name   = "proximity",
-		.category = MICROP_FUNCTION_P,
-		.int_pin = 1 << 11,
-		.mask_r = {0x00, 0x00, 0x10},
-		.mask_w = {0x00, 0x00, 0x04},
-	},
-};
-
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct bma150_platform_data incrediblec_g_sensor_pdata = {
-	.microp_new_cmd = 1,
-};
-
-/* Proximity Sensor (Capella_CM3602)*/
-
-static int __capella_cm3602_power(int on)
-{
-	uint8_t data[3], addr;
-	int ret;
-
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on)
-		gpio_direction_output(INCREDIBLEC_GPIO_PROXIMITY_EN_N, 1);
-
-	data[0] = 0x00;
-	data[1] = 0x00;
-	data[2] = 0x04;
-	addr = on ? MICROP_I2C_WCMD_GPO_LED_STATUS_EN :
-			MICROP_I2C_WCMD_GPO_LED_STATUS_DIS;
-	ret = microp_i2c_write(addr, data, 3);
-	if (ret < 0)
-		pr_err("%s: %s capella power failed\n",
-			__func__, (on ? "enable" : "disable"));
-
-	if (!on)
-		gpio_direction_output(INCREDIBLEC_GPIO_PROXIMITY_EN_N, 0);
-
-	return ret;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static unsigned int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable)
-		als_power_control |= pwr_device;
-	else
-		als_power_control &= ~pwr_device;
-
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-		ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-}
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.power = capella_cm3602_power,
-	.p_en = INCREDIBLEC_GPIO_PROXIMITY_EN_N,
-	.p_out = MSM_uP_TO_INT(11),
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev = {
-			.platform_data = &lightsensor_data,
-		},
-	},
-	 {
-		.name = "leds-microp",
-		.id = -1,
-		.dev = {
-			.platform_data = &microp_leds_data,
-		},
-	},
-	{
-		.name = BMA150_G_SENSOR_NAME,
-		.dev = {
-			.platform_data = &incrediblec_g_sensor_pdata,
-		},
-	},
-	{
-		.name = "incrediblec_proximity",
-		.id = -1,
-		.dev = {
-			.platform_data = &capella_cm3602_pdata,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = INCREDIBLEC_GPIO_UP_RESET_N,
-	.microp_ls_on = LS_PWR_ON | PS_PWR_ON,
-	.spi_devices = SPI_OJ | SPI_GSENSOR,
-};
-
-static struct gpio_led incrediblec_led_list[] = {
-	{
-		.name = "button-backlight",
-		.gpio = INCREDIBLEC_AP_KEY_LED_EN,
-		.active_low = 0,
-	},
-};
-
-static struct gpio_led_platform_data incrediblec_leds_data = {
-	.num_leds	= ARRAY_SIZE(incrediblec_led_list),
-	.leds		= incrediblec_led_list,
-};
-
-static struct platform_device incrediblec_leds = {
-	.name		= "leds-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &incrediblec_leds_data,
-	},
-};
-
-static struct msm_hsusb_product incrediblec_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c9e,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-static int incrediblec_phy_init_seq[] = { 0x1D, 0x0D, 0x1D, 0x10, -1 };
-extern void msm_hsusb_8x50_phy_reset(void);
-
-static struct platform_device incrediblec_rfkill = {
-	.name = "incrediblec_rfkill",
-	.id = -1,
-};
-
-static struct resource qsd_spi_resources[] = {
-	{
-		.name   = "spi_irq_in",
-		.start  = INT_SPI_INPUT,
-		.end    = INT_SPI_INPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_out",
-		.start  = INT_SPI_OUTPUT,
-		.end    = INT_SPI_OUTPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_err",
-		.start  = INT_SPI_ERROR,
-		.end    = INT_SPI_ERROR,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_base",
-		.start  = 0xA1200000,
-		.end    = 0xA1200000 + SZ_4K - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.name   = "spi_clk",
-		.start  = 17,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_mosi",
-		.start  = 18,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_miso",
-		.start  = 19,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_cs0",
-		.start  = 20,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_pwr",
-		.start  = 21,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_cs0",
-		.start  = 22,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device qsd_device_spi = {
-	.name           = "spi_qsd",
-	.id             = 0,
-	.num_resources  = ARRAY_SIZE(qsd_spi_resources),
-	.resource       = qsd_spi_resources,
-};
-
-static struct resource msm_kgsl_resources[] = {
-	{
-		.name	= "kgsl_reg_memory",
-		.start	= MSM_GPU_REG_PHYS,
-		.end	= MSM_GPU_REG_PHYS + MSM_GPU_REG_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "kgsl_phys_memory",
-		.start	= MSM_GPU_MEM_BASE,
-		.end	= MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_GRAPHICS,
-		.end	= INT_GRAPHICS,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-#define PWR_RAIL_GRP_CLK		8
-static int incrediblec_kgsl_power_rail_mode(int follow_clk)
-{
-	int mode = follow_clk ? 0 : 1;
-	int rail_id = PWR_RAIL_GRP_CLK;
-
-	return msm_proc_comm(PCOM_CLKCTL_RPC_RAIL_CONTROL, &rail_id, &mode);
-}
-
-static int incrediblec_kgsl_power(bool on)
-{
-	int cmd;
-	int rail_id = PWR_RAIL_GRP_CLK;
-
-	cmd = on ? PCOM_CLKCTL_RPC_RAIL_ENABLE : PCOM_CLKCTL_RPC_RAIL_DISABLE;
-	return msm_proc_comm(cmd, &rail_id, NULL);
-}
-
-static struct platform_device msm_kgsl_device = {
-	.name		= "kgsl",
-	.id		= -1,
-	.resource	= msm_kgsl_resources,
-	.num_resources	= ARRAY_SIZE(msm_kgsl_resources),
-};
-
-static struct android_pmem_platform_data mdp_pmem_pdata = {
-	.name		= "pmem",
-	.start		= MSM_PMEM_MDP_BASE,
-	.size		= MSM_PMEM_MDP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-static struct android_pmem_platform_data android_pmem_adsp_pdata = {
-	.name		= "pmem_adsp",
-	.start		= MSM_PMEM_ADSP_BASE,
-	.size		= MSM_PMEM_ADSP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-
-static struct android_pmem_platform_data android_pmem_camera_pdata = {
-	.name		= "pmem_camera",
-	.start		= MSM_PMEM_CAMERA_BASE,
-	.size		= MSM_PMEM_CAMERA_SIZE,
-	.no_allocator	= 1,
-	.cached		= 1,
-};
-
-static struct platform_device android_pmem_mdp_device = {
-	.name		= "android_pmem",
-	.id		= 0,
-	.dev		= {
-		.platform_data = &mdp_pmem_pdata
-	},
-};
-
-static struct platform_device android_pmem_adsp_device = {
-	.name		= "android_pmem",
-	.id		= 4,
-	.dev		= {
-		.platform_data = &android_pmem_adsp_pdata,
-	},
-};
-
-static struct platform_device android_pmem_camera_device = {
-	.name		= "android_pmem",
-	.id		= 5,
-	.dev		= {
-		.platform_data = &android_pmem_camera_pdata,
-	},
-};
-
-static struct resource ram_console_resources[] = {
-	{
-		.start	= MSM_RAM_CONSOLE_BASE,
-		.end	= MSM_RAM_CONSOLE_BASE + MSM_RAM_CONSOLE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device ram_console_device = {
-	.name		= "ram_console",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(ram_console_resources),
-	.resource	= ram_console_resources,
-};
-
-static int incrediblec_atmel_ts_power(int on)
-{
-	printk(KERN_INFO "incrediblec_atmel_ts_power(%d)\n", on);
-	if (on) {
-		gpio_set_value(INCREDIBLEC_GPIO_TP_EN, 1);
-		msleep(2);
-		gpio_set_value(INCREDIBLEC_GPIO_TP_RST, 1);
-	} else {
-		gpio_set_value(INCREDIBLEC_GPIO_TP_EN, 0);
-		msleep(2);
-	}
-	return 0;
-}
-
-struct atmel_i2c_platform_data incrediblec_atmel_ts_data[] = {
-	{
-		.version = 0x016,
-		.abs_x_min = 1,
-		.abs_x_max = 1023,
-		.abs_y_min = 2,
-		.abs_y_max = 966,
-		.abs_pressure_min = 0,
-		.abs_pressure_max = 255,
-		.abs_width_min = 0,
-		.abs_width_max = 20,
-		.gpio_irq = INCREDIBLEC_GPIO_TP_INT_N,
-		.power = incrediblec_atmel_ts_power,
-		.config_T6 = {0, 0, 0, 0, 0, 0},
-		.config_T7 = {50, 15, 25},
-		.config_T8 = {10, 0, 20, 10, 0, 0, 5, 0},
-		.config_T9 = {139, 0, 0, 18, 12, 0, 16, 45, 2, 7, 0, 5, 2, 15, 2, 10, 25, 5, 0, 0, 0, 0, 0, 0, 0, 0, 159, 47, 149, 81},
-		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T20 = {7, 0, 0, 0, 0, 0, 0, 40, 20, 4, 15, 0},
-		.config_T22 = {7, 0, 0, 0, 0, 0, 0, 0, 20, 0, 1, 10, 15, 20, 25, 30, 0},
-		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T25 = {3, 0, 200, 50, 64, 31, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-		.config_T28 = {0, 0, 2, 4, 8, 60},
-		.object_crc = {0x83, 0xC3, 0xE4},
-		.filter_level = {15, 60, 963, 1008},
-	},
-	{
-		.version = 0x015,
-		.abs_x_min = 13,
-		.abs_x_max = 1009,
-		.abs_y_min = 15,
-		.abs_y_max = 960,
-		.abs_pressure_min = 0,
-		.abs_pressure_max = 255,
-		.abs_width_min = 0,
-		.abs_width_max = 20,
-		.gpio_irq = INCREDIBLEC_GPIO_TP_INT_N,
-		.power = incrediblec_atmel_ts_power,
-		.config_T6 = {0, 0, 0, 0, 0, 0},
-		.config_T7 = {50, 15, 25},
-		.config_T8 = {12, 0, 20, 20, 0, 0, 20, 0},
-		.config_T9 = {139, 0, 0, 18, 12, 0, 32, 40, 2, 7, 0, 5, 2, 0, 2, 10, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 47, 149, 81},
-		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T20 = {7, 0, 0, 0, 0, 0, 0, 30, 20, 4, 15, 5},
-		.config_T22 = {7, 0, 0, 25, 0, -25, 255, 4, 50, 0, 1, 10, 15, 20, 25, 30, 4},
-		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T25 = {3, 0, 200, 50, 64, 31, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-		.config_T28 = {0, 0, 2, 4, 8, 60},
-		.object_crc = {0x19, 0x87, 0x7E},
-	},
-	{
-		.version = 0x014,
-		.abs_x_min = 13,
-		.abs_x_max = 1009,
-		.abs_y_min = 15,
-		.abs_y_max = 960,
-		.abs_pressure_min = 0,
-		.abs_pressure_max = 255,
-		.abs_width_min = 0,
-		.abs_width_max = 20,
-		.gpio_irq = INCREDIBLEC_GPIO_TP_INT_N,
-		.power = incrediblec_atmel_ts_power,
-		.config_T6 = {0, 0, 0, 0, 0, 0},
-		.config_T7 = {50, 15, 25},
-		.config_T8 = {12, 0, 20, 20, 0, 0, 10, 15},
-		.config_T9 = {3, 0, 0, 18, 12, 0, 48, 45, 2, 7, 0, 0, 0, 0, 2, 10, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 47, 143, 81},
-		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T20 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T22 = {5, 0, 0, 25, 0, -25, 255, 4, 50, 0, 1, 10, 15, 20, 25, 30, 4},
-		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T25 = {3, 0, 200, 50, 64, 31, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-		.config_T28 = {0, 0, 2, 4, 8, 60},
-	}
-};
-
-static struct regulator_consumer_supply tps65023_dcdc1_supplies[] = {
-	{
-		.supply = "acpu_vcore",
-	},
-};
-
-static struct regulator_init_data tps65023_data[5] = {
-	{
-		.constraints = {
-			.name = "dcdc1", /* VREG_MSMC2_1V29 */
-			.min_uV = 1000000,
-			.max_uV = 1300000,
-			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
-		},
-		.consumer_supplies = tps65023_dcdc1_supplies,
-		.num_consumer_supplies = ARRAY_SIZE(tps65023_dcdc1_supplies),
-	},
-	/* dummy values for unused regulators to not crash driver: */
-	{
-		.constraints = {
-			.name = "dcdc2", /* VREG_MSMC1_1V26 */
-			.min_uV = 1260000,
-			.max_uV = 1260000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "dcdc3", /* unused */
-			.min_uV = 800000,
-			.max_uV = 3300000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo1", /* unused */
-			.min_uV = 1000000,
-			.max_uV = 3150000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo2", /* V_USBPHY_3V3 */
-			.min_uV = 3300000,
-			.max_uV = 3300000,
-		},
-	},
-};
-
-static void set_h2w_dat(int n)
-{
-	gpio_set_value(INCREDIBLEC_GPIO_H2W_DATA, n);
-}
-
-static void set_h2w_clk(int n)
-{
-	gpio_set_value(INCREDIBLEC_GPIO_H2W_CLK, n);
-}
-
-static int get_h2w_dat(void)
-{
-	return gpio_get_value(INCREDIBLEC_GPIO_H2W_DATA);
-}
-
-static int get_h2w_clk(void)
-{
-	return gpio_get_value(INCREDIBLEC_GPIO_H2W_CLK);
-}
-
-static void h2w_dev_power_on(int on)
-{
-	printk(KERN_INFO "Not support H2W power\n");
-}
-
-/* default TX,RX to GPI */
-static uint32_t uart3_off_gpi_table[] = {
-	/* RX, H2W DATA */
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_H2W_DATA, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),
-	/* TX, H2W CLK */
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_H2W_CLK, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),
-};
-
-/* set TX,RX to GPO */
-static uint32_t uart3_off_gpo_table[] = {
-	/* RX, H2W DATA */
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_H2W_DATA, 0,
-		      GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	/* TX, H2W CLK */
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_H2W_CLK, 0,
-		      GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-};
-
-static void set_h2w_dat_dir(int n)
-{
-#if 0
-	if (n == 0) /* input */
-		gpio_direction_input(INCREDIBLEC_GPIO_H2W_DATA);
-	else
-		gpio_configure(INCREDIBLEC_GPIO_H2W_DATA, GPIOF_DRIVE_OUTPUT);
-#else
-	if (n == 0) /* input */
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table + 0, 0);
-	else
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpo_table + 0, 0);
-#endif
-}
-
-static void set_h2w_clk_dir(int n)
-{
-#if 0
-	if (n == 0) /* input */
-		gpio_direction_input(INCREDIBLEC_GPIO_H2W_CLK);
-	else
-		gpio_configure(INCREDIBLEC_GPIO_H2W_CLK, GPIOF_DRIVE_OUTPUT);
-#else
-	if (n == 0) /* input */
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table + 1, 0);
-	else
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpo_table + 1, 0);
-#endif
-}
-
-
-static void incrediblec_config_serial_debug_gpios(void);
-
-static void h2w_configure(int route)
-{
-	printk(KERN_INFO "H2W route = %d \n", route);
-	switch (route) {
-	case H2W_UART3:
-		incrediblec_config_serial_debug_gpios();
-		printk(KERN_INFO "H2W -> UART3\n");
-		break;
-	case H2W_GPIO:
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table + 0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table + 1, 0);
-		printk(KERN_INFO "H2W -> GPIO\n");
-		break;
-	}
-}
-
-static struct h2w_platform_data incrediblec_h2w_data = {
-	.cable_in1	= INCREDIBLEC_GPIO_CABLE_IN1,
-	.cable_in2	= INCREDIBLEC_GPIO_CABLE_IN2,
-	.h2w_clk	= INCREDIBLEC_GPIO_H2W_CLK,
-	.h2w_data	= INCREDIBLEC_GPIO_H2W_DATA,
-	.debug_uart = H2W_UART3,
-
-	.config		= h2w_configure,
-	.h2w_power	= h2w_dev_power_on,
-
-	.set_dat_dir	= set_h2w_dat_dir,
-	.set_clk_dir	= set_h2w_clk_dir,
-	.set_dat	= set_h2w_dat,
-	.set_clk	= set_h2w_clk,
-	.get_dat	= get_h2w_dat,
-	.get_clk	= get_h2w_clk,
-};
-
-static struct platform_device incrediblec_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &incrediblec_h2w_data,
-	},
-};
-
-static struct audio_jack_platform_data incrediblec_jack_data = {
-	.gpio	= INCREDIBLEC_GPIO_35MM_HEADSET_DET,
-};
-
-static struct platform_device incrediblec_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &incrediblec_jack_data,
-	},
-};
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = INCREDIBLEC_LAYOUTS,
-	.project_name = INCREDIBLEC_PROJECT_NAME,
-	.reset = INCREDIBLEC_GPIO_COMPASS_RST_N,
-	.intr = INCREDIBLEC_GPIO_COMPASS_INT_N,
-};
-
-static struct tpa6130_platform_data headset_amp_platform_data = {
-	.enable_rpc_server = 0,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(ATMEL_QT602240_NAME, 0x94 >> 1),
-		.platform_data = &incrediblec_atmel_ts_data,
-		.irq = MSM_GPIO_TO_INT(INCREDIBLEC_GPIO_TP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = MSM_GPIO_TO_INT(INCREDIBLEC_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO("ds2482", 0x30 >> 1),
-		/*.platform_data = &microp_data,*/
-		/*.irq = MSM_GPIO_TO_INT(PASSION_GPIO_UP_INT_N)*/
-	},
-	{
-		I2C_BOARD_INFO("smb329", 0x6E >> 1),
-	},
-	{
-		I2C_BOARD_INFO("akm8973", 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = MSM_GPIO_TO_INT(INCREDIBLEC_GPIO_COMPASS_INT_N),
-	},
-#ifdef CONFIG_MSM_CAMERA
-#ifdef CONFIG_OV8810
-	{
-		I2C_BOARD_INFO("ov8810", 0x6C >> 1),
-	},
-#endif
-#endif/*CONIFIG_MSM_CAMERA*/
-
-	{
-		I2C_BOARD_INFO(TPA6130_I2C_NAME, 0xC0 >> 1),
-		.platform_data = &headset_amp_platform_data,
-	},
-	{
-		I2C_BOARD_INFO("tps65023", 0x48),
-		.platform_data = tps65023_data,
-	},
-};
-
-#ifdef CONFIG_ARCH_QSD8X50
-static char bdaddress[20];
-
-static void bt_export_bd_address(void)
- {
-	unsigned char cTemp[6];
-
-	memcpy(cTemp, get_bt_bd_ram(), 6);
-	sprintf(bdaddress, "%02x:%02x:%02x:%02x:%02x:%02x", cTemp[0], cTemp[1], cTemp[2], cTemp[3], cTemp[4], cTemp[5]);
-	printk(KERN_INFO "YoYo--BD_ADDRESS=%s\n", bdaddress);
-}
-
-module_param_string(bdaddress, bdaddress, sizeof(bdaddress), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bdaddress, "BT MAC ADDRESS");
-#endif
-
-static uint32_t camera_off_gpio_table[] = {
-
-#if 0	/* CAMERA OFF*/
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-#endif
-	/* CAMERA SUSPEND*/
-	PCOM_GPIO_CFG(0, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-	PCOM_GPIO_CFG(99, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA), /* CAM1_RST */
-	PCOM_GPIO_CFG(INCREDIBLEC_CAM_PWD,
-		0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA), /* CAM1_PWD */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA ON */
-	PCOM_GPIO_CFG(0, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_16MA), /* MCLK */
-};
-
-static void config_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-static void config_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		 INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_camera_on_gpios,
-	.camera_gpio_off = config_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
-	.camera_flash		= flashlight_control,
-	.num_flash_levels	= FLASHLIGHT_NUM,
-	.low_temp_limit		= 10,
-	.low_cap_limit		= 15,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_ov8810_data = {
-	.sensor_name    = "ov8810",
-	.sensor_reset   = INCREDIBLEC_CAM_RST, /* CAM1_RST */
-	.sensor_pwd     = INCREDIBLEC_CAM_PWD,  /* CAM1_PWDN, enabled in a9 */
-	.pdata		= &msm_camera_device_data,
-	.resource	= msm_camera_resources,
-	.num_resources	= ARRAY_SIZE(msm_camera_resources),
-	.waked_up	= 0,
-	.need_suspend	= 0,
-	.flash_cfg	= &msm_camera_sensor_flash_cfg,
-};
-
-static struct platform_device msm_camera_sensor_ov8810 = {
-    .name           = "msm_camera_ov8810",
-    .dev            = {
-    .platform_data = &msm_camera_sensor_ov8810_data,
-    },
-};
-
-static void config_incrediblec_flashlight_gpios(void)
-{
-	static uint32_t flashlight_gpio_table[] = {
-		PCOM_GPIO_CFG(INCREDIBLEC_GPIO_FLASHLIGHT_TORCH, 0,
-					GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-		PCOM_GPIO_CFG(INCREDIBLEC_GPIO_FLASHLIGHT_FLASH, 0,
-					GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-		PCOM_GPIO_CFG(INCREDIBLEC_GPIO_FLASHLIGHT_FLASH_ADJ, 0,
-					GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	};
-
-	config_gpio_table(flashlight_gpio_table,
-		ARRAY_SIZE(flashlight_gpio_table));
-}
-
-static struct flashlight_platform_data incrediblec_flashlight_data = {
-	.gpio_init  = config_incrediblec_flashlight_gpios,
-	.torch = INCREDIBLEC_GPIO_FLASHLIGHT_TORCH,
-	.flash = INCREDIBLEC_GPIO_FLASHLIGHT_FLASH,
-	.flash_adj = INCREDIBLEC_GPIO_FLASHLIGHT_FLASH_ADJ,
-	.flash_duration_ms = 600,
-	.led_count = 1,
-};
-
-static struct platform_device incrediblec_flashlight_device = {
-	.name = "flashlight",
-	.dev		= {
-		.platform_data	= &incrediblec_flashlight_data,
-	},
-};
-
-static void curcial_oj_shutdown(int enable)
-{
-	uint8_t cmd[3];
-	memset(cmd, 0, sizeof(uint8_t)*3);
-
-	cmd[2] = 0x80;
-	if (enable)
-		microp_i2c_write(0x91, cmd, 3);
-	else
-		microp_i2c_write(0x90, cmd, 3);
-}
-
-static int curcial_oj_poweron(int on)
-{
-	struct vreg *oj_power = vreg_get(0, "synt");
-	if (IS_ERR(oj_power)) {
-		printk(KERN_ERR "%s: Error power domain\n", __func__);
-		return 0;
-	}
-
-	if (on) {
-		vreg_set_level(oj_power, 2750);
-		vreg_enable(oj_power);
-	} else
-		vreg_disable(oj_power);
-
-	printk(KERN_INFO "%s: OJ power enable(%d)\n", __func__, on);
-	return 1;
-};
-static void curcial_oj_adjust_xy(uint8_t *data, int16_t *mSumDeltaX, int16_t *mSumDeltaY)
-{
-	int8_t 	deltaX;
-	int8_t 	deltaY;
-
-
-	if (data[2] == 0x80)
-		data[2] = 0x81;
-	if (data[1] == 0x80)
-		data[1] = 0x81;
-	if (0) {
-		deltaX = (1)*((int8_t) data[2]); /*X=2*/
-		deltaY = (1)*((int8_t) data[1]); /*Y=1*/
-	} else {
-		deltaX = (1)*((int8_t) data[1]);
-		deltaY = (1)*((int8_t) data[2]);
-	}
-	*mSumDeltaX += -((int16_t)deltaX);
-	*mSumDeltaY += -((int16_t)deltaY);
-}
-static struct curcial_oj_platform_data incrediblec_oj_data = {
-	.oj_poweron	= curcial_oj_poweron,
-	.oj_shutdown	= curcial_oj_shutdown,
-	.oj_adjust_xy = curcial_oj_adjust_xy,
-	.microp_version	= INCREDIBLEC_MICROP_VER,
-	.mdelay_time = 0,
-	.msleep_time = 1,
-	.x_send_count = 3,
-	.y_send_count = 3,
-	.fast_th = 1,
-	.normal_th = 15,
-	.continue_th = 3,
-	.continue_max = 0,
-	.xy_ratio = 15,
-	.interval = 70,
-	.softclick	= true,
-	.swap		= true,
-	.x 		= 1,
-	.y		= 1,
-	.share_power	= true,
-	.Xsteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-	.Ysteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-};
-
-static struct platform_device incrediblec_oj = {
-	.name = CURCIAL_OJ_NAME,
-	.id = -1,
-	.dev = {
-		.platform_data	= &incrediblec_oj_data,
-	}
-};
-
-static int amoled_power(int on)
-{
-	static struct vreg *vreg_lcm_2v6;
-	if (!vreg_lcm_2v6) {
-		vreg_lcm_2v6 = vreg_get(0, "gp1");
-		if (IS_ERR(vreg_lcm_2v6))
-			return -EINVAL;
-	}
-
-	if (on) {
-		unsigned id, on = 1;
-
-		id = PM_VREG_PDOWN_CAM_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on, &id);
-		vreg_enable(vreg_lcm_2v6);
-
-		gpio_set_value(INCREDIBLEC_LCD_RST_ID1, 1);
-		mdelay(25);
-		gpio_set_value(INCREDIBLEC_LCD_RST_ID1, 0);
-		mdelay(10);
-		gpio_set_value(INCREDIBLEC_LCD_RST_ID1, 1);
-		mdelay(20);
-	} else {
-		unsigned id, on = 0;
-
-		gpio_set_value(INCREDIBLEC_LCD_RST_ID1, 0);
-
-		id = PM_VREG_PDOWN_CAM_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on, &id);
-		vreg_disable(vreg_lcm_2v6);
-	}
-	return 0;
-}
-
-#define LCM_GPIO_CFG(gpio, func) \
-PCOM_GPIO_CFG(gpio, func, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA)
-static uint32_t display_on_gpio_table[] = {
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R0, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R1, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R2, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R3, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R4, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R5, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G0, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G1, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G2, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G3, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G4, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G5, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B0, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B1, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B2, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B3, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B4, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B5, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_PCLK, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_VSYNC, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_HSYNC, 1),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_DE, 1),
-};
-
-static uint32_t display_off_gpio_table[] = {
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R0, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R1, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R2, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R3, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R4, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_R5, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G0, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G1, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G2, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G3, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G4, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_G5, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B0, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B1, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B2, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B3, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B4, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_B5, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_PCLK, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_VSYNC, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_HSYNC, 0),
-	LCM_GPIO_CFG(INCREDIBLEC_LCD_DE, 0),
-};
-
-static int panel_gpio_switch(int on)
-{
-	if (on)
-		config_gpio_table(display_on_gpio_table,
-			ARRAY_SIZE(display_on_gpio_table));
-	else {
-		int i;
-
-		config_gpio_table(display_off_gpio_table,
-			ARRAY_SIZE(display_off_gpio_table));
-
-		for (i = INCREDIBLEC_LCD_R0; i <= INCREDIBLEC_LCD_R5; i++)
-			gpio_set_value(i, 0);
-		for (i = INCREDIBLEC_LCD_G0; i <= INCREDIBLEC_LCD_G5; i++)
-			gpio_set_value(i, 0);
-		for (i = INCREDIBLEC_LCD_B0; i <= INCREDIBLEC_LCD_DE; i++)
-			gpio_set_value(i, 0);
-	}
-	return 0;
-}
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct panel_platform_data amoled_data = {
-	.fb_res = &resources_msm_fb[0],
-	.power = amoled_power,
-	.gpio_switch = panel_gpio_switch,
-};
-
-static struct platform_device amoled_panel = {
-	.name = "amoled-panel",
-	.id = -1,
-	.dev = {
-		.platform_data = &amoled_data
-	},
-};
-static struct platform_device *devices[] __initdata = {
-	&amoled_panel,
-	&msm_device_uart1,
-#ifdef CONFIG_SERIAL_MSM_HS
-	&msm_device_uart_dm1,
-#endif
-	&incrediblec_h2w,
-	&htc_battery_pdev,
-	&incrediblec_audio_jack,
-	&ram_console_device,
-	&incrediblec_rfkill,
-	&msm_device_smd,
-	&msm_device_nand,
-	/*&msm_device_hsusb,*/
-	/*&usb_mass_storage_device,*/
-	&android_pmem_mdp_device,
-	&android_pmem_adsp_device,
-	&android_pmem_camera_device,
-	&msm_camera_sensor_ov8810,
-	&msm_kgsl_device,
-	&msm_device_i2c,
-	&incrediblec_flashlight_device,
-	&incrediblec_leds,
-
-#if defined(CONFIG_SPI_QSD)
-	&qsd_device_spi,
-#endif
-	&incrediblec_oj,
-};
-
-static uint32_t incrediblec_serial_debug_table[] = {
-	/* RX */
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_UART3_RX, 3, GPIO_INPUT, GPIO_NO_PULL,
-		      GPIO_4MA),
-	/* TX */
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_UART3_TX, 3, GPIO_OUTPUT, GPIO_NO_PULL,
-		      GPIO_4MA),
-};
-
-static uint32_t incrediblec_uart_gpio_table[] = {
-        /* RX */
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_UART3_RX, 3, GPIO_INPUT, GPIO_NO_PULL,
-                      GPIO_4MA),
-	/* TX */
-        PCOM_GPIO_CFG(INCREDIBLEC_GPIO_UART3_TX, 3, GPIO_INPUT, GPIO_NO_PULL,
-                      GPIO_4MA),
-};
-
-static uint32_t incrediblec_usb_phy_3v3_table[] = {
-	PCOM_GPIO_CFG(INCREDIBLEC_USB_PHY_3V3_ENABLE, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA)
-};
-
-static uint32_t usb_ID_PIN_table[] = {
-	PCOM_GPIO_CFG(INCREDIBLEC_GPIO_USB_ID_PIN, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),
-};
-
-static void incrediblec_config_serial_debug_gpios(void)
-{
-	config_gpio_table(incrediblec_serial_debug_table,
-				ARRAY_SIZE(incrediblec_serial_debug_table));
-}
-
-static void incrediblec_config_uart_gpios(void)
-{
-        config_gpio_table(incrediblec_uart_gpio_table,
-				ARRAY_SIZE(incrediblec_uart_gpio_table));
-}
-
-static struct msm_i2c_device_platform_data msm_i2c_pdata = {
-	.i2c_clock = 100000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_8MA,
-};
-
-static void __init msm_device_i2c_init(void)
-{
-	msm_device_i2c.dev.platform_data = &msm_i2c_pdata;
-}
-
-static struct msm_acpu_clock_platform_data incrediblec_clock_data = {
-	.acpu_switch_time_us	= 20,
-	.max_speed_delta_khz	= 256000,
-	.vdd_switch_time_us	= 62,
-	.power_collapse_khz	= 245000,
-	.wait_for_irq_khz	= 245000,
-};
-
-static unsigned incrediblec_perf_acpu_table[] = {
-	245000000,
-	576000000,
-	998400000,
-};
-
-static struct perflock_platform_data incrediblec_perflock_data = {
-	.perf_acpu_table = incrediblec_perf_acpu_table,
-	.table_size = ARRAY_SIZE(incrediblec_perf_acpu_table),
-};
-
-int incrediblec_init_mmc(int sysrev);
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(INCREDIBLEC_GPIO_BT_HOST_WAKE),	/*Chip to Device*/
-	.inject_rx_on_wakeup = 0,
-	.cpu_lock_supported = 0,
-
-	/* for bcm */
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = INCREDIBLEC_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = INCREDIBLEC_GPIO_BT_HOST_WAKE,
-
-};
-#endif
-
-static int OJ_BMA_power(void)
-{
-	int ret;
-	struct vreg *vreg = vreg_get(0, "synt");
-
-	if (!vreg) {
-		printk(KERN_ERR "%s: vreg error\n", __func__);
-		return -EIO;
-	}
-	ret = vreg_set_level(vreg, 2850);
-
-	ret = vreg_enable(vreg);
-	if (ret < 0)
-		printk(KERN_ERR "%s: vreg enable failed\n", __func__);
-
-	return 0;
-}
-
-unsigned int incrediblec_get_engineerid(void)
-{
-	return engineerid;
-}
-
-static ssize_t incrediblec_virtual_keys_show(struct kobject *kobj,
-			struct kobj_attribute *attr, char *buf)
-{
-	if (engineerid > 1 && system_rev > 1) {
-			/* center: x: home: 45, menu: 152, back: 318, search 422, y: 830 */
-		return sprintf(buf,
-			__stringify(EV_KEY) ":" __stringify(KEY_HOME)	    ":47:830:74:50"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":155:830:80:50"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":337:830:90:50"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":434:830:60:50"
-			"\n");
-	} else {
-		/* center: x: home: 50, menu: 184, back: 315, search 435, y: 830*/
-		return sprintf(buf,
-			__stringify(EV_KEY) ":" __stringify(KEY_HOME)	    ":50:830:98:50"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":184:830:120:50"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":315:830:100:50"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":435:830:88:50"
-			"\n");
-	}
-
-}
-
-static struct kobj_attribute incrediblec_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.atmel-touchscreen",
-		.mode = S_IRUGO,
-	},
-	.show = &incrediblec_virtual_keys_show,
-};
-
-static struct attribute *incrediblec_properties_attrs[] = {
-	&incrediblec_virtual_keys_attr.attr,
-	NULL
-};
-
-static struct attribute_group incrediblec_properties_attr_group = {
-	.attrs = incrediblec_properties_attrs,
-};
-
-static void incrediblec_reset(void)
-{
-       gpio_set_value(INCREDIBLEC_GPIO_PS_HOLD, 0);
-}
-
-static void __init incrediblec_init(void)
-{
-	int ret;
-	struct kobject *properties_kobj;
-
-	printk("incrediblec_init() revision=%d, engineerid=%d\n", system_rev, engineerid);
-
-	 msm_hw_reset_hook = incrediblec_reset;
-
-	if (0 == engineerid || 0xF == engineerid) {
-		mdp_pmem_pdata.start = MSM_PMEM_MDP_XA_BASE;
-		android_pmem_adsp_pdata.start = MSM_PMEM_ADSP_XA_BASE;
-                msm_kgsl_resources[1].start = MSM_GPU_MEM_XA_BASE;
-                msm_kgsl_resources[1].end = MSM_GPU_MEM_XA_BASE + MSM_GPU_MEM_SIZE - 1;
-	} else if (engineerid >= 3) {
-		mdp_pmem_pdata.start = MSM_PMEM_MDP_BASE + MSM_MEM_128MB_OFFSET;
-		android_pmem_adsp_pdata.start = MSM_PMEM_ADSP_BASE + MSM_MEM_128MB_OFFSET;
-		msm_kgsl_resources[1].start = MSM_GPU_MEM_BASE;
-		msm_kgsl_resources[1].end =  msm_kgsl_resources[1].start + MSM_GPU_MEM_SIZE - 1;
-	}
-
-	OJ_BMA_power();
-
-	gpio_direction_output(INCREDIBLEC_GPIO_PROXIMITY_EN_N, 0);
-
-	msm_acpu_clock_init(&incrediblec_clock_data);
-
-	perflock_init(&incrediblec_perflock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	msm_serial_debug_init(MSM_UART1_PHYS, INT_UART1,
-				&msm_device_uart1.dev, 1, INT_UART1_RX);
-#endif
-
-#ifdef CONFIG_ARCH_QSD8X50
-	bt_export_bd_address();
-#endif
-	/* set the gpu power rail to manual mode so clk en/dis will not
-	 * turn off gpu power, and hang it on resume */
-	incrediblec_kgsl_power_rail_mode(0);
-	incrediblec_kgsl_power(true);
-
-	#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_device_uart_dm1.name = "msm_serial_hs_bcm";	/* for bcm */
-	#endif
-
-	incrediblec_config_uart_gpios();
-
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-	/*gpio_direction_output(INCREDIBLEC_GPIO_TP_LS_EN, 0);*/
-	gpio_direction_output(INCREDIBLEC_GPIO_TP_EN, 0);
-
-	incrediblec_audio_init();
-	msm_device_i2c_init();
-#ifdef CONFIG_MICROP_COMMON
-	incrediblec_microp_init();
-#endif
-
-	msm_init_ums_lun(2); /*0: sd card, 1: moving nand*/
-	msm_register_usb_phy_init_seq(incrediblec_phy_init_seq);
-	msm_hsusb_set_product(incrediblec_usb_products,
-		ARRAY_SIZE(incrediblec_usb_products));
-	msm_register_uart_usb_switch(NULL);
-	msm_add_usb_id_pin_gpio(INCREDIBLEC_GPIO_USB_ID_PIN);
-	msm_add_usb_devices(msm_hsusb_8x50_phy_reset, NULL);
-
-	if (system_rev >= 2) {
-		microp_data.num_functions   = ARRAY_SIZE(microp_functions_1);
-		microp_data.microp_function = microp_functions_1;
-	}
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	ret = incrediblec_init_mmc(system_rev);
-	if (ret != 0)
-		pr_crit("%s: Unable to initialize MMC\n", __func__);
-
-	properties_kobj = kobject_create_and_add("board_properties", NULL);
-	if (properties_kobj)
-		ret = sysfs_create_group(properties_kobj,
-				&incrediblec_properties_attr_group);
-	if (!properties_kobj || ret)
-		pr_err("failed to create board_properties\n");
-
-	msm_init_pmic_vibrator();
-
-	config_gpio_table(incrediblec_usb_phy_3v3_table, ARRAY_SIZE(incrediblec_usb_phy_3v3_table));
-	config_gpio_table(usb_ID_PIN_table, ARRAY_SIZE(usb_ID_PIN_table));
-	gpio_direction_output(INCREDIBLEC_USB_PHY_3V3_ENABLE, 1);
-}
-
-static void __init incrediblec_fixup(struct machine_desc *desc, struct tag *tags,
-				 char **cmdline, struct meminfo *mi)
-{
-	engineerid = parse_tag_engineerid(tags);
-	mi->nr_banks = 1;
-	mi->bank[0].start = PHYS_OFFSET;
-	mi->bank[0].node = PHYS_TO_NID(PHYS_OFFSET);
-	if (0 == engineerid || 0xF == engineerid)
-		mi->bank[0].size = (MSM_LINUX_XA_SIZE);
-	else if (engineerid <= 2) { /* 4G3G */
-		mi->bank[0].size = MSM_EBI1_BANK0_SIZE;
-		mi->nr_banks++;
-		mi->bank[1].start = MSM_EBI1_BANK1_BASE;
-		mi->bank[1].node = PHYS_TO_NID(MSM_EBI1_BANK1_BASE);
-		mi->bank[1].size = MSM_EBI1_BANK1_SIZE;
-	} else {
-		mi->bank[0].size = MSM_EBI1_BANK0_SIZE;
-		mi->nr_banks++;
-		mi->bank[1].start = MSM_EBI1_BANK1_BASE;
-		mi->bank[1].node = PHYS_TO_NID(MSM_EBI1_BANK1_BASE);
-		mi->bank[1].size = MSM_EBI1_BANK1_SIZE + MSM_MEM_128MB_OFFSET;
-	}
-}
-
-static void __init incrediblec_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-extern struct sys_timer msm_timer;
-
-MACHINE_START(INCREDIBLEC, "incrediblec")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params	= 0x20000100,
-	.fixup		= incrediblec_fixup,
-	.map_io		= incrediblec_map_io,
-	.init_irq	= msm_init_irq,
-	.init_machine	= incrediblec_init,
-	.timer		= &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-incrediblec.h b/arch/arm/mach-msm/board-incrediblec.h
deleted file mode 100644
index d2965b6..0000000
--- a/arch/arm/mach-msm/board-incrediblec.h
+++ /dev/null
@@ -1,191 +0,0 @@
-/* arch/arm/mach-msm/board-incrediblec.h
- *
- * Copyright (C) 2009 HTC Corporation.
- * Author: Haley Teng <Haley_Teng@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_INCREDIBLEC_H
-#define __ARCH_ARM_MACH_MSM_BOARD_INCREDIBLEC_H
-
-#include <mach/board.h>
-
-
-#define MSM_SMI_BASE		0x02B00000
-#define MSM_SMI_SIZE		0x01500000
-
-#define MSM_PMEM_CAMERA_BASE	0x02B00000
-#define MSM_PMEM_CAMERA_SIZE	0x00C00000
-
-#define MSM_GPU_MEM_BASE	0x03700000
-#define MSM_GPU_MEM_SIZE	0x00300000
-
-#define MSM_RAM_CONSOLE_BASE	0x03A00000
-#define MSM_RAM_CONSOLE_SIZE	0x00040000
-
-#define MSM_FB_BASE		0x03B00000
-#define MSM_FB_SIZE		0x00465000
-
-#define MSM_EBI1_BANK0_BASE	0x20000000
-#define MSM_EBI1_BANK0_SIZE	0x0E800000
-
-#define MSM_EBI1_BANK1_BASE     0x30000000
-#define MSM_EBI1_BANK1_SIZE     0x03500000
-
-#define MSM_PMEM_MDP_BASE	0x33500000
-#define MSM_PMEM_MDP_SIZE	0x02000000
-
-#define MSM_PMEM_ADSP_BASE	0x35500000
-#define MSM_PMEM_ADSP_SIZE	0x02900000
-
-#define MSM_TV_FB_BASE          0x37E00000
-#define MSM_TV_FB_SIZE          0x00200000
-
-#define MSM_MEM_128MB_OFFSET	0x08000000
-
-/* 4G2G MCP */
-#define MSM_PMEM_ADSP_XA_BASE   0x29000000
-
-#define MSM_TV_FB_XA_BASE       0x2B900000
-
-#define MSM_PMEM_MDP_XA_BASE    0x2BB00000
-
-#define MSM_GPU_MEM_XA_BASE     0x03700000
-
-#define MSM_LINUX_XA_SIZE       0x09000000
-/* 4G2G END */
-
-#define INCREDIBLEC_GPIO_UP_INT_N		35
-#define INCREDIBLEC_GPIO_UP_RESET_N	108
-
-#define INCREDIBLEC_GPIO_TP_RST		34
-#define INCREDIBLEC_GPIO_TP_INT_N		145
-/*#define INCREDIBLEC_GPIO_TP_LS_EN		93*/
-#define INCREDIBLEC_GPIO_TP_EN			98
-
-#define INCREDIBLEC_GPIO_SDMC_CD_N		28
-
-/* BT */
-#define INCREDIBLEC_GPIO_BT_UART1_RTS (43)
-#define INCREDIBLEC_GPIO_BT_UART1_CTS (44)
-#define INCREDIBLEC_GPIO_BT_UART1_RX (45)
-#define INCREDIBLEC_GPIO_BT_UART1_TX (46)
-#define INCREDIBLEC_GPIO_BT_RESET_N (146)
-#define INCREDIBLEC_GPIO_BT_HOST_WAKE (86)
-#define INCREDIBLEC_GPIO_BT_CHIP_WAKE (87)
-#define INCREDIBLEC_GPIO_BT_SHUTDOWN_N (128)
-
-#define INCREDIBLEC_GPIO_COMPASS_RST_N	107
-#define INCREDIBLEC_GPIO_COMPASS_INT_N	36
-#define INCREDIBLEC_PROJECT_NAME        "incrediblec"
-#define INCREDIBLEC_LAYOUTS             { \
-		{ {  0,  1, 0}, { -1,  0, 0}, {0, 0, 1} }, \
-		{ {  0, -1, 0}, { -1,  0, 0}, {0, 0, 1} }, \
-		{ { -1,  0, 0}, {  0, -1, 0}, {0, 0, 1} }, \
-		{ {  1,  0, 0}, {  0,  0, 1}, {0, 1, 0} }  \
-					}
-
-/* Proximity */
-#define INCREDIBLEC_GPIO_PROXIMITY_EN_N	120
-
-/* Battery */
-#define INCREDIBLEC_GPIO_MBAT_IN		39
-#define INCREDIBLEC_GPIO_MCHG_EN_N	22
-#define INCREDIBLEC_GPIO_ISET		16
-
-/*Audio */
-#define INCREDIBLEC_AUD_JACKHP_EN       157
-#define INCREDIBLEC_AUD_2V5_EN          26
-
-/* Bluetooth PCM */
-#define INCREDIBLEC_BT_PCM_OUT          68
-#define INCREDIBLEC_BT_PCM_IN           69
-#define INCREDIBLEC_BT_PCM_SYNC         70
-#define INCREDIBLEC_BT_PCM_CLK          71
-
-#define INCREDIBLEC_GPIO_MENU_KEY	40
-#define INCREDIBLEC_GPIO_VOLUME_UP	41
-#define INCREDIBLEC_GPIO_VOLUME_DOWN	42
-#define INCREDIBLEC_GPIO_POWER_KEY	94
-#define INCREDIBLEC_GPIO_OJ_ACTION_XB	33
-
-/* flash light */
-#define INCREDIBLEC_GPIO_FLASHLIGHT_FLASH	(84)
-#define INCREDIBLEC_GPIO_FLASHLIGHT_TORCH	(85)
-#define INCREDIBLEC_GPIO_FLASHLIGHT_FLASH_ADJ	(31)
-
-/* 35mm headset */
-#define INCREDIBLEC_GPIO_35MM_HEADSET_DET (153)
-#define INCREDIBLEC_GPIO_CABLE_IN1 (38)
-#define INCREDIBLEC_GPIO_CABLE_IN2 (37)
-#define INCREDIBLEC_GPIO_H2W_DATA (139)
-#define INCREDIBLEC_GPIO_H2W_CLK (140)
-#define INCREDIBLEC_GPIO_UART3_RX (139)
-#define INCREDIBLEC_GPIO_UART3_TX (140)
-
-/* Wifi */
-#define INCREDIBLEC_GPIO_WIFI_SHUTDOWN_N	127
-#define INCREDIBLEC_GPIO_WIFI_IRQ		152
-
-/* SPI */
-#define INCREDIBLEC_SPI_CLK                     (17)
-#define INCREDIBLEC_SPI_DO                      (18)
-#define INCREDIBLEC_SPI_CS                      (20)
-
-#define INCREDIBLEC_LCD_RST_ID1                 (29)
-#define INCREDIBLEC_LCD_ID0                     (32)
-
-/* TV-out */
-#define INCREDIBLEC_TV_LOAD_DET			(82)
-#define INCREDIBLEC_VIDEO_SHDN_N                (109)
-#define INCREDIBLEC_AV_SWITCH			(119)
-
-/* LCD */
-#define INCREDIBLEC_LCD_R0                      (113)
-#define INCREDIBLEC_LCD_R1                      (114)
-#define INCREDIBLEC_LCD_R2                      (115)
-#define INCREDIBLEC_LCD_R3                      (116)
-#define INCREDIBLEC_LCD_R4                      (117)
-#define INCREDIBLEC_LCD_R5                      (118)
-#define INCREDIBLEC_LCD_G0                      (121)
-#define INCREDIBLEC_LCD_G1                      (122)
-#define INCREDIBLEC_LCD_G2                      (123)
-#define INCREDIBLEC_LCD_G3                      (124)
-#define INCREDIBLEC_LCD_G4                      (125)
-#define INCREDIBLEC_LCD_G5                      (126)
-#define INCREDIBLEC_LCD_B0                      (129)
-#define INCREDIBLEC_LCD_B1                      (130)
-#define INCREDIBLEC_LCD_B2                      (131)
-#define INCREDIBLEC_LCD_B3                      (132)
-#define INCREDIBLEC_LCD_B4                      (133)
-#define INCREDIBLEC_LCD_B5                      (134)
-#define INCREDIBLEC_LCD_PCLK                    (135)
-#define INCREDIBLEC_LCD_VSYNC                   (136)
-#define INCREDIBLEC_LCD_HSYNC                   (137)
-#define INCREDIBLEC_LCD_DE                      (138)
-
-/* USB PHY 3V3 enable*/
-#define INCREDIBLEC_USB_PHY_3V3_ENABLE                      (104)
-#define INCREDIBLEC_GPIO_USB_CABLE_IN_PIN          (144)
-#define INCREDIBLEC_GPIO_USB_ID_PIN          (112)
-
-/* AP Key Led turn on*/
-#define INCREDIBLEC_AP_KEY_LED_EN                     (143)
-
-/*Camera*/
-#define INCREDIBLEC_CAM_PWD	(100)
-#define INCREDIBLEC_CAM_RST	(99)
-
-#define INCREDIBLEC_GPIO_PS_HOLD	(25)
-
-unsigned int incrediblec_get_engineerid(void);
-
-#endif /* __ARCH_ARM_MACH_MSM_BOARD_INCREDIBLEC_H */
diff --git a/arch/arm/mach-msm/board-latte-keypad.c b/arch/arm/mach-msm/board-latte-keypad.c
deleted file mode 100644
index 990bcc3..0000000
--- a/arch/arm/mach-msm/board-latte-keypad.c
+++ /dev/null
@@ -1,354 +0,0 @@
-/* arch/arm/mach-msm/board-latte-keypad.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <linux/gpio.h>
-#include <linux/keyreset.h>
-#include <asm/mach-types.h>
-#include <mach/board_htc.h>
-
-#include "board-latte.h"
-#include "proc_comm.h"
-
-static char *keycaps = "--qwerty";
-#undef MODULE_PARAM_PREFIX
-#define MODULE_PARAM_PREFIX "board_latte."
-
-module_param_named(keycaps, keycaps, charp, 0);
-
-static unsigned int latte_col_gpios[] = {
-	LATTE_GPIO_KP_MKOUT0, /* 35 */
-	LATTE_GPIO_KP_MKOUT1, /* 34 */
-	LATTE_GPIO_KP_MKOUT2, /* 33 */
-	LATTE_GPIO_KP_MKOUT3, /* 120 */
-	LATTE_GPIO_KP_MKOUT4, /* 119 */
-	LATTE_GPIO_KP_MKOUT5, /* 118 */
-	LATTE_GPIO_KP_MKOUT6, /* 117 */
-	LATTE_GPIO_KP_MKOUT7, /* 116 */
-};
-static unsigned int latte_row_gpios[] = {
-	LATTE_GPIO_KP_MKIN0, /* 42 */
-	LATTE_GPIO_KP_MKIN1, /* 41 */
-	LATTE_GPIO_KP_MKIN2, /* 40 */
-	LATTE_GPIO_KP_MKIN3, /* 92 */
-	LATTE_GPIO_KP_MKIN4, /* 17 */
-	LATTE_GPIO_KP_MKIN5, /* 114 */
-	LATTE_GPIO_KP_MKIN6, /* 112 */
-};
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(latte_row_gpios) + (row))
-
-static const unsigned short latte_keymap_x0[ARRAY_SIZE(latte_col_gpios) *
-					ARRAY_SIZE(latte_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_Q,
-	[KEYMAP_INDEX(0, 1)] = KEY_I,
-	[KEYMAP_INDEX(0, 2)] = KEY_G,
-	[KEYMAP_INDEX(0, 3)] = KEY_Z,
-	[KEYMAP_INDEX(0, 4)] = KEY_RIGHTSHIFT,
-	[KEYMAP_INDEX(0, 5)] = KEY_SEARCH,
-	[KEYMAP_INDEX(0, 6)] = KEY_EMAIL, /* @ */
-
-	[KEYMAP_INDEX(1, 0)] = KEY_W,
-	[KEYMAP_INDEX(1, 1)] = KEY_O,
-	[KEYMAP_INDEX(1, 2)] = KEY_H,
-	[KEYMAP_INDEX(1, 3)] = KEY_X,
-	[KEYMAP_INDEX(1, 4)] = KEY_ENTER, /* e-SYM */
-	[KEYMAP_INDEX(1, 5)] = KEY_F13,
-	[KEYMAP_INDEX(1, 6)] = KEY_TAB,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_E,
-	[KEYMAP_INDEX(2, 1)] = KEY_P,
-	[KEYMAP_INDEX(2, 2)] = KEY_J,
-	[KEYMAP_INDEX(2, 3)] = KEY_C,
-	[KEYMAP_INDEX(2, 4)] = KEY_LEFTALT, /* FN */
-	[KEYMAP_INDEX(2, 5)] = KEY_RIGHTALT,
-	[KEYMAP_INDEX(2, 6)] = KEY_DOT,
-
-	[KEYMAP_INDEX(3, 0)] = KEY_R,
-	[KEYMAP_INDEX(3, 1)] = KEY_A,
-	[KEYMAP_INDEX(3, 2)] = KEY_K,
-	[KEYMAP_INDEX(3, 3)] = KEY_V,
-	[KEYMAP_INDEX(3, 4)] = KEY_QUESTION, /* ? */
-	[KEYMAP_INDEX(3, 5)] = KEY_F16, /* AP1 */
-	[KEYMAP_INDEX(3, 6)] = KEY_VOLUMEUP,
-
-	[KEYMAP_INDEX(4, 0)] = KEY_T,
-	[KEYMAP_INDEX(4, 1)] = KEY_S,
-	[KEYMAP_INDEX(4, 2)] = KEY_L,
-	[KEYMAP_INDEX(4, 3)] = KEY_B,
-	[KEYMAP_INDEX(4, 4)] = KEY_COMMA, /* , */
-	[KEYMAP_INDEX(4, 5)] = KEY_HOME, /* HOME (AP) */
-	[KEYMAP_INDEX(4, 6)] = KEY_VOLUMEDOWN,
-
-	[KEYMAP_INDEX(5, 0)] = KEY_Y,
-	[KEYMAP_INDEX(5, 1)] = KEY_D,
-	[KEYMAP_INDEX(5, 2)] = KEY_BACKSPACE,
-	[KEYMAP_INDEX(5, 3)] = KEY_N,
-	[KEYMAP_INDEX(5, 4)] = KEY_F14, /* SYM */
-	[KEYMAP_INDEX(5, 5)] = BTN_MOUSE, /* OJ-action */
-	[KEYMAP_INDEX(5, 6)] = KEY_F17,
-
-	[KEYMAP_INDEX(6, 0)] = KEY_U,
-	[KEYMAP_INDEX(6, 1)] = KEY_F,
-	[KEYMAP_INDEX(6, 2)] = KEY_LEFTSHIFT, /* SHIFT */
-	[KEYMAP_INDEX(6, 3)] = KEY_M,
-	[KEYMAP_INDEX(6, 4)] = KEY_SPACE,
-	[KEYMAP_INDEX(6, 5)] = KEY_MENU, /* MENU (AP) */
-	[KEYMAP_INDEX(6, 6)] = KEY_BACK, /* BACK (AP) */
-
-	[KEYMAP_INDEX(7, 0)] = KEY_HP, /* CAM STEP1 */
-	[KEYMAP_INDEX(7, 1)] = KEY_CAMERA, /* CAM STEP2 */
-	[KEYMAP_INDEX(7, 2)] = KEY_F15,
-	[KEYMAP_INDEX(7, 3)] = KEY_RESERVED,
-	[KEYMAP_INDEX(7, 4)] = KEY_RESERVED,
-	[KEYMAP_INDEX(7, 5)] = KEY_RESERVED,
-	[KEYMAP_INDEX(7, 6)] = KEY_RESERVED,
-};
-
-static const unsigned short latte_keymap_x1[ARRAY_SIZE(latte_col_gpios) *
-					ARRAY_SIZE(latte_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_Q,
-	[KEYMAP_INDEX(0, 1)] = KEY_I,
-	[KEYMAP_INDEX(0, 2)] = KEY_G,
-	[KEYMAP_INDEX(0, 3)] = KEY_Z,
-	[KEYMAP_INDEX(0, 4)] = KEY_LEFTALT,
-	[KEYMAP_INDEX(0, 5)] = KEY_SEARCH,
-	[KEYMAP_INDEX(0, 6)] = KEY_EMAIL, /* @ */
-
-	[KEYMAP_INDEX(1, 0)] = KEY_W,
-	[KEYMAP_INDEX(1, 1)] = KEY_O,
-	[KEYMAP_INDEX(1, 2)] = KEY_H,
-	[KEYMAP_INDEX(1, 3)] = KEY_X,
-	[KEYMAP_INDEX(1, 4)] = KEY_F15, /* HOME */
-	[KEYMAP_INDEX(1, 5)] = KEY_F13, /* 0-SYM */
-	[KEYMAP_INDEX(1, 6)] = KEY_TAB,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_E,
-	[KEYMAP_INDEX(2, 1)] = KEY_BACKSPACE,
-	[KEYMAP_INDEX(2, 2)] = KEY_ENTER,
-	[KEYMAP_INDEX(2, 3)] = KEY_C,
-	[KEYMAP_INDEX(2, 4)] = KEY_RIGHTSHIFT, /* SHIFT_R */
-	[KEYMAP_INDEX(2, 5)] = KEY_RIGHTALT,
-	[KEYMAP_INDEX(2, 6)] = KEY_DOT,
-
-	[KEYMAP_INDEX(3, 0)] = KEY_R,
-	[KEYMAP_INDEX(3, 1)] = KEY_P,
-	[KEYMAP_INDEX(3, 2)] = KEY_L,
-	[KEYMAP_INDEX(3, 3)] = KEY_V,
-	[KEYMAP_INDEX(3, 4)] = KEY_QUESTION, /* ? */
-	[KEYMAP_INDEX(3, 5)] = KEY_F14, /* SYM */
-	[KEYMAP_INDEX(3, 6)] = KEY_VOLUMEUP,
-
-	[KEYMAP_INDEX(4, 0)] = KEY_T,
-	[KEYMAP_INDEX(4, 1)] = KEY_S,
-	[KEYMAP_INDEX(4, 2)] = KEY_LEFTSHIFT,
-	[KEYMAP_INDEX(4, 3)] = KEY_B,
-	[KEYMAP_INDEX(4, 4)] = KEY_COMMA,
-	[KEYMAP_INDEX(4, 5)] = KEY_HOME,
-	[KEYMAP_INDEX(4, 6)] = KEY_VOLUMEDOWN,
-
-	[KEYMAP_INDEX(5, 0)] = KEY_Y,
-	[KEYMAP_INDEX(5, 1)] = KEY_D,
-	[KEYMAP_INDEX(5, 2)] = KEY_F,
-	[KEYMAP_INDEX(5, 3)] = KEY_N,
-	[KEYMAP_INDEX(5, 4)] = KEY_F16, /* BACK */
-	[KEYMAP_INDEX(5, 5)] = BTN_MOUSE, /* OJ-action */
-	[KEYMAP_INDEX(5, 6)] = KEY_F17,
-
-	[KEYMAP_INDEX(6, 0)] = KEY_A,
-	[KEYMAP_INDEX(6, 1)] = KEY_U,
-	[KEYMAP_INDEX(6, 2)] = KEY_K,
-	[KEYMAP_INDEX(6, 3)] = KEY_M,
-	[KEYMAP_INDEX(6, 4)] = KEY_SPACE,
-	[KEYMAP_INDEX(6, 5)] = KEY_MENU, /* MENU (AP) */
-	[KEYMAP_INDEX(6, 6)] = KEY_BACK, /* BACK (AP) */
-
-	[KEYMAP_INDEX(7, 0)] = KEY_HP, /* CAM STEP1 */
-	[KEYMAP_INDEX(7, 1)] = KEY_CAMERA, /* CAM STEP2 */
-	[KEYMAP_INDEX(7, 2)] = KEY_J,
-	[KEYMAP_INDEX(7, 3)] = KEY_RESERVED,
-	[KEYMAP_INDEX(7, 4)] = KEY_RESERVED,
-	[KEYMAP_INDEX(7, 5)] = KEY_RESERVED,
-	[KEYMAP_INDEX(7, 6)] = KEY_RESERVED,
-};
-
-static void latte_matrix_inputs_gpio(void)
-{
-	static uint32_t matirx_inputs_gpio_table[] = {
-		PCOM_GPIO_CFG(LATTE_GPIO_KP_MKIN0, 0, GPIO_INPUT, GPIO_PULL_UP,
-								GPIO_4MA),
-		PCOM_GPIO_CFG(LATTE_GPIO_KP_MKIN1, 0, GPIO_INPUT, GPIO_PULL_UP,
-								GPIO_4MA),
-		PCOM_GPIO_CFG(LATTE_GPIO_KP_MKIN2, 0, GPIO_INPUT, GPIO_PULL_UP,
-								GPIO_4MA),
-		PCOM_GPIO_CFG(LATTE_GPIO_KP_MKIN3, 0, GPIO_INPUT, GPIO_PULL_UP,
-								GPIO_4MA),
-		PCOM_GPIO_CFG(LATTE_GPIO_KP_MKIN4, 0, GPIO_INPUT, GPIO_PULL_UP,
-								GPIO_4MA),
-		PCOM_GPIO_CFG(LATTE_GPIO_KP_MKIN5, 0, GPIO_INPUT, GPIO_PULL_UP,
-								GPIO_4MA),
-		PCOM_GPIO_CFG(LATTE_GPIO_KP_MKIN6, 0, GPIO_INPUT, GPIO_PULL_UP,
-								GPIO_4MA),
-	};
-
-	config_gpio_table(matirx_inputs_gpio_table,
-		ARRAY_SIZE(matirx_inputs_gpio_table));
-}
-
-
-static struct gpio_event_matrix_info latte_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = latte_keymap_x1,
-	.output_gpios = latte_col_gpios,
-	.input_gpios = latte_row_gpios,
-	.noutputs = ARRAY_SIZE(latte_col_gpios),
-	.ninputs = ARRAY_SIZE(latte_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		  GPIOKPF_REMOVE_PHANTOM_KEYS |
-		  GPIOKPF_PRINT_UNMAPPED_KEYS |
-		  GPIOKPF_PRINT_MAPPED_KEYS ),
-	.setup_ninputs_gpio = latte_matrix_inputs_gpio,
-};
-
-static struct gpio_event_direct_entry latte_keypad_power_map[] = {
-	{
-		.gpio = LATTE_POWER_KEY,
-		.code = KEY_POWER,
-	},
-};
-
-static void latte_power_input_gpio(void)
-{
-	static uint32_t inputs_gpio_table[] = {
-		PCOM_GPIO_CFG(LATTE_POWER_KEY, 0, GPIO_INPUT,
-					GPIO_PULL_UP, GPIO_4MA),
-	};
-
-	config_gpio_table(inputs_gpio_table,
-		ARRAY_SIZE(inputs_gpio_table));
-}
-
-static struct gpio_event_input_info latte_keypad_power_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = GPIOEDF_PRINT_KEYS,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = latte_keypad_power_map,
-	.keymap_size = ARRAY_SIZE(latte_keypad_power_map),
-	.setup_input_gpio = latte_power_input_gpio,
-};
-
-static struct gpio_event_direct_entry latte_sliding_switch[] = {
-	{
-		.gpio = LATTE_GPIO_SLIDING_DET,
-		.code = SW_LID
-	},
-};
-
-static void latte_sliding_input_gpio(void)
-{
-	static uint32_t inputs_gpio_table[] = {
-		PCOM_GPIO_CFG(LATTE_GPIO_SLIDING_DET, 0, GPIO_INPUT,
-						GPIO_NO_PULL, GPIO_4MA),
-	};
-
-	config_gpio_table(inputs_gpio_table,
-		ARRAY_SIZE(inputs_gpio_table));
-}
-
-
-static struct gpio_event_input_info latte_keypad_switch_info = {
-	.info.func = gpio_event_input_func,
-#if 1
-	.flags = GPIOEDF_PRINT_KEYS,
-#else
-	.flags = GPIOKPF_ACTIVE_HIGH,
-	/* FIXME: since sliding is opened on Latte barebone system,
-	 * set the active direction inverse on purpose
-	 * just for our convenience in current stage.
-	 */
-#endif
-	.type = EV_SW,
-	.keymap = latte_sliding_switch,
-	.keymap_size = ARRAY_SIZE(latte_sliding_switch),
-	.setup_input_gpio = latte_sliding_input_gpio,
-};
-
-static struct gpio_event_info *latte_keypad_info[] = {
-	&latte_keypad_switch_info.info,
-	&latte_keypad_matrix_info.info,
-	&latte_keypad_power_info.info,
-};
-
-static struct gpio_event_platform_data latte_keypad_data = {
-	.name = "latte-keypad-v2",
-	.info = latte_keypad_info,
-	.info_count = ARRAY_SIZE(latte_keypad_info)
-};
-
-static struct platform_device latte_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &latte_keypad_data,
-	},
-};
-
-static int latte_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0
-};
-
-static struct keyreset_platform_data latte_reset_keys_pdata = {
-	.keys_up = latte_reset_keys_up,
-	.keys_down = {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-static struct platform_device latte_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &latte_reset_keys_pdata,
-};
-
-int __init latte_init_keypad(void)
-{
-	char *get_cid, *get_carrier, *get_keycaps;
-
-	board_get_cid_tag(&get_cid);
-	board_get_carrier_tag(&get_carrier);
-	board_get_keycaps_tag(&get_keycaps);
-	if (system_rev < 2) {
-		latte_keypad_data.name = "latte-keypad-v0";
-		latte_keypad_matrix_info.keymap =  latte_keymap_x0;
-	}
-
-	if (system_rev == 2)
-		latte_keypad_data.name = "latte-keypad-v1";
-
-	if (platform_device_register(&latte_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	return platform_device_register(&latte_keypad_device);
-}
-
diff --git a/arch/arm/mach-msm/board-latte-microp.c b/arch/arm/mach-msm/board-latte-microp.c
deleted file mode 100644
index 82ca9ce..0000000
--- a/arch/arm/mach-msm/board-latte-microp.c
+++ /dev/null
@@ -1,172 +0,0 @@
-/* arch/arm/mach-msm/board-latte-microp.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <mach/atmega_microp.h>
-#include <mach/drv_callback.h>
-
-#include "board-latte.h"
-
-static struct i2c_client *latte_microp_client;
-/*
-static struct led_trigger latte_als_level_trigger = {
-	.name     = "auto-backlight-trigger",
-};
-*/
-/*
-static int latte_als_intr_enable(struct i2c_client *client,
-		uint32_t als_func, uint8_t enable)
-{
-	struct microp_i2c_client_data *cdata;
-
-	cdata = i2c_get_clientdata(client);
-
-	return microp_write_interrupt(client,
-		cdata->int_pin.int_lsensor, enable);
-}
-*/
-
-/*
-static void latte_als_level_change(struct i2c_client *client,
-		uint8_t *data)
-{
-	led_trigger_event(&latte_als_level_trigger, data[2]);
-}
-*/
-
-/*
-static int latte_als_power(int pwr_device, uint8_t enable)
-{
-	struct i2c_client *client = latte_microp_client;
-	struct microp_i2c_platform_data *pdata;
-	int value;
-
-	pdata = client->dev.platform_data;
-	value = enable ? 1 : 0;
-	if (pdata->ls_power)
-		pdata->ls_power(value);
-
-	return 0;
-}
-*/
-
-/*
-static int latte_als_table_init(struct i2c_client *client,
-			int i, uint32_t kadc, uint32_t gadc)
-{
-	struct microp_i2c_platform_data *pdata;
-	uint8_t data[20];
-	int j;
-
-	pdata = client->dev.platform_data;
-
-	for (j = 0; j < 10; j++) {
-		data[j] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc >> 8);
-		data[j + 10] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc);
-	}
-
-	return microp_i2c_write(MICROP_I2C_WCMD_ADC_TABLE, data, 20);
-}
-*/
-
-static int latte_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	latte_microp_client = client;
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Light sensor */
-/*
-	ret = microp_function_check(client, MICROP_FUNCTION_LSENSOR);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_LSENSOR] = i;
-		cdata->int_pin.int_lsensor = pdata->microp_function[i].int_pin;
-		microp_get_als_kvalue(i);
-
-		ret = latte_als_table_init(client, i, cdata->als_kadc,
-				cdata->als_gadc);
-		if (ret < 0)
-			goto exit;
-
-		if (pdata->ls_power)
-			pdata->ls_power(1);
-	}
-*/
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	ret = microp_write_interrupt(client, (1<<8), 1);
-	if (ret)
-		goto exit;
-
-	/* OJ interrupt */
-	ret = microp_function_check(client, MICROP_FUNCTION_OJ);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_oj = pdata->microp_function[i].int_pin;
-
-		ret = microp_write_interrupt(client, cdata->int_pin.int_oj, 1);
-		if (ret)
-			goto exit;
-	}
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = latte_microp_function_init,
-/*
-	.als_pwr_enable = latte_als_power,
-	.als_intr_enable = latte_als_intr_enable,
-	.als_level_change = latte_als_level_change,
-*/
-};
-
-void __init latte_microp_init(void)
-{
-	/*led_trigger_register(&latte_als_level_trigger);*/
-	microp_register_ops(&ops);
-}
-
-#endif
diff --git a/arch/arm/mach-msm/board-latte-mmc.c b/arch/arm/mach-msm/board-latte-mmc.c
deleted file mode 100755
index 06c31b1..0000000
--- a/arch/arm/mach-msm/board-latte-mmc.c
+++ /dev/null
@@ -1,401 +0,0 @@
-/* linux/arch/arm/mach-msm/board-latte-mmc.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-#include <mach/htc_pwrsink.h>
-
-#include "devices.h"
-#include "board-latte.h"
-#include "proc_comm.h"
-
-#include <linux/dma-mapping.h>
-#include <mach/dma.h>
-#include "../../../drivers/mmc/host/msm_sdcc.h"
-
-/* #include <linux/irq.h> */
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_6MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_6MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_6MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_6MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_6MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_6MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init latte_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_espresso.disable_sdcard=", latte_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t latte_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-		writel(MCI_PWR_OFF, MSM_SDC2_BASE + MMCIPOWER);
-		mdelay(1);
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		vreg_enable(vreg_sdslot);
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-			printk(KERN_INFO "%s: Setting level to %u\n",
-					__func__, mmc_vdd_table[i].level);
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-			if (!sdslot_vreg_enabled)
-				break;
-			else
-				return 0;
-		}
-	}
-
-	/* All vdd match failed */
-	if (i == ARRAY_SIZE(mmc_vdd_table))
-		goto out;
-
-	if (!sdslot_vreg_enabled) {
-		u32 pwr = 0;
-
-		/* Power on MCI controller */
-		mdelay(5);
-		pwr = readl(MSM_SDC2_BASE + MMCIPOWER);
-		writel(pwr | MCI_PWR_UP, MSM_SDC2_BASE + MMCIPOWER);
-		mdelay(5);
-		pwr = readl(MSM_SDC2_BASE + MMCIPOWER);
-		writel(pwr | MCI_PWR_ON, MSM_SDC2_BASE + MMCIPOWER);
-		mdelay(5);
-
-		/* ..then, config GPIO */
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-		return 0;
-	}
-
-out:
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int latte_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(LATTE_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define LATTE_MMC_VDD	MMC_VDD_28_29 | MMC_VDD_29_30
-
-static unsigned int latte_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data latte_sdslot_data = {
-	.ocr_mask	= LATTE_MMC_VDD,
-	.status_irq	= MSM_GPIO_TO_INT(LATTE_GPIO_SDMC_CD_N),
-	.status		= latte_sdslot_status,
-	.translate_vdd	= latte_sdslot_switchvdd,
-	.slot_type	= &latte_sdslot_type,
-};
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_16MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-static struct vreg *vreg_wifi_osc;	/* WIFI 32khz oscilator */
-static int latte_wifi_cd;		/* WIFI virtual 'card detect' status */
-
-static struct sdio_embedded_func wifi_func[2] = {
-	{.f_class	= SDIO_CLASS_WLAN,
-	.f_maxblksize	= 512},
-	{.f_class       = SDIO_CLASS_WLAN,
-	.f_maxblksize   = 512},
-};
-
-static struct embedded_sdio_data latte_wifi_emb_data = {
-	.cis	= {
-		.vendor		= 0x104c,
-		.device		= 0x9066,
-		.blksize	= 512,
-		/* .max_dtr	= 24000000, */
-		.max_dtr	= 25000000,
-	},
-	.cccr	= {
-		.multi_block	= 0,
-		.low_speed	= 0,
-		.wide_bus	= 1,
-		.high_power	= 0,
-		.high_speed	= 0,
-	},
-	.funcs	= wifi_func,
-	.num_funcs = 2,
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-latte_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int latte_wifi_status(struct device *dev)
-{
-	return latte_wifi_cd;
-}
-
-static struct mmc_platform_data latte_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= latte_wifi_status,
-	.register_status_notify	= latte_wifi_status_register,
-	.embedded_sdio		= &latte_wifi_emb_data,
-#ifdef CONFIG_MMC_SUPPORT_EXTERNEL_DRIVER
-	.use_ext_sdiodrv	= 1,
-	.ext_sdiodrv_name	= "TIWLAN_SDIO",
-#endif
-};
-
-int latte_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	latte_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(latte_wifi_set_carddetect);
-
-int latte_wifi_power_state = 0;
-int latte_bt_power_state = 0;
-
-int latte_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-
-		rc = vreg_enable(vreg_wifi_osc);
-		mdelay(100);
-
-		gpio_set_value(LATTE_GPIO_WIFI_EN, 1);
-		mdelay(50);
-		gpio_set_value(LATTE_GPIO_WIFI_EN, 0);
-		mdelay(1);
-		gpio_set_value(LATTE_GPIO_WIFI_EN, 1);
-		mdelay(200);
-		htc_pwrsink_set(PWRSINK_WIFI, 70);
-
-
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-		gpio_set_value(LATTE_GPIO_WIFI_EN, on);
-		mdelay(10);
-
-		htc_pwrsink_set(PWRSINK_WIFI, 0);
-
-		if (!latte_bt_power_state) {
-			vreg_disable(vreg_wifi_osc);
-			printk(KERN_INFO "WiFi disable vreg_wifi_osc.\n");
-		} else
-			printk(KERN_ERR "WiFi shouldn't disable "
-					"vreg_wifi_osc. BT is using it!!\n");
-	}
-
-	latte_wifi_power_state = on;
-	return 0;
-}
-EXPORT_SYMBOL(latte_wifi_power);
-
-/* Eenable VREG_MMC pin to turn on fastclock oscillator : colin */
-int latte_bt_fastclock_power(int on)
-{
-	int rc;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (vreg_wifi_osc) {
-		if (on) {
-			rc = vreg_enable(vreg_wifi_osc);
-
-			if (rc) {
-				printk(KERN_ERR "Error turn bt_fastclock_power"
-							" rc=%d\n", rc);
-				return rc;
-			}
-		} else {
-			if (!latte_wifi_power_state)
-				vreg_disable(vreg_wifi_osc);
-		}
-	}
-	latte_bt_power_state = on;
-	return 0;
-}
-EXPORT_SYMBOL(latte_bt_fastclock_power);
-
-// static int latte_wifi_reset_state;
-int latte_wifi_reset(int on)
-{
-#if 1
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-#else
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-	gpio_set_value(TROUT_GPIO_WIFI_PA_RESETX, !on);
-	latte_wifi_reset_state = on;
-	mdelay(50);
-#endif
-	return 0;
-}
-
-int __init latte_init_mmc(unsigned int sys_rev)
-{
-
-	uint32_t id;
-	sdslot_vreg_enabled = 0;
-
-
-	/* initial LEVEL_SHIT_EN */
-	id = PCOM_GPIO_CFG(30, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	/* let level shifter alaways enabled,
-	   and remove all GPIO30 configuration codes */
-	gpio_set_value(30, 0);
-
-	wifi_status_cb = NULL;
-
-
-	printk(KERN_INFO "%s\n", __func__);
-
-	vreg_wifi_osc = vreg_get(0, "rftx");
-	if (IS_ERR(vreg_wifi_osc))
-		return PTR_ERR(vreg_wifi_osc);
-	vreg_set_level(vreg_wifi_osc, 1800);
-
-	msm_add_sdcc(1, &latte_wifi_data, 0, 0);
-
-
-	if (opt_disable_sdcard) {
-		printk(KERN_INFO "latte: SD-Card interface disabled\n");
-		goto done;
-	}
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-
-	set_irq_wake(MSM_GPIO_TO_INT(LATTE_GPIO_SDMC_CD_N), 1);
-
-	msm_add_sdcc(2, &latte_sdslot_data, MSM_GPIO_TO_INT(LATTE_GPIO_SDMC_CD_N),
-			IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-done:
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-latte-panel.c b/arch/arm/mach-msm/board-latte-panel.c
deleted file mode 100644
index e811cfd..0000000
--- a/arch/arm/mach-msm/board-latte-panel.c
+++ /dev/null
@@ -1,297 +0,0 @@
-/* linux/arch/arm/mach-msm/board-latte-panel.c
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/leds.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-#include <mach/vreg.h>
-#include <mach/pmic.h>
-
-#include "devices.h"
-#include "board-latte.h"
-#include "proc_comm.h"
-
-#if 0
-#define B(s...) printk(s)
-#else
-#define B(s...) do {} while (0)
-#endif
-
-static struct led_trigger *latte_lcd_backlight;
-static void latte_set_backlight(int on)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	if (on) {
-		/* vsync back porch is about 17 ms */
-		hr_msleep(40);
-		led_trigger_event(latte_lcd_backlight, LED_FULL);
-	} else
-		led_trigger_event(latte_lcd_backlight, LED_OFF);
-}
-
-static struct vreg *vreg_lcm_2v6;
-static struct vreg *vreg_lcm_2v85;
-
-static void
-latte_mddi_eid_power(struct msm_mddi_client_data *client_data, int on)
-{
-	unsigned id, on_off = 1;
-
-	B(KERN_DEBUG "%s: power %s.\n", __func__, on ? "on" : "off");
-	if (on) {
-		on_off = 0;
-		/* 2V6(pmic gp4) */
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v6);
-		hr_msleep(1);
-
-		/* 2V8(pmic rfrx2) */
-		id = PM_VREG_PDOWN_RFRX2_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v85);
-		hr_msleep(5);
-
-		gpio_set_value(LATTE_LCD_RSTz, 1);
-		hr_msleep(100);
-	} else {
-		on_off = 1;
-		hr_msleep(150);
-		gpio_set_value(LATTE_LCD_RSTz, 0);
-		hr_msleep(3);
-
-		/* 2V8(pmic rfrx2) */
-		id = PM_VREG_PDOWN_RFRX2_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_disable(vreg_lcm_2v85);
-		hr_msleep(5);
-
-		/* 2V6(pmic gp4) */
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_disable(vreg_lcm_2v6);
-	}
-}
-
-static int
-latte_panel_unblank(struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	latte_set_backlight(1);
-	return 0;
-}
-
-static int
-latte_panel_blank(struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	latte_set_backlight(0);
-	return 0;
-}
-
-#define LATTE_BR_DEF_USER_TOP           102
-#define LATTE_BR_MIN_USER_TOP           30
-#define LATTE_BR_MAX_USER_TOP           255
-#define LATTE_BR_DEF_PANEL_TOP          115
-#define LATTE_BR_MIN_PANEL_TOP          8
-#define LATTE_BR_MAX_PANEL_TOP          250
-
-#define LATTE_BR_DEF_USER_SHARP         102
-#define LATTE_BR_MIN_USER_SHARP         30
-#define LATTE_BR_MAX_USER_SHARP         255
-#define LATTE_BR_DEF_PANEL_SHARP        115
-#define LATTE_BR_MIN_PANEL_SHARP        8
-#define LATTE_BR_MAX_PANEL_SHARP        255
-
-static int
-latte_panel_shrink_top(int brightness)
-{
-        if (brightness <= LATTE_BR_DEF_USER_TOP) {
-                if (brightness <= LATTE_BR_MIN_USER_TOP)
-                        brightness = LATTE_BR_MIN_PANEL_TOP;
-                else
-                        brightness = (LATTE_BR_DEF_PANEL_TOP - LATTE_BR_MIN_PANEL_TOP) *
-                                (brightness - LATTE_BR_MIN_USER_TOP) /
-                                (LATTE_BR_DEF_USER_TOP - LATTE_BR_MIN_USER_TOP) +
-                                LATTE_BR_MIN_PANEL_TOP;
-                } else
-                        brightness = (LATTE_BR_MAX_PANEL_TOP - LATTE_BR_DEF_PANEL_TOP) *
-                                (brightness - LATTE_BR_DEF_USER_TOP) /
-                                (LATTE_BR_MAX_USER_TOP - LATTE_BR_DEF_USER_TOP) +
-                                LATTE_BR_DEF_PANEL_TOP;
-
-        return brightness;
-}
-
-static int
-latte_panel_shrink_sharp(int brightness)
-{
-        if (brightness <= LATTE_BR_DEF_USER_SHARP) {
-                if (brightness <= LATTE_BR_MIN_USER_SHARP)
-                        brightness = LATTE_BR_MIN_PANEL_SHARP;
-                else
-                        brightness = (LATTE_BR_DEF_PANEL_SHARP - LATTE_BR_MIN_PANEL_SHARP) *
-                                (brightness - LATTE_BR_MIN_USER_SHARP) /
-                                (LATTE_BR_DEF_USER_SHARP - LATTE_BR_MIN_USER_SHARP) +
-                                LATTE_BR_MIN_PANEL_SHARP;
-                } else
-                        brightness = (LATTE_BR_MAX_PANEL_SHARP - LATTE_BR_DEF_PANEL_SHARP) *
-                                (brightness - LATTE_BR_DEF_USER_SHARP) /
-                                (LATTE_BR_MAX_USER_SHARP - LATTE_BR_DEF_USER_SHARP) +
-                                LATTE_BR_DEF_PANEL_SHARP;
-
-        return brightness;
-}
-
-static void panel_eid_fixup(uint16_t *mfr_name, uint16_t *product_code)
-{
-	B("%s: enter.\n", __func__);
-	*mfr_name = 0x0101;
-	*product_code = 0x0;
-}
-
-static u8 pwm_eid[10] = {8, 16, 34, 61, 96, 138, 167, 195, 227, 255};
-
-static struct msm_mddi_bridge_platform_data eid_client_data = {
-	.blank = latte_panel_blank,
-	.unblank = latte_panel_unblank,
-	.fb_data = {
-		.xres = 320,
-		.yres = 480,
-		.output_format = 0,
-	},
-};
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct msm_mddi_platform_data latte_pdata = {
-	.clk_rate = 106000000,
-	.power_client = latte_mddi_eid_power,
-	.fixup = panel_eid_fixup,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 1,
-	.client_platform_data = {
-		{
-			.product_id = (0x0101 << 16 | 0),
-			.name = "mddi_c_0101_0000",
-			.id = 1,
-			.client_data = &eid_client_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-/*
- * In boot loader, mddi is powered on already.
- *
- * So, we just detect panel here, setting different
- * power function for each panel.
- *
- * Then we did not have to detect panel in each time
- * mddi_client_power or panel_power is called.
- *
- * jay: Nov 20, 08'
- */
-int __init latte_init_panel(void)
-{
-	int rc;
-	int panel_type = 0;
-	int panel_id = -1;
-	int gpio_lcd_id0, gpio_lcd_id1;
-	uint32_t config;
-	struct panel_data *panel_data = &eid_client_data.panel_conf;
-
-	if (!machine_is_latte())
-		return -1;
-
-	B(KERN_INFO "%s: enter.\n", __func__);
-
-	vreg_lcm_2v6 = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_lcm_2v6))
-		return PTR_ERR(vreg_lcm_2v6);
-
-	vreg_lcm_2v85 = vreg_get(0, "rfrx2");
-	if (IS_ERR(vreg_lcm_2v85))
-		return PTR_ERR(vreg_lcm_2v85);
-
-	gpio_lcd_id0 =  PCOM_GPIO_CFG(LATTE_GPIO_LCD_ID0, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA);
-	gpio_lcd_id1 =  PCOM_GPIO_CFG(LATTE_GPIO_LCD_ID1, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA);
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &gpio_lcd_id0, 0);
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &gpio_lcd_id1, 0);
-
-	panel_id = gpio_get_value(LATTE_GPIO_LCD_ID0) |
-		(gpio_get_value(LATTE_GPIO_LCD_ID1) << 1);
-
-	B(KERN_INFO "%s: panel_id: %d\n", __func__, panel_id);
-
-	switch(panel_id) {
-		case 0:
-			panel_type = 8;
-			panel_data->shrink_br = latte_panel_shrink_sharp;
-		break;
-		case 1:
-			panel_type = 7;
-			panel_data->shrink_br = latte_panel_shrink_top;
-		break;
-		default:
-			return -1;
-		break;
-        }
-	panel_data->panel_id = panel_type;
-	panel_data->caps = MSMFB_CAP_CABC;
-	panel_data->pwm = pwm_eid;
-        panel_data->shrink = 1;
-	panel_data->default_br = 66;
-
-	config = PCOM_GPIO_CFG(LATTE_GPIO_LCD_VSYNC, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA);
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &config, 0);
-
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-
-	msm_device_mddi0.dev.platform_data = &latte_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-
-	led_trigger_register_simple("lcd-backlight-gate", &latte_lcd_backlight);
-	if (IS_ERR(latte_lcd_backlight))
-		printk(KERN_ERR "%s: backlight registration failed!\n",
-			__func__);
-	return 0;
-
-}
-device_initcall(latte_init_panel);
-
diff --git a/arch/arm/mach-msm/board-latte-rfkill.c b/arch/arm/mach-msm/board-latte-rfkill.c
deleted file mode 100644
index 26254ae..0000000
--- a/arch/arm/mach-msm/board-latte-rfkill.c
+++ /dev/null
@@ -1,316 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for latte platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-latte.h"
-
-extern int latte_bt_fastclock_power(int on);
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "brf6450";
-
-static uint32_t latte_bt_init_table[] = {
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_RTS, /* BT_RTS */
-			0,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_CTS, /* BT_CTS */
-			0,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_RX, /* BT_RX */
-			0,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_TX, /* BT_TX */
-			0,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_EN, /* BT_ENABLE */
-			0,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-};
-
-static uint32_t latte_bt_on_table[] = {
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_RTS, /* BT_RTS */
-			2,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_CTS, /* BT_CTS */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_RX, /* BT_RX */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_TX, /* BT_TX */
-			3,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-};
-
-static uint32_t latte_bt_off_table[] = {
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_RTS, /* BT_RTS */
-			2,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_CTS, /* BT_CTS */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_RX, /* BT_RX */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_TX, /* BT_TX */
-			3,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-};
-
-#if 0
-static uint32_t latte_bt_disable_active_table[] = {
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_RTS, /* BT_RTS */
-			2,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_CTS, /* BT_CTS */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_RX, /* BT_RX */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_TX, /* BT_TX */
-			3,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-};
-
-static uint32_t latte_bt_disable_sleep_table[] = {
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_RTS, /* O(L) */
-			0,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_CTS, /* I(PU) */
-			0,
-			GPIO_INPUT,
-			GPIO_PULL_UP,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_RX, /* I(PU) */
-			0,
-			GPIO_INPUT,
-			GPIO_PULL_UP,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LATTE_GPIO_BT_UART1_TX, /* O(H) */
-			0,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-};
-#endif
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void latte_config_bt_init(void)
-{
-	config_bt_table(latte_bt_init_table,
-			ARRAY_SIZE(latte_bt_init_table));
-	mdelay(2);
-
-	gpio_configure(LATTE_GPIO_BT_EN,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-}
-
-static void latte_config_bt_on(void)
-{
-	config_bt_table(latte_bt_on_table,
-			ARRAY_SIZE(latte_bt_on_table));
-	mdelay(2);
-
-	gpio_configure(LATTE_GPIO_BT_EN,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(15);
-	gpio_configure(LATTE_GPIO_BT_EN,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(1);
-	gpio_configure(LATTE_GPIO_BT_EN,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(1);
-
-	latte_bt_fastclock_power(1);
-	mdelay(2);
-}
-
-static void latte_config_bt_off(void)
-{
-	gpio_configure(LATTE_GPIO_BT_EN,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	latte_bt_fastclock_power(0);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(latte_bt_off_table,
-			ARRAY_SIZE(latte_bt_off_table));
-	mdelay(2);
-}
-
-#if 0
-void latte_config_bt_disable_active(void)
-{
-	config_bt_table(latte_bt_disable_active_table,
-			ARRAY_SIZE(latte_bt_disable_active_table));
-}
-
-void latte_config_bt_disable_sleep(void)
-{
-	config_bt_table(latte_bt_disable_sleep_table,
-			ARRAY_SIZE(latte_bt_disable_sleep_table));
-	mdelay(5);
-	gpio_configure(LATTE_GPIO_BT_UART1_RTS,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW); /* O(L) */
-	gpio_configure(LATTE_GPIO_BT_UART1_TX,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH); /* O(H) */
-}
-
-int latte_is_bluetooth_off(void)
-{
-	return !latte_bt_status;	/* ON:1, OFF:0 */
-}
-#endif
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		latte_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		latte_config_bt_off();
-		break;
-	default:
-		printk(KERN_ERR "bad bluetooth rfkill state %d\n", state);
-	}
-	return 0;
-}
-
-static int latte_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;  /* off */
-
-	/* force BT on and off to do GPIO setting when initiate */
-	bluetooth_set_power(NULL, RFKILL_STATE_UNBLOCKED);
-	latte_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;  /* user data */
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-
-	if (rc)
-		rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int latte_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver latte_rfkill_driver = {
-	.probe = latte_rfkill_probe,
-	.remove = latte_rfkill_remove,
-	.driver = {
-		.name = "latte_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init latte_rfkill_init(void)
-{
-	if (!machine_is_latte())
-		return 0;
-	return platform_driver_register(&latte_rfkill_driver);
-}
-
-static void __exit latte_rfkill_exit(void)
-{
-	platform_driver_unregister(&latte_rfkill_driver);
-}
-
-module_init(latte_rfkill_init);
-module_exit(latte_rfkill_exit);
-MODULE_DESCRIPTION("latte rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-latte-wifi.c b/arch/arm/mach-msm/board-latte-wifi.c
deleted file mode 100644
index 7a6dc2c..0000000
--- a/arch/arm/mach-msm/board-latte-wifi.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/* arch/arm/mach-msm/board-latte-wifi.c
- *
- * Copyright (C) 2008 Google, Inc.
- * Author: Dmitry Shmidt <dimitrysh@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/vmalloc.h>
-#include <linux/err.h>
-#include <linux/wifi_tiwlan.h>
-
-extern int latte_wifi_set_carddetect(int val);
-extern int latte_wifi_power(int on);
-extern int latte_wifi_reset(int on);
-
-
-struct wifi_platform_data latte_wifi_control = {
-	.set_power		= latte_wifi_power,
-	.set_reset		= latte_wifi_reset,
-	.set_carddetect	= latte_wifi_set_carddetect,
-	.mem_prealloc	= NULL,
-};
-
-static struct platform_device wifi_ctrl_dev = {
-	.name		= "msm_wifi",
-	.id		= 1,
-	.num_resources	= 0,
-	.resource	= NULL,
-	.dev		= {
-		.platform_data = &latte_wifi_control,
-	},
-};
-
-static int __init latte_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_latte())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	ret = platform_device_register(&wifi_ctrl_dev);
-	return ret;
-}
-
-
-late_initcall(latte_wifi_init);
-
diff --git a/arch/arm/mach-msm/board-latte.c b/arch/arm/mach-msm/board-latte.c
deleted file mode 100644
index 57b9dbd..0000000
--- a/arch/arm/mach-msm/board-latte.c
+++ /dev/null
@@ -1,1005 +0,0 @@
-/* arch/arm/mach-msm/board-latte.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/irq.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/sysdev.h>
-#include <linux/android_pmem.h>
-#include <linux/curcial_oj.h>
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/delay.h>
-#include <asm/setup.h>
-#include <asm/mach/mmc.h>
-#ifdef CONFIG_CACHE_L2X0
-#include <asm/hardware/cache-l2x0.h>
-#endif
-
-#include <mach/system.h>
-#include <mach/vreg.h>
-#include <mach/hardware.h>
-#include <mach/gpio_chip.h>
-#include <mach/board.h>
-#include <mach/board_htc.h>
-#include <mach/msm_serial_hs.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <mach/atmega_microp.h>
-#include <mach/msm_tssc.h>
-#include <mach/htc_battery.h>
-#include <mach/htc_pwrsink.h>
-#include <mach/perflock.h>
-#include <mach/drv_callback.h>
-#include <mach/camera.h>
-#include <mach/msm_flashlight.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/msm_iomap.h>
-#include <mach/msm_hsusb.h>
-
-#include "devices.h"
-#include "board-latte.h"
-#include "proc_comm.h"
-
-void msm_init_irq(void);
-void msm_init_gpio(void);
-void config_latte_camera_on_gpios(void);
-void config_latte_camera_off_gpios(void);
-void config_latte_proximity_gpios(int on);
-#ifdef CONFIG_MICROP_COMMON
-void __init latte_microp_init(void);
-#endif
-
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-//	.gpio_mbat_in = LATTE_GPIO_MBAT_IN,
-//	.gpio_mchg_en_n = LATTE_GPIO_MCHG_EN_N,
-//	.gpio_iset = LATTE_GPIO_ISET,
-	.guage_driver = GUAGE_MODEM,
-	.charger = LINEAR_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0, 0x21, 0x4D, 0xDC, 0x134, 0x18D, 0x1E5, 0x3FF, 0x3FF, 0x3FF },
-		.channel = 3,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xC0,
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 38, 82, 95, 167},
-		.channel = 1,
-		.int_pin = 1 << 5,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "reset-int",
-		.category = MICROP_FUNCTION_RESET_INT,
-		.int_pin = 1 << 8,
-	},
-	{
-		.name   = "oj",
-		.category = MICROP_FUNCTION_OJ,
-		.int_pin = 1 << 12,
-	},
-};
-
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "button-backlight",
-		.type = LED_GPO,
-		.mask_w = {0x00, 0x00, 0x08},
-	},
-	{
-		.name	= "keyboard-backlight",
-		.type = LED_GPO,
-		.mask_w = {0x00, 0x00, 0x04},
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct bma150_platform_data latte_g_sensor_pdata = {
-	.microp_new_cmd = 1,
-};
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev = {
-			.platform_data = &lightsensor_data,
-		},
-	},
-	{
-		.name = "leds-microp",
-		.id = -1,
-		.dev = {
-			.platform_data = &microp_leds_data,
-		},
-	},
-	{
-		.name = BMA150_G_SENSOR_NAME,
-		.dev = {
-			.platform_data = &latte_g_sensor_pdata,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = LATTE_GPIO_UP_RESET_N,
-	.spi_devices = SPI_OJ | SPI_GSENSOR,
-};
-
-static int latte_ts_power(int on)
-{
-	printk(KERN_INFO "latte_ts_power:%d\n", on);
-	if (on) {
-		gpio_set_value(LATTE_TP_5V_EN, 1);
-		msleep(250);
-		/* enable touch panel level shift */
-		gpio_set_value(LATTE_TP_LS_EN, 1);
-		msleep(2);
-	} else {
-		gpio_set_value(LATTE_TP_LS_EN, 0);
-		udelay(50);
-		gpio_set_value(LATTE_TP_5V_EN, 0);
-
-	}
-	return 0;
-}
-
-static struct synaptics_i2c_rmi_platform_data latte_ts_rmi_data[] = {
-	{
-		.version = 0x0100,
-		.power = latte_ts_power,
-		.sensitivity_adjust = 5,
-		.flags = SYNAPTICS_FLIP_Y | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = -1 * 0x10000 / 320,
-		.inactive_right = -1 * 0x10000 / 320,
-		.inactive_top = -1 * 0x10000 / 480,
-		.inactive_bottom = -1 * 0x10000 / 480,
-		.display_width = 320,
-		.display_height = 480,
-		.dup_threshold = 10,
-		.margin_inactive_pixel = {8, 20, 20, 8},
-	}
-};
-
-static void latte_phy_shutdown(void)
-{
-	printk(KERN_INFO "%s\n", __func__);
-	gpio_set_value(LATTE_GPIO_USBPHY_3V3_EN, 0);
-}
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = LATTE_LAYOUTS,
-	.project_name = LATTE_PROJECT_NAME,
-	.reset = LATTE_GPIO_COMPASS_RST_N,
-	.intr = LATTE_GPIO_COMPASS_INT_N,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{	/* new panel uses I2C dev addr 0x2C */
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x2C),
-		.platform_data = &latte_ts_rmi_data,
-		.irq = LATTE_GPIO_TO_INT(LATTE_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x2D),
-		.platform_data = &latte_ts_rmi_data,
-		.irq = LATTE_GPIO_TO_INT(LATTE_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = LATTE_GPIO_TO_INT(LATTE_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = LATTE_GPIO_TO_INT(LATTE_GPIO_COMPASS_INT_N),
-	},
-};
-
-static struct h2w_platform_data latte_h2w_data = {
-};
-
-static struct platform_device latte_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &latte_h2w_data,
-	},
-};
-
-static struct audio_jack_platform_data latte_jack_data = {
-	.gpio	= LATTE_GPIO_35MM_HEADSET_DET,
-};
-
-static struct platform_device latte_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &latte_jack_data,
-	},
-};
-
-static struct pwr_sink latte_pwrsink_table[] = {
-	{
-		.id     = PWRSINK_AUDIO,
-		.ua_max = 100000,
-	},
-	{
-		.id     = PWRSINK_BACKLIGHT,
-		.ua_max = 125000,
-	},
-	{
-		.id     = PWRSINK_LED_BUTTON,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_LED_KEYBOARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_GP_CLK,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_BLUETOOTH,
-		.ua_max = 15000,
-	},
-	{
-		.id     = PWRSINK_CAMERA,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_SDCARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_VIDEO,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id     = PWRSINK_SYSTEM_LOAD,
-		.ua_max = 100000,
-		.percent_util = 38,
-	},
-};
-
-static int espresso_phy_init_seq[] = { 0xC, 0x31, 0x31, 0x32, 0x1D, 0x0D, 0x1D, 0x10, -1 };
-static struct msm_hsusb_product espresso_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c86,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-
-static void latte_phy_reset(void)
-{
-	int ret;
-	printk(KERN_INFO "msm_hsusb_phy_reset\n");
-	ret = msm_proc_comm(PCOM_MSM_HSUSB_PHY_RESET,
-			NULL, NULL);
-	if (ret)
-		printk(KERN_INFO "%s failed\n", __func__);
-}
-
-static int latte_pwrsink_resume_early(struct platform_device *pdev)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-	return 0;
-}
-
-static void latte_pwrsink_resume_late(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 38);
-}
-
-static void latte_pwrsink_suspend_early(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-}
-
-static int latte_pwrsink_suspend_late(struct platform_device *pdev, pm_message_t state)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 1);
-	return 0;
-}
-
-static struct pwr_sink_platform_data latte_pwrsink_data = {
-	.num_sinks      = ARRAY_SIZE(latte_pwrsink_table),
-	.sinks          = latte_pwrsink_table,
-	.suspend_late	= latte_pwrsink_suspend_late,
-	.resume_early	= latte_pwrsink_resume_early,
-	.suspend_early	= latte_pwrsink_suspend_early,
-	.resume_late	= latte_pwrsink_resume_late,
-};
-
-static struct platform_device latte_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev    = {
-		.platform_data = &latte_pwrsink_data,
-	},
-};
-
-static struct msm_pmem_setting pmem_setting = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-        .kgsl_start = MSM_GPU_MEM_BASE,
-        .kgsl_size = MSM_GPU_MEM_SIZE,
-};
-
-#ifdef CONFIG_MSM_CAMERA
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		.end	= INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_latte_camera_on_gpios,
-	.camera_gpio_off = config_latte_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
-	.camera_flash		= flashlight_control,
-	.num_flash_levels	= FLASHLIGHT_NUM,
-	.low_temp_limit		= 5,
-	.low_cap_limit		= 15,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_s5k4e1gx_data = {
-	.sensor_name    = "s5k4e1gx",
-	.sensor_reset   = LATTE_GPIO_CAM1_RST_N,
-	.vcm_pwd        = LATTE_GPIO_VCM_PWDN,
-	.pdata          = &msm_camera_device_data,
-	.resource       = msm_camera_resources,
-	.num_resources  = ARRAY_SIZE(msm_camera_resources),
-	.flash_cfg	= &msm_camera_sensor_flash_cfg,
-};
-
-static struct platform_device msm_camera_sensor_s5k4e1gx = {
-	.name      = "msm_camera_s5k4e1gx",
-	.dev       = {
-		.platform_data = &msm_camera_sensor_s5k4e1gx_data,
-	},
-};
-#endif
-
-static struct platform_device latte_rfkill = {
-	.name = "latte_rfkill",
-	.id = -1,
-};
-
-/* Proximity Sensor (Capella_CM3602)*/
-static int __capella_cm3602_power(int on)
-{
-	int rc;
-	struct vreg *vreg = vreg_get(0, "wlan");
-	if (!vreg) {
-		printk(KERN_ERR "%s: vreg error\n", __func__);
-		return -EIO;
-	}
-	rc = vreg_set_level(vreg, 2800);
-
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on) {
-		config_latte_proximity_gpios(1);
-		gpio_direction_output(LATTE_GPIO_PROXIMITY_EN, 1);
-		rc = vreg_enable(vreg);
-		if (rc < 0)
-			printk(KERN_ERR "%s: vreg enable failed\n", __func__);
-	} else {
-		rc = vreg_disable(vreg);
-		if (rc < 0)
-			printk(KERN_ERR "%s: vreg disable failed\n", __func__);
-		gpio_direction_output(LATTE_GPIO_PROXIMITY_EN, 0);
-		config_latte_proximity_gpios(0);
-	}
-
-	return rc;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static unsigned int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable)
-		als_power_control |= pwr_device;
-	else
-		als_power_control &= ~pwr_device;
-
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-	ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-}
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.p_out = LATTE_GPIO_PROXIMITY_INT,
-	.p_en = LATTE_GPIO_PROXIMITY_EN,
-	.power = capella_cm3602_power,
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-#define CURCIAL_OJ_POWER            85
-static void curcial_oj_shutdown (int	enable)
-{
-
-}
-static int curcial_oj_poweron(int on)
-{
-	gpio_set_value(CURCIAL_OJ_POWER, on);
-
-	if (gpio_get_value(CURCIAL_OJ_POWER) != on) {
-		printk(KERN_ERR "%s:OJ:power status fail \n", __func__);
-		return 0;
-	}
-		printk(KERN_ERR "%s:OJ:power status ok \n", __func__);
-	return 1;
-}
-#define LATTE_MICROP_VER	0x05
-static void curcial_oj_adjust_xy(uint8_t *data, int16_t *mSumDeltaX, int16_t *mSumDeltaY)
-{
-	int8_t 	deltaX;
-	int8_t 	deltaY;
-
-
-	if (data[2] == 0x80)
-		data[2] = 0x81;
-	if (data[1] == 0x80)
-		data[1] = 0x81;
-	if (system_rev <= 2) {
-		deltaX = (-1)*((int8_t) data[2]); /*X=2*/
-		deltaY = (1)*((int8_t) data[1]); /*Y=1*/
-	} else {
-		deltaX = (-1)*((int8_t) data[1]);
-		deltaY = (-1)*((int8_t) data[2]);
-	}
-	*mSumDeltaX += -((int16_t)deltaX);
-	*mSumDeltaY += -((int16_t)deltaY);
-}
-static struct curcial_oj_platform_data latte_oj_data = {
-	.oj_poweron = curcial_oj_poweron,
-	.oj_shutdown = curcial_oj_shutdown,
-	.oj_adjust_xy = curcial_oj_adjust_xy,
-	.microp_version = LATTE_MICROP_VER,
-	.mdelay_time = 15,
-	.msleep_time = 0,
-	.x_send_count = 3,
-	.y_send_count = 3,
-	.fast_th = 1,
-	.normal_th = 15,
-	.continue_th = 3,
-	.continue_max = 0,
-	.xy_ratio = 15,
-	.interval = 60,
-	.softclick = false,
-	.swap = false,
-	.x = -1,
-	.y = 1,
-	.share_power = false,
-	.Xsteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-	.Ysteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-};
-
-static struct platform_device latte_oj = {
-	.name = CURCIAL_OJ_NAME,
-	.id = -1,
-	.dev = {
-		.platform_data	= &latte_oj_data,
-	}
-};
-
-static struct msm_i2c_device_platform_data latte_i2c_device_data = {
-	.i2c_clock = 400000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-static struct gpio_led espresso_led_list[] = {
-	{
-		.name = "caps",
-		.gpio = LATTE_GPIO_LED_CAP_LED_EN,
-	},
-	{
-		.name = "func",
-		.gpio = LATTE_GPIO_LED_FN_LED_EN,
-	},
-};
-
-static struct gpio_led_platform_data espresso_leds_data = {
-	.num_leds	= ARRAY_SIZE(espresso_led_list),
-	.leds		= espresso_led_list,
-};
-
-static struct platform_device espresso_leds = {
-	.name		= "leds-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &espresso_leds_data,
-	},
-};
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_i2c,
-	&latte_h2w,
-	&htc_battery_pdev,
-	&latte_audio_jack,
-	&msm_camera_sensor_s5k4e1gx,
-	&latte_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&latte_pwr_sink,
-#endif
-	&latte_oj,
-	&capella_cm3602,
-	&espresso_leds,
-};
-
-extern struct sys_timer msm_timer;
-
-static void __init latte_init_irq(void)
-{
-	printk("latte_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint cpld_iset;
-static uint cpld_charger_en;
-static uint cpld_usb_h2w_sw;
-static uint opt_disable_uart3;
-static char *keycaps = "";
-
-module_param_named(iset, cpld_iset, uint, 0);
-module_param_named(charger_en, cpld_charger_en, uint, 0);
-module_param_named(usb_h2w_sw, cpld_usb_h2w_sw, uint, 0);
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-module_param_named(keycaps, keycaps, charp, 0);
-
-static char bt_chip_id[10] = "brfxxxx";
-module_param_string(bt_chip_id, bt_chip_id, sizeof(bt_chip_id), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_chip_id, "BT's chip id");
-
-static char bt_fw_version[10] = "v2.0.38";
-module_param_string(bt_fw_version, bt_fw_version, sizeof(bt_fw_version), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_fw_version, "BT's fw version");
-
-static void latte_reset(void)
-{
-	gpio_set_value(LATTE_GPIO_PS_HOLD, 0);
-}
-
-
-static struct i2c_board_info i2c_camera_devices[] = {
-	{
-		I2C_BOARD_INFO("s5k4e1gx", 0x20 >> 1),/*5M samsung bayer sensor driver*/
-	},
-};
-
-static uint32_t proximity_on_gpio_table[] = {
-	PCOM_GPIO_CFG(21, 0, GPIO_INPUT, GPIO_NO_PULL, 0), /* PS_VOUT */
-};
-
-static uint32_t proximity_off_gpio_table[] = {
-	PCOM_GPIO_CFG(21, 0, GPIO_INPUT, GPIO_PULL_DOWN, 0) /* PS_VOUT */
-};
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* MCLK */
-
-	PCOM_GPIO_CFG(27, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA), /* CAM_I2C_SDA */
-	PCOM_GPIO_CFG(124, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA), /* CAM_I2C_SCL */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-void config_latte_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void config_latte_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-void config_latte_proximity_gpios(int on)
-{
-	if (on)
-		config_gpio_table(proximity_on_gpio_table,
-			ARRAY_SIZE(proximity_on_gpio_table));
-	else
-		config_gpio_table(proximity_off_gpio_table,
-			ARRAY_SIZE(proximity_off_gpio_table));
-}
-
-static uint32_t latte_serial_debug_table[] = {
-	/* config as serial debug uart */
-	PCOM_GPIO_CFG(LATTE_GPIO_UART3_RX, 1,
-			GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* UART3 RX */
-	PCOM_GPIO_CFG(LATTE_GPIO_UART3_TX, 1,
-			GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* UART3 TX */
-};
-
-static void latte_config_serial_debug_gpios(void)
-{
-	config_gpio_table(latte_serial_debug_table,
-			ARRAY_SIZE(latte_serial_debug_table));
-}
-
-static void __init config_gpios(void)
-{
-	latte_config_serial_debug_gpios();
-	config_latte_camera_off_gpios();
-}
-
-static struct msm_acpu_clock_platform_data latte_clock_data = {
-	.acpu_switch_time_us = 50,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200,
-	.wait_for_irq_khz = 200000,
-};
-
-static unsigned latte_perf_acpu_table[] = {
-	245760000,
-	480000000,
-	600000000,
-};
-
-static struct perflock_platform_data latte_perflock_data = {
-	.perf_acpu_table = latte_perf_acpu_table,
-	.table_size = ARRAY_SIZE(latte_perf_acpu_table),
-};
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(LATTE_GPIO_BT_UART1_RX),
-	.inject_rx_on_wakeup = 1,
-	.rx_to_inject = 0x32,
-	.cpu_lock_supported = 1,
-};
-#endif
-
-static void config_latte_flashlight_gpios(void)
-{
-	uint32_t flashlight_gpio_table[] = {
-		PCOM_GPIO_CFG(LATTE_GPIO_TORCH_EN, 0, GPIO_OUTPUT,
-							GPIO_NO_PULL, GPIO_2MA),
-		PCOM_GPIO_CFG(LATTE_GPIO_FLASH_EN, 0, GPIO_OUTPUT,
-							GPIO_NO_PULL, GPIO_2MA),
-	};
-
-	config_gpio_table(flashlight_gpio_table,
-		ARRAY_SIZE(flashlight_gpio_table));
-}
-
-static struct flashlight_platform_data latte_flashlight_data = {
-	.gpio_init = config_latte_flashlight_gpios,
-	.torch = LATTE_GPIO_TORCH_EN,
-	.flash = LATTE_GPIO_FLASH_EN,
-	.flash_duration_ms = 600,
-};
-
-static struct platform_device latte_flashlight_device = {
-	.name = FLASHLIGHT_NAME,
-	.dev = {
-		.platform_data  = &latte_flashlight_data,
-	},
-};
-
-static void __init latte_init(void)
-{
-	int rc;
-	char *cid = NULL;
-	printk("latte_init() revision = 0x%X\n", system_rev);
-	board_get_cid_tag(&cid);
-
-	/*
-	 * Setup common MSM GPIOS
-	 */
-	config_gpios();
-
-	/* We need to set this pin to 0 only once on power-up; we will
-	 * not actually enable the chip until we apply power to it via
-	 * vreg.
-	 */
-	gpio_direction_output(LATTE_GPIO_LS_EN, 0);
-	/* disable power for cm3602 chip */
-	__capella_cm3602_power(0);
-
-	msm_hw_reset_hook = latte_reset;
-
-	msm_acpu_clock_init(&latte_clock_data);
-	perflock_init(&latte_perflock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-			&msm_device_uart3.dev, 1,
-				MSM_GPIO_TO_INT(LATTE_GPIO_UART3_RX));
-#endif
-
-	msm_add_devices();
-
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_add_serial_devices(3);
-#else
-	msm_add_serial_devices(0);
-#endif
-
-	msm_add_serial_devices(2);
-/*
-	msm_change_usb_id(0x0bb4, 0x0c10);
-*/
-	msm_add_usb_id_pin_gpio(LATTE_GPIO_USB_ID_PIN);
-
-	msm_register_usb_phy_init_seq(espresso_phy_init_seq);
-	msm_hsusb_set_product(espresso_usb_products,
-		ARRAY_SIZE(espresso_usb_products));
-	msm_add_usb_devices(latte_phy_reset, latte_phy_shutdown);
-
-
-	msm_add_mem_devices(&pmem_setting);
-
-	msm_init_pmic_vibrator();
-#ifdef CONFIG_MICROP_COMMON
-	latte_microp_init();
-#endif
-
-	rc = latte_init_mmc(system_rev);
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-
-	/* register flashlight at new-XA above */
-	platform_device_register(&latte_flashlight_device);
-
-	/* probe camera driver */
-	i2c_register_board_info(0, i2c_camera_devices, ARRAY_SIZE(i2c_camera_devices));
-
-	msm_device_i2c.dev.platform_data = &latte_i2c_device_data;
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	latte_init_keypad();
-}
-
-static void __init latte_fixup(struct machine_desc *desc, struct tag *tags,
-                               char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks=1;
-	mi->bank[0].start = MSM_LINUX_BASE;
-	mi->bank[0].node = PHYS_TO_NID(MSM_LINUX_BASE);
-	mi->bank[0].size = MSM_LINUX_SIZE;
-}
-
-static void __init latte_map_io(void)
-{
-	printk("latte_init_map_io()\n");
-	msm_map_common_io();
-	msm_clock_init();
-#ifdef CONFIG_CACHE_L2X0
-	/* 7x27 has 256KB L2 cache:
-	* 64Kb/Way and 4-Way Associativity;
-	* R/W latency: 3 cycles;
-	* evmon/parity/share disabled.
-	*/
-	l2x0_init(MSM_L2CC_BASE, 0x00068012, 0xfe000000);
-#endif
-}
-
-MACHINE_START(LATTE, "latte")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params    = 0x12C00100,
-	.fixup          = latte_fixup,
-	.map_io         = latte_map_io,
-	.init_irq       = latte_init_irq,
-	.init_machine   = latte_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-latte.h b/arch/arm/mach-msm/board-latte.h
deleted file mode 100644
index 22893bb..0000000
--- a/arch/arm/mach-msm/board-latte.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/* linux/arch/arm/mach-msm/board-latte.h
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_LATTE_H
-#define __ARCH_ARM_MACH_MSM_BOARD_LATTE_H
-
-#include <mach/board.h>
-
-#define MSM_MEM_BASE		0x10000000
-#define MSM_MEM_SIZE		0x20000000
-
-#define MSM_LINUX_BASE_OFFSET	0x02C00000
-
-#define MSM_MM_HEAP_SIZE        0x02800000
-
-#define MSM_LINUX_BASE          (MSM_MEM_BASE + MSM_LINUX_BASE_OFFSET) /* 2MB alignment */
-#define MSM_LINUX_SIZE          (MSM_MEM_SIZE - MSM_LINUX_BASE_OFFSET - MSM_MM_HEAP_SIZE)
-
-#define MSM_FB_BASE             (MSM_MEM_BASE + 0x02A00000)
-#define MSM_FB_SIZE             0x00200000
-
-#define MSM_GPU_MEM_BASE        (MSM_MEM_BASE + MSM_MEM_SIZE - MSM_MM_HEAP_SIZE)
-#define MSM_GPU_MEM_SIZE        0x00300000
-
-#define MSM_PMEM_MDP_BASE       MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE
-#define MSM_PMEM_MDP_SIZE       0x01000000
-
-#define MSM_PMEM_ADSP_BASE      MSM_PMEM_MDP_BASE + MSM_PMEM_MDP_SIZE
-#define MSM_PMEM_ADSP_SIZE      0x00C1B000
-
-#define MSM_PMEM_CAMERA_BASE    MSM_PMEM_ADSP_BASE + MSM_PMEM_ADSP_SIZE
-#define MSM_PMEM_CAMERA_SIZE    0x00800000
-
-/* TODO: To save space, we can move RAM_CONSOLE to 0x00000000 */
-#define MSM_RAM_CONSOLE_BASE    MSM_PMEM_CAMERA_BASE + MSM_PMEM_CAMERA_SIZE
-#define MSM_RAM_CONSOLE_SIZE    128 * SZ_1K
-
-#define LATTE_GPIO_TO_INT(x)           (x+64) /* from gpio_to_irq */
-#define LATTE_GPIO_USB_ID_PIN          (19)
-#define LATTE_POWER_KEY                (20)
-#define LATTE_GPIO_WIFI_EN             (108)
-#define LATTE_GPIO_SDMC_CD_N           (38)
-#define LATTE_GPIO_UART3_RX            (86)
-#define LATTE_GPIO_UART3_TX            (87)
-#define LATTE_GPIO_PS_HOLD             (25)
-#define LATTE_GPIO_UP_RESET_N          (76)
-#define LATTE_GPIO_CAP_LED_EN          (121)
-#define LATTE_GPIO_USBPHY_3V3_EN       (109)
-#define LATTE_GPIO_FUNC_LED_EN         (0)
-#define LATTE_GPIO_LS_EN               (93)
-#define LATTE_GPIO_UP_INT_N            (39)
-#define LATTE_GPIO_COMPASS_INT_N       (36)
-#define LATTE_GPIO_COMPASS_RST_N       (84)
-#define LATTE_PROJECT_NAME		"latte"
-#define LATTE_LAYOUTS			{ \
-		{ { -1,  0, 0}, {  0, -1, 0}, {0, 0, 1} },  \
-		{ {  0, -1, 0}, { -1,  0, 0}, {0, 0, 1} },  \
-		{ {  0, -1, 0}, {  1,  0, 0}, {0, 0, 1} },  \
-		{ {  1,  0, 0}, {  0,  0, 1}, {0, 1, 0} }   \
-					}
-
-/* Proximity  */
-#define LATTE_GPIO_PROXIMITY_INT       (21)
-#define LATTE_GPIO_PROXIMITY_EN        (58)
-
-/* Navi key output/input matrix */
-#define LATTE_GPIO_KP_MKOUT7           (116)
-#define LATTE_GPIO_KP_MKOUT6           (117)
-#define LATTE_GPIO_KP_MKOUT5           (118)
-#define LATTE_GPIO_KP_MKOUT4           (119)
-#define LATTE_GPIO_KP_MKOUT3           (120)
-#define LATTE_GPIO_KP_MKOUT2           (33)
-#define LATTE_GPIO_KP_MKOUT1           (34)
-#define LATTE_GPIO_KP_MKOUT0           (35)
-#define LATTE_GPIO_KP_MKIN6            (112)
-#define LATTE_GPIO_KP_MKIN5            (114)
-#define LATTE_GPIO_KP_MKIN4            (17)
-#define LATTE_GPIO_KP_MKIN3            (92)
-#define LATTE_GPIO_KP_MKIN2            (40)
-#define LATTE_GPIO_KP_MKIN1            (41)
-#define LATTE_GPIO_KP_MKIN0            (42)
-
-/* sliding keyboard detect */
-#define LATTE_GPIO_SLIDING_DET         (49)
-
-/* BT */
-#define LATTE_GPIO_BT_UART1_RTS        (43)
-#define LATTE_GPIO_BT_UART1_CTS        (44)
-#define LATTE_GPIO_BT_UART1_RX         (45)
-#define LATTE_GPIO_BT_UART1_TX         (46)
-#define LATTE_GPIO_BT_EN               (90)
-
-/* Touch Panel */
-#define LATTE_TP_5V_EN                 (31)
-#define LATTE_GPIO_TP_RST              (57)
-#define LATTE_TP_LS_EN                 (91)
-#define LATTE_GPIO_TP_ATT_N            (94)
-
-/* 35mm headset */
-#define LATTE_GPIO_35MM_HEADSET_DET    (83)
-
-/* Camera AF VCM POWER*/
-#define LATTE_GPIO_VCM_PWDN            (82)
-#define LATTE_GPIO_CAM1_RST_N          (115)
-
-/* Other */
-#define LATTE_GPIO_BAT_DET_N           (28)
-#define LATTE_GPIO_MOT_INT_CPU         (18)
-#define LATTE_GPIO_CAM_I2C_SDA         (27)
-#define LATTE_GPIO_UP_INT2_N           (37)
-#define LATTE_GPIO_CAM_I2C_SCL         (124)
-#define LATTE_GPIO_FLASH_EN            (122)
-#define LATTE_GPIO_TORCH_EN            (123)
-
-/* Display */
-#define LATTE_GPIO_LCD_VSYNC           (97)
-#define LATTE_GPIO_LCD_ID1             (130)
-#define LATTE_LCD_RSTz                 (131)
-#define LATTE_GPIO_LCD_ID0             (132)
-
-/* LED */
-#define LATTE_GPIO_LED_FN_LED_EN       (128)
-#define LATTE_GPIO_LED_CAP_LED_EN      (129)
-
-int __init latte_init_keypad(void);
-int latte_init_mmc(unsigned int sys_rev);
-#endif /* GUARD */
-
diff --git a/arch/arm/mach-msm/board-legend-keypad.c b/arch/arm/mach-msm/board-legend-keypad.c
deleted file mode 100644
index d0b81a7..0000000
--- a/arch/arm/mach-msm/board-legend-keypad.c
+++ /dev/null
@@ -1,174 +0,0 @@
-/* arch/arm/mach-msm/board-legend-keypad.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <linux/gpio.h>
-#include <linux/keyreset.h>
-#include <asm/mach-types.h>
-#include <mach/board_htc.h>
-
-#include "board-legend.h"
-#include "proc_comm.h"
-
-static char *keycaps = "--qwerty";
-#undef MODULE_PARAM_PREFIX
-#define MODULE_PARAM_PREFIX "board_legend."
-
-module_param_named(keycaps, keycaps, charp, 0);
-
-static unsigned int legend_col_gpios[] = {
-	LEGEND_GPIO_KP_MKOUT0, //35
-	LEGEND_GPIO_KP_MKOUT1, //34
-	LEGEND_GPIO_KP_MKOUT2, //33
-};
-static unsigned int legend_row_gpios[] = {
-	LEGEND_GPIO_KP_MKIN0, //42
-	LEGEND_GPIO_KP_MKIN1, //41
-	LEGEND_GPIO_KP_MKIN2, //40
-};
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(legend_row_gpios) + (row))
-
-static const unsigned short legend_keymap[ARRAY_SIZE(legend_col_gpios) *
-					ARRAY_SIZE(legend_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = BTN_MOUSE,
-	[KEYMAP_INDEX(0, 1)] = KEY_MENU,
-	[KEYMAP_INDEX(0, 2)] = KEY_HOME,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(1, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 2)] = KEY_RESERVED,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_BACK,
-	[KEYMAP_INDEX(2, 1)] = KEY_RESERVED,
-	[KEYMAP_INDEX(2, 2)] = KEY_SEARCH,
-};
-
-static void legend_matrix_inputs_gpio(void)
-{
-	static uint32_t matirx_inputs_gpio_table[] = {
-		PCOM_GPIO_CFG(LEGEND_GPIO_KP_MKIN0, 0, GPIO_INPUT,
-						GPIO_PULL_UP, GPIO_4MA),
-		PCOM_GPIO_CFG(LEGEND_GPIO_KP_MKIN1, 0, GPIO_INPUT,
-						GPIO_PULL_UP, GPIO_4MA),
-		PCOM_GPIO_CFG(LEGEND_GPIO_KP_MKIN2, 0, GPIO_INPUT,
-						GPIO_PULL_UP, GPIO_4MA),
-	};
-
-	config_gpio_table(matirx_inputs_gpio_table,
-		ARRAY_SIZE(matirx_inputs_gpio_table));
-}
-
-static struct gpio_event_matrix_info legend_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = legend_keymap,
-	.output_gpios = legend_col_gpios,
-	.input_gpios = legend_row_gpios,
-	.noutputs = ARRAY_SIZE(legend_col_gpios),
-	.ninputs = ARRAY_SIZE(legend_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		  GPIOKPF_REMOVE_PHANTOM_KEYS |
-		  GPIOKPF_PRINT_UNMAPPED_KEYS /*|
-		   GPIOKPF_PRINT_MAPPED_KEYS */),
-	.setup_ninputs_gpio = legend_matrix_inputs_gpio,
-};
-
-static struct gpio_event_direct_entry legend_keypad_nav_map[] = {
-	{
-		.gpio = LEGEND_POWER_KEY,
-		.code = KEY_POWER
-	},
-};
-
-static void legend_direct_input_gpio(void)
-{
-	static uint32_t matirx_inputs_gpio_table[] = {
-		PCOM_GPIO_CFG(LEGEND_POWER_KEY, 0, GPIO_INPUT,
-					GPIO_PULL_UP, GPIO_4MA),
-	};
-
-	config_gpio_table(matirx_inputs_gpio_table,
-		ARRAY_SIZE(matirx_inputs_gpio_table));
-}
-
-
-static struct gpio_event_input_info legend_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = GPIOEDF_PRINT_KEYS,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = legend_keypad_nav_map,
-	.keymap_size = ARRAY_SIZE(legend_keypad_nav_map),
-	.setup_input_gpio = legend_direct_input_gpio,
-};
-
-static struct gpio_event_info *legend_keypad_info[] = {
-	&legend_keypad_matrix_info.info,
-	&legend_keypad_nav_info.info,
-};
-
-static struct gpio_event_platform_data legend_keypad_data = {
-	.name = "legend-keypad",
-	.info = legend_keypad_info,
-	.info_count = ARRAY_SIZE(legend_keypad_info)
-};
-
-static struct platform_device legend_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &legend_keypad_data,
-	},
-};
-
-static int legend_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0
-};
-
-static struct keyreset_platform_data legend_reset_keys_pdata = {
-	.keys_up = legend_reset_keys_up,
-	.keys_down = {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-static struct platform_device legend_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &legend_reset_keys_pdata,
-};
-
-int __init legend_init_keypad(void)
-{
-	char *get_cid, *get_carrier, *get_keycaps;
-
-	board_get_cid_tag(&get_cid);
-	board_get_carrier_tag(&get_carrier);
-	board_get_keycaps_tag(&get_keycaps);
-
-	if (platform_device_register(&legend_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	return platform_device_register(&legend_keypad_device);
-}
-
diff --git a/arch/arm/mach-msm/board-legend-microp.c b/arch/arm/mach-msm/board-legend-microp.c
deleted file mode 100644
index eae7650..0000000
--- a/arch/arm/mach-msm/board-legend-microp.c
+++ /dev/null
@@ -1,183 +0,0 @@
-/* arch/arm/mach-msm/board-legend-microp.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <mach/atmega_microp.h>
-#include <mach/drv_callback.h>
-
-#include "board-legend.h"
-
-static struct i2c_client *legend_microp_client;
-/*
-static struct led_trigger legend_als_level_trigger = {
-	.name     = "auto-backlight-trigger",
-};
-*/
-/*
-static int legend_als_intr_enable(struct i2c_client *client,
-		uint32_t als_func, uint8_t enable)
-{
-	struct microp_i2c_client_data *cdata;
-
-	cdata = i2c_get_clientdata(client);
-
-	return microp_write_interrupt(client,
-		cdata->int_pin.int_lsensor, enable);
-}
-*/
-/*
-static int legend_als_power(int pwr_device, uint8_t enable)
-{
-	struct i2c_client *client = legend_microp_client;
-	struct microp_i2c_platform_data *pdata;
-	int value;
-
-	pdata = client->dev.platform_data;
-	value = enable ? 1 : 0;
-*/
-/*
-	if (pdata->gpio_ls_on)
-		gpio_set_value(pdata->gpio_ls_on, !value);
-*/
-/*
-	if (pdata->ls_power)
-		pdata->ls_power(value);
-
-	return 0;
-}
-*/
-/*
-static int legend_als_table_init(struct i2c_client *client,
-			int i, uint32_t kadc, uint32_t gadc)
-{
-	struct microp_i2c_platform_data *pdata;
-	uint8_t data[20];
-	int j;
-
-	pdata = client->dev.platform_data;
-
-	for (j = 0; j < 10; j++) {
-		data[j] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc >> 8);
-		data[j + 10] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc);
-	}
-
-	return microp_i2c_write(MICROP_I2C_WCMD_ADC_TABLE, data, 20);
-}
-*/
-static int legend_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	legend_microp_client = client;
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Light sensor */
-/*
-	ret = microp_function_check(client, MICROP_FUNCTION_LSENSOR);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_LSENSOR] = i;
-		cdata->int_pin.int_lsensor = pdata->microp_function[i].int_pin;
-		microp_get_als_kvalue(i);
-
-		ret = legend_als_table_init(client, i, cdata->als_kadc,
-				cdata->als_gadc);
-		if (ret < 0)
-			goto exit;
-*/
-/*
-		if (pdata->gpio_ls_on) {
-			ret = gpio_request(pdata->gpio_ls_on,
-					"microp_i2c");
-			if (ret < 0) {
-				dev_err(&client->dev,
-					"failed on request gpio ls_on\n");
-				goto exit;
-			}
-			ret = gpio_direction_output(pdata->gpio_ls_on, 0);
-			if (ret < 0) {
-				dev_err(&client->dev,
-					"failed on gpio_direction_output ls_on\n");
-				goto exit;
-			}
-		}
-*/
-/*
-		if (pdata->ls_power)
-			pdata->ls_power(1);
-	}
-*/
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	ret = microp_write_interrupt(client, (1<<8), 1);
-	if (ret)
-		goto exit;
-
-	/* OJ interrupt */
-	ret = microp_function_check(client, MICROP_FUNCTION_OJ);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_oj = pdata->microp_function[i].int_pin;
-
-		ret = microp_write_interrupt(client, cdata->int_pin.int_oj, 1);
-		if (ret)
-			goto exit;
-	}
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = legend_microp_function_init,
-	/*.als_pwr_enable = legend_als_power,*/
-	/*.als_intr_enable = legend_als_intr_enable,*/
-	/*.als_level_change = legend_als_level_change,*/
-};
-
-void __init legend_microp_init(void)
-{
-	/*led_trigger_register(&legend_als_level_trigger);*/
-	microp_register_ops(&ops);
-}
-
-#endif
diff --git a/arch/arm/mach-msm/board-legend-mmc.c b/arch/arm/mach-msm/board-legend-mmc.c
deleted file mode 100755
index 7baa92e..0000000
--- a/arch/arm/mach-msm/board-legend-mmc.c
+++ /dev/null
@@ -1,388 +0,0 @@
-/* linux/arch/arm/mach-msm/board-legend-mmc.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-#include <linux/gpio.h>
-
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-#include <mach/htc_pwrsink.h>
-#include <mach/msm_iomap.h>
-
-#include "devices.h"
-#include "board-legend.h"
-#include "proc_comm.h"
-
-/* #include <linux/irq.h> */
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_6MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_6MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_6MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_6MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_6MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_6MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init legend_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_legend.disable_sdcard=", legend_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t legend_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-
-	BUG_ON(!vreg_sdslot);
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	printk("%s::vdd=%08x sdslot_vdd=%08x\n",__func__,vdd,sdslot_vdd);
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-		printk("off:MCI_Power=%08x\n", readl(MSM_SDC2_BASE));
-		writel(readl(MSM_SDC2_BASE) & 0xfffffffc, MSM_SDC2_BASE); /* MCI_Power */
-		printk("off:MCI_Power=%08x\n",readl(MSM_SDC2_BASE));
-		mdelay(1);
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		mdelay(1);
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		vreg_enable(vreg_sdslot);
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-			printk(KERN_INFO "%s: Setting level to %u\n",
-					__func__, mmc_vdd_table[i].level);
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-		}
-	}
-		mdelay(5);
-		writel(readl(MSM_SDC2_BASE) | 0x2, MSM_SDC2_BASE); /* MCI_Power */
-		printk("on:MCI_Power=%08x\n", readl(MSM_SDC2_BASE));
-		mdelay(5);
-		writel(readl(MSM_SDC2_BASE) | 0x3, MSM_SDC2_BASE); /* MCI_Power */
-		printk("on:MCI_Power=%08x\n", readl(MSM_SDC2_BASE));
-		mdelay(5);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-		return 0;
-	}
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-			printk(KERN_INFO "%s: Setting level to %u\n",
-					__func__, mmc_vdd_table[i].level);
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-			mdelay(5);
-			return 0;
-		}
-	}
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int legend_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(LEGEND_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define LEGEND_MMC_VDD	MMC_VDD_28_29 | MMC_VDD_29_30
-
-static struct mmc_platform_data legend_sdslot_data = {
-	.ocr_mask	= LEGEND_MMC_VDD,
-	.status_irq	= MSM_GPIO_TO_INT(LEGEND_GPIO_SDMC_CD_N),
-	.status		= legend_sdslot_status,
-	.translate_vdd	= legend_sdslot_switchvdd,
-};
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_16MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-static struct vreg *vreg_wifi_osc;	/* WIFI 32khz oscilator */
-static int legend_wifi_cd;		/* WIFI virtual 'card detect' status */
-
-static struct sdio_embedded_func wifi_func[2] = {
-	{.f_class	= SDIO_CLASS_WLAN,
-	.f_maxblksize	= 512},
-	{.f_class       = SDIO_CLASS_WLAN,
-	.f_maxblksize   = 512},
-};
-
-static struct embedded_sdio_data legend_wifi_emb_data = {
-	.cis	= {
-		.vendor		= 0x104c,
-		.device		= 0x9066,
-		.blksize	= 512,
-		/* .max_dtr	= 24000000, */
-		.max_dtr	= 25000000,
-	},
-	.cccr	= {
-		.multi_block	= 0,
-		.low_speed	= 0,
-		.wide_bus	= 1,
-		.high_power	= 0,
-		.high_speed	= 0,
-	},
-	.funcs	= wifi_func,
-	.num_funcs = 2,
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-legend_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int legend_wifi_status(struct device *dev)
-{
-	return legend_wifi_cd;
-}
-
-static struct mmc_platform_data legend_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= legend_wifi_status,
-	.register_status_notify	= legend_wifi_status_register,
-	.embedded_sdio		= &legend_wifi_emb_data,
-#ifdef CONFIG_MMC_SUPPORT_EXTERNEL_DRIVER
-	.use_ext_sdiodrv	= 1,
-	.ext_sdiodrv_name	= "TIWLAN_SDIO",
-#endif
-};
-
-int legend_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	legend_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(legend_wifi_set_carddetect);
-
-int legend_wifi_power_state = 0;
-int legend_bt_power_state = 0;
-
-int legend_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-
-		rc = vreg_enable(vreg_wifi_osc);
-		mdelay(100);
-
-		gpio_set_value(LEGEND_GPIO_WIFI_EN, 1);
-		mdelay(50);
-		gpio_set_value(LEGEND_GPIO_WIFI_EN, 0);
-		mdelay(1);
-		gpio_set_value(LEGEND_GPIO_WIFI_EN, 1);
-		mdelay(200);
-		htc_pwrsink_set(PWRSINK_WIFI, 70);
-
-
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-		gpio_set_value(LEGEND_GPIO_WIFI_EN, on);
-		mdelay(10);
-
-		htc_pwrsink_set(PWRSINK_WIFI, 0);
-
-		if (!legend_bt_power_state) {
-			vreg_disable(vreg_wifi_osc);
-			printk(KERN_INFO "WiFi disable vreg_wifi_osc.\n");
-		} else
-			printk(KERN_ERR "WiFi shouldn't disable "
-					"vreg_wifi_osc. BT is using it!!\n");
-	}
-
-	legend_wifi_power_state = on;
-	return 0;
-}
-EXPORT_SYMBOL(legend_wifi_power);
-
-/* Eenable VREG_MMC pin to turn on fastclock oscillator : colin */
-int legend_bt_fastclock_power(int on)
-{
-	int rc;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (vreg_wifi_osc) {
-		if (on) {
-			rc = vreg_enable(vreg_wifi_osc);
-
-			if (rc) {
-				printk(KERN_ERR "Error turn bt_fastclock_power"
-							" rc=%d\n", rc);
-				return rc;
-			}
-		} else {
-			if (!legend_wifi_power_state)
-				vreg_disable(vreg_wifi_osc);
-		}
-	}
-	legend_bt_power_state = on;
-	return 0;
-}
-EXPORT_SYMBOL(legend_bt_fastclock_power);
-
-// static int legend_wifi_reset_state;
-int legend_wifi_reset(int on)
-{
-#if 1
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-#else
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-	gpio_set_value(TROUT_GPIO_WIFI_PA_RESETX, !on);
-	legend_wifi_reset_state = on;
-	mdelay(50);
-#endif
-	return 0;
-}
-
-int __init legend_init_mmc(unsigned int sys_rev)
-{
-
-	uint32_t id;
-	sdslot_vreg_enabled = 0;
-
-
-	/* initial LEVEL_SHIT_EN */
-	id = PCOM_GPIO_CFG(30, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	/* let level shifter alaways enabled,
-	   and remove all GPIO30 configuration codes */
-	gpio_set_value(30, 0);
-
-	wifi_status_cb = NULL;
-
-	printk(KERN_INFO "%s\n", __func__);
-
-	vreg_wifi_osc = vreg_get(0, "rftx");
-	if (IS_ERR(vreg_wifi_osc))
-		return PTR_ERR(vreg_wifi_osc);
-	vreg_set_level(vreg_wifi_osc, 1800);
-
-	msm_add_sdcc(1, &legend_wifi_data, 0, 0);
-
-
-	if (opt_disable_sdcard) {
-		printk(KERN_INFO "legend: SD-Card interface disabled\n");
-		goto done;
-	}
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-
-	set_irq_wake(MSM_GPIO_TO_INT(LEGEND_GPIO_SDMC_CD_N), 1);
-
-	msm_add_sdcc(2, &legend_sdslot_data, MSM_GPIO_TO_INT(LEGEND_GPIO_SDMC_CD_N),
-			IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-
-done:
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-legend-panel.c b/arch/arm/mach-msm/board-legend-panel.c
deleted file mode 100644
index c29c818..0000000
--- a/arch/arm/mach-msm/board-legend-panel.c
+++ /dev/null
@@ -1,1153 +0,0 @@
-/* linux/arch/arm/mach-msm/board-legend-panel.c
- *
- * Copyright (c) 2009 Google Inc.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/wakelock.h>
-#include <linux/leds.h>
-#include <linux/workqueue.h>
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-
-#include <mach/vreg.h>
-#include <mach/msm_fb.h>
-#include <mach/pmic.h>
-
-#include "devices.h"
-#include "board-legend.h"
-#include "proc_comm.h"
-
-#ifdef CONFIG_MICROP_COMMON
-#include <mach/atmega_microp.h>
-#endif
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "Panel: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-static struct wake_lock backlight_wakelock;
-static struct work_struct work_set_brightness;
-static int g_brightness_level;
-static DEFINE_MUTEX(legend_backlight_lock);
-static atomic_t gate;
-extern int microp_spi_vote_enable(int spi_device, uint8_t enable);
-#define SPI_LCM                         (1 << 1)
-#define GAMMA_LEVEL_MAX 27
-#define GAMMA_LEVEL_MIN 0
-#define GAMMA_LEVEL_DEFAULT 11
-#define LED_VALUE_MAX LED_FULL
-#define LED_VALUE_MIN 30
-#define LED_VALUE_DEFAULT 100
-
-void config_legend_display_on_gpios(void);
-void config_legend_display_off_gpios(void);
-
-typedef struct lcd_init_table {
-	u8 reg;
-	u8 val;
-	int delay;
-} LCD_INIT_TABLE;
-
-static const LCD_INIT_TABLE OLED_POWER_SEQUENCE[] = {
-	{0x01, 0x00, 0},
-	{0x21, 0x33, 0},
-	{0x22, 0x08, 0},
-	{0x23, 0x00, 0},
-	{0x24, 0x33, 0},
-	{0x25, 0x33, 0},
-	{0x26, 0x02, 0},
-	{0x27, 0x42, 0},
-	{0x2F, 0x02, 0},
-
-	{0x20, 0x01, 10},
-	{0x20, 0x11, 20},
-	{0x20, 0x31, 60},
-	{0x20, 0x71, 60},
-	{0x20, 0x73, 20},
-	{0x20, 0x77, 10},
-
-	{0x04, 0x01, 10},
-};
-
-static const LCD_INIT_TABLE OLED_INIT_SEQUENCE[] = {
-	{0x06, 0x44, 0},
-	{0x07, 0x04, 0},
-	{0x08, 0x01, 0},
-	{0x09, 0x06, 0},
-	{0x0a, 0x21, 0},
-	{0x0c, 0x00, 0},
-	{0x0d, 0x14, 0},
-	{0x0e, 0x00, 0},
-	{0x0f, 0x1E, 0},
-	{0x10, 0x02, 0},	// 0:RGB888 2:RGB565
-	{0x1c, 0x08, 0},
-	{0x1d, 0x05, 0},
-	{0x1f, 0x00, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_10_TABLE[] = {
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x0D, 0},
-		{0x34, 0x11, 0},
-		{0x35, 0x14, 0},
-		{0x36, 0x1F, 0},
-		{0x37, 0x1D, 0},
-		{0x38, 0x1D, 0},
-		{0x39, 0x27, 0},
-		{0x3A, 0x15, 0},
-		{0x3B, 0x25, 0},
-		{0x3C, 0x3F, 0},
-		{0x3D, 0x00, 0},
-		{0x3E, 0x31, 0},
-		{0x3F, 0x3F, 0},
-		{0x40, 0x00, 0},
-		{0x41, 0x3F, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_40_TABLE[] = {
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x20, 0},
-		{0x34, 0x27, 0},
-		{0x35, 0x2B, 0},
-		{0x36, 0x20, 0},
-		{0x37, 0x1F, 0},
-		{0x38, 0x1E, 0},
-		{0x39, 0x2B, 0},
-		{0x3A, 0x23, 0},
-		{0x3B, 0x2B, 0},
-		{0x3C, 0x1A, 0},
-		{0x3D, 0x0A, 0},
-		{0x3E, 0x13, 0},
-		{0x3F, 0x3F, 0},
-		{0x40, 0x00, 0},
-		{0x41, 0x3E, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_50_TABLE[] = {
-		/* 50 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x24, 0},
-		{0x34, 0x2B, 0},
-		{0x35, 0x30, 0},
-		{0x36, 0x1F, 0},
-		{0x37, 0x20, 0},
-		{0x38, 0x1E, 0},
-		{0x39, 0x2B, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2B, 0},
-		{0x3C, 0x1B, 0},
-		{0x3D, 0x14, 0},
-		{0x3E, 0x16, 0},
-		{0x3F, 0x3F, 0},
-		{0x40, 0x00, 0},
-		{0x41, 0x3B, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_60_TABLE[] = {
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x28, 0},
-		{0x34, 0x2F, 0},
-		{0x35, 0x34, 0},
-		{0x36, 0x1F, 0},
-		{0x37, 0x20, 0},
-		{0x38, 0x1E, 0},
-		{0x39, 0x2B, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2B, 0},
-		{0x3C, 0x1C, 0},
-		{0x3D, 0x18, 0},
-		{0x3E, 0x18, 0},
-		{0x3F, 0x3F, 0},
-		{0x40, 0x00, 0},
-		{0x41, 0x38, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_70_TABLE[] = {
-		/* 70 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x2B, 0},
-		{0x34, 0x33, 0},
-		{0x35, 0x38, 0},
-		{0x36, 0x1F, 0},
-		{0x37, 0x20, 0},
-		{0x38, 0x1E, 0},
-		{0x39, 0x2B, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2B, 0},
-		{0x3C, 0x1E, 0},
-		{0x3D, 0x1D, 0},
-		{0x3E, 0x1A, 0},
-		{0x3F, 0x3F, 0},
-		{0x40, 0x00, 0},
-		{0x41, 0x35, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_80_TABLE[] = {
-		/* 80 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x2E, 0},
-		{0x34, 0x36, 0},
-		{0x35, 0x3B, 0},
-		{0x36, 0x1F, 0},
-		{0x37, 0x20, 0},
-		{0x38, 0x1E, 0},
-		{0x39, 0x2B, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2B, 0},
-		{0x3C, 0x1F, 0},
-		{0x3D, 0x21, 0},
-		{0x3E, 0x1C, 0},
-		{0x3F, 0x3F, 0},
-		{0x40, 0x00, 0},
-		{0x41, 0x32, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_90_TABLE[] = {
-		/* 90 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x31, 0},
-		{0x34, 0x39, 0},
-		{0x35, 0x3E, 0},
-		{0x36, 0x1F, 0},
-		{0x37, 0x1F, 0},
-		{0x38, 0x1E, 0},
-		{0x39, 0x2B, 0},
-		{0x3A, 0x25, 0},
-		{0x3B, 0x2B, 0},
-		{0x3C, 0x20, 0},
-		{0x3D, 0x23, 0},
-		{0x3E, 0x1D, 0},
-		{0x3F, 0x3E, 0},
-		{0x40, 0x00, 0},
-		{0x41, 0x31, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_100_TABLE[] = {
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x33, 0},
-		{0x34, 0x3C, 0},
-		{0x35, 0x41, 0},
-		{0x36, 0x1F, 0},
-		{0x37, 0x1F, 0},
-		{0x38, 0x1E, 0},
-		{0x39, 0x2B, 0},
-		{0x3A, 0x25, 0},
-		{0x3B, 0x2B, 0},
-		{0x3C, 0x20, 0},
-		{0x3D, 0x25, 0},
-		{0x3E, 0x1E, 0},
-		{0x3F, 0x3E, 0},
-		{0x40, 0x00, 0},
-		{0x41, 0x30, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_110_TABLE[] = {
-		/* 110 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x35, 0},
-		{0x34, 0x3F, 0},
-		{0x35, 0x44, 0},
-		{0x36, 0x1F, 0},
-		{0x37, 0x1F, 0},
-		{0x38, 0x1E, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2A, 0},
-		{0x3C, 0x21, 0},
-		{0x3D, 0x26, 0},
-		{0x3E, 0x1F, 0},
-		{0x3F, 0x3C, 0},
-		{0x40, 0x00, 0},
-		{0x41, 0x2E, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_120_TABLE[] = {
-		/* 120 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x37, 0},
-		{0x34, 0x41, 0},
-		{0x35, 0x46, 0},
-		{0x36, 0x1F, 0},
-		{0x37, 0x1F, 0},
-		{0x38, 0x1E, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2A, 0},
-		{0x3C, 0x22, 0},
-		{0x3D, 0x27, 0},
-		{0x3E, 0x20, 0},
-		{0x3F, 0x3A, 0},
-		{0x40, 0x00, 0},
-		{0x41, 0x2C, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_130_TABLE[] = {
-		/* 130 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x3A, 0},
-		{0x34, 0x44, 0},
-		{0x35, 0x49, 0},
-		{0x36, 0x1D, 0},
-		{0x37, 0x1E, 0},
-		{0x38, 0x1D, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2A, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x29, 0},
-		{0x3E, 0x21, 0},
-		{0x3F, 0x39, 0},
-		{0x40, 0x04, 0},
-		{0x41, 0x2C, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_140_TABLE[] = {
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x3C, 0},
-		{0x34, 0x46, 0},
-		{0x35, 0x4C, 0},
-		{0x36, 0x1D, 0},
-		{0x37, 0x1E, 0},
-		{0x38, 0x1C, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2A, 0},
-		{0x3C, 0x24, 0},
-		{0x3D, 0x2A, 0},
-		{0x3E, 0x22, 0},
-		{0x3F, 0x38, 0},
-		{0x40, 0x07, 0},
-		{0x41, 0x2C, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_150_TABLE[] = {
-		/* 150 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x3E, 0},
-		{0x34, 0x48, 0},
-		{0x35, 0x4E, 0},
-		{0x36, 0x1E, 0},
-		{0x37, 0x1E, 0},
-		{0x38, 0x1C, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2A, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x2A, 0},
-		{0x3E, 0x22, 0},
-		{0x3F, 0x38, 0},
-		{0x40, 0x09, 0},
-		{0x41, 0x2C, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_160_TABLE[] = {
-		/* 160 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x3F, 0},
-		{0x34, 0x4A, 0},
-		{0x35, 0x50, 0},
-		{0x36, 0x1E, 0},
-		{0x37, 0x1E, 0},
-		{0x38, 0x1C, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2A, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x2A, 0},
-		{0x3E, 0x22, 0},
-		{0x3F, 0x38, 0},
-		{0x40, 0x0B, 0},
-		{0x41, 0x2C, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_170_TABLE[] = {
-		/* 170 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x41, 0},
-		{0x34, 0x4C, 0},
-		{0x35, 0x52, 0},
-		{0x36, 0x1D, 0},
-		{0x37, 0x1E, 0},
-		{0x38, 0x1C, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2A, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x2A, 0},
-		{0x3E, 0x22, 0},
-		{0x3F, 0x39, 0},
-		{0x40, 0x11, 0},
-		{0x41, 0x2E, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_180_TABLE[] = {
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x43, 0},
-		{0x34, 0x4E, 0},
-		{0x35, 0x54, 0},
-		{0x36, 0x1D, 0},
-		{0x37, 0x1E, 0},
-		{0x38, 0x1C, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x2A, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x2A, 0},
-		{0x3E, 0x22, 0},
-		{0x3F, 0x39, 0},
-		{0x40, 0x13, 0},
-		{0x41, 0x2F, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_190_TABLE[] = {
-		/* 190 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x45, 0},
-		{0x34, 0x50, 0},
-		{0x35, 0x56, 0},
-		{0x36, 0x1D, 0},
-		{0x37, 0x1D, 0},
-		{0x38, 0x1C, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x29, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x2B, 0},
-		{0x3E, 0x23, 0},
-		{0x3F, 0x38, 0},
-		{0x40, 0x14, 0},
-		{0x41, 0x2E, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_200_TABLE[] = {
-		/* 200 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x46, 0},
-		{0x34, 0x52, 0},
-		{0x35, 0x58, 0},
-		{0x36, 0x1D, 0},
-		{0x37, 0x1D, 0},
-		{0x38, 0x1C, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x29, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x2B, 0},
-		{0x3E, 0x23, 0},
-		{0x3F, 0x38, 0},
-		{0x40, 0x15, 0},
-		{0x41, 0x2E, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_210_TABLE[] = {
-		/* 210 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x48, 0},
-		{0x34, 0x54, 0},
-		{0x35, 0x5B, 0},
-		{0x36, 0x1C, 0},
-		{0x37, 0x1C, 0},
-		{0x38, 0x1B, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x29, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x2B, 0},
-		{0x3E, 0x23, 0},
-		{0x3F, 0x3A, 0},
-		{0x40, 0x18, 0},
-		{0x41, 0x30, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_220_TABLE[] = {
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x4A, 0},
-		{0x34, 0x56, 0},
-		{0x35, 0x5D, 0},
-		{0x36, 0x1B, 0},
-		{0x37, 0x1C, 0},
-		{0x38, 0x1A, 0},
-		{0x39, 0x2A, 0},
-		{0x3A, 0x24, 0},
-		{0x3B, 0x29, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x2B, 0},
-		{0x3E, 0x23, 0},
-		{0x3F, 0x3B, 0},
-		{0x40, 0x1B, 0},
-		{0x41, 0x32, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_230_TABLE[] = {
-		/* 230 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x4B, 0},
-		{0x34, 0x58, 0},
-		{0x35, 0x5F, 0},
-		{0x36, 0x1C, 0},
-		{0x37, 0x1D, 0},
-		{0x38, 0x1B, 0},
-		{0x39, 0x29, 0},
-		{0x3A, 0x23, 0},
-		{0x3B, 0x28, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x2B, 0},
-		{0x3E, 0x24, 0},
-		{0x3F, 0x3B, 0},
-		{0x40, 0x1C, 0},
-		{0x41, 0x33, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_240_TABLE[] = {
-		/* 240 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x4C, 0},
-		{0x34, 0x59, 0},
-		{0x35, 0x60, 0},
-		{0x36, 0x1D, 0},
-		{0x37, 0x1D, 0},
-		{0x38, 0x1B, 0},
-		{0x39, 0x29, 0},
-		{0x3A, 0x23, 0},
-		{0x3B, 0x28, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x2B, 0},
-		{0x3E, 0x24, 0},
-		{0x3F, 0x3B, 0},
-		{0x40, 0x1D, 0},
-		{0x41, 0x33, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_250_TABLE[] = {
-		/* 250 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x4E, 0},
-		{0x34, 0x5B, 0},
-		{0x35, 0x62, 0},
-		{0x36, 0x1C, 0},
-		{0x37, 0x1C, 0},
-		{0x38, 0x1A, 0},
-		{0x39, 0x29, 0},
-		{0x3A, 0x23, 0},
-		{0x3B, 0x28, 0},
-		{0x3C, 0x24, 0},
-		{0x3D, 0x2C, 0},
-		{0x3E, 0x25, 0},
-		{0x3F, 0x3C, 0},
-		{0x40, 0x1F, 0},
-		{0x41, 0x34, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_260_TABLE[] = {
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x50, 0},
-		{0x34, 0x5D, 0},
-		{0x35, 0x64, 0},
-		{0x36, 0x1B, 0},
-		{0x37, 0x1C, 0},
-		{0x38, 0x1A, 0},
-		{0x39, 0x29, 0},
-		{0x3A, 0x23, 0},
-		{0x3B, 0x28, 0},
-		{0x3C, 0x25, 0},
-		{0x3D, 0x2C, 0},
-		{0x3E, 0x25, 0},
-		{0x3F, 0x3C, 0},
-		{0x40, 0x21, 0},
-		{0x41, 0x34, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_270_TABLE[] = {
-		/* 270 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x51, 0},
-		{0x34, 0x5F, 0},
-		{0x35, 0x66, 0},
-		{0x36, 0x1C, 0},
-		{0x37, 0x1C, 0},
-		{0x38, 0x1A, 0},
-		{0x39, 0x29, 0},
-		{0x3A, 0x23, 0},
-		{0x3B, 0x28, 0},
-		{0x3C, 0x25, 0},
-		{0x3D, 0x2D, 0},
-		{0x3E, 0x25, 0},
-		{0x3F, 0x3D, 0},
-		{0x40, 0x22, 0},
-		{0x41, 0x35, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_280_TABLE[] = {
-		/* 280 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x52, 0},
-		{0x34, 0x60, 0},
-		{0x35, 0x67, 0},
-		{0x36, 0x1C, 0},
-		{0x37, 0x1C, 0},
-		{0x38, 0x1A, 0},
-		{0x39, 0x29, 0},
-		{0x3A, 0x23, 0},
-		{0x3B, 0x28, 0},
-		{0x3C, 0x25, 0},
-		{0x3D, 0x2D, 0},
-		{0x3E, 0x25, 0},
-		{0x3F, 0x3D, 0},
-		{0x40, 0x23, 0},
-		{0x41, 0x36, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_290_TABLE[] = {
-		/* 290 nits*/
-		{0x30, 0x3A, 0},
-		{0x31, 0x3A, 0},
-		{0x32, 0x3A, 0},
-		{0x33, 0x54, 0},
-		{0x34, 0x62, 0},
-		{0x35, 0x69, 0},
-		{0x36, 0x1B, 0},
-		{0x37, 0x1B, 0},
-		{0x38, 0x1A, 0},
-		{0x39, 0x29, 0},
-		{0x3A, 0x23, 0},
-		{0x3B, 0x28, 0},
-		{0x3C, 0x25, 0},
-		{0x3D, 0x2E, 0},
-		{0x3E, 0x25, 0},
-		{0x3F, 0x3E, 0},
-		{0x40, 0x25, 0},
-		{0x41, 0x37, 0},
-};
-
-static const LCD_INIT_TABLE LCD_GAMMA_300_TABLE[] = {
-		{0x30, 0x3a, 0},
-		{0x31, 0x3a, 0},
-		{0x32, 0x3a, 0},
-		{0x33, 0x53, 0},
-		{0x34, 0x62, 0},
-		{0x35, 0x6e, 0},
-		{0x36, 0x18, 0},
-		{0x37, 0x1b, 0},
-		{0x38, 0x16, 0},
-		{0x39, 0x2e, 0},
-		{0x3A, 0x26, 0},
-		{0x3B, 0x2c, 0},
-		{0x3C, 0x23, 0},
-		{0x3D, 0x31, 0},
-		{0x3E, 0x29, 0},
-		{0x3F, 0x30, 0},
-		{0x40, 0x28, 0},
-		{0x41, 0x3f, 0},
-};
-
-static const LCD_INIT_TABLE *gamma_level_table[] = {
-	LCD_GAMMA_10_TABLE,
-	LCD_GAMMA_40_TABLE,
-	LCD_GAMMA_50_TABLE,
-	LCD_GAMMA_60_TABLE,
-	LCD_GAMMA_70_TABLE,
-	LCD_GAMMA_80_TABLE,
-	LCD_GAMMA_90_TABLE,
-	LCD_GAMMA_100_TABLE,
-	LCD_GAMMA_110_TABLE,
-	LCD_GAMMA_120_TABLE,
-	LCD_GAMMA_130_TABLE,
-	LCD_GAMMA_140_TABLE,
-	LCD_GAMMA_150_TABLE,
-	LCD_GAMMA_160_TABLE,
-	LCD_GAMMA_170_TABLE,
-	LCD_GAMMA_180_TABLE,
-	LCD_GAMMA_190_TABLE,
-	LCD_GAMMA_200_TABLE,
-	LCD_GAMMA_210_TABLE,
-	LCD_GAMMA_220_TABLE,
-	LCD_GAMMA_230_TABLE,
-	LCD_GAMMA_240_TABLE,
-	LCD_GAMMA_250_TABLE,
-	LCD_GAMMA_260_TABLE,
-	LCD_GAMMA_270_TABLE,
-	LCD_GAMMA_280_TABLE,
-	LCD_GAMMA_290_TABLE,
-	LCD_GAMMA_300_TABLE
-};
-
-static struct vreg *vreg_lcm_1v8;
-static struct vreg *vreg_lcm_2v8;
-
-static uint32_t display_on_gpio_table[] = {
-	/* Display */
-	PCOM_GPIO_CFG(LEGEND_LCD_G5, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_DE, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_HSYNC, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_VSYNC, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_B0, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_B1, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-
-	PCOM_GPIO_CFG(LEGEND_LCD_G1, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_G0, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_B4, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_B3, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_B2, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_G4, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_G3, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_G2, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-
-};
-
-static uint32_t display_off_gpio_table[] = {
-	/* Display */
-	PCOM_GPIO_CFG(LEGEND_LCD_G5, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_DE, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_HSYNC, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_VSYNC, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_B0, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_B1, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-
-	PCOM_GPIO_CFG(LEGEND_LCD_G1, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_G0, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_B4, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_B3, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_B2, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_G4, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_G3, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-	PCOM_GPIO_CFG(LEGEND_LCD_G2, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA),
-};
-
-void config_legend_display_on_gpios(void)
-{
-	D( "%s: enter.\n", __func__);
-	config_gpio_table(display_on_gpio_table,
-		ARRAY_SIZE(display_on_gpio_table));
-}
-
-void config_legend_display_off_gpios(void)
-{
-	D( "%s: enter.\n", __func__);
-	config_gpio_table(display_off_gpio_table,
-		ARRAY_SIZE(display_off_gpio_table));
-}
-
-static int lcm_spi_write(unsigned char add, unsigned char val)
-{
-	uint8_t buf[3] = {0, add, val};
-	int ret = 0;
-
-#ifdef CONFIG_MICROP_COMMON
-	ret = microp_i2c_write(MICROP_I2C_WCMD_LCM_REGISTER, buf, 3);
-#endif
-
-	if (ret < 0) {
-		D("%s: microp_spi_write fail\n", __func__);
-		return ret;
-	}
-	return ret;
-}
-
-static int spi_write_tb(const LCD_INIT_TABLE init_table[], unsigned size)
-{
-	int i;
-
-	for (i = 0; i < size; i++) {
-		/* microp need 1 ms to finish its task */
-
-		lcm_spi_write(init_table[i].reg, init_table[i].val);
-
-		if (init_table[i].delay > 20)
-			msleep(init_table[i].delay);
-		else if (init_table[i].delay)
-			mdelay(init_table[i].delay);
-	}
-	return 0;
-}
-
-static int spi_write_gmtb(const LCD_INIT_TABLE init_table[], unsigned size)
-{
-	int i, ret = -1;
-	uint8_t buf[18];
-
-	for (i = 0; i < size; i++)
-		buf[i] = init_table[i].val;
-
-#ifdef CONFIG_MICROP_COMMON
-	ret = microp_i2c_write(MICROP_I2C_WCMD_LCM_BURST, buf, 18);
-	if (ret < 0) {
-		D("%s: write gamma table failed\n", __func__);
-		return ret;
-	}
-	buf[0] = 0x00;
-	buf[1] = 0x01;
-	ret = microp_i2c_write(MICROP_I2C_WCMD_LCM_BURST_EN, buf, 2);
-	if (ret < 0) {
-		D("%s: burst data enable failed\n", __func__);
-		return ret;
-	}
-#endif
-
-	return ret;
-}
-
-
-int set_backlight_level(int level)
-{
-	mutex_lock(&legend_backlight_lock);
-
-	if (level < 0 || level > GAMMA_LEVEL_MAX)
-		goto finish;
-
-	printk("set_backlight_level:%d\n", level);
-	spi_write_gmtb(gamma_level_table[level], ARRAY_SIZE(LCD_GAMMA_40_TABLE));
-finish:
-	mutex_unlock(&legend_backlight_lock);
-	return 0;
-}
-
-static void set_brightness_work_func(struct work_struct *work)
-{
-	if (atomic_read(&gate) == 0)
-		return;
-
-	set_backlight_level(g_brightness_level);
-}
-
-static void legend_brightness_set(struct led_classdev *led_cdev,
-				  enum led_brightness value)
-{
-	static uint8_t last_level = -1;
-	uint8_t level;
-
-	/* LED_VALUE_DEFAULT ~ LED_VALUE_MAX map to
-	 GAMMA_LEVEL_DEFAULT ~ GAMMA_LEVEL_MAX */
-	/* LED_VALUE_MIN ~ LED_VALUE_DEFAULT map to
-	 0 ~ GAMMA_LEVEL_DEFAULT */
-	if (value > LED_VALUE_DEFAULT)
-		level = ((value - LED_VALUE_DEFAULT) *
-			(GAMMA_LEVEL_MAX - GAMMA_LEVEL_DEFAULT) /
-			(LED_VALUE_MAX  - LED_VALUE_DEFAULT)) + GAMMA_LEVEL_DEFAULT;
-	else if (value <= LED_VALUE_MIN)
-		level = GAMMA_LEVEL_MIN;
-	else
-		level = (value - LED_VALUE_MIN) *
-			(GAMMA_LEVEL_DEFAULT - GAMMA_LEVEL_MIN)/
-			(LED_VALUE_DEFAULT - LED_VALUE_MIN +1) + 1;
-
-	D("%s:%d level:%d\n", __func__, value, level);
-	mutex_lock(&legend_backlight_lock);
-
-	if (level == last_level) {
-		mutex_unlock(&legend_backlight_lock);
-		return;
-	}
-	g_brightness_level = level;
-	last_level = level;
-
-	mutex_unlock(&legend_backlight_lock);
-
-	schedule_work(&work_set_brightness);
-}
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static int samsung_panel_blank(struct msm_lcdc_panel_ops *op)
-{
-	unsigned id, off = 1;
-	unsigned int status;
-
-	printk(KERN_DEBUG "%s\n", __func__);
-
-	atomic_set(&gate, 0);
-
-	/* start display off sequence */
-	lcm_spi_write(0x4, 0x3);
-	mdelay(100);
-	lcm_spi_write(0x4, 0x1);
-	mdelay(60);
-	lcm_spi_write(0x4, 0x0);
-
-	mdelay(100);
-
-	lcm_spi_write(0x20, 0x0);
-
-	/* start power off sequence */
-	/*Reset pull low*/
-	gpio_set_value(LEGEND_GPIO_LCD_RST_N, 0);
-	mdelay(100);
-
-	/* config LCDC pin mux to gpio function */
-	config_legend_display_off_gpios();
-	gpio_set_value(118,0);
-
-	status = (unsigned int) gpio_get_value(118);
-	D("GPIO118 = %x.\n", status);
-
-	mdelay(15);
-	/* turn off VCI */
-	id = PM_VREG_PDOWN_RFRX2_ID;
-	msm_proc_comm(PCOM_VREG_PULLDOWN, &off, &id);
-	vreg_disable(vreg_lcm_2v8);
-
-	/* turn off VDD3 */
-	id = PM_VREG_PDOWN_AUX_ID;
-	msm_proc_comm(PCOM_VREG_PULLDOWN, &off, &id);
-	vreg_disable(vreg_lcm_1v8);
-	mdelay(10);
-
-	microp_spi_vote_enable(SPI_LCM, 0);
-
-	return 0;
-}
-
-static int samsung_panel_unblank(struct msm_lcdc_panel_ops *op)
-{
-	unsigned id, on = 1;
-	int ret;
-
-	printk(KERN_DEBUG "%s\n", __func__);
-
-	/* check RST pin value, 1 means already on, 0 means off */
-	if(gpio_get_value(LEGEND_GPIO_LCD_RST_N))
-	{
-		/* delay and check again to filter ripple */
-		mdelay(1);
-		if(gpio_get_value(LEGEND_GPIO_LCD_RST_N))
-		{
-			atomic_set(&gate, 1);
-			printk(KERN_DEBUG "%s already unblank\n", __func__);
-			return 0;
-		}
-	}
-
-	/* config LCDC pin mux to RGB function */
-	config_legend_display_on_gpios();
-
-	/* power on sequence */
-	id = PM_VREG_PDOWN_AUX_ID;
-	msm_proc_comm(PCOM_VREG_PULLDOWN, &on, &id);
-	vreg_enable(vreg_lcm_1v8);
-	mdelay(10);
-
-	id = PM_VREG_PDOWN_RFRX2_ID;
-	msm_proc_comm(PCOM_VREG_PULLDOWN, &on, &id);
-	vreg_enable(vreg_lcm_2v8);
-	msleep(15);
-
-	gpio_set_value(LEGEND_GPIO_LCD_RST_N, 1);
-	mdelay(10);
-
-	ret = microp_spi_vote_enable(SPI_LCM, 1);
-	if (ret)
-		printk(KERN_ERR "%s: enable SPI fail\n", __func__);
-
-	spi_write_tb(OLED_POWER_SEQUENCE, ARRAY_SIZE(OLED_POWER_SEQUENCE));
-	spi_write_tb(OLED_INIT_SEQUENCE, ARRAY_SIZE(OLED_INIT_SEQUENCE));
-
-	/* display on sequence */
-	lcm_spi_write(0x4, 0x5);
-	mdelay(20);
-	lcm_spi_write(0x4, 0x7);
-
-	mutex_lock(&legend_backlight_lock);
-	spi_write_gmtb(gamma_level_table[g_brightness_level], ARRAY_SIZE(LCD_GAMMA_40_TABLE));
-	mutex_unlock(&legend_backlight_lock);
-
-	atomic_set(&gate, 1);
-	return 0;
-}
-
-static struct msm_lcdc_panel_ops legend_lcdc_panel_ops = {
-#if 0
-	.init = samsung_oled_panel_init,
-	.uninit = samsung_panel_uninit,
-#endif
-	.blank = samsung_panel_blank,
-	.unblank = samsung_panel_unblank,
-};
-
-#define CLK_NS_TO_RATE(ns)	(1000000000UL / (ns))
-static struct msm_lcdc_timing legend_lcdc_timing = {
-	.clk_rate = CLK_NS_TO_RATE(75),
-	.hsync_pulse_width = 4,
-	.hsync_back_porch = 60,
-	.hsync_front_porch = 64,
-	.hsync_skew = 0,
-	.vsync_pulse_width = 4,
-	.vsync_back_porch = 4,
-	.vsync_front_porch = 8,
-	.vsync_act_low = 1,
-	.hsync_act_low = 1,
-	.den_act_low = 1,
-};
-
-static struct msm_fb_data legend_lcdc_fb_data = {
-	.xres = 320,
-	.yres = 480,
-	.width = 67,
-	.height = 45,
-	.output_format = 0,
-};
-
-static struct msm_lcdc_platform_data legend_lcdc_platform_data = {
-	.panel_ops = &legend_lcdc_panel_ops,
-	.timing = &legend_lcdc_timing,
-	.fb_id = 0,
-	.fb_data = &legend_lcdc_fb_data,
-	.fb_resource = &resources_msm_fb[0],
-};
-
-static struct platform_device legend_lcdc_device = {
-	.name = "msm_mdp_lcdc",
-	.id = -1,
-	.dev = {
-		.platform_data = &legend_lcdc_platform_data,
-		},
-};
-
-static struct led_classdev legend_backlight_led = {
-	.name = "lcd-backlight",
-	.brightness = LED_FULL,
-	.brightness_set = legend_brightness_set,
-};
-
-static int legend_backlight_probe(struct platform_device *pdev)
-{
-	int rc;
-
-	rc = led_classdev_register(&pdev->dev, &legend_backlight_led);
-	if (rc) {
-		printk("backlight: failure on register led_classdev\n");
-	}
-	INIT_WORK(&work_set_brightness, set_brightness_work_func);
-
-	return 0;
-}
-
-static int legend_backlight_remove(struct platform_device *pdev)
-{
-	led_classdev_unregister(&legend_backlight_led);
-	return 0;
-}
-
-static struct platform_device legend_backlight = {
-	.name = "legend-backlight",
-};
-
-static struct platform_driver legend_backlight_driver = {
-	.probe = legend_backlight_probe,
-	.remove = legend_backlight_remove,
-	.driver = {
-		   .name = "legend-backlight",
-		   .owner = THIS_MODULE,
-	},
-};
-
-int __init legend_init_panel(void)
-{
-	int ret;
-
-	if (!machine_is_legend())
-		return 0;
-
-	vreg_lcm_1v8 = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_lcm_1v8))
-		return PTR_ERR(vreg_lcm_1v8);
-
-	vreg_lcm_2v8 = vreg_get(0, "rfrx2");
-	if (IS_ERR(vreg_lcm_2v8))
-		return PTR_ERR(vreg_lcm_2v8);
-
-	ret = platform_device_register(&msm_device_mdp);
-	if (ret != 0)
-		return ret;
-
-	wake_lock_init(&backlight_wakelock, WAKE_LOCK_SUSPEND,
-		       "backlight_present");
-
-	ret = platform_device_register(&legend_lcdc_device);
-	if (ret != 0)
-		return ret;
-	platform_device_register(&legend_backlight);
-	ret = platform_driver_register(&legend_backlight_driver);
-	if (ret)
-		return ret;
-	return 0;
-}
-
-device_initcall(legend_init_panel);
diff --git a/arch/arm/mach-msm/board-legend-rfkill.c b/arch/arm/mach-msm/board-legend-rfkill.c
deleted file mode 100644
index 8716799..0000000
--- a/arch/arm/mach-msm/board-legend-rfkill.c
+++ /dev/null
@@ -1,316 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for legend platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-legend.h"
-
-extern int legend_bt_fastclock_power(int on);
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "brf6450";
-
-static uint32_t legend_bt_init_table[] = {
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_RTS, /* BT_RTS */
-			0,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_CTS, /* BT_CTS */
-			0,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_RX, /* BT_RX */
-			0,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_TX, /* BT_TX */
-			0,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-
-	PCOM_GPIO_CFG(LEGEND_GPIO_BT_EN, /* BT_ENABLE */
-			0,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-};
-
-static uint32_t legend_bt_on_table[] = {
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_RTS, /* BT_RTS */
-			2,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_CTS, /* BT_CTS */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_RX, /* BT_RX */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_TX, /* BT_TX */
-			3,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-};
-
-static uint32_t legend_bt_off_table[] = {
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_RTS, /* BT_RTS */
-			2,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_CTS, /* BT_CTS */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_RX, /* BT_RX */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_TX, /* BT_TX */
-			3,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-};
-
-#if 0
-static uint32_t legend_bt_disable_active_table[] = {
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_RTS, /* BT_RTS */
-			2,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_CTS, /* BT_CTS */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_RX, /* BT_RX */
-			2,
-			GPIO_INPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_TX, /* BT_TX */
-			3,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-};
-
-static uint32_t legend_bt_disable_sleep_table[] = {
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_RTS, /* O(L) */
-			0,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_CTS, /* I(PU) */
-			0,
-			GPIO_INPUT,
-			GPIO_PULL_UP,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_RX, /* I(PU) */
-			0,
-			GPIO_INPUT,
-			GPIO_PULL_UP,
-			GPIO_8MA),
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART1_TX, /* O(H) */
-			0,
-			GPIO_OUTPUT,
-			GPIO_NO_PULL,
-			GPIO_8MA),
-};
-#endif
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void legend_config_bt_init(void)
-{
-	config_bt_table(legend_bt_init_table,
-			ARRAY_SIZE(legend_bt_init_table));
-	mdelay(2);
-
-	gpio_configure(LEGEND_GPIO_BT_EN,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-}
-
-static void legend_config_bt_on(void)
-{
-	config_bt_table(legend_bt_on_table,
-			ARRAY_SIZE(legend_bt_on_table));
-	mdelay(2);
-
-	gpio_configure(LEGEND_GPIO_BT_EN,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(15);
-	gpio_configure(LEGEND_GPIO_BT_EN,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(1);
-	gpio_configure(LEGEND_GPIO_BT_EN,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(1);
-
-	legend_bt_fastclock_power(1);
-	mdelay(2);
-}
-
-static void legend_config_bt_off(void)
-{
-	gpio_configure(LEGEND_GPIO_BT_EN,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	legend_bt_fastclock_power(0);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(legend_bt_off_table,
-			ARRAY_SIZE(legend_bt_off_table));
-	mdelay(2);
-}
-
-#if 0
-void legend_config_bt_disable_active(void)
-{
-	config_bt_table(legend_bt_disable_active_table,
-			ARRAY_SIZE(legend_bt_disable_active_table));
-}
-
-void legend_config_bt_disable_sleep(void)
-{
-	config_bt_table(legend_bt_disable_sleep_table,
-			ARRAY_SIZE(legend_bt_disable_sleep_table));
-	mdelay(5);
-	gpio_configure(LEGEND_GPIO_UART1_RTS,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);	/* O(L) */
-	gpio_configure(LEGEND_GPIO_UART1_TX,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH); /* O(H) */
-}
-
-int legend_is_bluetooth_off(void)
-{
-	return !legend_bt_status;	/* ON:1, OFF:0 */
-}
-#endif
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		legend_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		legend_config_bt_off();
-		break;
-	default:
-		printk(KERN_ERR "bad bluetooth rfkill state %d\n", state);
-	}
-	return 0;
-}
-
-static int legend_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;  /* off */
-
-	/* force BT on and off to do GPIO setting when initiate */
-	bluetooth_set_power(NULL, RFKILL_STATE_UNBLOCKED);
-	legend_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;  /* user data */
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-
-	if (rc)
-		rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int legend_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver legend_rfkill_driver = {
-	.probe = legend_rfkill_probe,
-	.remove = legend_rfkill_remove,
-	.driver = {
-		.name = "legend_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init legend_rfkill_init(void)
-{
-	if (!machine_is_legend())
-		return 0;
-	return platform_driver_register(&legend_rfkill_driver);
-}
-
-static void __exit legend_rfkill_exit(void)
-{
-	platform_driver_unregister(&legend_rfkill_driver);
-}
-
-module_init(legend_rfkill_init);
-module_exit(legend_rfkill_exit);
-MODULE_DESCRIPTION("legend rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-legend-wifi.c b/arch/arm/mach-msm/board-legend-wifi.c
deleted file mode 100644
index 88d794c..0000000
--- a/arch/arm/mach-msm/board-legend-wifi.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/* arch/arm/mach-msm/board-legend-wifi.c
- *
- * Copyright (C) 2008 Google, Inc.
- * Author: Dmitry Shmidt <dimitrysh@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/vmalloc.h>
-#include <linux/err.h>
-#include <linux/wifi_tiwlan.h>
-
-extern int legend_wifi_set_carddetect(int val);
-extern int legend_wifi_power(int on);
-extern int legend_wifi_reset(int on);
-
-
-struct wifi_platform_data legend_wifi_control = {
-	.set_power		= legend_wifi_power,
-	.set_reset		= legend_wifi_reset,
-	.set_carddetect	= legend_wifi_set_carddetect,
-	.mem_prealloc	= NULL,
-};
-
-static struct platform_device wifi_ctrl_dev = {
-	.name		= "msm_wifi",
-	.id		= 1,
-	.num_resources	= 0,
-	.resource	= NULL,
-	.dev		= {
-		.platform_data = &legend_wifi_control,
-	},
-};
-
-static int __init legend_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_legend())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	ret = platform_device_register(&wifi_ctrl_dev);
-	return ret;
-}
-
-
-late_initcall(legend_wifi_init);
-
diff --git a/arch/arm/mach-msm/board-legend.c b/arch/arm/mach-msm/board-legend.c
deleted file mode 100644
index 316529b..0000000
--- a/arch/arm/mach-msm/board-legend.c
+++ /dev/null
@@ -1,1064 +0,0 @@
-/* arch/arm/mach-msm/board-legend.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/irq.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/sysdev.h>
-#include <linux/android_pmem.h>
-#include <linux/curcial_oj.h>
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/delay.h>
-#include <linux/atmel_qt602240.h>
-#include <linux/gpio.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/delay.h>
-#include <asm/setup.h>
-#include <asm/mach/mmc.h>
-#ifdef CONFIG_CACHE_L2X0
-#include <asm/hardware/cache-l2x0.h>
-#endif
-
-#include <mach/system.h>
-#include <mach/vreg.h>
-#include <mach/gpio_chip.h>
-#include <mach/board.h>
-#include <mach/board_htc.h>
-#include <mach/msm_serial_hs.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <mach/atmega_microp.h>
-#include <mach/msm_tssc.h>
-#include <mach/htc_battery.h>
-#include <mach/htc_pwrsink.h>
-#include <mach/perflock.h>
-#include <mach/drv_callback.h>
-#include <mach/camera.h>
-#include <mach/msm_flashlight.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/hardware.h>
-#include <mach/msm_iomap.h>
-#include <mach/msm_hsusb.h>
-
-#include "devices.h"
-#include "board-legend.h"
-#include "proc_comm.h"
-
-void msm_init_irq(void);
-void msm_init_gpio(void);
-void config_legend_camera_on_gpios(void);
-void config_legend_camera_off_gpios(void);
-#ifdef CONFIG_MICROP_COMMON
-void __init legend_microp_init(void);
-#endif
-void config_legend_proximity_gpios(int on);
-static int legend_phy_init_seq[] = {0x20, 0x31, 0x1, 0x0D, 0x1, 0x10, -1};
-static struct msm_hsusb_product legend_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c97,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-
-static void legend_phy_reset(void)
-{
-	int ret;
-	printk(KERN_INFO "%s\n", __func__);
-	ret = msm_proc_comm(PCOM_MSM_HSUSB_PHY_RESET,
-			NULL, NULL);
-	if (ret)
-		printk(KERN_INFO "%s failed\n", __func__);
-}
-
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-//	.gpio_mbat_in = LEGEND_GPIO_MBAT_IN,
-//	.gpio_mchg_en_n = LEGEND_GPIO_MCHG_EN_N,
-//	.gpio_iset = LEGEND_GPIO_ISET,
-	.guage_driver = GUAGE_MODEM,
-	.charger = LINEAR_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0, 0x21, 0x4D, 0xDC, 0x134, 0x18D, 0x1E5, 0x3FF, 0x3FF, 0x3FF },
-		.channel = 3,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xC0,
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 38, 82, 95, 167},
-		.channel = 1,
-		.int_pin = 1 << 5,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "reset-int",
-		.category = MICROP_FUNCTION_RESET_INT,
-		.int_pin = 1 << 8,
-	},
-	{
-		.name   = "oj",
-		.category = MICROP_FUNCTION_OJ,
-		.int_pin = 1 << 12,
-	},
-};
-
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "button-backlight",
-		.type = LED_GPO,
-		.mask_w = {0x00, 0x00, 0x08},
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct bma150_platform_data legend_g_sensor_pdata = {
-	.microp_new_cmd = 1,
-};
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev = {
-			.platform_data = &lightsensor_data,
-		},
-	},
-	 {
-		.name = "leds-microp",
-		.id = -1,
-		.dev = {
-			.platform_data = &microp_leds_data,
-		},
-	},
-	{
-		.name = BMA150_G_SENSOR_NAME,
-		.dev = {
-			.platform_data = &legend_g_sensor_pdata,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = LEGEND_GPIO_UP_RESET_N,
-	.spi_devices = SPI_OJ | SPI_LCM | SPI_GSENSOR,
-	.spi_devices_init = SPI_LCM,
-};
-
-static struct synaptics_i2c_rmi_platform_data legend_ts_rmi_data[] = {
-	{
-		.version = 0x0100,
-		.flags = SYNAPTICS_FLIP_Y | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = -1 * 0x10000 / 320,
-		.inactive_right = -1 * 0x10000 / 320,
-		.inactive_top = -1 * 0x10000 / 480,
-		.inactive_bottom = -1 * 0x10000 / 480,
-		.display_width = 320,
-		.display_height = 480,
-		.dup_threshold = 10,
-	}
-};
-
-static struct synaptics_i2c_rmi_platform_data legend_ts_t1021_data[] = {
-	{
-		.version = 0x0100,
-		.flags = SYNAPTICS_FLIP_Y | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = -10 * 0x10000 / 1808,
-		.inactive_right = -10 * 0x10000 / 1808,
-		.inactive_top = -20 * 0x10000 / 2707,
-		.inactive_bottom = -20 * 0x10000 / 2707,
-		.snap_left_on = 10 * 0x10000 / 1808,
-		.snap_left_off = 20 * 0x10000 / 1808,
-		.snap_right_on = 10 * 0x10000 / 1808,
-		.snap_right_off = 20 * 0x10000 / 1808,
-		.snap_top_on = 20 * 0x10000 / 2707,
-		.snap_top_off = 30 * 0x10000 / 2707,
-		.snap_bottom_on = 20 * 0x10000 / 2707,
-		.snap_bottom_off = 30 * 0x10000 / 2707,
-	}
-};
-
-static int legend_ts_atmel_power(int on)
-{
-	printk(KERN_INFO "%s():\n", __func__);
-	if (on) {
-		gpio_set_value(LEGEND_TP_5V_EN, 1);
-		msleep(2);
-		gpio_set_value(LEGEND_GPIO_TP_RST, 1);
-	} else {
-		gpio_set_value(LEGEND_TP_5V_EN, 0);
-		msleep(2);
-	}
-	return 0;
-}
-
-struct atmel_i2c_platform_data legend_ts_atmel_data[] = {
-	{
-		.version = 0x0015,
-		.abs_x_min = 0,
-		.abs_x_max = 1023,
-		.abs_y_min = 0,
-		.abs_y_max = 1023,
-		.abs_pressure_min = 0,
-		.abs_pressure_max = 255,
-		.abs_width_min = 0,
-		.abs_width_max = 20,
-		.gpio_irq = LEGEND_GPIO_TP_ATT_N,
-		.power = legend_ts_atmel_power,
-		.config_T6 = {0, 0, 0, 0, 0, 0},
-		.config_T7 = {50, 15, 25},
-		.config_T8 = {8, 0, 20, 10, 0, 0, 5, 25},
-		.config_T9 = {139, 0, 0, 14, 10, 0, 16, 35, 2, 5, 0, 2, 2, 14, 2, 10, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 153, 60, 152, 89},
-		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T20 = {19, 0, 0, 5, 5, 0, 0, 35, 20, 4, 15, 0},
-		.config_T22 = {13, 0, 0, 25, 0, 231, 255, 4, 20, 0, 1, 10, 15, 20, 255, 255, 4},
-		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T25 = {3, 0, 248, 42, 88, 27, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-		.config_T28 = {0, 0, 0, 4, 8, 60},
-		.object_crc = {0x50, 0x8A, 0xD1},
-	},
-	{
-		.version = 0x0014,
-		.abs_x_min = 0,
-		.abs_x_max = 1023,
-		.abs_y_min = 0,
-		.abs_y_max = 1023,
-		.abs_pressure_min = 0,
-		.abs_pressure_max = 255,
-		.abs_width_min = 0,
-		.abs_width_max = 20,
-		.gpio_irq = LEGEND_GPIO_TP_ATT_N,
-		.power = legend_ts_atmel_power,
-		.config_T6 = {0, 0, 0, 0, 0, 0},
-		.config_T7 = {50, 15, 25},
-		.config_T8 = {8, 0, 20, 20, 0, 0, 10, 15},
-		.config_T9 = {139, 0, 0, 14, 10, 0, 48, 35, 2, 5, 0, 1, 1, 0, 2, 10, 25, 0, 0, 0, 0, 0, 5, 10, 30, 30, 153, 60, 152, 89},
-		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T20 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T22 = {5, 0, 0, 25, 0, -25, 255, 4, 30, 0, 1, 10, 15, 20, 10, 10, 0},
-		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T25 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-		.config_T28 = {0, 0, 0, 4, 8},
-		.object_crc = {0x59, 0xB6, 0x5E},
-	}
-};
-#if 0
-static void legend_phy_reset(void)
-{
-	printk(KERN_INFO "%s\n", __func__);
-	gpio_set_value(LEGEND_GPIO_USBPHY_3V3_EN, 0);
-	mdelay(10);
-	gpio_set_value(LEGEND_GPIO_USBPHY_3V3_EN, 1);
-	mdelay(10);
-}
-#endif
-static void legend_phy_shutdown(void)
-{
-	printk(KERN_INFO "%s\n", __func__);
-	gpio_set_value(LEGEND_GPIO_USBPHY_3V3_EN, 0);
-}
-
-
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = LEGEND_LAYOUTS,
-	.project_name = LEGEND_PROJECT_NAME,
-	.reset = LEGEND_GPIO_COMPASS_RST_N,
-	.intr = LEGEND_GPIO_COMPASS_INT_N,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x20),
-		.platform_data = &legend_ts_rmi_data,
-		.irq = LEGEND_GPIO_TO_INT(LEGEND_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(SYNAPTICS_T1021_NAME, 0x21),
-		.platform_data = &legend_ts_t1021_data,
-		.irq = LEGEND_GPIO_TO_INT(LEGEND_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(ATMEL_QT602240_NAME, 0x94 >> 1),
-		.platform_data = &legend_ts_atmel_data,
-		.irq = MSM_GPIO_TO_INT(LEGEND_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = LEGEND_GPIO_TO_INT(LEGEND_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = LEGEND_GPIO_TO_INT(LEGEND_GPIO_COMPASS_INT_N),
-	},
-};
-
-static struct h2w_platform_data legend_h2w_data = {
-};
-
-static struct platform_device legend_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &legend_h2w_data,
-	},
-};
-
-static struct audio_jack_platform_data legend_jack_data = {
-	.gpio	= LEGEND_GPIO_35MM_HEADSET_DET,
-};
-
-static struct platform_device legend_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &legend_jack_data,
-	},
-};
-
-static struct pwr_sink legend_pwrsink_table[] = {
-	{
-		.id     = PWRSINK_AUDIO,
-		.ua_max = 100000,
-	},
-	{
-		.id     = PWRSINK_BACKLIGHT,
-		.ua_max = 125000,
-	},
-	{
-		.id     = PWRSINK_LED_BUTTON,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_LED_KEYBOARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_GP_CLK,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_BLUETOOTH,
-		.ua_max = 15000,
-	},
-	{
-		.id     = PWRSINK_CAMERA,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_SDCARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_VIDEO,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id     = PWRSINK_SYSTEM_LOAD,
-		.ua_max = 100000,
-		.percent_util = 38,
-	},
-};
-
-static int legend_pwrsink_resume_early(struct platform_device *pdev)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-	return 0;
-}
-
-static void legend_pwrsink_resume_late(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 38);
-}
-
-static void legend_pwrsink_suspend_early(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-}
-
-static int legend_pwrsink_suspend_late(struct platform_device *pdev, pm_message_t state)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 1);
-	return 0;
-}
-
-static struct pwr_sink_platform_data legend_pwrsink_data = {
-	.num_sinks      = ARRAY_SIZE(legend_pwrsink_table),
-	.sinks          = legend_pwrsink_table,
-	.suspend_late	= legend_pwrsink_suspend_late,
-	.resume_early	= legend_pwrsink_resume_early,
-	.suspend_early	= legend_pwrsink_suspend_early,
-	.resume_late	= legend_pwrsink_resume_late,
-};
-
-static struct platform_device legend_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev    = {
-		.platform_data = &legend_pwrsink_data,
-	},
-};
-
-static struct msm_pmem_setting pmem_setting = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-	.kgsl_start = MSM_GPU_MEM_BASE,
-	.kgsl_size = MSM_GPU_MEM_SIZE,
-};
-
-
-#ifdef CONFIG_MSM_CAMERA
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		.end	= INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_legend_camera_on_gpios,
-	.camera_gpio_off = config_legend_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
-	.camera_flash		= flashlight_control,
-	.num_flash_levels	= FLASHLIGHT_NUM,
-	.low_temp_limit		= 5,
-	.low_cap_limit		= 15,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_s5k4e1gx_data = {
-	.sensor_name    = "s5k4e1gx",
-	.sensor_reset   = LEGEND_GPIO_CAM1_RST_N,
-	.vcm_pwd        = LEGEND_GPIO_VCM_PWDN,
-	.pdata          = &msm_camera_device_data,
-	.resource       = msm_camera_resources,
-	.num_resources  = ARRAY_SIZE(msm_camera_resources),
-	.flash_cfg	= &msm_camera_sensor_flash_cfg,
-};
-
-static struct platform_device msm_camera_sensor_s5k4e1gx = {
-	.name      = "msm_camera_s5k4e1gx",
-	.dev       = {
-		.platform_data = &msm_camera_sensor_s5k4e1gx_data,
-	},
-};
-#endif
-
-static struct platform_device legend_rfkill = {
-	.name = "legend_rfkill",
-	.id = -1,
-};
-
-/* Proximity Sensor (Capella_CM3602)*/
-static int __capella_cm3602_power(int on)
-{
-	int rc;
-	struct vreg *vreg = vreg_get(0, "wlan");
-	if (!vreg) {
-		printk(KERN_ERR "%s: vreg error\n", __func__);
-		return -EIO;
-	}
-	rc = vreg_set_level(vreg, 2800);
-
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on) {
-		config_legend_proximity_gpios(1);
-		gpio_direction_output(LEGEND_GPIO_PROXIMITY_EN, 1);
-		rc = vreg_enable(vreg);
-		if (rc < 0)
-			printk(KERN_ERR "%s: vreg enable failed\n", __func__);
-	} else {
-		rc = vreg_disable(vreg);
-		if (rc < 0)
-			printk(KERN_ERR "%s: vreg disable failed\n", __func__);
-		gpio_direction_output(LEGEND_GPIO_PROXIMITY_EN, 0);
-		config_legend_proximity_gpios(0);
-	}
-
-	return rc;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable)
-		als_power_control |= pwr_device;
-	else
-		als_power_control &= ~pwr_device;
-
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-		ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-
-}
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.p_out = LEGEND_GPIO_PROXIMITY_INT,
-	.p_en = LEGEND_GPIO_PROXIMITY_EN,
-	.power = capella_cm3602_power,
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-#define CURCIAL_OJ_POWER            85
-static void curcial_oj_shutdown (int	enable)
-{
-	uint8_t	cmd[3];
-	memset(cmd, 0x00, sizeof(uint8_t)*3);
-
-	cmd[2] = 0x80;
-	if (enable)
-		microp_i2c_write(0x90, cmd,	3);
-	else
-		microp_i2c_write(0x91, cmd,	3);
-}
-static int curcial_oj_poweron(int on)
-{
-	gpio_set_value(CURCIAL_OJ_POWER, on);
-
-	if (gpio_get_value(CURCIAL_OJ_POWER) != on) {
-		printk(KERN_ERR "%s:OJ:power status fail \n", __func__);
-		return 0;
-	}
-		printk(KERN_ERR "%s:OJ:power status ok \n", __func__);
-	return 1;
-}
-static void curcial_oj_adjust_xy(uint8_t *data, int16_t *mSumDeltaX, int16_t *mSumDeltaY)
-{
-	int8_t 	deltaX;
-	int8_t 	deltaY;
-
-
-	if (data[2] == 0x80)
-		data[2] = 0x81;
-	if (data[1] == 0x80)
-		data[1] = 0x81;
-	if (0) {
-		deltaX = (1)*((int8_t) data[2]); /*X=2*/
-		deltaY = (1)*((int8_t) data[1]); /*Y=1*/
-	} else {
-		deltaX = (1)*((int8_t) data[1]);
-		deltaY = (1)*((int8_t) data[2]);
-	}
-	*mSumDeltaX += -((int16_t)deltaX);
-	*mSumDeltaY += -((int16_t)deltaY);
-}
-#define LED_MICROP_VER	0x08
-
-static struct curcial_oj_platform_data legend_oj_data = {
-	.oj_poweron = curcial_oj_poweron,
-	.oj_shutdown = curcial_oj_shutdown,
-	.oj_adjust_xy = curcial_oj_adjust_xy,
-	.microp_version = LED_MICROP_VER,
-	.mdelay_time = 0,
-	.msleep_time = 1,
-	.x_send_count = 2,
-	.y_send_count = 2,
-	.fast_th = 1,
-	.normal_th = 8,
-	.continue_th = 3,
-	.continue_max = 0,
-	.xy_ratio = 15,
-	.interval = 80,
-	.softclick = true,
-	.swap = true,
-	.x = 1,
-	.y = 1,
-	.share_power = true,
-	.Xsteps = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-		3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
-	.Ysteps = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-		3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
-};
-
-static struct platform_device legend_oj = {
-	.name = CURCIAL_OJ_NAME,
-	.id = -1,
-	.dev = {
-		.platform_data	= &legend_oj_data,
-	}
-};
-
-static struct msm_i2c_device_platform_data legend_i2c_device_data = {
-	.i2c_clock = 400000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_i2c,
-	&legend_h2w,
-	&htc_battery_pdev,
-	&legend_audio_jack,
-	&msm_camera_sensor_s5k4e1gx,
-	&legend_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&legend_pwr_sink,
-#endif
-	&legend_oj,
-	&capella_cm3602,
-};
-
-extern struct sys_timer msm_timer;
-
-static void __init legend_init_irq(void)
-{
-	printk("legend_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint cpld_iset;
-static uint cpld_charger_en;
-static uint cpld_usb_h2w_sw;
-static uint opt_disable_uart3;
-static char *keycaps = "";
-
-module_param_named(iset, cpld_iset, uint, 0);
-module_param_named(charger_en, cpld_charger_en, uint, 0);
-module_param_named(usb_h2w_sw, cpld_usb_h2w_sw, uint, 0);
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-module_param_named(keycaps, keycaps, charp, 0);
-
-static char bt_chip_id[10] = "brfxxxx";
-module_param_string(bt_chip_id, bt_chip_id, sizeof(bt_chip_id), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_chip_id, "BT's chip id");
-
-static char bt_fw_version[10] = "v2.0.38";
-module_param_string(bt_fw_version, bt_fw_version, sizeof(bt_fw_version), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_fw_version, "BT's fw version");
-
-static void legend_reset(void)
-{
-	gpio_set_value(LEGEND_GPIO_PS_HOLD, 0);
-}
-
-static uint32_t proximity_on_gpio_table[] = {
-	PCOM_GPIO_CFG(21, 0, GPIO_INPUT, GPIO_NO_PULL, 0), /* PS_VOUT */
-};
-
-static uint32_t proximity_off_gpio_table[] = {
-	PCOM_GPIO_CFG(21, 0, GPIO_INPUT, GPIO_PULL_DOWN, 0) /* PS_VOUT */
-};
-
-static struct i2c_board_info i2c_camera_devices[] = {
-	{
-		I2C_BOARD_INFO("s5k4e1gx", 0x20 >> 1),/*5M samsung bayer sensor driver*/
-	},
-};
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* MCLK */
-
-	PCOM_GPIO_CFG(27, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA), /* CAM_I2C_SDA */
-	PCOM_GPIO_CFG(49, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA), /* CAM_I2C_SCL */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-void config_legend_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void config_legend_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-void config_legend_proximity_gpios(int on)
-{
-	if (on)
-		config_gpio_table(proximity_on_gpio_table,
-			ARRAY_SIZE(proximity_on_gpio_table));
-	else
-		config_gpio_table(proximity_off_gpio_table,
-			ARRAY_SIZE(proximity_off_gpio_table));
-}
-
-static uint32_t legend_serial_debug_table[] = {
-	/* config as serial debug uart */
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART3_RX, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA)	/* UART3 RX */,
-	PCOM_GPIO_CFG(LEGEND_GPIO_UART3_TX, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* UART3 TX */
-};
-
-static void legend_config_serial_debug_gpios(void)
-{
-	config_gpio_table(legend_serial_debug_table, ARRAY_SIZE(legend_serial_debug_table));
-}
-
-static void __init config_gpios(void)
-{
-	legend_config_serial_debug_gpios();
-	config_legend_camera_off_gpios();
-}
-
-static struct msm_acpu_clock_platform_data legend_clock_data = {
-	.acpu_switch_time_us = 50,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200,
-	.wait_for_irq_khz = 200000,
-};
-
-static unsigned legend_perf_acpu_table[] = {
-	245760000,
-	480000000,
-	600000000,
-};
-
-static struct perflock_platform_data legend_perflock_data = {
-	.perf_acpu_table = legend_perf_acpu_table,
-	.table_size = ARRAY_SIZE(legend_perf_acpu_table),
-};
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(LEGEND_GPIO_UART1_RX),
-	.inject_rx_on_wakeup = 1,
-	.rx_to_inject = 0x32,
-	.cpu_lock_supported = 1,
-};
-#endif
-
-static void config_legend_flashlight_gpios(void)
-{
-	uint32_t flashlight_gpio_table[] = {
-		PCOM_GPIO_CFG(LEGEND_GPIO_TORCH_EN, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-		PCOM_GPIO_CFG(LEGEND_GPIO_FLASH_EN, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-	};
-	config_gpio_table(flashlight_gpio_table,
-		ARRAY_SIZE(flashlight_gpio_table));
-}
-
-static struct flashlight_platform_data legend_flashlight_data = {
-	.gpio_init = config_legend_flashlight_gpios,
-	.torch = LEGEND_GPIO_TORCH_EN,
-	.flash = LEGEND_GPIO_FLASH_EN,
-	.flash_duration_ms = 600,
-};
-
-static struct platform_device legend_flashlight_device = {
-	.name = FLASHLIGHT_NAME,
-	.dev = {
-		.platform_data  = &legend_flashlight_data,
-	},
-};
-
-static void __init legend_init(void)
-{
-	int rc;
-	char *cid = NULL;
-	printk("legend_init() revision = 0x%X\n", system_rev);
-	board_get_cid_tag(&cid);
-
-	/*
-	 * Setup common MSM GPIOS
-	 */
-	config_gpios();
-
-	/* We need to set this pin to 0 only once on power-up; we will
-	 * not actually enable the chip until we apply power to it via
-	 * vreg.
-	 */
-	gpio_direction_output(LEGEND_GPIO_LS_EN, 0);
-	/* disable power for cm3602 chip */
-	__capella_cm3602_power(0);
-
-	msm_hw_reset_hook = legend_reset;
-
-	msm_acpu_clock_init(&legend_clock_data);
-	perflock_init(&legend_perflock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-			&msm_device_uart3.dev, 1,
-				MSM_GPIO_TO_INT(LEGEND_GPIO_UART3_RX));
-#endif
-
-	msm_add_devices();
-
-	#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_add_serial_devices(3);
-	#else
-	msm_add_serial_devices(0);
-	#endif
-
-	msm_add_serial_devices(2);
-
-	msm_register_usb_phy_init_seq(legend_phy_init_seq);
-	msm_hsusb_set_product(legend_usb_products,
-		ARRAY_SIZE(legend_usb_products));
-	msm_add_usb_id_pin_gpio(LEGEND_GPIO_USB_ID_PIN);
-	msm_add_usb_devices(legend_phy_reset, legend_phy_shutdown);
-
-	msm_add_mem_devices(&pmem_setting);
-
-	msm_init_pmic_vibrator();
-#ifdef CONFIG_MICROP_COMMON
-	legend_microp_init();
-#endif
-
-	rc = legend_init_mmc(system_rev);
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-
-	/* register flashlight at new-XA above */
-	platform_device_register(&legend_flashlight_device);
-
-	/* probe camera driver */
-	i2c_register_board_info(0, i2c_camera_devices, ARRAY_SIZE(i2c_camera_devices));
-
-	msm_device_i2c.dev.platform_data = &legend_i2c_device_data;
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	legend_init_keypad();
-}
-
-static void __init legend_fixup(struct machine_desc *desc, struct tag *tags,
-					char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 1;
-	mi->bank[0].start = MSM_LINUX_BASE;
-	mi->bank[0].node = PHYS_TO_NID(MSM_LINUX_BASE);
-	mi->bank[0].size = MSM_LINUX_SIZE;
-}
-
-static void __init legend_map_io(void)
-{
-	printk("legend_init_map_io()\n");
-	msm_map_common_io();
-	msm_clock_init();
-#ifdef CONFIG_CACHE_L2X0
-	/* 7x27 has 256KB L2 cache:
-	* 64Kb/Way and 4-Way Associativity;
-	* R/W latency: 3 cycles;
-	* evmon/parity/share disabled.
-	*/
-	l2x0_init(MSM_L2CC_BASE, 0x00068012, 0xfe000000);
-#endif
-}
-
-MACHINE_START(LEGEND, "legend")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params    = 0x12C00100,
-	.fixup          = legend_fixup,
-	.map_io         = legend_map_io,
-	.init_irq       = legend_init_irq,
-	.init_machine   = legend_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-legend.h b/arch/arm/mach-msm/board-legend.h
deleted file mode 100644
index f58eb99..0000000
--- a/arch/arm/mach-msm/board-legend.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/* linux/arch/arm/mach-msm/board-legend.h
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_LEGEND_H
-#define __ARCH_ARM_MACH_MSM_BOARD_LEGEND_H
-
-#include <mach/board.h>
-
-#define MSM_MEM_BASE		0x10000000
-#define MSM_MEM_SIZE		0x18000000
-
-#define MSM_LINUX_BASE_OFFSET	0x02C00000
-
-#define MSM_MM_HEAP_SIZE        0x02800000
-
-#define MSM_LINUX_BASE          (MSM_MEM_BASE + MSM_LINUX_BASE_OFFSET) /* 2MB alignment */
-#define MSM_LINUX_SIZE          (MSM_MEM_SIZE - MSM_LINUX_BASE_OFFSET - MSM_MM_HEAP_SIZE)
-
-#define MSM_FB_BASE             (MSM_MEM_BASE + 0x02A00000)
-#define MSM_FB_SIZE             0x00200000
-
-#define MSM_GPU_MEM_BASE        (MSM_MEM_BASE + MSM_MEM_SIZE - MSM_MM_HEAP_SIZE)
-#define MSM_GPU_MEM_SIZE        0x00300000
-
-#define MSM_PMEM_MDP_BASE       MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE
-#define MSM_PMEM_MDP_SIZE       0x01000000
-
-#define MSM_PMEM_ADSP_BASE      MSM_PMEM_MDP_BASE + MSM_PMEM_MDP_SIZE
-#define MSM_PMEM_ADSP_SIZE      0x00C1B000
-
-#define MSM_PMEM_CAMERA_BASE    MSM_PMEM_ADSP_BASE + MSM_PMEM_ADSP_SIZE
-#define MSM_PMEM_CAMERA_SIZE    0x00800000
-
-/* TODO: To save space, we can move RAM_CONSOLE to 0x00000000 */
-#define MSM_RAM_CONSOLE_BASE    MSM_PMEM_CAMERA_BASE + MSM_PMEM_CAMERA_SIZE
-#define MSM_RAM_CONSOLE_SIZE    128 * SZ_1K
-
-#define LEGEND_GPIO_TO_INT(x)           (x+64) /* from gpio_to_irq */
-
-#define LEGEND_GPIO_USB_ID_PIN          (19) /*for legend USB ID pin*/
-
-#define LEGEND_POWER_KEY                (20)
-#define LEGEND_GPIO_WIFI_EN             (108)
-#define LEGEND_GPIO_SDMC_CD_N           (38)
-#define LEGEND_GPIO_UART3_RX            (86)
-#define LEGEND_GPIO_UART3_TX            (87)
-#define LEGEND_GPIO_PS_HOLD             (25)
-#define LEGEND_GPIO_UP_RESET_N          (76)
-#define LEGEND_GPIO_CAP_LED_EN          (121)
-#define LEGEND_GPIO_USBPHY_3V3_EN       (109)
-#define LEGEND_GPIO_FUNC_LED_EN         (0)
-#define LEGEND_GPIO_LS_EN               (93)
-#define LEGEND_GPIO_UP_INT_N            (39)
-#define LEGEND_GPIO_COMPASS_INT_N       (36)
-#define LEGEND_GPIO_COMPASS_RST_N       (92)
-#define LEGEND_PROJECT_NAME		"legend"
-#define LEGEND_LAYOUTS			{ \
-		{ {-1,  0, 0}, {  0,  1, 0}, {0, 0, -1} },  \
-		{ { 0, -1, 0}, { -1,  0, 0}, {0, 0,  1} },  \
-		{ { 0,  1, 0}, {  1,  0, 0}, {0, 0, -1} },  \
-		{ { 1,  0, 0}, {  0,  0, 1}, {0, 1,  0} }   \
-					}
-
-/* Proximity  */
-#define LEGEND_GPIO_PROXIMITY_INT       (21)
-#define LEGEND_GPIO_PROXIMITY_EN        (58)
-
-/* Navi key output/input matrix */
-#define LEGEND_GPIO_KP_MKOUT2           (33)
-#define LEGEND_GPIO_KP_MKOUT1           (34)
-#define LEGEND_GPIO_KP_MKOUT0           (35)
-#define LEGEND_GPIO_KP_MKIN2            (40)
-#define LEGEND_GPIO_KP_MKIN1            (41)
-#define LEGEND_GPIO_KP_MKIN0            (42)
-
-/* BT */
-#define LEGEND_GPIO_UART1_RTS           (43)
-#define LEGEND_GPIO_UART1_CTS           (44)
-#define LEGEND_GPIO_UART1_RX            (45)
-#define LEGEND_GPIO_UART1_TX            (46)
-#define LEGEND_GPIO_BT_EN               (90)
-
-/* Touch Panel */
-#define LEGEND_TP_5V_EN                 (31)
-#define LEGEND_GPIO_TP_RST              (57)
-#define LEGEND_TP_LS_EN                 (91)
-#define LEGEND_GPIO_TP_ATT_N            (94)
-
-/* 35mm headset */
-#define LEGEND_GPIO_35MM_HEADSET_DET    (83)
-
-/*Camera AF VCM POWER*/
-#define LEGEND_GPIO_VCM_PWDN            (82)
-#define LEGEND_GPIO_CAM1_RST_N          (97)
-
-/*Display*/
-
-#define LEGEND_LCD_G1                   (111)
-#define LEGEND_LCD_G0                   (112)
-
-#define LEGEND_LCD_B4                   (116)
-#define LEGEND_LCD_B3                   (117)
-#define LEGEND_LCD_B2                   (118)
-#define LEGEND_LCD_G4                   (119)
-#define LEGEND_LCD_G3                   (120)
-#define LEGEND_LCD_G2                   (121)
-
-#define LEGEND_LCD_B1                   (125)
-#define LEGEND_LCD_B0                   (126)
-#define LEGEND_LCD_VSYNC                (127)
-#define LEGEND_LCD_HSYNC                (128)
-#define LEGEND_LCD_DE                   (129)
-#define LEGEND_LCD_G5                   (130)
-#define LEGEND_LCD_RSTz_ID1             (131)
-#define LEGEND_LCD_ID0                  (132)
-
-/* for new XA board */
-#define LEGEND_GPIO_BAT_DET_N           (17)
-#define LEGEND_GPIO_MOT_INT_CPU         (18)
-#define LEGEND_GPIO_CAM_I2C_SDA         (27)
-#define LEGEND_GPIO_UP_INT2_N           (37)
-#define LEGEND_GPIO_CAM_I2C_SCL         (49)
-#define LEGEND_GPIO_EL_ADJ              (84)
-#define LEGEND_GPIO_FLASH_EN            (122)
-#define LEGEND_GPIO_TORCH_EN            (123)
-#define LEGEND_GPIO_EL_EN               (124)
-#define LEGEND_GPIO_LCD_RST_N           (131)
-
-int __init legend_init_keypad(void);
-int legend_init_mmc(unsigned int sys_rev);
-#endif /* GUARD */
-
diff --git a/arch/arm/mach-msm/board-liberty-keypad.c b/arch/arm/mach-msm/board-liberty-keypad.c
deleted file mode 100644
index 15c9a9f..0000000
--- a/arch/arm/mach-msm/board-liberty-keypad.c
+++ /dev/null
@@ -1,177 +0,0 @@
-/* arch/arm/mach-msm/board-liberty-keypad.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <linux/gpio.h>
-#include <linux/keyreset.h>
-#include <asm/mach-types.h>
-
-#include <mach/board_htc.h>
-
-#include "board-liberty.h"
-#include "proc_comm.h"
-
-static char *keycaps = "--qwerty";
-#undef MODULE_PARAM_PREFIX
-#define MODULE_PARAM_PREFIX "board_liberty."
-
-module_param_named(keycaps, keycaps, charp, 0);
-
-static unsigned int liberty_col_gpios[] = {
-	LIBERTY_GPIO_KP_MKOUT0, //35
-	LIBERTY_GPIO_KP_MKOUT1, //34
-	LIBERTY_GPIO_KP_MKOUT2, //33
-};
-static unsigned int liberty_row_gpios[] = {
-	LIBERTY_GPIO_KP_MKIN0, //42
-	LIBERTY_GPIO_KP_MKIN1, //41
-	LIBERTY_GPIO_KP_MKIN2, //40
-};
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(liberty_row_gpios) + (row))
-
-static const unsigned short liberty_keymap[ARRAY_SIZE(liberty_col_gpios) *
-					ARRAY_SIZE(liberty_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(0, 2)] = KEY_RESERVED,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_BACK,
-	[KEYMAP_INDEX(1, 1)] = KEY_SEND,
-	[KEYMAP_INDEX(1, 2)] = KEY_END,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(2, 1)] = KEY_HOME,
-	[KEYMAP_INDEX(2, 2)] = BTN_MOUSE, /* OJ_ACTION */
-};
-
-static void liberty_matrix_inputs_gpio(void)
-{
-	static uint32_t matirx_inputs_gpio_table[] = {
-		PCOM_GPIO_CFG(LIBERTY_GPIO_KP_MKIN0, 0, GPIO_INPUT,
-						GPIO_PULL_UP, GPIO_4MA),
-		PCOM_GPIO_CFG(LIBERTY_GPIO_KP_MKIN1, 0, GPIO_INPUT,
-						GPIO_PULL_UP, GPIO_4MA),
-		PCOM_GPIO_CFG(LIBERTY_GPIO_KP_MKIN2, 0, GPIO_INPUT,
-						GPIO_PULL_UP, GPIO_4MA),
-	};
-
-	config_gpio_table(matirx_inputs_gpio_table,
-		ARRAY_SIZE(matirx_inputs_gpio_table));
-}
-
-static struct gpio_event_matrix_info liberty_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = liberty_keymap,
-	.output_gpios = liberty_col_gpios,
-	.input_gpios = liberty_row_gpios,
-	.noutputs = ARRAY_SIZE(liberty_col_gpios),
-	.ninputs = ARRAY_SIZE(liberty_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		  GPIOKPF_REMOVE_PHANTOM_KEYS |
-		  GPIOKPF_PRINT_UNMAPPED_KEYS /*|
-		   GPIOKPF_PRINT_MAPPED_KEYS */),
-	.setup_ninputs_gpio = liberty_matrix_inputs_gpio,
-};
-
-static struct gpio_event_direct_entry liberty_keypad_nav_map[] = {
-	{
-		.gpio = LIBERTY_POWER_KEY,
-		.code = KEY_POWER
-	},
-};
-
-static void liberty_direct_inputs_gpio(void)
-{
-	static uint32_t matirx_inputs_gpio_table[] = {
-		PCOM_GPIO_CFG(LIBERTY_POWER_KEY, 0, GPIO_INPUT, GPIO_PULL_UP,
-								GPIO_4MA),
-		PCOM_GPIO_CFG(LIBERTY_GPIO_RESET_BTN_N, 0, GPIO_INPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-	};
-
-	config_gpio_table(matirx_inputs_gpio_table,
-		ARRAY_SIZE(matirx_inputs_gpio_table));
-}
-
-
-static struct gpio_event_input_info liberty_keypad_power_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = GPIOEDF_PRINT_KEYS,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = liberty_keypad_nav_map,
-	.keymap_size = ARRAY_SIZE(liberty_keypad_nav_map),
-	.setup_input_gpio = liberty_direct_inputs_gpio,
-};
-
-static struct gpio_event_info *liberty_keypad_info[] = {
-	&liberty_keypad_matrix_info.info,
-	&liberty_keypad_power_info.info,
-};
-
-static struct gpio_event_platform_data liberty_keypad_data = {
-	.name = "liberty-keypad",
-	.info = liberty_keypad_info,
-	.info_count = ARRAY_SIZE(liberty_keypad_info)
-};
-
-static struct platform_device liberty_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &liberty_keypad_data,
-	},
-};
-
-static int liberty_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0
-};
-
-static struct keyreset_platform_data liberty_reset_keys_pdata = {
-	.keys_up = liberty_reset_keys_up,
-	.keys_down = {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-static struct platform_device liberty_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &liberty_reset_keys_pdata,
-};
-
-int __init liberty_init_keypad(void)
-{
-	char *get_cid, *get_carrier, *get_keycaps;
-
-	board_get_cid_tag(&get_cid);
-	board_get_carrier_tag(&get_carrier);
-	board_get_keycaps_tag(&get_keycaps);
-
-	if (platform_device_register(&liberty_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	return platform_device_register(&liberty_keypad_device);
-}
-
diff --git a/arch/arm/mach-msm/board-liberty-microp.c b/arch/arm/mach-msm/board-liberty-microp.c
deleted file mode 100644
index 97febf8..0000000
--- a/arch/arm/mach-msm/board-liberty-microp.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/* arch/arm/mach-msm/board-liberty-microp.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <mach/atmega_microp.h>
-#include <mach/drv_callback.h>
-
-#include "board-liberty.h"
-
-static struct i2c_client *liberty_microp_client;
-/*
-static struct led_trigger liberty_als_level_trigger = {
-	.name     = "auto-backlight-trigger",
-};
-*/
-
-/*
-static int liberty_als_intr_enable(struct i2c_client *client,
-		uint32_t als_func, uint8_t enable)
-{
-	struct microp_i2c_client_data *cdata;
-
-	cdata = i2c_get_clientdata(client);
-
-	return microp_write_interrupt(client,
-		cdata->int_pin.int_lsensor, enable);
-}
-*/
-
-/*
-static void liberty_als_level_change(struct i2c_client *client,
-		uint8_t *data)
-{
-	led_trigger_event(&liberty_als_level_trigger, data[2]);
-}
-*/
-
-/*
-static int liberty_als_power(int pwr_device, uint8_t enable)
-{
-	struct i2c_client *client = liberty_microp_client;
-	struct microp_i2c_platform_data *pdata;
-	int value;
-
-	pdata = client->dev.platform_data;
-	value = enable ? 1 : 0;
-	if (pdata->ls_power)
-		pdata->ls_power(value);
-
-	return 0;
-}
-*/
-
-/*
-static int liberty_als_table_init(struct i2c_client *client,
-			int i, uint32_t kadc, uint32_t gadc)
-{
-	struct microp_i2c_platform_data *pdata;
-	uint8_t data[20];
-	int j;
-
-	pdata = client->dev.platform_data;
-
-	for (j = 0; j < 10; j++) {
-		data[j] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc >> 8);
-		data[j + 10] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc);
-	}
-
-	return microp_i2c_write(MICROP_I2C_WCMD_ADC_TABLE, data, 20);
-}
-*/
-
-static int liberty_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	liberty_microp_client = client;
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Light sensor */
-/*
-	ret = microp_function_check(client, MICROP_FUNCTION_LSENSOR);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_LSENSOR] = i;
-		cdata->int_pin.int_lsensor = pdata->microp_function[i].int_pin;
-		microp_get_als_kvalue(i);
-
-		ret = liberty_als_table_init(client, i, cdata->als_kadc,
-				cdata->als_gadc);
-		if (ret < 0)
-			goto exit;
-
-		if (pdata->ls_power)
-			pdata->ls_power(1);
-	}
-*/
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	ret = microp_write_interrupt(client, (1<<8), 1);
-	if (ret)
-		goto exit;
-
-	/* OJ interrupt */
-	ret = microp_function_check(client, MICROP_FUNCTION_OJ);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_oj = pdata->microp_function[i].int_pin;
-
-		ret = microp_write_interrupt(client, cdata->int_pin.int_oj, 1);
-		if (ret)
-			goto exit;
-	}
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = liberty_microp_function_init,
-/*
-	.als_pwr_enable = liberty_als_power,
-	.als_intr_enable = liberty_als_intr_enable,
-	.als_level_change = liberty_als_level_change,
-*/
-};
-
-void __init liberty_microp_init(void)
-{
-	/*led_trigger_register(&liberty_als_level_trigger);*/
-	microp_register_ops(&ops);
-}
-
-#endif
diff --git a/arch/arm/mach-msm/board-liberty-mmc.c b/arch/arm/mach-msm/board-liberty-mmc.c
deleted file mode 100644
index 695f7f7..0000000
--- a/arch/arm/mach-msm/board-liberty-mmc.c
+++ /dev/null
@@ -1,315 +0,0 @@
-/* linux/arch/arm/mach-msm/board-liberty-mmc.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-#include <mach/htc_pwrsink.h>
-
-#include "devices.h"
-#include "board-liberty.h"
-#include "proc_comm.h"
-
-#include <linux/dma-mapping.h>
-#include <mach/dma.h>
-#include "../../../drivers/mmc/host/msm_sdcc.h"
-
-/* #include <linux/irq.h> */
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_6MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init liberty_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_liberty.disable_sdcard=", liberty_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t liberty_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-		writel(MCI_PWR_OFF, MSM_SDC2_BASE + MMCIPOWER);
-		mdelay(1);
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		vreg_enable(vreg_sdslot);
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-			printk(KERN_INFO "%s: Setting level to %u\n",
-					__func__, mmc_vdd_table[i].level);
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-			if (!sdslot_vreg_enabled)
-				break;
-			else
-				return 0;
-		}
-	}
-
-	/* All vdd match failed */
-	if (i == ARRAY_SIZE(mmc_vdd_table))
-		goto out;
-
-	if (!sdslot_vreg_enabled) {
-		u32 pwr = 0;
-
-		/* Power on MCI controller */
-		mdelay(5);
-		pwr = readl(MSM_SDC2_BASE + MMCIPOWER);
-		writel(pwr | MCI_PWR_UP, MSM_SDC2_BASE + MMCIPOWER);
-		mdelay(5);
-		pwr = readl(MSM_SDC2_BASE + MMCIPOWER);
-		writel(pwr | MCI_PWR_ON, MSM_SDC2_BASE + MMCIPOWER);
-		mdelay(5);
-
-		/* ..then, config GPIO */
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-		return 0;
-	}
-
-out:
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int liberty_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(LIBERTY_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define LIBERTY_MMC_VDD	MMC_VDD_28_29 | MMC_VDD_29_30
-
-static unsigned int liberty_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data liberty_sdslot_data = {
-	.ocr_mask	= LIBERTY_MMC_VDD,
-	.status_irq	= MSM_GPIO_TO_INT(LIBERTY_GPIO_SDMC_CD_N),
-	.status		= liberty_sdslot_status,
-	.translate_vdd	= liberty_sdslot_switchvdd,
-	.slot_type	= &liberty_sdslot_type,
-};
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_16MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data liberty_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-
-static int liberty_wifi_cd;		/* WIFI virtual 'card detect' status */
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-liberty_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int liberty_wifi_status(struct device *dev)
-{
-	return liberty_wifi_cd;
-}
-
-static struct mmc_platform_data liberty_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= liberty_wifi_status,
-	.register_status_notify	= liberty_wifi_status_register,
-	.embedded_sdio		= &liberty_wifi_emb_data,
-};
-
-int liberty_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	liberty_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(liberty_wifi_set_carddetect);
-
-int liberty_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-
-	mdelay(100);
-	gpio_set_value(LIBERTY_GPIO_WIFI_EN, on);
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(liberty_wifi_power);
-
-int liberty_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-int __init liberty_init_mmc(unsigned int sys_rev)
-{
-
-	uint32_t id;
-	sdslot_vreg_enabled = 0;
-
-
-	/* initial WIFI_SHUTDOWN */
-	id = PCOM_GPIO_CFG(LIBERTY_GPIO_WIFI_EN, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	wifi_status_cb = NULL;
-
-	printk(KERN_INFO "%s\n", __func__);
-
-	msm_add_sdcc(1, &liberty_wifi_data, 0, 0);
-
-
-	if (opt_disable_sdcard) {
-		printk(KERN_INFO "liberty: SD-Card interface disabled\n");
-		goto done;
-	}
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-
-	set_irq_wake(MSM_GPIO_TO_INT(LIBERTY_GPIO_SDMC_CD_N), 1);
-
-	msm_add_sdcc(2, &liberty_sdslot_data, MSM_GPIO_TO_INT(LIBERTY_GPIO_SDMC_CD_N),
-			IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-done:
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-liberty-panel.c b/arch/arm/mach-msm/board-liberty-panel.c
deleted file mode 100644
index dac9965..0000000
--- a/arch/arm/mach-msm/board-liberty-panel.c
+++ /dev/null
@@ -1,266 +0,0 @@
-/* linux/arch/arm/mach-msm/board-liberty-panel.c
- *
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/leds.h>
-
-#include <asm/io.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-#include <mach/vreg.h>
-#include <mach/pmic.h>
-
-#include "devices.h"
-#include "board-liberty.h"
-#include "proc_comm.h"
-
-#if 0
-#define B(s...) printk(s)
-#else
-#define B(s...) do {} while (0)
-#endif
-
-static struct led_trigger *liberty_lcd_backlight;
-static void liberty_set_backlight(int on)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	if (on) {
-		/* vsync back porch is about 17 ms */
-		msleep(40);
-		led_trigger_event(liberty_lcd_backlight, LED_FULL);
-	} else
-		led_trigger_event(liberty_lcd_backlight, LED_OFF);
-}
-
-static struct vreg *vreg_lcm_2v6;
-static struct vreg *vreg_lcm_2v85;
-
-static void
-liberty_mddi_eid_power(struct msm_mddi_client_data *client_data, int on)
-{
-	unsigned id, on_off = 1;
-
-	B(KERN_DEBUG "%s: power %s.\n", __func__, on ? "on" : "off");
-	if (on) {
-		on_off = 0;
-		/* 2V6(pmic gp4) */
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v6);
-		mdelay(10);
-
-		/* 2V8(pmic rfrx2) */
-		id = PM_VREG_PDOWN_RFRX2_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v85);
-		mdelay(10);
-
-		gpio_set_value(LIBERTY_LCD_RSTz, 1);
-		msleep(30);
-	} else {
-		on_off = 1;
-		mdelay(10);
-		gpio_set_value(LIBERTY_LCD_RSTz, 0);
-		mdelay(10);
-
-		/* 2V8(pmic rfrx2) */
-		id = PM_VREG_PDOWN_RFRX2_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_disable(vreg_lcm_2v85);
-		mdelay(10);
-
-		/* 2V6(pmic gp4) */
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_disable(vreg_lcm_2v6);
-	}
-}
-
-static int
-liberty_panel_unblank(struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	liberty_set_backlight(1);
-	return 0;
-}
-
-static int
-liberty_panel_blank(struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s: enter.\n", __func__);
-	liberty_set_backlight(0);
-	return 0;
-}
-
-static int
-liberty_panel_shrink(int brightness)
-{
-		if (brightness <= 102) {
-			if (brightness <= 30)
-				brightness = 6;
-			else
-				brightness = 114 * (brightness - 30) / 72 + 6;
-		} else
-			brightness = 135 * (brightness - 102) / 153 + 120;
-
-	return brightness;
-}
-
-static int liberty_panel_shutdown(
-                struct msm_mddi_bridge_platform_data *bridge_data,
-                struct msm_mddi_client_data *client_data)
-{
-        B("%s\n", __func__);
-        liberty_mddi_eid_power(client_data, 0);
-        return 0;
-}
-
-static void panel_eid_fixup(uint16_t *mfr_name, uint16_t *product_code)
-{
-	B("%s: enter.\n", __func__);
-	*mfr_name = 0x0101;
-	*product_code = 0x0;
-}
-
-static u8 pwm_eid[10] = {8, 16, 34, 61, 96, 138, 167, 195, 227, 255};
-
-static struct msm_mddi_bridge_platform_data eid_client_data = {
-	.blank = liberty_panel_blank,
-	.unblank = liberty_panel_unblank,
-	.shutdown = liberty_panel_shutdown,
-	.fb_data = {
-		.xres = 320,
-		.yres = 480,
-		.output_format = 0,
-	},
-};
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct msm_mddi_platform_data liberty_pdata = {
-	.clk_rate = 106000000,
-	.power_client = liberty_mddi_eid_power,
-	.fixup = panel_eid_fixup,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 1,
-	.client_platform_data = {
-		{
-			.product_id = (0x0101 << 16 | 0),
-			.name = "mddi_c_0101_0000",
-			.id = 1,
-			.client_data = &eid_client_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-/*
- * In boot loader, mddi is powered on already.
- *
- * So, we just detect panel here, setting different
- * power function for each panel.
- *
- * Then we did not have to detect panel in each time
- * mddi_client_power or panel_power is called.
- *
- * jay: Nov 20, 08'
- */
-int __init liberty_init_panel(void)
-{
-	int rc;
-	int panel_type = 0;
-	int panel_id = -1;
-	int gpio_lcd_id0, gpio_lcd_id1;
-	uint32_t config;
-	struct panel_data *panel_data = &eid_client_data.panel_conf;
-
-	if (!machine_is_liberty())
-		return -1;
-
-	B(KERN_INFO "%s: enter.\n", __func__);
-
-	vreg_lcm_2v6 = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_lcm_2v6))
-		return PTR_ERR(vreg_lcm_2v6);
-
-	vreg_lcm_2v85 = vreg_get(0, "rfrx2");
-	if (IS_ERR(vreg_lcm_2v85))
-		return PTR_ERR(vreg_lcm_2v85);
-
-	gpio_lcd_id0 =  PCOM_GPIO_CFG(LIBERTY_GPIO_LCD_ID0, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA);
-	gpio_lcd_id1 =  PCOM_GPIO_CFG(LIBERTY_GPIO_LCD_ID1, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA);
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &gpio_lcd_id0, 0);
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &gpio_lcd_id1, 0);
-
-	panel_id = gpio_get_value(LIBERTY_GPIO_LCD_ID0) |
-	           (gpio_get_value(LIBERTY_GPIO_LCD_ID1) << 1);
-
-	B(KERN_INFO "%s: panel_id:%d.\n", __func__,panel_id);
-
-	switch(panel_id) {
-		case 0:
-			panel_type = 10;
-		break;
-		case 2:
-			panel_type = 9;
-		break;
-		default:
-			return -1;
-		break;
-	}
-
-	panel_data->panel_id = panel_type;
-	panel_data->caps = MSMFB_CAP_CABC;
-	panel_data->pwm = pwm_eid;
-	panel_data->shrink = 1;
-	panel_data->shrink_br = liberty_panel_shrink;
-	panel_data->default_br = 90;
-
-	config = PCOM_GPIO_CFG(LIBERTY_GPIO_LCD_VSYNC, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA);
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &config, 0);
-
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-
-	msm_device_mddi0.dev.platform_data = &liberty_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-
-	led_trigger_register_simple("lcd-backlight-gate", &liberty_lcd_backlight);
-	if (IS_ERR(liberty_lcd_backlight))
-		printk(KERN_ERR "%s: backlight registration failed!\n",
-			__func__);
-	return 0;
-}
-device_initcall(liberty_init_panel);
-
diff --git a/arch/arm/mach-msm/board-liberty-rfkill.c b/arch/arm/mach-msm/board-liberty-rfkill.c
deleted file mode 100644
index c576e1d..0000000
--- a/arch/arm/mach-msm/board-liberty-rfkill.c
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for liberty platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-liberty.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-/* bt initial configuration */
-static uint32_t liberty_bt_init_table[] = {
-
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_TX, /* BT_TX */
-				3,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt on configuration */
-static uint32_t liberty_bt_on_table[] = {
-
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_RX, /* BT_RX */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_TX, /* BT_TX */
-				3,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt off configuration */
-static uint32_t liberty_bt_off_table[] = {
-
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_RTS, /* BT_RTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_UART1_TX, /* BT_TX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(LIBERTY_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void liberty_config_bt_init(void)
-{
-	/* set bt initial configuration*/
-	config_bt_table(liberty_bt_init_table,
-				ARRAY_SIZE(liberty_bt_init_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(LIBERTY_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(LIBERTY_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(LIBERTY_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-
-}
-
-static void liberty_config_bt_on(void)
-{
-	/* set bt on configuration*/
-	config_bt_table(liberty_bt_on_table,
-				ARRAY_SIZE(liberty_bt_on_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(LIBERTY_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(LIBERTY_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-}
-
-static void liberty_config_bt_off(void)
-{
-	/* BT_SHUTDOWN_N */
-	gpio_configure(LIBERTY_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_RESET_N */
-	gpio_configure(LIBERTY_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(liberty_bt_off_table,
-				ARRAY_SIZE(liberty_bt_off_table));
-	mdelay(5);
-
-	/* BT_RTS */
-	gpio_configure(LIBERTY_GPIO_BT_UART1_RTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CTS */
-
-	/* BT_TX */
-	gpio_configure(LIBERTY_GPIO_BT_UART1_TX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_RX */
-
-	/* BT_HOST_WAKE */
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(LIBERTY_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		liberty_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		liberty_config_bt_off();
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int liberty_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	liberty_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int liberty_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver liberty_rfkill_driver = {
-	.probe = liberty_rfkill_probe,
-	.remove = liberty_rfkill_remove,
-	.driver = {
-		.name = "liberty_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init liberty_rfkill_init(void)
-{
-	if (!machine_is_liberty())
-		return 0;
-
-	return platform_driver_register(&liberty_rfkill_driver);
-}
-
-static void __exit liberty_rfkill_exit(void)
-{
-	platform_driver_unregister(&liberty_rfkill_driver);
-}
-
-module_init(liberty_rfkill_init);
-module_exit(liberty_rfkill_exit);
-MODULE_DESCRIPTION("liberty rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-liberty-wifi.c b/arch/arm/mach-msm/board-liberty-wifi.c
deleted file mode 100644
index c9ef14f..0000000
--- a/arch/arm/mach-msm/board-liberty-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-liberty-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-liberty.h"
-
-int liberty_wifi_power(int on);
-int liberty_wifi_reset(int on);
-int liberty_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *liberty_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init liberty_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource liberty_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(LIBERTY_GPIO_WIFI_IRQ1),
-		.end		= MSM_GPIO_TO_INT(LIBERTY_GPIO_WIFI_IRQ1),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data liberty_wifi_control = {
-	.set_power      = liberty_wifi_power,
-	.set_reset      = liberty_wifi_reset,
-	.set_carddetect = liberty_wifi_set_carddetect,
-	.mem_prealloc   = liberty_wifi_mem_prealloc,
-};
-
-static struct platform_device liberty_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(liberty_wifi_resources),
-        .resource       = liberty_wifi_resources,
-        .dev            = {
-                .platform_data = &liberty_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned liberty_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init liberty_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_liberty())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	liberty_wifi_update_nvs("sd_oobonly=1\n");
-	liberty_init_wifi_mem();
-	ret = platform_device_register(&liberty_wifi_device);
-        return ret;
-}
-
-device_initcall(liberty_wifi_init);
diff --git a/arch/arm/mach-msm/board-liberty.c b/arch/arm/mach-msm/board-liberty.c
deleted file mode 100644
index 256c722..0000000
--- a/arch/arm/mach-msm/board-liberty.c
+++ /dev/null
@@ -1,1131 +0,0 @@
-/* arch/arm/mach-msm/board-liberty.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/irq.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/atmel_qt602240.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/sysdev.h>
-#include <linux/android_pmem.h>
-#include <linux/curcial_oj.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/delay.h>
-#include <asm/setup.h>
-#include <asm/mach/mmc.h>
-#ifdef CONFIG_CACHE_L2X0
-#include <asm/hardware/cache-l2x0.h>
-#endif
-
-#include <mach/hardware.h>
-#include <mach/system.h>
-#include <mach/vreg.h>
-#include <mach/gpio_chip.h>
-#include <mach/board.h>
-#include <mach/board_htc.h>
-#include <mach/msm_serial_hs.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <mach/atmega_microp.h>
-#include <mach/msm_tssc.h>
-#include <mach/htc_battery.h>
-#include <mach/htc_pwrsink.h>
-#include <mach/perflock.h>
-#include <mach/drv_callback.h>
-#include <mach/camera.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/msm_iomap.h>
-#include <mach/msm_hsusb.h>
-
-#include "devices.h"
-#include "board-liberty.h"
-#include "proc_comm.h"
-#include "../../../drivers/staging/android/timed_gpio.h"
-
-
-void msm_init_irq(void);
-void msm_init_gpio(void);
-void config_liberty_camera_on_gpios(void);
-void config_liberty_camera_off_gpios(void);
-
-void config_liberty_proximity_gpios(int on);
-
-#ifdef CONFIG_MICROP_COMMON
-void __init liberty_microp_init(void);
-#endif
-
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-//	.gpio_mbat_in = LIBERTY_GPIO_MBAT_IN,
-//	.gpio_mchg_en_n = LIBERTY_GPIO_MCHG_EN_N,
-//	.gpio_iset = LIBERTY_GPIO_ISET,
-	.guage_driver = GUAGE_MODEM,
-	.charger = LINEAR_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0, 0x21, 0x4D, 0xDC, 0x134, 0x18D, 0x1E5, 0x3FF, 0x3FF, 0x3FF },
-		.channel = 3,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xC0,
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 38, 82, 95, 167},
-		.channel = 1,
-		.int_pin = 1 << 5,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "reset-int",
-		.category = MICROP_FUNCTION_RESET_INT,
-		.int_pin = 1 << 8,
-	},
-	{
-		.name   = "oj",
-		.category = MICROP_FUNCTION_OJ,
-		.int_pin = 1 << 12,
-	},
-};
-
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "button-backlight",
-		.type = LED_GPO,
-		.mask_w = {0x00, 0x00, 0x08},
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-
-static struct bma150_platform_data liberty_g_sensor_pdata = {
-	.microp_new_cmd = 1,
-	.chip_layout = 1,
-};
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev		= {
-			.platform_data	= &lightsensor_data,
-		},
-	},
-	{
-		.name		= "leds-microp",
-		.id		= -1,
-		.dev		= {
-			.platform_data	= &microp_leds_data,
-		},
-	},
-	{
-		.name = BMA150_G_SENSOR_NAME,
-		.dev = {
-			.platform_data = &liberty_g_sensor_pdata,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = LIBERTY_GPIO_UP_RESET_N,
-	.spi_devices = SPI_OJ | SPI_GSENSOR,
-};
-
-static struct synaptics_i2c_rmi_platform_data liberty_ts_t1007_data[] = {
-	{
-		.version = 0x0100,
-		.flags = SYNAPTICS_FLIP_Y | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = -10 * 0x10000 / 3214,
-		.inactive_right = -10 * 0x10000 / 3214,
-		.inactive_top = -20 * 0x10000 / 5414,
-		.inactive_bottom = -20 * 0x10000 / 5414,
-		.snap_left_on = 10 * 0x10000 / 3214,
-		.snap_left_off = 20 * 0x10000 / 3214,
-		.snap_right_on = 10 * 0x10000 / 3214,
-		.snap_right_off = 20 * 0x10000 / 3214,
-		.snap_top_on = 20 * 0x10000 / 5414,
-		.snap_top_off = 30 * 0x10000 / 5414,
-		.snap_bottom_on = 20 * 0x10000 / 5414,
-		.snap_bottom_off = 30 * 0x10000 / 5414,
-	}
-};
-
-static struct synaptics_i2c_rmi_platform_data liberty_ts_t1021_data[] = {
-	{
-		.version = 0x0100,
-		.inactive_left = -1 * 0x10000 / 320,
-		.inactive_right = -1 * 0x10000 / 320,
-		.inactive_top = -1 * 0x10000 / 480,
-		.inactive_bottom = -50 * 0x10000 / 480,
-	}
-};
-
-static int liberty_ts_atmel_power(int on)
-{
-	printk(KERN_INFO "%s():\n", __func__);
-	if (on) {
-		gpio_set_value(LIBERTY_TP_5V_EN, 1);
-		msleep(2);
-		gpio_set_value(LIBERTY_GPIO_TP_RST, 1);
-	} else {
-		gpio_set_value(LIBERTY_TP_5V_EN, 0);
-		msleep(2);
-	}
-	return 0;
-}
-
-struct atmel_i2c_platform_data liberty_ts_atmel_data[] = {
-	{
-		.version = 0x0015,
-		.abs_x_min = 0,
-		.abs_x_max = 1023,
-		.abs_y_min = 0,
-		.abs_y_max = 915,
-		.abs_pressure_min = 0,
-		.abs_pressure_max = 255,
-		.abs_width_min = 0,
-		.abs_width_max = 20,
-		.gpio_irq = LIBERTY_GPIO_TP_ATT_N,
-		.power = liberty_ts_atmel_power,
-		.config_T6 = {0, 0, 0, 0, 0, 0},
-		.config_T7 = {50, 15, 25},
-		.config_T8 = {8, 0, 20, 10, 0, 0, 5, 25},
-		.config_T9 = {139, 0, 0, 16, 10, 0, 16, 35, 2, 1, 0, 5, 2, 14, 2, 10, 20, 0, 0, 0, 0, 0, 1, 1, 20, 20, 153, 54, 153, 89},
-		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T20 = {19, 0, 0, 5, 5, 0, 0, 35, 20, 4, 15, 0},
-		.config_T22 = {13, 0, 0, 25, 0, -25, 255, 4, 20, 0, 1, 10, 15, 20, 25, 30, 4},
-		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T25 = {3, 0, 200, 50, 64, 31, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-		.config_T28 = {0, 0, 0, 4, 8, 60},
-		.object_crc = {0x62, 0xAE, 0x09},
-	},
-	{
-		.version = 0x0014,
-		.abs_x_min = 13,
-		.abs_x_max = 1009,
-		.abs_y_min = 10,
-		.abs_y_max = 930,
-		.abs_pressure_min = 0,
-		.abs_pressure_max = 255,
-		.abs_width_min = 0,
-		.abs_width_max = 20,
-		.gpio_irq = LIBERTY_GPIO_TP_ATT_N,
-		.power = liberty_ts_atmel_power,
-		.config_T6 = {0, 0, 0, 0, 0, 0},
-		.config_T7 = {32, 16, 50},
-		.config_T8 = {8, 0, 20, 20, 0, 0, 10, 15},
-		.config_T9 = {131, 0, 0, 16, 10, 0, 48, 35, 2, 1, 0, 1, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T20 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T22 = {5, 0, 0, 25, 0, -25, 255, 4, 50, 0, 1, 10, 15, 20, 10, 10, 0},
-		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T25 = {3, 0, 224, 46, 88, 27, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-		.config_T28 = {0, 0, 0, 4, 8},
-	}
-};
-
-static struct msm_hsusb_product liberty_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c92,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-static void liberty_phy_reset(void)
-{
-	int ret;
-	printk(KERN_INFO "msm_hsusb_phy_reset\n");
-	ret = msm_proc_comm(PCOM_MSM_HSUSB_PHY_RESET,
-			NULL, NULL);
-	if (ret)
-		printk(KERN_INFO "%s failed\n", __func__);
-}
-
-static void liberty_phy_shutdown(void)
-{
-	printk(KERN_INFO "%s\n", __func__);
-	gpio_set_value(LIBERTY_GPIO_USBPHY_3V3_EN, 0);
-}
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = LIBERTY_LAYOUTS,
-	.project_name = LIBERTY_PROJECT_NAME,
-	.reset = LIBERTY_GPIO_COMPASS_RST_N,
-	.intr = LIBERTY_GPIO_COMPASS_INT_N,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(SYNAPTICS_T1007_NAME, 0x20),
-		.platform_data = &liberty_ts_t1007_data,
-		.irq = LIBERTY_GPIO_TO_INT(LIBERTY_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(SYNAPTICS_T1021_NAME, 0x21),
-		.platform_data = &liberty_ts_t1021_data,
-		.irq = LIBERTY_GPIO_TO_INT(LIBERTY_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(ATMEL_QT602240_NAME, 0x94 >> 1),
-		.platform_data = &liberty_ts_atmel_data,
-		.irq = MSM_GPIO_TO_INT(LIBERTY_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = LIBERTY_GPIO_TO_INT(LIBERTY_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = LIBERTY_GPIO_TO_INT(LIBERTY_GPIO_COMPASS_INT_N),
-	},
-};
-
-static struct h2w_platform_data liberty_h2w_data = {
-};
-
-static struct platform_device liberty_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &liberty_h2w_data,
-	},
-};
-
-static struct audio_jack_platform_data liberty_jack_data = {
-	.gpio	= LIBERTY_GPIO_35MM_HEADSET_DET,
-};
-
-static struct platform_device liberty_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &liberty_jack_data,
-	},
-};
-
-static struct pwr_sink liberty_pwrsink_table[] = {
-	{
-		.id     = PWRSINK_AUDIO,
-		.ua_max = 100000,
-	},
-	{
-		.id     = PWRSINK_BACKLIGHT,
-		.ua_max = 125000,
-	},
-	{
-		.id     = PWRSINK_LED_BUTTON,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_LED_KEYBOARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_GP_CLK,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_BLUETOOTH,
-		.ua_max = 15000,
-	},
-	{
-		.id     = PWRSINK_CAMERA,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_SDCARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_VIDEO,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id     = PWRSINK_SYSTEM_LOAD,
-		.ua_max = 100000,
-		.percent_util = 38,
-	},
-};
-
-static int liberty_pwrsink_resume_early(struct platform_device *pdev)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-	return 0;
-}
-
-static void liberty_pwrsink_resume_late(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 38);
-}
-
-static void liberty_pwrsink_suspend_early(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-}
-
-static int liberty_pwrsink_suspend_late(struct platform_device *pdev, pm_message_t state)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 1);
-	return 0;
-}
-
-static struct pwr_sink_platform_data liberty_pwrsink_data = {
-	.num_sinks      = ARRAY_SIZE(liberty_pwrsink_table),
-	.sinks          = liberty_pwrsink_table,
-	.suspend_late	= liberty_pwrsink_suspend_late,
-	.resume_early	= liberty_pwrsink_resume_early,
-	.suspend_early	= liberty_pwrsink_suspend_early,
-	.resume_late	= liberty_pwrsink_resume_late,
-};
-
-static struct platform_device liberty_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev    = {
-		.platform_data = &liberty_pwrsink_data,
-	},
-};
-
-static struct msm_pmem_setting pmem_setting = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-        .kgsl_start = MSM_GPU_MEM_BASE,
-        .kgsl_size = MSM_GPU_MEM_SIZE,
-};
-
-
-#ifdef CONFIG_MSM_CAMERA
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		.end	= INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_liberty_camera_on_gpios,
-	.camera_gpio_off = config_liberty_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_s5k4e1gx_data = {
-	.sensor_name    = "s5k4e1gx",
-	.sensor_reset   = LIBERTY_GPIO_CAM1_RST_N,
-	.vcm_pwd        = LIBERTY_GPIO_VCM_PWDN,
-	.pdata          = &msm_camera_device_data,
-	.flash_type     = MSM_CAMERA_FLASH_LED,
-	.resource       = msm_camera_resources,
-	.num_resources  = ARRAY_SIZE(msm_camera_resources)
-};
-
-static struct platform_device msm_camera_sensor_s5k4e1gx = {
-	.name      = "msm_camera_s5k4e1gx",
-	.dev       = {
-		.platform_data = &msm_camera_sensor_s5k4e1gx_data,
-	},
-};
-#endif
-
-static struct platform_device liberty_rfkill = {
-	.name = "liberty_rfkill",
-	.id = -1,
-};
-
-/* Proximity Sensor (Capella_CM3602)*/
-static int __capella_cm3602_power(int on)
-{
-	int rc;
-	struct vreg *vreg = vreg_get(0, "wlan");
-	if (!vreg) {
-		printk(KERN_ERR "%s: vreg error\n", __func__);
-		return -EIO;
-	}
-	rc = vreg_set_level(vreg, 2800);
-
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on) {
-		config_liberty_proximity_gpios(1);
-		gpio_direction_output(LIBERTY_GPIO_PROXIMITY_EN, 1);
-		rc = vreg_enable(vreg);
-		if (rc < 0)
-			printk(KERN_ERR "%s: vreg enable failed\n", __func__);
-	} else {
-		rc = vreg_disable(vreg);
-		if (rc < 0)
-			printk(KERN_ERR "%s: vreg disable failed\n", __func__);
-		gpio_direction_output(LIBERTY_GPIO_PROXIMITY_EN, 0);
-		config_liberty_proximity_gpios(0);
-	}
-
-	return rc;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static unsigned int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable)
-		als_power_control |= pwr_device;
-	else
-		als_power_control &= ~pwr_device;
-
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-		ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-}
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.p_out = LIBERTY_GPIO_PROXIMITY_INT,
-	.p_en = LIBERTY_GPIO_PROXIMITY_EN,
-	.power = capella_cm3602_power,
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-
-static void curcial_oj_shutdown (int	enable)
-{
-	uint8_t cmd[3];
-	memset(cmd, 0, sizeof(uint8_t)*3);
-
-	cmd[2] = 0x80;
-	if (enable)
-		microp_i2c_write(0x91, cmd, 3);
-	else
-		microp_i2c_write(0x90, cmd, 3);
-}
-static int curcial_oj_poweron(int on)
-{
-	struct vreg	*oj_power = vreg_get(0, "rftx");
-	if (IS_ERR(oj_power)) {
-		printk(KERN_ERR"%s:Error power domain\n",__func__);
-		return 0;
-	}
-
-	if (on) {
-		vreg_set_level(oj_power, 2850);
-		vreg_enable(oj_power);
-		printk(KERN_ERR "%s:OJ	power	enable(%d)\n", __func__, on);
-	} else {
-		vreg_disable(oj_power);
-		printk(KERN_ERR "%s:OJ	power	enable(%d)\n", __func__, on);
-		}
-	return 1;
-}
-#define LIB_MICROP_VER	0x02
-static void curcial_oj_adjust_xy(uint8_t *data, int16_t *mSumDeltaX, int16_t *mSumDeltaY)
-{
-	int8_t 	deltaX;
-	int8_t 	deltaY;
-
-
-	if (data[2] == 0x80)
-		data[2] = 0x81;
-	if (data[1] == 0x80)
-		data[1] = 0x81;
-	if (0) {
-		deltaX = (1)*((int8_t) data[2]); /*X=2*/
-		deltaY = (1)*((int8_t) data[1]); /*Y=1*/
-	} else {
-		deltaX = (1)*((int8_t) data[1]);
-		deltaY = (1)*((int8_t) data[2]);
-	}
-	*mSumDeltaX += -((int16_t)deltaX);
-	*mSumDeltaY += -((int16_t)deltaY);
-}
-static struct curcial_oj_platform_data liberty_oj_data = {
-	.oj_poweron = curcial_oj_poweron,
-	.oj_shutdown = curcial_oj_shutdown,
-	.oj_adjust_xy = curcial_oj_adjust_xy,
-	.microp_version = LIB_MICROP_VER,
-	.mdelay_time = 0,
-	.msleep_time = 1,
-	.x_send_count = 3,
-	.y_send_count = 3,
-	.fast_th = 0,
-	.normal_th = 15,
-	.continue_th = 3,
-	.continue_max = 0,
-	.xy_ratio = 15,
-	.interval = 60,
-	.softclick = false,
-	.swap = true,
-	.x = 1,
-	.y = 1,
-	.share_power = false,
-	.Xsteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-	.Ysteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-};
-
-static struct platform_device liberty_oj = {
-	.name = CURCIAL_OJ_NAME,
-	.id = -1,
-	.dev = {
-		.platform_data	= &liberty_oj_data,
-	}
-};
-
-static struct msm_i2c_device_platform_data liberty_i2c_device_data = {
-	.i2c_clock = 400000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-static struct timed_gpio liberty_timed_gpios_str[] = {
-	{
-		.name = "vibrator",
-		.gpio = LIBERTY_GPIO_VIB_3V_EN,
-		.max_timeout = 15000,
-	},
-};
-
-static struct timed_gpio_platform_data liberty_timed_gpio_data = {
-	.num_gpios	= ARRAY_SIZE(liberty_timed_gpios_str),
-	.gpios		= liberty_timed_gpios_str,
-};
-
-static struct platform_device liberty_timed_gpios = {
-	.name		= TIMED_GPIO_NAME,
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &liberty_timed_gpio_data,
-	},
-};
-
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_i2c,
-	&liberty_h2w,
-	&htc_battery_pdev,
-	&liberty_audio_jack,
-	&msm_camera_sensor_s5k4e1gx,
-	&liberty_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&liberty_pwr_sink,
-#endif
-	&liberty_oj,
-	&capella_cm3602,
-	&liberty_timed_gpios,
-};
-
-extern struct sys_timer msm_timer;
-
-static void __init liberty_init_irq(void)
-{
-	printk("liberty_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint cpld_iset;
-static uint cpld_charger_en;
-static uint cpld_usb_h2w_sw;
-static uint opt_disable_uart3;
-static char *keycaps = "";
-
-module_param_named(iset, cpld_iset, uint, 0);
-module_param_named(charger_en, cpld_charger_en, uint, 0);
-module_param_named(usb_h2w_sw, cpld_usb_h2w_sw, uint, 0);
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-module_param_named(keycaps, keycaps, charp, 0);
-
-static char bt_chip_id[10] = "brfxxxx";
-module_param_string(bt_chip_id, bt_chip_id, sizeof(bt_chip_id), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_chip_id, "BT's chip id");
-
-static char bt_fw_version[10] = "v2.0.38";
-module_param_string(bt_fw_version, bt_fw_version, sizeof(bt_fw_version), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_fw_version, "BT's fw version");
-
-static void liberty_reset(void)
-{
-	gpio_set_value(LIBERTY_GPIO_PS_HOLD, 0);
-}
-
-static uint32_t proximity_on_gpio_table[] = {
-	PCOM_GPIO_CFG(LIBERTY_GPIO_PROXIMITY_INT,
-		0, GPIO_INPUT, GPIO_NO_PULL, 0), /* PS_VOUT */
-};
-
-static uint32_t proximity_off_gpio_table[] = {
-	PCOM_GPIO_CFG(LIBERTY_GPIO_PROXIMITY_INT,
-		0, GPIO_INPUT, GPIO_PULL_DOWN, 0) /* PS_VOUT */
-};
-
-static struct i2c_board_info i2c_camera_devices[] = {
-	{
-		I2C_BOARD_INFO("s5k4e1gx", 0x20 >> 1),/*5M samsung bayer sensor driver*/
-	},
-};
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_4MA), /* MCLK */
-
-	PCOM_GPIO_CFG(27, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA), /* CAM_I2C_SDA */
-	PCOM_GPIO_CFG(49, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA), /* CAM_I2C_SCL */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-void config_liberty_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void config_liberty_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-void config_liberty_proximity_gpios(int on)
-{
-	if (on)
-		config_gpio_table(proximity_on_gpio_table,
-			ARRAY_SIZE(proximity_on_gpio_table));
-	else
-		config_gpio_table(proximity_off_gpio_table,
-			ARRAY_SIZE(proximity_off_gpio_table));
-}
-
-/* for bcm */
-static char bdaddress[20];
-extern unsigned char *get_bt_bd_ram(void);
-
-static void bt_export_bd_address(void)
-{
-	unsigned char cTemp[6];
-
-	memcpy(cTemp, get_bt_bd_ram(), 6);
-	sprintf(bdaddress, "%02x:%02x:%02x:%02x:%02x:%02x",
-		cTemp[0], cTemp[1], cTemp[2], cTemp[3], cTemp[4], cTemp[5]);
-	printk(KERN_INFO "YoYo--BD_ADDRESS=%s\n", bdaddress);
-}
-
-module_param_string(bdaddress, bdaddress, sizeof(bdaddress), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bdaddress, "BT MAC ADDRESS");
-
-static uint32_t liberty_serial_debug_table[] = {
-	/* config as serial debug uart */
-	PCOM_GPIO_CFG(LIBERTY_GPIO_UART3_RX, 1,
-			GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* UART3 RX */
-	PCOM_GPIO_CFG(LIBERTY_GPIO_UART3_TX, 1,
-			GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* UART3 TX */
-};
-
-static void liberty_config_serial_debug_gpios(void)
-{
-	config_gpio_table(liberty_serial_debug_table,
-			ARRAY_SIZE(liberty_serial_debug_table));
-}
-
-static void __init config_gpios(void)
-{
-	liberty_config_serial_debug_gpios();
-	config_liberty_camera_off_gpios();
-}
-
-static struct msm_acpu_clock_platform_data liberty_clock_data = {
-	.acpu_switch_time_us = 50,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200,
-	.wait_for_irq_khz = 200000,
-};
-
-static unsigned liberty_perf_acpu_table[] = {
-	245760000,
-	480000000,
-	600000000,
-};
-
-static struct perflock_platform_data liberty_perflock_data = {
-	.perf_acpu_table = liberty_perf_acpu_table,
-	.table_size = ARRAY_SIZE(liberty_perf_acpu_table),
-};
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(LIBERTY_GPIO_BT_HOST_WAKE),
-	.inject_rx_on_wakeup = 0,
-	.cpu_lock_supported = 1,
-
-	/* for bcm */
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = LIBERTY_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = LIBERTY_GPIO_BT_HOST_WAKE,
-
-};
-#endif
-
-static ssize_t liberty_virtual_keys_show(struct kobject *kobj,
-			       struct kobj_attribute *attr, char *buf)
-{
-	if (system_rev > 1) {
-			/* center: x: home: 25, menu: 85, back: 235, search 295, y: 510 */
-		return sprintf(buf,
-			__stringify(EV_KEY) ":" __stringify(KEY_HOME)	    ":25:510:50:55"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":85:510:50:55"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":235:510:50:55"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":295:510:50:55"
-			"\n");
-	} else {
-
-		/* center: x: home: 30, menu: 110, back: 205, search 285, y: 510 */
-		return sprintf(buf,
-			__stringify(EV_KEY) ":" __stringify(KEY_HOME)  ":30:510:60:55"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":110:510:100:55"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":205:510:90:55"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":285:510:70:55"
-			"\n");
-	}
-}
-
-static struct kobj_attribute liberty_synaptics_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.synaptics-rmi-touchscreen",
-		.mode = S_IRUGO,
-	},
-	.show = &liberty_virtual_keys_show,
-};
-
-static struct kobj_attribute liberty_atmel_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.atmel-touchscreen",
-		.mode = S_IRUGO,
-	},
-	.show = &liberty_virtual_keys_show,
-};
-
-static struct attribute *liberty_properties_attrs[] = {
-	&liberty_synaptics_virtual_keys_attr.attr,
-	&liberty_atmel_virtual_keys_attr.attr,
-	NULL
-};
-
-static struct attribute_group liberty_properties_attr_group = {
-	.attrs = liberty_properties_attrs,
-};
-
-static void __init liberty_init(void)
-{
-	int rc;
-	char *cid = NULL;
-	struct kobject *properties_kobj;
-
-	printk("liberty_init() revision = 0x%X\n", system_rev);
-	board_get_cid_tag(&cid);
-
-	/* for bcm */
-	bt_export_bd_address();
-
-	/*
-	 * Setup common MSM GPIOS
-	 */
-	config_gpios();
-
-	/* We need to set this pin to 0 only once on power-up; we will
-	 * not actually enable the chip until we apply power to it via
-	 * vreg.
-	 */
-	gpio_direction_output(LIBERTY_GPIO_LS_EN, 0);
-	/* disable power for cm3602 chip */
-	__capella_cm3602_power(0);
-
-	msm_hw_reset_hook = liberty_reset;
-
-	msm_acpu_clock_init(&liberty_clock_data);
-	perflock_init(&liberty_perflock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-			&msm_device_uart3.dev, 1,
-				MSM_GPIO_TO_INT(LIBERTY_GPIO_UART3_RX));
-#endif
-
-	msm_add_devices();
-
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_device_uart_dm1.name = "msm_serial_hs_bcm";	/* for bcm */
-	msm_add_serial_devices(3);
-#else
-	msm_add_serial_devices(0);
-#endif
-
-	msm_add_serial_devices(2);
-	/*
-	msm_change_usb_id(0x0bb4, 0x0c10);
-	*/
-	msm_add_usb_id_pin_gpio(LIBERTY_GPIO_USB_ID_PIN);
-	msm_hsusb_set_product(liberty_usb_products,
-		ARRAY_SIZE(liberty_usb_products));
-	msm_add_usb_devices(liberty_phy_reset, liberty_phy_shutdown);
-
-	msm_add_mem_devices(&pmem_setting);
-
-#ifdef CONFIG_MICROP_COMMON
-	liberty_microp_init();
-#endif
-
-	rc = liberty_init_mmc(system_rev);
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-
-	properties_kobj = kobject_create_and_add("board_properties", NULL);
-	if (properties_kobj)
-		rc = sysfs_create_group(properties_kobj,
-						&liberty_properties_attr_group);
-	if (!properties_kobj || rc)
-		pr_err("failed to create board_properties\n");
-
-	/* probe camera driver */
-	i2c_register_board_info(0, i2c_camera_devices, ARRAY_SIZE(i2c_camera_devices));
-
-	msm_device_i2c.dev.platform_data = &liberty_i2c_device_data;
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	liberty_init_keypad();
-}
-
-static void __init liberty_fixup(struct machine_desc *desc, struct tag *tags,
-                               char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks=1;
-	mi->bank[0].start = MSM_LINUX_BASE;
-	mi->bank[0].node = PHYS_TO_NID(MSM_LINUX_BASE);
-	mi->bank[0].size = MSM_LINUX_SIZE;
-}
-
-static void __init liberty_map_io(void)
-{
-	printk("liberty_init_map_io()\n");
-	msm_map_common_io();
-	msm_clock_init();
-#ifdef CONFIG_CACHE_L2X0
-	/* 7x27 has 256KB L2 cache:
-	* 64Kb/Way and 4-Way Associativity;
-	* R/W latency: 3 cycles;
-	* evmon/parity/share disabled.
-	*/
-	l2x0_init(MSM_L2CC_BASE, 0x00068012, 0xfe000000);
-#endif
-}
-
-MACHINE_START(LIBERTY, "liberty")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params    = 0x12C00100,
-	.fixup          = liberty_fixup,
-	.map_io         = liberty_map_io,
-	.init_irq       = liberty_init_irq,
-	.init_machine   = liberty_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-liberty.h b/arch/arm/mach-msm/board-liberty.h
deleted file mode 100644
index 9752a5f..0000000
--- a/arch/arm/mach-msm/board-liberty.h
+++ /dev/null
@@ -1,151 +0,0 @@
-/* linux/arch/arm/mach-msm/board-liberty.h
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_LIBERTY_H
-#define __ARCH_ARM_MACH_MSM_BOARD_LIBERTY_H
-
-#include <mach/board.h>
-
-#define MSM_MEM_BASE		0x10000000
-#define MSM_MEM_SIZE		0x18000000
-
-#define MSM_LINUX_BASE_OFFSET	0x02C00000
-
-#define MSM_MM_HEAP_SIZE        0x02800000
-
-#define MSM_LINUX_BASE          (MSM_MEM_BASE + MSM_LINUX_BASE_OFFSET) /* 2MB alignment */
-#define MSM_LINUX_SIZE          (MSM_MEM_SIZE - MSM_LINUX_BASE_OFFSET - MSM_MM_HEAP_SIZE)
-
-#define MSM_FB_BASE             (MSM_MEM_BASE + 0x02A00000)
-#define MSM_FB_SIZE             0x00200000
-
-#define MSM_GPU_MEM_BASE        (MSM_MEM_BASE + MSM_MEM_SIZE - MSM_MM_HEAP_SIZE)
-#define MSM_GPU_MEM_SIZE        0x00300000
-
-#define MSM_PMEM_MDP_BASE       MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE
-#define MSM_PMEM_MDP_SIZE       0x01000000
-
-#define MSM_PMEM_ADSP_BASE      MSM_PMEM_MDP_BASE + MSM_PMEM_MDP_SIZE
-#define MSM_PMEM_ADSP_SIZE      0x00C1B000
-
-#define MSM_PMEM_CAMERA_BASE    MSM_PMEM_ADSP_BASE + MSM_PMEM_ADSP_SIZE
-#define MSM_PMEM_CAMERA_SIZE    0x00800000
-
-/* TODO: To save space, we can move RAM_CONSOLE to 0x00000000 */
-#define MSM_RAM_CONSOLE_BASE    MSM_PMEM_CAMERA_BASE + MSM_PMEM_CAMERA_SIZE
-#define MSM_RAM_CONSOLE_SIZE    128 * SZ_1K
-
-#define LIBERTY_GPIO_TO_INT(x)           (x+64) /* from gpio_to_irq */
-
-#define LIBERTY_GPIO_UP_INT2_N           (18)
-#define LIBERTY_GPIO_USB_ID_PIN          (19)
-#define LIBERTY_POWER_KEY                (20)
-#define LIBERTY_GPIO_PS_HOLD             (25)
-#define LIBERTY_GPIO_CAM_I2C_SDA         (27)
-#define LIBERTY_GPIO_WIFI_IRQ1           (29)
-#define LIBERTY_GPIO_USB_ISET            (30)
-#define LIBERTY_GPIO_RESET_BTN_N         (36)
-#define LIBERTY_GPIO_COMPASS_INT_N       (37)
-#define LIBERTY_GPIO_SDMC_CD_N           (38)
-#define LIBERTY_GPIO_UP_INT_N            (39)
-#define LIBERTY_GPIO_CAM_I2C_SCL         (49)
-
-/* WLAN SD data */
-#define LIBERTY_GPIO_SD_D3               (51)
-#define LIBERTY_GPIO_SD_D2               (52)
-#define LIBERTY_GPIO_SD_D1               (53)
-#define LIBERTY_GPIO_SD_D0               (54)
-#define LIBERTY_GPIO_SD_CMD              (55)
-#define LIBERTY_GPIO_SD_CLK_0            (56)
-
-/* I2C */
-#define LIBERTY_GPIO_I2C_SCL             (60)
-#define LIBERTY_GPIO_I2C_SDA             (61)
-
-/* MicroSD */
-#define LIBERTY_GPIO_SDMC_CLK_0          (62)
-#define LIBERTY_GPIO_SDMC_CMD            (63)
-#define LIBERTY_GPIO_SDMC_D3             (64)
-#define LIBERTY_GPIO_SDMC_D2             (65)
-#define LIBERTY_GPIO_SDMC_D1             (66)
-#define LIBERTY_GPIO_SDMC_D0             (67)
-
-/* BT PCM */
-#define LIBERTY_GPIO_AUD_PCM_DO          (68)
-#define LIBERTY_GPIO_AUD_PCM_DI          (69)
-#define LIBERTY_GPIO_AUD_PCM_SYNC        (70)
-#define LIBERTY_GPIO_AUD_PCM_CLK         (71)
-
-#define LIBERTY_GPIO_UP_RESET_N          (76)
-#define LIBERTY_GPIO_UART3_RX            (86)
-#define LIBERTY_GPIO_UART3_TX            (87)
-#define LIBERTY_GPIO_VIB_3V_EN           (92)
-#define LIBERTY_GPIO_LS_EN               (93)
-#define LIBERTY_GPIO_COMPASS_RST_N       (107)
-#define LIBERTY_GPIO_WIFI_EN             (108)
-#define LIBERTY_GPIO_USBPHY_3V3_EN       (109)
-
-#define LIBERTY_PROJECT_NAME		"liberty"
-#define LIBERTY_LAYOUTS			{ \
-		{ { -1,  0, 0}, {  0, -1, 0}, {0, 0, 1} },  \
-		{ { 0, -1, 0}, { 1,  0, 0}, {0, 0, -1} },  \
-		{ { 0, -1, 0}, {  1, 0, 0}, {0, 0, 1} },  \
-		{ { -1,  0, 0}, {  0,  0, -1}, {0, 1,  0} }   \
-					}
-
-/* Proximity  */
-#define LIBERTY_GPIO_PROXIMITY_INT       (21)
-#define LIBERTY_GPIO_PROXIMITY_EN        (119)
-
-/* Navi key output/input matrix */
-#define LIBERTY_GPIO_KP_MKOUT2           (33)
-#define LIBERTY_GPIO_KP_MKOUT1           (34)
-#define LIBERTY_GPIO_KP_MKOUT0           (35)
-#define LIBERTY_GPIO_KP_MKIN2            (40)
-#define LIBERTY_GPIO_KP_MKIN1            (41)
-#define LIBERTY_GPIO_KP_MKIN0            (42)
-
-/* BT */
-#define LIBERTY_GPIO_BT_UART1_RTS        (43)
-#define LIBERTY_GPIO_BT_UART1_CTS        (44)
-#define LIBERTY_GPIO_BT_UART1_RX         (45)
-#define LIBERTY_GPIO_BT_UART1_TX         (46)
-#define LIBERTY_GPIO_BT_RESET_N          (90)
-#define LIBERTY_GPIO_BT_HOST_WAKE        (112)
-#define LIBERTY_GPIO_BT_CHIP_WAKE        (122)
-#define LIBERTY_GPIO_BT_SHUTDOWN_N       (123)
-
-/* Touch Panel */
-#define LIBERTY_TP_5V_EN                 (31)
-#define LIBERTY_TP_LS_EN                 (91)
-#define LIBERTY_GPIO_TP_ATT_N            (94)
-#define LIBERTY_LCD_RSTz		 (118)
-#define LIBERTY_GPIO_TP_RST              (120)
-
-/* 35mm headset */
-#define LIBERTY_GPIO_35MM_HEADSET_DET    (83)
-
-/*Camera AF VCM POWER*/
-#define LIBERTY_GPIO_VCM_PWDN            (82)
-#define LIBERTY_GPIO_CAM1_RST_N          (121)
-
-/*Display*/
-#define LIBERTY_GPIO_LCD_ID0             (57)
-#define LIBERTY_GPIO_LCD_ID1             (58)
-#define LIBERTY_GPIO_LCD_VSYNC           (97)
-#define LIBERTY_GPIO_LCD_RST_N           (118)
-
-int __init liberty_init_keypad(void);
-int liberty_init_mmc(unsigned int sys_rev);
-#endif /* GUARD */
-
diff --git a/arch/arm/mach-msm/board-mahimahi-audio.c b/arch/arm/mach-msm/board-mahimahi-audio.c
deleted file mode 100644
index 5b1ccb6..0000000
--- a/arch/arm/mach-msm/board-mahimahi-audio.c
+++ /dev/null
@@ -1,193 +0,0 @@
-/* arch/arm/mach-msm/board-mahimahi-audio.c
- *
- * Copyright (C) 2009 HTC Corporation
- * Copyright (C) 2009 Google Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/gpio.h>
-#include <linux/delay.h>
-#include <mach/msm_qdsp6_audio.h>
-#include <mach/htc_acoustic_qsd.h>
-
-#include "board-mahimahi.h"
-#include "proc_comm.h"
-#include "pmic.h"
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "Audio: "fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-static struct mutex mic_lock;
-static struct mutex bt_sco_lock;
-
-void mahimahi_headset_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	/* enable audio amp */
-	if (en) mdelay(15);
-	gpio_set_value(MAHIMAHI_AUD_JACKHP_EN, !!en);
-}
-
-void mahimahi_speaker_enable(int en)
-{
-	struct spkr_config_mode scm;
-	memset(&scm, 0, sizeof(scm));
-
-	D("%s %d\n", __func__, en);
-	if (en) {
-		scm.is_right_chan_en = 0;
-		scm.is_left_chan_en = 1;
-		scm.is_stereo_en = 0;
-		scm.is_hpf_en = 1;
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-		pmic_spkr_en_mute(RIGHT_SPKR, 0);
-		pmic_set_spkr_configuration(&scm);
-		pmic_spkr_en(LEFT_SPKR, 1);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		/* unmute */
-		pmic_spkr_en_mute(LEFT_SPKR, 1);
-	} else {
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-
-		pmic_spkr_en(LEFT_SPKR, 0);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		pmic_set_spkr_configuration(&scm);
-	}
-}
-
-void mahimahi_receiver_enable(int en)
-{
-	/* Do nothing for mahimahi. */
-}
-
-static uint32_t bt_sco_enable[] = {
-	PCOM_GPIO_CFG(MAHIMAHI_BT_PCM_OUT, 1, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(MAHIMAHI_BT_PCM_IN, 1, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(MAHIMAHI_BT_PCM_SYNC, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(MAHIMAHI_BT_PCM_CLK, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-static uint32_t bt_sco_disable[] = {
-	PCOM_GPIO_CFG(MAHIMAHI_BT_PCM_OUT, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(MAHIMAHI_BT_PCM_IN, 0, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(MAHIMAHI_BT_PCM_SYNC, 0, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(MAHIMAHI_BT_PCM_CLK, 0, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-void mahimahi_bt_sco_enable(int en)
-{
-	static int bt_sco_refcount;
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&bt_sco_lock);
-	if (en) {
-		if (++bt_sco_refcount == 1)
-			config_gpio_table(bt_sco_enable,
-					ARRAY_SIZE(bt_sco_enable));
-	} else {
-		if (--bt_sco_refcount == 0) {
-			config_gpio_table(bt_sco_disable,
-					ARRAY_SIZE(bt_sco_disable));
-			gpio_set_value(MAHIMAHI_BT_PCM_OUT, 0);
-		}
-	}
-	mutex_unlock(&bt_sco_lock);
-}
-
-void mahimahi_mic_enable(int en)
-{
-	static int old_state = 0, new_state = 0;
-
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&mic_lock);
-	if (!!en)
-		new_state++;
-	else
-		new_state--;
-
-	if (new_state == 1 && old_state == 0) {
-		gpio_set_value(MAHIMAHI_AUD_2V5_EN, 1);
-		mdelay(60);
-	} else if (new_state == 0 && old_state == 1)
-		gpio_set_value(MAHIMAHI_AUD_2V5_EN, 0);
-	else
-		D("%s: do nothing %d %d\n", __func__, old_state, new_state);
-
-	old_state = new_state;
-	mutex_unlock(&mic_lock);
-}
-
-void mahimahi_analog_init(void)
-{
-	D("%s\n", __func__);
-	/* stereo pmic init */
-	pmic_spkr_set_gain(LEFT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_set_gain(RIGHT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_en_right_chan(OFF_CMD);
-	pmic_spkr_en_left_chan(OFF_CMD);
-	pmic_spkr_add_right_left_chan(OFF_CMD);
-	pmic_spkr_en_stereo(OFF_CMD);
-	pmic_spkr_select_usb_with_hpf_20hz(OFF_CMD);
-	pmic_spkr_bypass_mux(OFF_CMD);
-	pmic_spkr_en_hpf(ON_CMD);
-	pmic_spkr_en_sink_curr_from_ref_volt_cir(OFF_CMD);
-	pmic_spkr_set_mux_hpf_corner_freq(SPKR_FREQ_0_73KHZ);
-	pmic_mic_set_volt(MIC_VOLT_1_80V);
-
-	gpio_direction_output(MAHIMAHI_AUD_JACKHP_EN, 0);
-	gpio_set_value(MAHIMAHI_AUD_JACKHP_EN, 0);
-	gpio_set_value(MAHIMAHI_AUD_2V5_EN, 0);
-
-	mutex_lock(&bt_sco_lock);
-	config_gpio_table(bt_sco_disable,
-			ARRAY_SIZE(bt_sco_disable));
-	gpio_set_value(MAHIMAHI_BT_PCM_OUT, 0);
-	mutex_unlock(&bt_sco_lock);
-}
-
-static struct qsd_acoustic_ops acoustic = {
-	.enable_mic_bias = mahimahi_mic_enable,
-};
-
-static struct q6audio_analog_ops ops = {
-	.init = mahimahi_analog_init,
-	.speaker_enable = mahimahi_speaker_enable,
-	.headset_enable = mahimahi_headset_enable,
-	.receiver_enable = mahimahi_receiver_enable,
-	.bt_sco_enable = mahimahi_bt_sco_enable,
-	.int_mic_enable = mahimahi_mic_enable,
-	.ext_mic_enable = mahimahi_mic_enable,
-};
-
-void __init mahimahi_audio_init(void)
-{
-	mutex_init(&mic_lock);
-	mutex_init(&bt_sco_lock);
-#if defined(CONFIG_QSD_AUDIO)
-	q6audio_register_analog_ops(&ops);
-#endif
-	acoustic_register_ops(&acoustic);
-}
diff --git a/arch/arm/mach-msm/board-mahimahi-flashlight.c b/arch/arm/mach-msm/board-mahimahi-flashlight.c
deleted file mode 100644
index c958f32..0000000
--- a/arch/arm/mach-msm/board-mahimahi-flashlight.c
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * arch/arm/mach-msm/flashlight.c - flashlight driver
- *
- *  Copyright (C) 2009 zion huang <zion_huang@htc.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- */
-
-#define DEBUG
-
-#include <linux/delay.h>
-#include <linux/earlysuspend.h>
-#include <linux/platform_device.h>
-#include <linux/leds.h>
-#include <linux/wakelock.h>
-#include <linux/hrtimer.h>
-#include <mach/flashlight.h>
-#include <mach/msm_iomap.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-
-struct flashlight_struct {
-	struct led_classdev fl_lcdev;
-	struct early_suspend early_suspend_flashlight;
-	spinlock_t spin_lock;
-	struct hrtimer timer;
-	int brightness;
-	int gpio_torch;
-	int gpio_flash;
-	int flash_duration_ms;
-};
-
-static struct flashlight_struct the_fl;
-
-static inline void toggle(void)
-{
-	gpio_direction_output(the_fl.gpio_torch, 0);
-	udelay(2);
-	gpio_direction_output(the_fl.gpio_torch, 1);
-	udelay(2);
-}
-
-static void flashlight_hw_command(uint8_t addr, uint8_t data)
-{
-	int i;
-
-	for (i = 0; i < addr + 17; i++)
-		toggle();
-	udelay(500);
-
-	for (i = 0; i < data; i++)
-		toggle();
-	udelay(500);
-}
-
-static enum hrtimer_restart flashlight_timeout(struct hrtimer *timer)
-{
-	unsigned long flags;
-
-	pr_debug("%s\n", __func__);
-
-	spin_lock_irqsave(&the_fl.spin_lock, flags);
-	gpio_direction_output(the_fl.gpio_flash, 0);
-	the_fl.brightness = LED_OFF;
-	spin_unlock_irqrestore(&the_fl.spin_lock, flags);
-
-	return HRTIMER_NORESTART;
-}
-
-int flashlight_control(int mode)
-{
-	int ret = 0;
-	unsigned long flags;
-
-	pr_debug("%s: mode %d -> %d\n", __func__,
-			the_fl.brightness, mode);
-
-	spin_lock_irqsave(&the_fl.spin_lock, flags);
-
-	switch (mode) {
-	case FLASHLIGHT_TORCH:
-		pr_info("%s: half\n", __func__);
-		/* If we are transitioning from flash to torch, make sure to
-		 * cancel the flash timeout timer, otherwise when it expires,
-		 * the torch will go off as well.
-		 */
-		hrtimer_cancel(&the_fl.timer);
-		flashlight_hw_command(2, 4);
-		break;
-
-	case FLASHLIGHT_FLASH:
-		pr_info("%s: full\n", __func__);
-		hrtimer_cancel(&the_fl.timer);
-		gpio_direction_output(the_fl.gpio_flash, 0);
-		udelay(40);
-		gpio_direction_output(the_fl.gpio_flash, 1);
-		hrtimer_start(&the_fl.timer,
-			ktime_set(the_fl.flash_duration_ms / 1000,
-					(the_fl.flash_duration_ms % 1000) *
-						NSEC_PER_MSEC),
-				HRTIMER_MODE_REL);
-		/* Flash overrides torch mode, and after the flash period, the
-		 * flash LED will turn off.
-		 */
-		mode = LED_OFF;
-		break;
-
-	case FLASHLIGHT_OFF:
-		pr_info("%s: off\n", __func__);
-		gpio_direction_output(the_fl.gpio_flash, 0);
-		gpio_direction_output(the_fl.gpio_torch, 0);
-		break;
-
-	default:
-		pr_err("%s: unknown flash_light flags: %d\n", __func__, mode);
-		ret = -EINVAL;
-		goto done;
-	}
-
-	the_fl.brightness = mode;
-
-done:
-	spin_unlock_irqrestore(&the_fl.spin_lock, flags);
-	return ret;
-}
-EXPORT_SYMBOL(flashlight_control);
-
-static void fl_lcdev_brightness_set(struct led_classdev *led_cdev,
-		enum led_brightness brightness)
-{
-	int level;
-	switch (brightness) {
-	case LED_HALF:
-		level = FLASHLIGHT_TORCH;
-		break;
-	case LED_FULL:
-		level = FLASHLIGHT_FLASH;
-		break;
-	case LED_OFF:
-	default:
-		level = FLASHLIGHT_OFF;
-	};
-
-	flashlight_control(level);
-}
-
-static void flashlight_early_suspend(struct early_suspend *handler)
-{
-	flashlight_control(FLASHLIGHT_OFF);
-}
-
-static int flashlight_setup_gpio(struct flashlight_platform_data *fl_pdata)
-{
-	int ret;
-
-	pr_debug("%s\n", __func__);
-
-	if (fl_pdata->gpio_init) {
-		ret = fl_pdata->gpio_init();
-		if (ret < 0) {
-			pr_err("%s: gpio init failed: %d\n", __func__,
-				ret);
-			return ret;
-		}
-	}
-
-	if (fl_pdata->torch) {
-		ret = gpio_request(fl_pdata->torch, "flashlight_torch");
-		if (ret < 0) {
-			pr_err("%s: gpio_request failed\n", __func__);
-			return ret;
-		}
-	}
-
-	if (fl_pdata->flash) {
-		ret = gpio_request(fl_pdata->flash, "flashlight_flash");
-		if (ret < 0) {
-			pr_err("%s: gpio_request failed\n", __func__);
-			gpio_free(fl_pdata->torch);
-			return ret;
-		}
-	}
-
-	the_fl.gpio_torch = fl_pdata->torch;
-	the_fl.gpio_flash = fl_pdata->flash;
-	the_fl.flash_duration_ms = fl_pdata->flash_duration_ms;
-	return 0;
-}
-
-static int flashlight_probe(struct platform_device *pdev)
-{
-	struct flashlight_platform_data *fl_pdata = pdev->dev.platform_data;
-	int err = 0;
-
-	pr_debug("%s\n", __func__);
-
-	err = flashlight_setup_gpio(fl_pdata);
-	if (err < 0) {
-		pr_err("%s: setup GPIO failed\n", __func__);
-		goto fail_free_mem;
-	}
-
-	spin_lock_init(&the_fl.spin_lock);
-	the_fl.fl_lcdev.name = pdev->name;
-	the_fl.fl_lcdev.brightness_set = fl_lcdev_brightness_set;
-	the_fl.fl_lcdev.brightness = LED_OFF;
-	err = led_classdev_register(&pdev->dev, &the_fl.fl_lcdev);
-	if (err < 0) {
-		pr_err("failed on led_classdev_register\n");
-		goto fail_free_gpio;
-	}
-
-	hrtimer_init(&the_fl.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	the_fl.timer.function = flashlight_timeout;
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	the_fl.early_suspend_flashlight.suspend = flashlight_early_suspend;
-	the_fl.early_suspend_flashlight.resume = NULL;
-	register_early_suspend(&the_fl.early_suspend_flashlight);
-#endif
-
-	return 0;
-
-fail_free_gpio:
-	if (fl_pdata->torch)
-		gpio_free(fl_pdata->torch);
-	if (fl_pdata->flash)
-		gpio_free(fl_pdata->flash);
-fail_free_mem:
-	return err;
-}
-
-static int flashlight_remove(struct platform_device *pdev)
-{
-	struct flashlight_platform_data *fl_pdata = pdev->dev.platform_data;
-
-	pr_debug("%s\n", __func__);
-
-	hrtimer_cancel(&the_fl.timer);
-	unregister_early_suspend(&the_fl.early_suspend_flashlight);
-	flashlight_control(FLASHLIGHT_OFF);
-	led_classdev_unregister(&the_fl.fl_lcdev);
-	if (fl_pdata->torch)
-		gpio_free(fl_pdata->torch);
-	if (fl_pdata->flash)
-		gpio_free(fl_pdata->flash);
-	return 0;
-}
-
-static struct platform_driver flashlight_driver = {
-	.probe		= flashlight_probe,
-	.remove		= flashlight_remove,
-	.driver		= {
-		.name		= FLASHLIGHT_NAME,
-		.owner		= THIS_MODULE,
-	},
-};
-
-static int __init flashlight_init(void)
-{
-	pr_debug("%s\n", __func__);
-	return platform_driver_register(&flashlight_driver);
-}
-
-static void __exit flashlight_exit(void)
-{
-	pr_debug("%s\n", __func__);
-	platform_driver_unregister(&flashlight_driver);
-}
-
-module_init(flashlight_init);
-module_exit(flashlight_exit);
-
-MODULE_AUTHOR("Zion Huang <zion_huang@htc.com>");
-MODULE_DESCRIPTION("flash light driver");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-mahimahi-keypad.c b/arch/arm/mach-msm/board-mahimahi-keypad.c
deleted file mode 100644
index ca8b496..0000000
--- a/arch/arm/mach-msm/board-mahimahi-keypad.c
+++ /dev/null
@@ -1,224 +0,0 @@
-/* arch/arm/mach-msm/board-mahimahi-keypad.c
- *
- * Copyright (C) 2009 Google, Inc
- * Copyright (C) 2009 HTC Corporation.
- *
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/gpio_event.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/keyreset.h>
-#include <linux/platform_device.h>
-#include <mach/vreg.h>
-
-#include <asm/mach-types.h>
-
-#include "board-mahimahi.h"
-
-struct jog_axis_info {
-	struct gpio_event_axis_info	info;
-	uint16_t			in_state;
-	uint16_t			out_state;
-};
-
-static struct vreg *jog_vreg;
-static bool jog_just_on;
-static unsigned long jog_on_jiffies;
-
-static unsigned int mahimahi_col_gpios[] = { 33, 32, 31 };
-static unsigned int mahimahi_row_gpios[] = { 42, 41, 40 };
-
-#define KEYMAP_INDEX(col, row)	((col)*ARRAY_SIZE(mahimahi_row_gpios) + (row))
-#define KEYMAP_SIZE		(ARRAY_SIZE(mahimahi_col_gpios) * \
-				 ARRAY_SIZE(mahimahi_row_gpios))
-
-/* keypad */
-static const unsigned short mahimahi_keymap[KEYMAP_SIZE] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 1)] = MATRIX_KEY(1, BTN_MOUSE),
-};
-
-static struct gpio_event_matrix_info mahimahi_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = mahimahi_keymap,
-	.output_gpios = mahimahi_col_gpios,
-	.input_gpios = mahimahi_row_gpios,
-	.noutputs = ARRAY_SIZE(mahimahi_col_gpios),
-	.ninputs = ARRAY_SIZE(mahimahi_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		  GPIOKPF_REMOVE_PHANTOM_KEYS |
-		  GPIOKPF_PRINT_UNMAPPED_KEYS),
-};
-
-static struct gpio_event_direct_entry mahimahi_keypad_key_map[] = {
-	{
-		.gpio	= MAHIMAHI_GPIO_POWER_KEY,
-		.code	= KEY_POWER,
-	},
-};
-
-static struct gpio_event_input_info mahimahi_keypad_key_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = 0,
-	.type = EV_KEY,
-	.keymap = mahimahi_keypad_key_map,
-	.keymap_size = ARRAY_SIZE(mahimahi_keypad_key_map)
-};
-
-/* jogball */
-static uint16_t jogball_axis_map(struct gpio_event_axis_info *info, uint16_t in)
-{
-	struct jog_axis_info *ai =
-		container_of(info, struct jog_axis_info, info);
-	uint16_t out = ai->out_state;
-
-	if (jog_just_on) {
-		if (jiffies == jog_on_jiffies || jiffies == jog_on_jiffies + 1)
-			goto ignore;
-		jog_just_on = 0;
-	}
-	if((ai->in_state ^ in) & 1)
-		out--;
-	if((ai->in_state ^ in) & 2)
-		out++;
-	ai->out_state = out;
-ignore:
-	ai->in_state = in;
-	return out;
-}
-
-static int jogball_power(const struct gpio_event_platform_data *pdata, bool on)
-{
-	if (on) {
-		vreg_enable(jog_vreg);
-		jog_just_on = 1;
-		jog_on_jiffies = jiffies;
-	} else {
-		vreg_disable(jog_vreg);
-	}
-
-	return 0;
-}
-
-static uint32_t jogball_x_gpios[] = {
-	MAHIMAHI_GPIO_BALL_LEFT, MAHIMAHI_GPIO_BALL_RIGHT,
-};
-static uint32_t jogball_y_gpios[] = {
-	MAHIMAHI_GPIO_BALL_UP, MAHIMAHI_GPIO_BALL_DOWN,
-};
-
-static struct jog_axis_info jogball_x_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(jogball_x_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_X,
-		.decoded_size = 1U << ARRAY_SIZE(jogball_x_gpios),
-		.map = jogball_axis_map,
-		.gpio = jogball_x_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION,
-	}
-};
-
-static struct jog_axis_info jogball_y_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(jogball_y_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_Y,
-		.decoded_size = 1U << ARRAY_SIZE(jogball_y_gpios),
-		.map = jogball_axis_map,
-		.gpio = jogball_y_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION,
-	}
-};
-
-static struct gpio_event_info *mahimahi_input_info[] = {
-	&mahimahi_keypad_matrix_info.info,
-	&mahimahi_keypad_key_info.info,
-	&jogball_x_axis.info.info,
-	&jogball_y_axis.info.info,
-};
-
-static struct gpio_event_platform_data mahimahi_input_data = {
-	.names = {
-		"mahimahi-keypad",
-		"mahimahi-nav",
-		NULL,
-	},
-	.info = mahimahi_input_info,
-	.info_count = ARRAY_SIZE(mahimahi_input_info),
-	.power = jogball_power,
-};
-
-static struct platform_device mahimahi_input_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev = {
-		.platform_data = &mahimahi_input_data,
-	},
-};
-
-static int mahimahi_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0,
-};
-
-static struct keyreset_platform_data mahimahi_reset_keys_pdata = {
-	.keys_up	= mahimahi_reset_keys_up,
-	.keys_down	= {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-struct platform_device mahimahi_reset_keys_device = {
-	.name	= KEYRESET_NAME,
-	.dev	= {
-		.platform_data = &mahimahi_reset_keys_pdata,
-	},
-};
-
-
-static int __init mahimahi_init_keypad_jogball(void)
-{
-	int ret;
-
-	if (!machine_is_mahimahi())
-		return 0;
-
-	ret = platform_device_register(&mahimahi_reset_keys_device);
-	if (ret != 0)
-		return ret;
-
-	jog_vreg = vreg_get(&mahimahi_input_device.dev, "gp2");
-	if (jog_vreg == NULL)
-		return -ENOENT;
-
-	ret = platform_device_register(&mahimahi_input_device);
-	if (ret != 0)
-		return ret;
-
-	return 0;
-}
-
-device_initcall(mahimahi_init_keypad_jogball);
diff --git a/arch/arm/mach-msm/board-mahimahi-microp.c b/arch/arm/mach-msm/board-mahimahi-microp.c
deleted file mode 100644
index a199d41..0000000
--- a/arch/arm/mach-msm/board-mahimahi-microp.c
+++ /dev/null
@@ -1,1824 +0,0 @@
-/* board-mahimahi-microp.c
- * Copyright (C) 2009 Google.
- * Copyright (C) 2009 HTC Corporation.
- *
- * The Microp on mahimahi is an i2c device that supports
- * the following functions
- *   - LEDs (Green, Amber, Jogball backlight)
- *   - Lightsensor
- *   - Headset remotekeys
- *   - G-sensor
- *   - Interrupts
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/leds.h>
-#include <linux/workqueue.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/miscdevice.h>
-#include <linux/input.h>
-#include <asm/uaccess.h>
-#include <linux/wakelock.h>
-#include <asm/mach-types.h>
-#include <mach/htc_pwrsink.h>
-#include <linux/earlysuspend.h>
-#include <linux/bma150.h>
-#include <linux/lightsensor.h>
-#include <asm/mach/mmc.h>
-#include <mach/htc_35mm_jack.h>
-
-#include "board-mahimahi.h"
-
-
-#define MICROP_I2C_NAME "mahimahi-microp"
-
-#define MICROP_LSENSOR_ADC_CHAN		6
-#define MICROP_REMOTE_KEY_ADC_CHAN	7
-
-#define MICROP_I2C_WCMD_MISC			0x20
-#define MICROP_I2C_WCMD_SPI_EN			0x21
-#define MICROP_I2C_WCMD_AUTO_BL_CTL		0x23
-#define MICROP_I2C_RCMD_SPI_BL_STATUS		0x24
-#define MICROP_I2C_WCMD_BUTTONS_LED_CTRL	0x25
-#define MICROP_I2C_RCMD_VERSION			0x30
-#define MICROP_I2C_WCMD_ADC_TABLE		0x42
-#define MICROP_I2C_WCMD_LED_MODE		0x53
-#define MICROP_I2C_RCMD_GREEN_LED_REMAIN_TIME	0x54
-#define MICROP_I2C_RCMD_AMBER_LED_REMAIN_TIME	0x55
-#define MICROP_I2C_WCMD_JOGBALL_LED_MODE	0x5A
-#define MICROP_I2C_RCMD_JOGBALL_LED_REMAIN_TIME	0x5B
-#define MICROP_I2C_WCMD_READ_ADC_VALUE_REQ	0x60
-#define MICROP_I2C_RCMD_ADC_VALUE		0x62
-#define MICROP_I2C_WCMD_REMOTEKEY_TABLE		0x63
-#define MICROP_I2C_WCMD_LCM_REGISTER		0x70
-#define MICROP_I2C_WCMD_GSENSOR_REG		0x73
-#define MICROP_I2C_WCMD_GSENSOR_REG_DATA_REQ	0x74
-#define MICROP_I2C_RCMD_GSENSOR_REG_DATA	0x75
-#define MICROP_I2C_WCMD_GSENSOR_DATA_REQ	0x76
-#define MICROP_I2C_RCMD_GSENSOR_X_DATA		0x77
-#define MICROP_I2C_RCMD_GSENSOR_Y_DATA		0x78
-#define MICROP_I2C_RCMD_GSENSOR_Z_DATA		0x79
-#define MICROP_I2C_RCMD_GSENSOR_DATA		0x7A
-#define MICROP_I2C_WCMD_OJ_REG			0x7B
-#define MICROP_I2C_WCMD_OJ_REG_DATA_REQ		0x7C
-#define MICROP_I2C_RCMD_OJ_REG_DATA		0x7D
-#define MICROP_I2C_WCMD_OJ_POS_DATA_REQ		0x7E
-#define MICROP_I2C_RCMD_OJ_POS_DATA		0x7F
-#define MICROP_I2C_WCMD_GPI_INT_CTL_EN		0x80
-#define MICROP_I2C_WCMD_GPI_INT_CTL_DIS		0x81
-#define MICROP_I2C_RCMD_GPI_INT_STATUS		0x82
-#define MICROP_I2C_RCMD_GPI_STATUS		0x83
-#define MICROP_I2C_WCMD_GPI_INT_STATUS_CLR	0x84
-#define MICROP_I2C_RCMD_GPI_INT_SETTING		0x85
-#define MICROP_I2C_RCMD_REMOTE_KEYCODE		0x87
-#define MICROP_I2C_WCMD_REMOTE_KEY_DEBN_TIME	0x88
-#define MICROP_I2C_WCMD_REMOTE_PLUG_DEBN_TIME	0x89
-#define MICROP_I2C_WCMD_SIMCARD_DEBN_TIME	0x8A
-#define MICROP_I2C_WCMD_GPO_LED_STATUS_EN	0x90
-#define MICROP_I2C_WCMD_GPO_LED_STATUS_DIS	0x91
-
-#define IRQ_GSENSOR	(1<<10)
-#define IRQ_LSENSOR  	(1<<9)
-#define IRQ_REMOTEKEY	(1<<7)
-#define IRQ_HEADSETIN	(1<<2)
-#define IRQ_SDCARD	(1<<0)
-
-#define READ_GPI_STATE_HPIN	(1<<2)
-#define READ_GPI_STATE_SDCARD	(1<<0)
-
-int microp_headset_has_mic(void);
-int microp_enable_headset_plug_event(void);
-
-static struct h35mm_platform_data mahimahi_h35mm_data = {
-	.plug_event_enable = microp_enable_headset_plug_event,
-	.headset_has_mic = microp_headset_has_mic,
-};
-
-static struct platform_device mahimahi_h35mm = {
-	.name           = "htc_headset",
-	.id                     = -1,
-	.dev            = {
-		.platform_data  = &mahimahi_h35mm_data,
-	},
-};
-
-enum led_type {
-	GREEN_LED,
-	AMBER_LED,
-	JOGBALL_LED,
-	BUTTONS_LED,
-	NUM_LEDS,
-};
-
-static uint16_t lsensor_adc_table[10] = {
-	0x005, 0x00A, 0x00F, 0x01E, 0x03C, 0x121, 0x205, 0x2BA, 0x26E, 0x3FF
-};
-
-static uint16_t remote_key_adc_table[6] = {
-	0, 39, 51, 98, 141, 192
-};
-
-static struct wake_lock microp_i2c_wakelock;
-
-static struct i2c_client *private_microp_client;
-
-struct microp_int_pin {
-	uint16_t int_gsensor;
-	uint16_t int_lsensor;
-	uint16_t int_reset;
-	uint16_t int_simcard;
-	uint16_t int_hpin;
-	uint16_t int_remotekey;
-};
-
-struct microp_led_data {
-	int type;
-	struct led_classdev ldev;
-	struct mutex led_data_mutex;
-	uint8_t mode;
-	uint8_t blink;
-};
-
-struct microp_i2c_work {
-	struct work_struct work;
-	struct i2c_client *client;
-	int (*intr_debounce)(uint8_t *pin_status);
-	void (*intr_function)(uint8_t *pin_status);
-};
-
-struct microp_i2c_client_data {
-	struct microp_led_data leds[NUM_LEDS];
-	uint16_t version;
-	struct microp_i2c_work work;
-	struct delayed_work hpin_enable_intr_work;
-	struct delayed_work hpin_debounce_work;
-	struct early_suspend early_suspend;
-	uint8_t enable_early_suspend;
-	uint8_t enable_reset_button;
-	int microp_is_suspend;
-	int als_intr_enabled;
-	uint8_t light_sensor_enabled;
-	int headset_is_in;
-	struct input_dev *ls_input_dev;
-};
-
-static char *hex2string(uint8_t *data, int len)
-{
-	static char buf[101];
-	int i;
-
-	i = (sizeof(buf) - 1) / 4;
-	if (len > i)
-		len = i;
-
-	for (i = 0; i < len; i++)
-		sprintf(buf + i * 4, "[%02X]", data[i]);
-
-	return buf;
-}
-
-#define I2C_READ_RETRY_TIMES  10
-#define I2C_WRITE_RETRY_TIMES 10
-
-static int i2c_read_block(struct i2c_client *client, uint8_t addr,
-	uint8_t *data, int length)
-{
-	int retry;
-	int ret;
-	struct i2c_msg msgs[] = {
-	{
-		.addr = client->addr,
-		.flags = 0,
-		.len = 1,
-		.buf = &addr,
-	},
-	{
-		.addr = client->addr,
-		.flags = I2C_M_RD,
-		.len = length,
-		.buf = data,
-	}
-	};
-
-	for (retry = 0; retry <= I2C_READ_RETRY_TIMES; retry++) {
-		ret = i2c_transfer(client->adapter, msgs, 2);
-		if (ret == 2) {
-			dev_dbg(&client->dev, "R [%02X] = %s\n", addr,
-					hex2string(data, length));
-			return 0;
-		}
-		msleep(10);
-	}
-
-	dev_err(&client->dev, "i2c_read_block retry over %d\n",
-			I2C_READ_RETRY_TIMES);
-	return -EIO;
-}
-
-#define MICROP_I2C_WRITE_BLOCK_SIZE 21
-static int i2c_write_block(struct i2c_client *client, uint8_t addr,
-	uint8_t *data, int length)
-{
-	int retry;
-	uint8_t buf[MICROP_I2C_WRITE_BLOCK_SIZE];
-	int ret;
-
-	struct i2c_msg msg[] = {
-		{
-			.addr = client->addr,
-			.flags = 0,
-			.len = length + 1,
-			.buf = buf,
-		}
-	};
-
-	dev_dbg(&client->dev, "W [%02X] = %s\n", addr,
-			hex2string(data, length));
-
-	if (length + 1 > MICROP_I2C_WRITE_BLOCK_SIZE) {
-		dev_err(&client->dev, "i2c_write_block length too long\n");
-		return -E2BIG;
-	}
-
-	buf[0] = addr;
-	memcpy((void *)&buf[1], (void *)data, length);
-
-	for (retry = 0; retry <= I2C_WRITE_RETRY_TIMES; retry++) {
-		ret = i2c_transfer(client->adapter, msg, 1);
-		if (ret == 1)
-			return 0;
-		msleep(10);
-	}
-	dev_err(&client->dev, "i2c_write_block retry over %d\n",
-			I2C_WRITE_RETRY_TIMES);
-	return -EIO;
-}
-
-static int microp_read_adc(uint8_t channel, uint16_t *value)
-{
-	struct i2c_client *client;
-	int ret;
-	uint8_t cmd[2], data[2];
-
-	client = private_microp_client;
-	cmd[0] = 0;
-	cmd[1] = channel;
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_READ_ADC_VALUE_REQ,
-			      cmd, 2);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s: request adc fail\n", __func__);
-		return -EIO;
-	}
-	msleep(1);
-	ret = i2c_read_block(client, MICROP_I2C_RCMD_ADC_VALUE, data, 2);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s: read adc fail\n", __func__);
-		return -EIO;
-	}
-	*value = data[0] << 8 | data[1];
-	return 0;
-}
-
-static int microp_read_gpi_status(struct i2c_client *client, uint16_t *status)
-{
-	uint8_t data[2];
-	int ret;
-
-	ret = i2c_read_block(client, MICROP_I2C_RCMD_GPI_STATUS, data, 2);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s: read failed\n", __func__);
-		return -EIO;
-	}
-	*status = (data[0] << 8) | data[1];
-	return 0;
-}
-
-static int microp_interrupt_enable(struct i2c_client *client,
-				   uint16_t interrupt_mask)
-{
-	uint8_t data[2];
-	int ret = -1;
-
-	data[0] = interrupt_mask >> 8;
-	data[1] = interrupt_mask & 0xFF;
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_GPI_INT_CTL_EN, data, 2);
-
-	if (ret < 0)
-		dev_err(&client->dev, "%s: enable 0x%x interrupt failed\n",
-			__func__, interrupt_mask);
-	return ret;
-}
-
-static int microp_interrupt_disable(struct i2c_client *client,
-				    uint16_t interrupt_mask)
-{
-	uint8_t data[2];
-	int ret = -1;
-
-	data[0] = interrupt_mask >> 8;
-	data[1] = interrupt_mask & 0xFF;
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_GPI_INT_CTL_DIS, data, 2);
-
-	if (ret < 0)
-		dev_err(&client->dev, "%s: disable 0x%x interrupt failed\n",
-			__func__, interrupt_mask);
-	return ret;
-}
-
-
-/*
- * SD slot card-detect support
- */
-static unsigned int sdslot_cd = 0;
-static void (*sdslot_status_cb)(int card_present, void *dev_id);
-static void *sdslot_mmc_dev;
-
-int mahimahi_microp_sdslot_status_register(
-		void (*cb)(int card_present, void *dev_id),
-		void *dev_id)
-{
-	if (sdslot_status_cb)
-		return -EBUSY;
-	sdslot_status_cb = cb;
-	sdslot_mmc_dev = dev_id;
-	return 0;
-}
-
-unsigned int mahimahi_microp_sdslot_status(struct device *dev)
-{
-	return sdslot_cd;
-}
-
-static void mahimahi_microp_sdslot_update_status(int status)
-{
-	sdslot_cd = !(status & READ_GPI_STATE_SDCARD);
-	if (sdslot_status_cb)
-		sdslot_status_cb(sdslot_cd, sdslot_mmc_dev);
-}
-
-/*
- *Headset Support
-*/
-static void hpin_debounce_do_work(struct work_struct *work)
-{
-	uint16_t gpi_status = 0;
-	struct microp_i2c_client_data *cdata;
-	int insert = 0;
-	struct i2c_client *client;
-
-	client = private_microp_client;
-	cdata = i2c_get_clientdata(client);
-
-	microp_read_gpi_status(client, &gpi_status);
-	insert = (gpi_status & READ_GPI_STATE_HPIN) ? 0 : 1;
-	if (insert != cdata->headset_is_in) {
-		cdata->headset_is_in = insert;
-		pr_debug("headset %s\n", insert ? "inserted" : "removed");
-		htc_35mm_jack_plug_event(cdata->headset_is_in);
-	}
-}
-
-int microp_enable_headset_plug_event(void)
-{
-	int ret;
-	struct i2c_client *client;
-	struct microp_i2c_client_data *cdata;
-	uint16_t stat;
-
-	client = private_microp_client;
-	cdata = i2c_get_clientdata(client);
-
-pr_info("%s\n", __func__);
-	/* enable microp interrupt to detect changes */
-	ret = microp_interrupt_enable(client, IRQ_HEADSETIN);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s: failed to enable irqs\n",
-			__func__);
-		return 0;
-	}
-	/* see if headset state has changed */
-	microp_read_gpi_status(client, &stat);
-	stat = !(stat & READ_GPI_STATE_HPIN);
-	if(cdata->headset_is_in != stat) {
-		pr_debug("Headset state changed\n");
-		htc_35mm_jack_plug_event(stat);
-	}
-
-	return 1;
-}
-
-int microp_headset_has_mic(void)
-{
-	uint16_t data;
-	int ret = 0;
-
-	microp_read_adc(MICROP_REMOTE_KEY_ADC_CHAN, &data);
-	if (data >= 200)
-		ret = 1;
-	else
-		ret = 0;
-
-	printk(KERN_DEBUG "%s: microp_mic_status =0x%d\n", __func__, ret);
-
-	return ret;
-}
-
-static int get_remote_keycode(uint8_t *keycode)
-{
-	struct i2c_client *client = private_microp_client;
-	int ret;
-	uint8_t data[2];
-
-	ret = i2c_read_block(client, MICROP_I2C_RCMD_REMOTE_KEYCODE, data, 2);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s: read remote keycode fail\n",
-			 __func__);
-		return -EIO;
-	}
-	if (!data[1]) {
-		*keycode = 0;
-		return 1;		/* no keycode */
-	} else if (data[1] & 0x80) {
-		*keycode = 0x0;  /* release keycode */
-	} else {
-		*keycode = data[1];
-	}
-	return 0;
-}
-
-static ssize_t microp_i2c_remotekey_adc_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	struct i2c_client *client;
-	uint16_t value;
-	int i, button = 0;
-	int ret;
-
-	client = to_i2c_client(dev);
-
-	microp_read_adc(MICROP_REMOTE_KEY_ADC_CHAN, &value);
-
-	for (i = 0; i < 3; i += 2) {
-		if ((value > remote_key_adc_table[i]) &&
-		    (value < remote_key_adc_table[i])) {
-			button = i + 1;
-		}
-
-	}
-
-	ret = sprintf(buf, "Remote Key[0x%03X] => button %d\n",
-		      value, button);
-
-	return ret;
-}
-
-static DEVICE_ATTR(key_adc, 0644, microp_i2c_remotekey_adc_show, NULL);
-
-/*
- * LED support
-*/
-static int microp_i2c_write_led_mode(struct i2c_client *client,
-				struct led_classdev *led_cdev,
-				uint8_t mode, uint16_t off_timer)
-{
-	struct microp_i2c_client_data *cdata;
-	struct microp_led_data *ldata;
-	uint8_t data[7];
-	int ret;
-
-	cdata = i2c_get_clientdata(client);
-	ldata = container_of(led_cdev, struct microp_led_data, ldev);
-
-
-	if (ldata->type == GREEN_LED) {
-		data[0] = 0x01;
-		data[1] = mode;
-		data[2] = off_timer >> 8;
-		data[3] = off_timer & 0xFF;
-		data[4] = 0x00;
-		data[5] = 0x00;
-		data[6] = 0x00;
-	} else if (ldata->type == AMBER_LED) {
-		data[0] = 0x02;
-		data[1] = 0x00;
-		data[2] = 0x00;
-		data[3] = 0x00;
-		data[4] = mode;
-		data[5] = off_timer >> 8;
-		data[6] = off_timer & 0xFF;
-	}
-
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_LED_MODE, data, 7);
-	if (ret == 0) {
-		mutex_lock(&ldata->led_data_mutex);
-		if (mode > 1)
-			ldata->blink = mode;
-		else
-			ldata->mode = mode;
-		mutex_unlock(&ldata->led_data_mutex);
-	}
-	return ret;
-}
-
-static ssize_t microp_i2c_led_blink_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	struct led_classdev *led_cdev;
-	struct microp_led_data *ldata;
-	int ret;
-
-	led_cdev = (struct led_classdev *)dev_get_drvdata(dev);
-	ldata = container_of(led_cdev, struct microp_led_data, ldev);
-
-	mutex_lock(&ldata->led_data_mutex);
-	ret = sprintf(buf, "%d\n", ldata->blink ? ldata->blink - 1 : 0);
-	mutex_unlock(&ldata->led_data_mutex);
-
-	return ret;
-}
-
-static ssize_t microp_i2c_led_blink_store(struct device *dev,
-				   struct device_attribute *attr,
-				   const char *buf, size_t count)
-{
-	struct led_classdev *led_cdev;
-	struct microp_led_data *ldata;
-	struct i2c_client *client;
-	int val, ret;
-	uint8_t mode;
-
-	val = -1;
-	sscanf(buf, "%u", &val);
-
-	led_cdev = (struct led_classdev *)dev_get_drvdata(dev);
-	ldata = container_of(led_cdev, struct microp_led_data, ldev);
-	client = to_i2c_client(dev->parent);
-
-	mutex_lock(&ldata->led_data_mutex);
-	switch (val) {
-	case 0: /* stop flashing */
-		mode = ldata->mode;
-		ldata->blink = 0;
-		break;
-	case 1:
-	case 2:
-	case 3:
-		mode = val + 1;
-		break;
-
-	default:
-		mutex_unlock(&ldata->led_data_mutex);
-		return -EINVAL;
-	}
-	mutex_unlock(&ldata->led_data_mutex);
-
-	ret = microp_i2c_write_led_mode(client, led_cdev, mode, 0xffff);
-	if (ret)
-		dev_err(&client->dev, "%s set blink failed\n", led_cdev->name);
-
-	return count;
-}
-
-static DEVICE_ATTR(blink, 0644, microp_i2c_led_blink_show,
-				microp_i2c_led_blink_store);
-
-static ssize_t microp_i2c_led_off_timer_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	struct microp_i2c_client_data *cdata;
-	struct led_classdev *led_cdev;
-	struct microp_led_data *ldata;
-	struct i2c_client *client;
-	uint8_t data[2];
-	int ret, offtime;
-
-
-	led_cdev = (struct led_classdev *)dev_get_drvdata(dev);
-	ldata = container_of(led_cdev, struct microp_led_data, ldev);
-	client = to_i2c_client(dev->parent);
-	cdata = i2c_get_clientdata(client);
-
-	dev_info(&client->dev, "Getting %s remaining time\n", led_cdev->name);
-
-	if (ldata->type == GREEN_LED) {
-		ret = i2c_read_block(client,
-				MICROP_I2C_RCMD_GREEN_LED_REMAIN_TIME, data, 2);
-	} else if (ldata->type == AMBER_LED) {
-		ret = i2c_read_block(client,
-				MICROP_I2C_RCMD_AMBER_LED_REMAIN_TIME, data, 2);
-	} else {
-		dev_err(&client->dev, "Unknown led %s\n", ldata->ldev.name);
-		return -EINVAL;
-	}
-
-	if (ret) {
-		dev_err(&client->dev,
-			"%s get off_timer failed\n", led_cdev->name);
-	}
-	offtime = (int)((data[1] | data[0] << 8) * 2);
-
-	ret = sprintf(buf, "Time remains %d:%d\n", offtime / 60, offtime % 60);
-	return ret;
-}
-
-static ssize_t microp_i2c_led_off_timer_store(struct device *dev,
-				   struct device_attribute *attr,
-				   const char *buf, size_t count)
-{
-	struct led_classdev *led_cdev;
-	struct microp_led_data *ldata;
-	struct i2c_client *client;
-	int min, sec, ret;
-	uint16_t off_timer;
-
-	min = -1;
-	sec = -1;
-	sscanf(buf, "%d %d", &min, &sec);
-
-	if (min < 0 || min > 255)
-		return -EINVAL;
-	if (sec < 0 || sec > 255)
-		return -EINVAL;
-
-	led_cdev = (struct led_classdev *)dev_get_drvdata(dev);
-	ldata = container_of(led_cdev, struct microp_led_data, ldev);
-	client = to_i2c_client(dev->parent);
-
-	dev_info(&client->dev, "Setting %s off_timer to %d min %d sec\n",
-			led_cdev->name, min, sec);
-
-	if (!min && !sec)
-		off_timer = 0xFFFF;
-	else
-		off_timer = (min * 60 + sec) / 2;
-
-	ret = microp_i2c_write_led_mode(client, led_cdev,
-					ldata->mode, off_timer);
-	if (ret) {
-		dev_err(&client->dev,
-			"%s set off_timer %d min %d sec failed\n",
-			led_cdev->name, min, sec);
-	}
-	return count;
-}
-
-static DEVICE_ATTR(off_timer, 0644, microp_i2c_led_off_timer_show,
-			microp_i2c_led_off_timer_store);
-
-static void microp_led_brightness_set(struct led_classdev *led_cdev,
-			       enum led_brightness brightness)
-{
-	struct i2c_client *client;
-	int ret;
-	uint8_t mode;
-
-	client = to_i2c_client(led_cdev->dev->parent);
-
-	dev_info(&client->dev, "Setting %s brightness current %d new %d\n",
-			led_cdev->name, led_cdev->brightness, brightness);
-
-	if (brightness > 255)
-		brightness = 255;
-	led_cdev->brightness = brightness;
-
-	if (brightness)
-		mode = 1;
-	else
-		mode = 0;
-
-	ret = microp_i2c_write_led_mode(client, led_cdev, mode, 0xffff);
-	if (ret) {
-		dev_err(&client->dev,
-			 "led_brightness_set failed to set mode\n");
-	}
-}
-
-struct device_attribute *green_amber_attrs[] = {
-	&dev_attr_blink,
-	&dev_attr_off_timer,
-};
-
-static void microp_led_buttons_brightness_set(struct led_classdev *led_cdev,
-				enum led_brightness brightness)
-{
-	struct i2c_client *client;
-	uint8_t data[4] = {0, 0, 0};
-	int ret = 0;
-
-	client = to_i2c_client(led_cdev->dev->parent);
-
-	dev_info(&client->dev, "Setting buttons brightness current %d new %d\n",
-		 led_cdev->brightness, brightness);
-
-	/* in 40ms */
-	data[0] = 0x05;
-	/* duty cycle 0-255 */
-	data[1] = brightness >= 255 ? 0x20 : 0;
-	/* bit2 == change brightness */
-	data[3] = 0x04;
-
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_BUTTONS_LED_CTRL,
-			      data, 4);
-	if (ret < 0)
-		dev_err(&client->dev, "%s failed on set buttons\n", __func__);
-}
-
-static void microp_led_jogball_brightness_set(struct led_classdev *led_cdev,
-			       enum led_brightness brightness)
-{
-	struct i2c_client *client;
-	uint8_t data[3] = {0, 0, 0};
-	int ret = 0;
-
-	client = to_i2c_client(led_cdev->dev->parent);
-
-	dev_info(&client->dev, "Setting Jog brightness current %d new %d\n",
-			led_cdev->brightness, brightness);
-
-	switch (brightness) {
-	case 0:
-		data[0] = 0;
-		break;
-	case 3:
-		data[0] = 1;
-		data[1] = data[2] = 0xFF;
-		break;
-	case 7:
-		data[0] = 2;
-		data[1] = 0;
-		data[2] = 60;
-		break;
-	default:
-		dev_warn(&client->dev, "%s: unknown value: %d\n",
-			__func__, brightness);
-		break;
-	}
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_JOGBALL_LED_MODE,
-			      data, 3);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s failed on set jogball mode:0x%2.2X\n",
-				__func__, data[0]);
-	} else {
-		led_cdev->brightness = brightness;
-	}
-}
-
-/*
- * Light Sensor Support
- */
-static int microp_i2c_auto_backlight_mode(struct i2c_client *client,
-					    uint8_t enabled)
-{
-	uint8_t data[2];
-	int ret = 0;
-
-	data[0] = 0;
-	if (enabled)
-		data[1] = 1;
-	else
-		data[1] = 0;
-
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_AUTO_BL_CTL, data, 2);
-	if (ret != 0)
-		printk(KERN_ERR "%s: set auto light sensor fail\n", __func__);
-
-	return ret;
-}
-
-static int lightsensor_enable(void)
-{
-	struct i2c_client *client;
-	struct microp_i2c_client_data *cdata;
-	int ret;
-
-	client = private_microp_client;
-	cdata = i2c_get_clientdata(client);
-
-	if (cdata->microp_is_suspend) {
-		printk(KERN_ERR "%s: abort, uP is going to suspend after #\n",
-		       __func__);
-		return -EIO;
-	}
-
-	ret = microp_i2c_auto_backlight_mode(client, 1);
-	if (ret < 0)
-		printk(KERN_ERR "%s: set auto light sensor fail\n", __func__);
-	else
-		cdata->als_intr_enabled = 1;
-	return 0;
-}
-
-static int lightsensor_disable(void)
-{
-	/* update trigger data when done */
-	struct i2c_client *client;
-	struct microp_i2c_client_data *cdata;
-	int ret;
-
-	client = private_microp_client;
-	cdata = i2c_get_clientdata(client);
-
-	if (cdata->microp_is_suspend) {
-		printk(KERN_ERR "%s: abort, uP is going to suspend after #\n",
-		       __func__);
-		return -EIO;
-	}
-
-	ret = microp_i2c_auto_backlight_mode(client, 0);
-	if (ret < 0)
-		printk(KERN_ERR "%s: disable auto light sensor fail\n",
-		       __func__);
-	else
-		cdata->als_intr_enabled = 0;
-	return 0;
-}
-
-static int microp_lightsensor_read(uint16_t *adc_value,
-					  uint8_t *adc_level)
-{
-	struct i2c_client *client;
-	uint8_t i, level = 0;
-	int ret;
-
-	client = private_microp_client;
-
-	ret = microp_read_adc(MICROP_LSENSOR_ADC_CHAN, adc_value);
-	if (ret != 0)
-		return -1;
-
-	if (*adc_value > 0x3FF) {
-		printk(KERN_WARNING "%s: get wrong value: 0x%X\n",
-			__func__, *adc_value);
-		return -1;
-	} else {
-		for (i = 0; i < 10; i++) {
-			if (*adc_value <= lsensor_adc_table[i]) {
-				level = i;
-				break;
-			}
-		}
-		*adc_level = level;
-		printk(KERN_DEBUG "%s: ADC value: 0x%X, level: %d #\n",
-				__func__, *adc_value, *adc_level);
-	}
-
-	return 0;
-}
-
-static ssize_t microp_i2c_lightsensor_adc_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	uint8_t adc_level = 0;
-	uint16_t adc_value = 0;
-	int ret;
-
-	ret = microp_lightsensor_read(&adc_value, &adc_level);
-
-	ret = sprintf(buf, "ADC[0x%03X] => level %d\n", adc_value, adc_level);
-
-	return ret;
-}
-
-static DEVICE_ATTR(ls_adc, 0644, microp_i2c_lightsensor_adc_show, NULL);
-
-static ssize_t microp_i2c_ls_auto_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	struct i2c_client *client;
-	uint8_t data[2] = {0, 0};
-	int ret;
-
-	client = to_i2c_client(dev);
-
-	i2c_read_block(client, MICROP_I2C_RCMD_SPI_BL_STATUS, data, 2);
-	ret = sprintf(buf, "Light sensor Auto = %d, SPI enable = %d\n",
-			data[0], data[1]);
-
-	return ret;
-}
-
-static ssize_t microp_i2c_ls_auto_store(struct device *dev,
-				   struct device_attribute *attr,
-				   const char *buf, size_t count)
-{
-	struct i2c_client *client;
-	struct microp_i2c_client_data *cdata;
-	uint8_t enable = 0;
-	int ls_auto;
-
-	ls_auto = -1;
-	sscanf(buf, "%d", &ls_auto);
-
-	if (ls_auto < 0 || ls_auto > 1)
-		return -EINVAL;
-
-	client = to_i2c_client(dev);
-	cdata = i2c_get_clientdata(client);
-
-	if (ls_auto) {
-		enable = 1;
-		cdata->als_intr_enabled = 1;
-	} else {
-		enable = 0;
-		cdata->als_intr_enabled = 0;
-	}
-
-	microp_i2c_auto_backlight_mode(client, enable);
-
-	return count;
-}
-
-static DEVICE_ATTR(ls_auto, 0644,  microp_i2c_ls_auto_show,
-			microp_i2c_ls_auto_store);
-
-DEFINE_MUTEX(mahimahi_microp_api_lock);
-static int lightsensor_opened;
-
-static int lightsensor_open(struct inode *inode, struct file *file)
-{
-	int rc = 0;
-	pr_info("%s\n", __func__);
-	mutex_lock(&mahimahi_microp_api_lock);
-	if (lightsensor_opened) {
-		pr_err("%s: already opened\n", __func__);
-		rc = -EBUSY;
-	}
-	lightsensor_opened = 1;
-	mutex_unlock(&mahimahi_microp_api_lock);
-	return rc;
-}
-
-static int lightsensor_release(struct inode *inode, struct file *file)
-{
-	pr_info("%s\n", __func__);
-	mutex_lock(&mahimahi_microp_api_lock);
-	lightsensor_opened = 0;
-	mutex_unlock(&mahimahi_microp_api_lock);
-	return 0;
-}
-
-static long lightsensor_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
-{
-	int rc, val;
-	struct i2c_client *client;
-	struct microp_i2c_client_data *cdata;
-
-	mutex_lock(&mahimahi_microp_api_lock);
-
-	client = private_microp_client;
-	cdata = i2c_get_clientdata(client);
-
-	pr_info("%s cmd %d\n", __func__, _IOC_NR(cmd));
-
-	switch (cmd) {
-	case LIGHTSENSOR_IOCTL_ENABLE:
-		if (get_user(val, (unsigned long __user *)arg)) {
-			rc = -EFAULT;
-			break;
-		}
-		rc = val ? lightsensor_enable() : lightsensor_disable();
-		break;
-	case LIGHTSENSOR_IOCTL_GET_ENABLED:
-		val = cdata->als_intr_enabled;
-		pr_info("%s enabled %d\n", __func__, val);
-		rc = put_user(val, (unsigned long __user *)arg);
-		break;
-	default:
-		pr_err("%s: invalid cmd %d\n", __func__, _IOC_NR(cmd));
-		rc = -EINVAL;
-	}
-
-	mutex_unlock(&mahimahi_microp_api_lock);
-	return rc;
-}
-
-static struct file_operations lightsensor_fops = {
-	.owner = THIS_MODULE,
-	.open = lightsensor_open,
-	.release = lightsensor_release,
-	.unlocked_ioctl = lightsensor_ioctl
-};
-
-static struct miscdevice lightsensor_misc = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "lightsensor",
-	.fops = &lightsensor_fops
-};
-
-/*
- * G-sensor
- */
-static int microp_spi_enable(uint8_t on)
-{
-	struct i2c_client *client;
-	int ret;
-
-	client = private_microp_client;
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_SPI_EN, &on, 1);
-	if (ret < 0) {
-		dev_err(&client->dev,"%s: i2c_write_block fail\n", __func__);
-		return ret;
-	}
-	msleep(10);
-	return ret;
-}
-
-static int gsensor_read_reg(uint8_t reg, uint8_t *data)
-{
-	struct i2c_client *client;
-	int ret;
-	uint8_t tmp[2];
-
-	client = private_microp_client;
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_GSENSOR_REG_DATA_REQ,
-			      &reg, 1);
-	if (ret < 0) {
-		dev_err(&client->dev,"%s: i2c_write_block fail\n", __func__);
-		return ret;
-	}
-	msleep(10);
-
-	ret = i2c_read_block(client, MICROP_I2C_RCMD_GSENSOR_REG_DATA, tmp, 2);
-	if (ret < 0) {
-		dev_err(&client->dev,"%s: i2c_read_block fail\n", __func__);
-		return ret;
-	}
-	*data = tmp[1];
-	return ret;
-}
-
-static int gsensor_write_reg(uint8_t reg, uint8_t data)
-{
-	struct i2c_client *client;
-	int ret;
-	uint8_t tmp[2];
-
-	client = private_microp_client;
-
-	tmp[0] = reg;
-	tmp[1] = data;
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_GSENSOR_REG, tmp, 2);
-	if (ret < 0) {
-		dev_err(&client->dev,"%s: i2c_write_block fail\n", __func__);
-		return ret;
-	}
-
-	return ret;
-}
-
-static int gsensor_read_acceleration(short *buf)
-{
-	struct i2c_client *client;
-	int ret;
-	uint8_t tmp[6];
-	struct microp_i2c_client_data *cdata;
-
-	client = private_microp_client;
-
-	cdata = i2c_get_clientdata(client);
-
-	tmp[0] = 1;
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_GSENSOR_DATA_REQ,
-			      tmp, 1);
-	if (ret < 0) {
-		dev_err(&client->dev,"%s: i2c_write_block fail\n", __func__);
-		return ret;
-	}
-
-	msleep(10);
-
-	if (cdata->version <= 0x615) {
-		/*
-		 * Note the data is a 10bit signed value from the chip.
-		*/
-		ret = i2c_read_block(client, MICROP_I2C_RCMD_GSENSOR_X_DATA,
-				     tmp, 2);
-		if (ret < 0) {
-			dev_err(&client->dev, "%s: i2c_read_block fail\n",
-				__func__);
-			return ret;
-		}
-		buf[0] = (short)(tmp[0] << 8 | tmp[1]);
-		buf[0] >>= 6;
-
-		ret = i2c_read_block(client, MICROP_I2C_RCMD_GSENSOR_Y_DATA,
-				     tmp, 2);
-		if (ret < 0) {
-			dev_err(&client->dev, "%s: i2c_read_block fail\n",
-				__func__);
-			return ret;
-		}
-		buf[1] = (short)(tmp[0] << 8 | tmp[1]);
-		buf[1] >>= 6;
-
-		ret = i2c_read_block(client, MICROP_I2C_RCMD_GSENSOR_Z_DATA,
-				     tmp, 2);
-		if (ret < 0) {
-			dev_err(&client->dev, "%s: i2c_read_block fail\n",
-				__func__);
-			return ret;
-		}
-		buf[2] = (short)(tmp[0] << 8 | tmp[1]);
-		buf[2] >>= 6;
-	} else {
-		ret = i2c_read_block(client, MICROP_I2C_RCMD_GSENSOR_DATA,
-				     tmp, 6);
-		buf[0] = (short)(tmp[0] << 8 | tmp[1]);
-		buf[0] >>= 6;
-		buf[1] = (short)(tmp[2] << 8 | tmp[3]);
-		buf[1] >>= 6;
-		buf[2] = (short)(tmp[4] << 8 | tmp[5]);
-		buf[2] >>= 6;
-	}
-
-	pr_debug("%s x = %x y = %x, z = %x\n", __func__,
-	       buf[0], buf[1], buf[2]);
-
-	return 1;
-}
-
-static int gsensor_init_hw(void)
-{
-	uint8_t reg;
-	int ret;
-
-	pr_debug("%s\n", __func__);
-
-	microp_spi_enable(1);
-
-	ret = gsensor_read_reg(RANGE_BWIDTH_REG, &reg);
-	if (ret < 0 )
-		return -EIO;
-	reg &= 0xe0;
-	ret = gsensor_write_reg(RANGE_BWIDTH_REG, reg);
-	if (ret < 0 )
-		return -EIO;
-
-	ret = gsensor_read_reg(SMB150_CONF2_REG, &reg);
-	if (ret < 0 )
-		return -EIO;
-	reg |= (1 << 3);
-	ret = gsensor_write_reg(SMB150_CONF2_REG, reg);
-
-	return ret;
-}
-
-static int bma150_set_mode(char mode)
-{
-	uint8_t reg;
-	int ret;
-
-	pr_debug("%s mode = %d\n", __func__, mode);
-	if (mode == BMA_MODE_NORMAL)
-		microp_spi_enable(1);
-
-
-	ret = gsensor_read_reg(SMB150_CTRL_REG, &reg);
-	if (ret < 0 )
-		return -EIO;
-	reg = (reg & 0xfe) | mode;
-	ret = gsensor_write_reg(SMB150_CTRL_REG, reg);
-
-	if (mode == BMA_MODE_SLEEP)
-		microp_spi_enable(0);
-
-	return ret;
-}
-static int gsensor_read(uint8_t *data)
-{
-	int ret;
-	uint8_t reg = data[0];
-
-	ret = gsensor_read_reg(reg, &data[1]);
-	pr_debug("%s reg = %x data = %x\n", __func__, reg, data[1]);
-	return ret;
-}
-
-static int gsensor_write(uint8_t *data)
-{
-	int ret;
-	uint8_t reg = data[0];
-
-	pr_debug("%s reg = %x data = %x\n", __func__, reg, data[1]);
-	ret = gsensor_write_reg(reg, data[1]);
-	return ret;
-}
-
-static int bma150_open(struct inode *inode, struct file *file)
-{
-	pr_debug("%s\n", __func__);
-	return nonseekable_open(inode, file);
-}
-
-static int bma150_release(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static int bma150_ioctl(struct inode *inode, struct file *file,
-			unsigned int cmd, unsigned long arg)
-{
-	void __user *argp = (void __user *)arg;
-	char rwbuf[8];
-	int ret = -1;
-	short buf[8], temp;
-
-	switch (cmd) {
-	case BMA_IOCTL_READ:
-	case BMA_IOCTL_WRITE:
-	case BMA_IOCTL_SET_MODE:
-		if (copy_from_user(&rwbuf, argp, sizeof(rwbuf)))
-			return -EFAULT;
-		break;
-	case BMA_IOCTL_READ_ACCELERATION:
-		if (copy_from_user(&buf, argp, sizeof(buf)))
-			return -EFAULT;
-		break;
-	default:
-		break;
-	}
-
-	switch (cmd) {
-	case BMA_IOCTL_INIT:
-		ret = gsensor_init_hw();
-		if (ret < 0)
-			return ret;
-		break;
-
-	case BMA_IOCTL_READ:
-		if (rwbuf[0] < 1)
-			return -EINVAL;
-		ret = gsensor_read(rwbuf);
-		if (ret < 0)
-			return ret;
-		break;
-	case BMA_IOCTL_WRITE:
-		if (rwbuf[0] < 2)
-			return -EINVAL;
-		ret = gsensor_write(rwbuf);
-		if (ret < 0)
-			return ret;
-		break;
-	case BMA_IOCTL_READ_ACCELERATION:
-		ret = gsensor_read_acceleration(&buf[0]);
-		if (ret < 0)
-			return ret;
-		break;
-	case BMA_IOCTL_SET_MODE:
-		bma150_set_mode(rwbuf[0]);
-		break;
-	case BMA_IOCTL_GET_INT:
-		temp = 0;
-		break;
-	default:
-		return -ENOTTY;
-	}
-
-	switch (cmd) {
-	case BMA_IOCTL_READ:
-		if (copy_to_user(argp, &rwbuf, sizeof(rwbuf)))
-			return -EFAULT;
-		break;
-	case BMA_IOCTL_READ_ACCELERATION:
-		if (copy_to_user(argp, &buf, sizeof(buf)))
-			return -EFAULT;
-		break;
-	case BMA_IOCTL_GET_INT:
-		if (copy_to_user(argp, &temp, sizeof(temp)))
-			return -EFAULT;
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static struct file_operations bma_fops = {
-	.owner = THIS_MODULE,
-	.open = bma150_open,
-	.release = bma150_release,
-	.ioctl = bma150_ioctl,
-};
-
-static struct miscdevice spi_bma_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = BMA150_G_SENSOR_NAME,
-	.fops = &bma_fops,
-};
-
-/*
- * Interrupt
- */
-static irqreturn_t microp_i2c_intr_irq_handler(int irq, void *dev_id)
-{
-	struct i2c_client *client;
-	struct microp_i2c_client_data *cdata;
-
-	client = to_i2c_client(dev_id);
-	cdata = i2c_get_clientdata(client);
-
-	dev_dbg(&client->dev, "intr_irq_handler\n");
-
-	disable_irq_nosync(client->irq);
-	schedule_work(&cdata->work.work);
-	return IRQ_HANDLED;
-}
-
-static void microp_i2c_intr_work_func(struct work_struct *work)
-{
-	struct microp_i2c_work *up_work;
-	struct i2c_client *client;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[3], node = 0, adc_level;
-	uint16_t intr_status = 0, adc_value, gpi_status = 0;
-	int insert = 0, keycode = 0, ret = 0;
-
-	up_work = container_of(work, struct microp_i2c_work, work);
-	client = up_work->client;
-	cdata = i2c_get_clientdata(client);
-
-	ret = i2c_read_block(client, MICROP_I2C_RCMD_GPI_INT_STATUS, data, 2);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s: read interrupt status fail\n",
-			 __func__);
-	}
-	msleep(1);
-	intr_status = data[0]<<8 | data[1];
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_GPI_INT_STATUS_CLR,
-			      data, 2);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s: clear interrupt status fail\n",
-			 __func__);
-	}
-	printk(KERN_DEBUG "intr_status=0x%02x\n", intr_status);
-	msleep(1);
-	if (intr_status & IRQ_LSENSOR) {
-		ret = microp_lightsensor_read(&adc_value, &adc_level);
-		input_report_abs(cdata->ls_input_dev, ABS_MISC, (int)adc_level);
-		input_sync(cdata->ls_input_dev);
-	}
-
-	if (intr_status & IRQ_SDCARD) {
-		microp_read_gpi_status(client, &gpi_status);
-		mahimahi_microp_sdslot_update_status(gpi_status);
-	}
-
-	if (intr_status & IRQ_HEADSETIN) {
-		wake_lock_timeout(&microp_i2c_wakelock, 3*HZ);
-		if (!cdata->headset_is_in)
-			schedule_delayed_work(&cdata->hpin_debounce_work,
-					msecs_to_jiffies(500));
-		else
-			schedule_delayed_work(&cdata->hpin_debounce_work,
-					msecs_to_jiffies(300));
-	}
-#if 0
-	if (intr_status & IRQ_REMOTEKEY) {
-		node = pdata->function_node[MICROP_FUNCTION_REMOTEKEY];
-		if (get_remote_keycode(data) == 0) {
-			keycode = (int)datla[1];
-			cnf_driver_event("H2W_3button", &keycode);
-		}
-	}
-#endif
-	enable_irq(client->irq);
-}
-
-static int microp_function_initialize(struct i2c_client *client)
-{
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	uint16_t stat, interrupts = 0;
-	int i;
-	int ret;
-
-	cdata = i2c_get_clientdata(client);
-
-	/* Light Sensor */
-	for (i = 0; i < 10; i++) {
-		data[i] = (uint8_t)(lsensor_adc_table[i] >> 8);
-		data[i + 10] = (uint8_t)(lsensor_adc_table[i]);
-	}
-	ret = i2c_write_block(client, MICROP_I2C_WCMD_ADC_TABLE, data, 20);
-	if (ret)
-		goto exit;
-
-	ret = gpio_request(MAHIMAHI_GPIO_LS_EN_N, "microp_i2c");
-	if (ret < 0) {
-		dev_err(&client->dev, "failed on request gpio ls_on\n");
-		goto exit;
-	}
-	ret = gpio_direction_output(MAHIMAHI_GPIO_LS_EN_N, 0);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed on gpio_direction_output"
-				"ls_on\n");
-		goto err_gpio_ls;
-	}
-	cdata->light_sensor_enabled = 1;
-
-	/* Headset */
-	for (i = 0; i < 6; i++) {
-		data[i] = (uint8_t)(remote_key_adc_table[i] >> 8);
-		data[i + 6] = (uint8_t)(remote_key_adc_table[i]);
-	}
-	ret = i2c_write_block(client,
-		MICROP_I2C_WCMD_REMOTEKEY_TABLE, data, 12);
-	if (ret)
-		goto exit;
-
-	INIT_DELAYED_WORK(
-		&cdata->hpin_debounce_work, hpin_debounce_do_work);
-
-	/* SD Card */
-	interrupts |= IRQ_SDCARD;
-
-	/* enable the interrupts */
-	ret = microp_interrupt_enable(client, interrupts);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s: failed to enable gpi irqs\n",
-			__func__);
-		goto err_irq_en;
-	}
-
-	microp_read_gpi_status(client, &stat);
-	mahimahi_microp_sdslot_update_status(stat);
-
-	return 0;
-
-err_irq_en:
-err_gpio_ls:
-	gpio_free(MAHIMAHI_GPIO_LS_EN_N);
-exit:
-	return ret;
-}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void microp_early_suspend(struct early_suspend *h)
-{
-	struct microp_i2c_client_data *cdata;
-	struct i2c_client *client = private_microp_client;
-	int ret;
-
-	if (!client) {
-		printk(KERN_ERR "%s: dataset: client is empty\n", __func__);
-		return;
-	}
-	cdata = i2c_get_clientdata(client);
-
-	cdata->microp_is_suspend = 1;
-
-	disable_irq(client->irq);
-	ret = cancel_work_sync(&cdata->work.work);
-	if (ret != 0) {
-		enable_irq(client->irq);
-	}
-
-	if (cdata->als_intr_enabled)
-		microp_i2c_auto_backlight_mode(client, 0);
-	if (cdata->light_sensor_enabled == 1) {
-		gpio_set_value(MAHIMAHI_GPIO_LS_EN_N, 1);
-		cdata->light_sensor_enabled = 0;
-	}
-}
-
-static void microp_early_resume(struct early_suspend *h)
-{
-	struct i2c_client *client = private_microp_client;
-	struct microp_i2c_client_data *cdata;
-
-	if (!client) {
-		printk(KERN_ERR "%s: dataset: client is empty\n", __func__);
-		return;
-	}
-	cdata = i2c_get_clientdata(client);
-
-	gpio_set_value(MAHIMAHI_GPIO_LS_EN_N, 0);
-	cdata->light_sensor_enabled = 1;
-
-	if (cdata->als_intr_enabled)
-		microp_i2c_auto_backlight_mode(client, 1);
-
-	cdata->microp_is_suspend = 0;
-	enable_irq(client->irq);
-}
-#endif
-
-static int microp_i2c_suspend(struct i2c_client *client,
-	pm_message_t mesg)
-{
-	return 0;
-}
-
-static int microp_i2c_resume(struct i2c_client *client)
-{
-	return 0;
-}
-
-static struct {
-	const char *name;
-	void (*led_set)(struct led_classdev *, enum led_brightness);
-	struct device_attribute **attrs;
-	int attr_cnt;
-} microp_leds[] = {
-	[GREEN_LED] = {
-		.name		= "green",
-		.led_set	= microp_led_brightness_set,
-		.attrs		= green_amber_attrs,
-		.attr_cnt	= ARRAY_SIZE(green_amber_attrs)
-	},
-	[AMBER_LED] = {
-		.name		= "amber",
-		.led_set	= microp_led_brightness_set,
-		.attrs		= green_amber_attrs,
-		.attr_cnt	= ARRAY_SIZE(green_amber_attrs)
-	},
-	[JOGBALL_LED] = {
-		.name		= "jogball-backlight",
-		.led_set	= microp_led_jogball_brightness_set,
-	},
-	[BUTTONS_LED] = {
-		.name		= "button-backlight",
-		.led_set	= microp_led_buttons_brightness_set,
-	},
-};
-
-static int microp_i2c_probe(struct i2c_client *client,
-			    const struct i2c_device_id *id)
-{
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[6];
-	int ret;
-	int i;
-	int j;
-
-	private_microp_client = client;
-	ret = i2c_read_block(client, MICROP_I2C_RCMD_VERSION, data, 2);
-	if (ret || !(data[0] && data[1])) {
-		ret = -ENODEV;
-		dev_err(&client->dev, "failed on get microp version\n");
-		goto err_exit;
-	}
-	dev_info(&client->dev, "microp version [%02X][%02X]\n",
-		  data[0], data[1]);
-
-	ret = gpio_request(MAHIMAHI_GPIO_UP_RESET_N, "microp_i2c_wm");
-	if (ret < 0) {
-		dev_err(&client->dev, "failed on request gpio reset\n");
-		goto err_exit;
-	}
-	ret = gpio_direction_output(MAHIMAHI_GPIO_UP_RESET_N, 1);
-	if (ret < 0) {
-		dev_err(&client->dev,
-			 "failed on gpio_direction_output reset\n");
-		goto err_gpio_reset;
-	}
-
-	cdata = kzalloc(sizeof(struct microp_i2c_client_data), GFP_KERNEL);
-	if (!cdata) {
-		ret = -ENOMEM;
-		dev_err(&client->dev, "failed on allocat cdata\n");
-		goto err_cdata;
-	}
-
-	i2c_set_clientdata(client, cdata);
-	cdata->version = data[0] << 8 | data[1];
-	cdata->microp_is_suspend = 0;
-	cdata->als_intr_enabled = 0;
-	cdata->light_sensor_enabled = 0;
-
-	wake_lock_init(&microp_i2c_wakelock, WAKE_LOCK_SUSPEND,
-			 "microp_i2c_present");
-
-	/* Light Sensor */
-	ret = device_create_file(&client->dev, &dev_attr_ls_adc);
-	ret = device_create_file(&client->dev, &dev_attr_ls_auto);
-	cdata->ls_input_dev = input_allocate_device();
-	if (!cdata->ls_input_dev) {
-		pr_err("%s: could not allocate input device\n", __func__);
-		ret = -ENOMEM;
-		goto err_request_input_dev;
-	}
-	cdata->ls_input_dev->name = "lightsensor-level";
-	set_bit(EV_ABS, cdata->ls_input_dev->evbit);
-	input_set_abs_params(cdata->ls_input_dev, ABS_MISC, 0, 9, 0, 0);
-
-	ret = input_register_device(cdata->ls_input_dev);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s: can not register input device\n",
-				__func__);
-		goto err_register_input_dev;
-	}
-
-	ret = misc_register(&lightsensor_misc);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s: can not register misc device\n",
-				__func__);
-		goto err_register_misc_register;
-	}
-
-	/* LEDs */
-	ret = 0;
-	for (i = 0; i < ARRAY_SIZE(microp_leds) && !ret; ++i) {
-		struct microp_led_data *ldata = &cdata->leds[i];
-
-		ldata->type = i;
-		ldata->ldev.name = microp_leds[i].name;
-		ldata->ldev.brightness_set = microp_leds[i].led_set;
-		mutex_init(&ldata->led_data_mutex);
-		ret = led_classdev_register(&client->dev, &ldata->ldev);
-		if (ret) {
-			ldata->ldev.name = NULL;
-			break;
-		}
-
-		for (j = 0; j < microp_leds[i].attr_cnt && !ret; ++j)
-			ret = device_create_file(ldata->ldev.dev,
-						 microp_leds[i].attrs[j]);
-	}
-	if (ret) {
-		dev_err(&client->dev, "failed to add leds\n");
-		goto err_add_leds;
-	}
-
-	/* Headset */
-	cdata->headset_is_in = 0;
-	platform_device_register(&mahimahi_h35mm);
-
-	ret = device_create_file(&client->dev, &dev_attr_key_adc);
-
-	/* G-sensor */
-	ret = misc_register(&spi_bma_device);
-	if (ret < 0) {
-		printk(KERN_ERR "%s: init bma150 misc_register fail\n",
-				__func__);
-		goto err_register_bma150;
-	}
-
-	/* Setup IRQ handler */
-	INIT_WORK(&cdata->work.work, microp_i2c_intr_work_func);
-	cdata->work.client = client;
-
-	ret = request_irq(client->irq,
-			microp_i2c_intr_irq_handler,
-			IRQF_TRIGGER_LOW,
-			"microp_interrupt",
-			&client->dev);
-	if (ret) {
-		dev_err(&client->dev, "request_irq failed\n");
-		goto err_intr;
-	}
-	ret = set_irq_wake(client->irq, 1);
-	if (ret) {
-		dev_err(&client->dev, "set_irq_wake failed\n");
-		goto err_intr;
-	}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	if (cdata->enable_early_suspend) {
-		cdata->early_suspend.level =
-				EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
-		cdata->early_suspend.suspend = microp_early_suspend;
-		cdata->early_suspend.resume = microp_early_resume;
-		register_early_suspend(&cdata->early_suspend);
-	}
-#endif
-
-	ret = microp_function_initialize(client);
-	if (ret) {
-		dev_err(&client->dev, "failed on microp function initialize\n");
-		goto err_fun_init;
-	}
-
-	return 0;
-
-err_fun_init:
-err_intr:
-	misc_deregister(&spi_bma_device);
-
-err_register_bma150:
-	platform_device_unregister(&mahimahi_h35mm);
-	device_remove_file(&client->dev, &dev_attr_key_adc);
-
-err_add_leds:
-	for (i = 0; i < ARRAY_SIZE(microp_leds); ++i) {
-		if (!cdata->leds[i].ldev.name)
-			continue;
-		led_classdev_unregister(&cdata->leds[i].ldev);
-		for (j = 0; j < microp_leds[i].attr_cnt; ++j)
-			device_remove_file(cdata->leds[i].ldev.dev,
-					   microp_leds[i].attrs[j]);
-	}
-
-	misc_deregister(&lightsensor_misc);
-
-err_register_misc_register:
-	input_unregister_device(cdata->ls_input_dev);
-
-err_register_input_dev:
-	input_free_device(cdata->ls_input_dev);
-
-err_request_input_dev:
-	wake_lock_destroy(&microp_i2c_wakelock);
-	device_remove_file(&client->dev, &dev_attr_ls_adc);
-	device_remove_file(&client->dev, &dev_attr_ls_auto);
-	kfree(cdata);
-	i2c_set_clientdata(client, NULL);
-
-err_cdata:
-err_gpio_reset:
-	gpio_free(MAHIMAHI_GPIO_UP_RESET_N);
-err_exit:
-	return ret;
-}
-
-static int __devexit microp_i2c_remove(struct i2c_client *client)
-{
-	struct microp_i2c_client_data *cdata;
-	int i;
-	int j;
-
-	cdata = i2c_get_clientdata(client);
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	if (cdata->enable_early_suspend) {
-		unregister_early_suspend(&cdata->early_suspend);
-	}
-#endif
-
-	for (i = 0; i < ARRAY_SIZE(microp_leds); ++i) {
-		if (!cdata->leds[i].ldev.name)
-			continue;
-		led_classdev_unregister(&cdata->leds[i].ldev);
-		for (j = 0; j < microp_leds[i].attr_cnt; ++j)
-			device_remove_file(cdata->leds[i].ldev.dev,
-					   microp_leds[i].attrs[j]);
-	}
-
-	free_irq(client->irq, &client->dev);
-
-	gpio_free(MAHIMAHI_GPIO_UP_RESET_N);
-
-	misc_deregister(&lightsensor_misc);
-	input_unregister_device(cdata->ls_input_dev);
-	input_free_device(cdata->ls_input_dev);
-	device_remove_file(&client->dev, &dev_attr_ls_adc);
-	device_remove_file(&client->dev, &dev_attr_key_adc);
-	device_remove_file(&client->dev, &dev_attr_ls_auto);
-
-	platform_device_unregister(&mahimahi_h35mm);
-
-	/* G-sensor */
-	misc_deregister(&spi_bma_device);
-
-	kfree(cdata);
-
-	return 0;
-}
-
-static const struct i2c_device_id microp_i2c_id[] = {
-	{ MICROP_I2C_NAME, 0 },
-	{ }
-};
-
-static struct i2c_driver microp_i2c_driver = {
-	.driver = {
-		   .name = MICROP_I2C_NAME,
-		   },
-	.id_table = microp_i2c_id,
-	.probe = microp_i2c_probe,
-	.suspend = microp_i2c_suspend,
-	.resume = microp_i2c_resume,
-	.remove = __devexit_p(microp_i2c_remove),
-};
-
-
-static int __init microp_i2c_init(void)
-{
-	return i2c_add_driver(&microp_i2c_driver);
-}
-
-static void __exit microp_i2c_exit(void)
-{
-	i2c_del_driver(&microp_i2c_driver);
-}
-
-module_init(microp_i2c_init);
-module_exit(microp_i2c_exit);
-
-MODULE_AUTHOR("Eric Olsen <eolsen@android.com>");
-MODULE_DESCRIPTION("MicroP I2C driver");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-mahimahi-mmc.c b/arch/arm/mach-msm/board-mahimahi-mmc.c
deleted file mode 100644
index a986761..0000000
--- a/arch/arm/mach-msm/board-mahimahi-mmc.c
+++ /dev/null
@@ -1,407 +0,0 @@
-/* linux/arch/arm/mach-msm/board-mahimahi-mmc.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/debugfs.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-
-#include "board-mahimahi.h"
-#include "devices.h"
-#include "proc_comm.h"
-
-#undef MAHIMAHI_DEBUG_MMC
-
-static bool opt_disable_sdcard;
-static int __init mahimahi_disablesdcard_setup(char *str)
-{
-	opt_disable_sdcard = (bool)simple_strtol(str, NULL, 0);
-	return 1;
-}
-
-__setup("board_mahimahi.disable_sdcard=", mahimahi_disablesdcard_setup);
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static struct vreg	*sdslot_vreg;
-static uint32_t		sdslot_vdd = 0xffffffff;
-static uint32_t		sdslot_vreg_enabled;
-
-static struct {
-	int mask;
-	int level;
-} mmc_vdd_table[] = {
-	{ MMC_VDD_165_195,	1800 },
-	{ MMC_VDD_20_21,	2050 },
-	{ MMC_VDD_21_22,	2150 },
-	{ MMC_VDD_22_23,	2250 },
-	{ MMC_VDD_23_24,	2350 },
-	{ MMC_VDD_24_25,	2450 },
-	{ MMC_VDD_25_26,	2550 },
-	{ MMC_VDD_26_27,	2650 },
-	{ MMC_VDD_27_28,	2750 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2950 },
-};
-
-static uint32_t mahimahi_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-	int ret;
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(sdslot_vreg);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		ret = vreg_enable(sdslot_vreg);
-		if (ret)
-			pr_err("%s: Error enabling vreg (%d)\n", __func__, ret);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask != (1 << vdd))
-			continue;
-		ret = vreg_set_level(sdslot_vreg, mmc_vdd_table[i].level);
-		if (ret)
-			pr_err("%s: Error setting level (%d)\n", __func__, ret);
-		return 0;
-	}
-
-	pr_err("%s: Invalid VDD (%d) specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int mahimahi_sdslot_status_rev0(struct device *dev)
-{
-	return !gpio_get_value(MAHIMAHI_GPIO_SDMC_CD_REV0_N);
-}
-
-#define MAHIMAHI_MMC_VDD	(MMC_VDD_165_195 | MMC_VDD_20_21 | \
-				 MMC_VDD_21_22  | MMC_VDD_22_23 | \
-				 MMC_VDD_23_24 | MMC_VDD_24_25 | \
-				 MMC_VDD_25_26 | MMC_VDD_26_27 | \
-				 MMC_VDD_27_28 | MMC_VDD_28_29 | \
-				 MMC_VDD_29_30)
-
-int mahimahi_microp_sdslot_status_register(void (*cb)(int, void *), void *);
-unsigned int mahimahi_microp_sdslot_status(struct device *);
-
-static struct mmc_platform_data mahimahi_sdslot_data = {
-	.ocr_mask		= MAHIMAHI_MMC_VDD,
-	.status			= mahimahi_microp_sdslot_status,
-	.register_status_notify	= mahimahi_microp_sdslot_status_register,
-	.translate_vdd		= mahimahi_sdslot_switchvdd,
-};
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data mahimahi_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-
-static int mahimahi_wifi_cd = 0; /* WIFI virtual 'card detect' status */
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int mahimahi_wifi_status_register(
-			void (*callback)(int card_present, void *dev_id),
-			void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int mahimahi_wifi_status(struct device *dev)
-{
-	return mahimahi_wifi_cd;
-}
-
-static struct mmc_platform_data mahimahi_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= mahimahi_wifi_status,
-	.register_status_notify	= mahimahi_wifi_status_register,
-	.embedded_sdio		= &mahimahi_wifi_emb_data,
-};
-
-int mahimahi_wifi_set_carddetect(int val)
-{
-	pr_info("%s: %d\n", __func__, val);
-	mahimahi_wifi_cd = val;
-	if (wifi_status_cb) {
-		wifi_status_cb(val, wifi_status_cb_devid);
-	} else
-		pr_warning("%s: Nobody to notify\n", __func__);
-	return 0;
-}
-
-static int mahimahi_wifi_power_state;
-
-int mahimahi_wifi_power(int on)
-{
-	printk("%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-
-	mdelay(100);
-	gpio_set_value(MAHIMAHI_GPIO_WIFI_SHUTDOWN_N, on); /* WIFI_SHUTDOWN */
-	mdelay(200);
-
-	mahimahi_wifi_power_state = on;
-	return 0;
-}
-
-static int mahimahi_wifi_reset_state;
-
-int mahimahi_wifi_reset(int on)
-{
-	printk("%s: do nothing\n", __func__);
-	mahimahi_wifi_reset_state = on;
-	return 0;
-}
-
-int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-		 unsigned int stat_irq, unsigned long stat_irq_flags);
-
-int __init mahimahi_init_mmc(unsigned int sys_rev, unsigned debug_uart)
-{
-	uint32_t id;
-
-	printk("%s()+\n", __func__);
-
-	/* initial WIFI_SHUTDOWN# */
-	id = PCOM_GPIO_CFG(MAHIMAHI_GPIO_WIFI_SHUTDOWN_N, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	msm_add_sdcc(1, &mahimahi_wifi_data, 0, 0);
-
-	if (debug_uart) {
-		pr_info("%s: sdcard disabled due to debug uart\n", __func__);
-		goto done;
-	}
-	if (opt_disable_sdcard) {
-		pr_info("%s: sdcard disabled on cmdline\n", __func__);
-		goto done;
-	}
-
-	sdslot_vreg_enabled = 0;
-
-	sdslot_vreg = vreg_get(0, "gp6");
-	if (IS_ERR(sdslot_vreg))
-		return PTR_ERR(sdslot_vreg);
-
-	if (system_rev > 0)
-		msm_add_sdcc(2, &mahimahi_sdslot_data, 0, 0);
-	else {
-		mahimahi_sdslot_data.status = mahimahi_sdslot_status_rev0;
-		mahimahi_sdslot_data.register_status_notify = NULL;
-		set_irq_wake(MSM_GPIO_TO_INT(MAHIMAHI_GPIO_SDMC_CD_REV0_N), 1);
-		msm_add_sdcc(2, &mahimahi_sdslot_data,
-			     MSM_GPIO_TO_INT(MAHIMAHI_GPIO_SDMC_CD_REV0_N),
-			     IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-	}
-
-done:
-	printk("%s()-\n", __func__);
-	return 0;
-}
-
-#if defined(MAHIMAHI_DEBUG_MMC) && defined(CONFIG_DEBUG_FS)
-
-static int mahimahimmc_dbg_wifi_reset_set(void *data, u64 val)
-{
-	mahimahi_wifi_reset((int) val);
-	return 0;
-}
-
-static int mahimahimmc_dbg_wifi_reset_get(void *data, u64 *val)
-{
-	*val = mahimahi_wifi_reset_state;
-	return 0;
-}
-
-static int mahimahimmc_dbg_wifi_cd_set(void *data, u64 val)
-{
-	mahimahi_wifi_set_carddetect((int) val);
-	return 0;
-}
-
-static int mahimahimmc_dbg_wifi_cd_get(void *data, u64 *val)
-{
-	*val = mahimahi_wifi_cd;
-	return 0;
-}
-
-static int mahimahimmc_dbg_wifi_pwr_set(void *data, u64 val)
-{
-	mahimahi_wifi_power((int) val);
-	return 0;
-}
-
-static int mahimahimmc_dbg_wifi_pwr_get(void *data, u64 *val)
-{
-	*val = mahimahi_wifi_power_state;
-	return 0;
-}
-
-static int mahimahimmc_dbg_sd_pwr_set(void *data, u64 val)
-{
-	mahimahi_sdslot_switchvdd(NULL, (unsigned int) val);
-	return 0;
-}
-
-static int mahimahimmc_dbg_sd_pwr_get(void *data, u64 *val)
-{
-	*val = sdslot_vdd;
-	return 0;
-}
-
-static int mahimahimmc_dbg_sd_cd_set(void *data, u64 val)
-{
-	return -ENOSYS;
-}
-
-static int mahimahimmc_dbg_sd_cd_get(void *data, u64 *val)
-{
-	*val = mahimahi_sdslot_data.status(NULL);
-	return 0;
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(mahimahimmc_dbg_wifi_reset_fops,
-			mahimahimmc_dbg_wifi_reset_get,
-			mahimahimmc_dbg_wifi_reset_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(mahimahimmc_dbg_wifi_cd_fops,
-			mahimahimmc_dbg_wifi_cd_get,
-			mahimahimmc_dbg_wifi_cd_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(mahimahimmc_dbg_wifi_pwr_fops,
-			mahimahimmc_dbg_wifi_pwr_get,
-			mahimahimmc_dbg_wifi_pwr_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(mahimahimmc_dbg_sd_pwr_fops,
-			mahimahimmc_dbg_sd_pwr_get,
-			mahimahimmc_dbg_sd_pwr_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(mahimahimmc_dbg_sd_cd_fops,
-			mahimahimmc_dbg_sd_cd_get,
-			mahimahimmc_dbg_sd_cd_set, "%llu\n");
-
-static int __init mahimahimmc_dbg_init(void)
-{
-	struct dentry *dent;
-
-	if (!machine_is_mahimahi())
-		return 0;
-
-	dent = debugfs_create_dir("mahimahi_mmc_dbg", 0);
-	if (IS_ERR(dent))
-		return PTR_ERR(dent);
-
-	debugfs_create_file("wifi_reset", 0644, dent, NULL,
-			    &mahimahimmc_dbg_wifi_reset_fops);
-	debugfs_create_file("wifi_cd", 0644, dent, NULL,
-			    &mahimahimmc_dbg_wifi_cd_fops);
-	debugfs_create_file("wifi_pwr", 0644, dent, NULL,
-			    &mahimahimmc_dbg_wifi_pwr_fops);
-	debugfs_create_file("sd_pwr", 0644, dent, NULL,
-			    &mahimahimmc_dbg_sd_pwr_fops);
-	debugfs_create_file("sd_cd", 0644, dent, NULL,
-			    &mahimahimmc_dbg_sd_cd_fops);
-	return 0;
-}
-
-device_initcall(mahimahimmc_dbg_init);
-#endif
diff --git a/arch/arm/mach-msm/board-mahimahi-panel.c b/arch/arm/mach-msm/board-mahimahi-panel.c
deleted file mode 100644
index 7c6af2b..0000000
--- a/arch/arm/mach-msm/board-mahimahi-panel.c
+++ /dev/null
@@ -1,584 +0,0 @@
-/* linux/arch/arm/mach-msm/board-mahimahi-panel.c
- *
- * Copyright (c) 2009 Google Inc.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/gpio.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/leds.h>
-#include <linux/platform_device.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-#include <mach/msm_iomap.h>
-
-#include "board-mahimahi.h"
-#include "devices.h"
-
-
-#define SPI_CONFIG              (0x00000000)
-#define SPI_IO_CONTROL          (0x00000004)
-#define SPI_OPERATIONAL         (0x00000030)
-#define SPI_ERROR_FLAGS_EN      (0x00000038)
-#define SPI_ERROR_FLAGS         (0x00000038)
-#define SPI_OUTPUT_FIFO         (0x00000100)
-
-static void __iomem *spi_base;
-static struct clk *spi_clk ;
-
-static int qspi_send(uint32_t id, uint8_t data)
-{
-	uint32_t err;
-
-	/* bit-5: OUTPUT_FIFO_NOT_EMPTY */
-	while (readl(spi_base + SPI_OPERATIONAL) & (1<<5)) {
-		if ((err = readl(spi_base + SPI_ERROR_FLAGS))) {
-			pr_err("%s: ERROR: SPI_ERROR_FLAGS=0x%08x\n", __func__,
-			       err);
-			return -EIO;
-		}
-	}
-	writel((0x7000 | (id << 9) | data) << 16, spi_base + SPI_OUTPUT_FIFO);
-	udelay(100);
-
-	return 0;
-}
-
-static int lcm_writeb(uint8_t reg, uint8_t val)
-{
-	qspi_send(0x0, reg);
-	qspi_send(0x1, val);
-	return 0;
-}
-
-static int lcm_writew(uint8_t reg, uint16_t val)
-{
-	qspi_send(0x0, reg);
-	qspi_send(0x1, val >> 8);
-	qspi_send(0x1, val & 0xff);
-	return 0;
-}
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-struct lcm_tbl {
-	uint8_t		reg;
-	uint8_t		val;
-};
-
-static struct lcm_tbl samsung_oled_init_table[] = {
-	{ 0x31, 0x08 },
-	{ 0x32, 0x14 },
-	{ 0x30, 0x2 },
-	{ 0x27, 0x1 },
-	{ 0x12, 0x8 },
-	{ 0x13, 0x8 },
-	{ 0x15, 0x0 },
-	{ 0x16, 0x02 },
-	{ 0x39, 0x44 },
-	{ 0x17, 0x22 },
-	{ 0x18, 0x33 },
-	{ 0x19, 0x3 },
-	{ 0x1A, 0x1 },
-	{ 0x22, 0xA4 },
-	{ 0x23, 0x0 },
-	{ 0x26, 0xA0 },
-};
-
-#define OLED_GAMMA_TABLE_SIZE		(7 * 3)
-static struct lcm_tbl samsung_oled_gamma_table[][OLED_GAMMA_TABLE_SIZE] = {
-	/* level 10 */
-	{
-		/* Gamma-R */
-		{ 0x40, 0x0 },
-		{ 0x41, 0x3f },
-		{ 0x42, 0x3f },
-		{ 0x43, 0x35 },
-		{ 0x44, 0x30 },
-		{ 0x45, 0x2c },
-		{ 0x46, 0x13 },
-		/* Gamma -G */
-		{ 0x50, 0x0 },
-		{ 0x51, 0x0 },
-		{ 0x52, 0x0 },
-		{ 0x53, 0x0 },
-		{ 0x54, 0x27 },
-		{ 0x55, 0x2b },
-		{ 0x56, 0x12 },
-		/* Gamma -B */
-		{ 0x60, 0x0 },
-		{ 0x61, 0x3f },
-		{ 0x62, 0x3f },
-		{ 0x63, 0x34 },
-		{ 0x64, 0x2f },
-		{ 0x65, 0x2b },
-		{ 0x66, 0x1b },
-	},
-
-	/* level 40 */
-	{
-		/* Gamma -R */
-		{ 0x40, 0x0 },
-		{ 0x41, 0x3f },
-		{ 0x42, 0x3e },
-		{ 0x43, 0x2e },
-		{ 0x44, 0x2d },
-		{ 0x45, 0x28 },
-		{ 0x46, 0x21 },
-		/* Gamma -G */
-		{ 0x50, 0x0 },
-		{ 0x51, 0x0 },
-		{ 0x52, 0x0 },
-		{ 0x53, 0x21 },
-		{ 0x54, 0x2a },
-		{ 0x55, 0x28 },
-		{ 0x56, 0x20 },
-		/* Gamma -B */
-		{ 0x60, 0x0 },
-		{ 0x61, 0x3f },
-		{ 0x62, 0x3e },
-		{ 0x63, 0x2d },
-		{ 0x64, 0x2b },
-		{ 0x65, 0x26 },
-		{ 0x66, 0x2d },
-	},
-
-	/* level 70 */
-	{
-		/* Gamma -R */
-		{ 0x40, 0x0 },
-		{ 0x41, 0x3f },
-		{ 0x42, 0x35 },
-		{ 0x43, 0x2c },
-		{ 0x44, 0x2b },
-		{ 0x45, 0x26 },
-		{ 0x46, 0x29 },
-		/* Gamma -G */
-		{ 0x50, 0x0 },
-		{ 0x51, 0x0 },
-		{ 0x52, 0x0 },
-		{ 0x53, 0x25 },
-		{ 0x54, 0x29 },
-		{ 0x55, 0x26 },
-		{ 0x56, 0x28 },
-		/* Gamma -B */
-		{ 0x60, 0x0 },
-		{ 0x61, 0x3f },
-		{ 0x62, 0x34 },
-		{ 0x63, 0x2b },
-		{ 0x64, 0x2a },
-		{ 0x65, 0x23 },
-		{ 0x66, 0x37 },
-	},
-
-	/* level 100 */
-	{
-		/* Gamma -R */
-		{ 0x40, 0x0 },
-		{ 0x41, 0x3f },
-		{ 0x42, 0x30 },
-		{ 0x43, 0x2a },
-		{ 0x44, 0x2b },
-		{ 0x45, 0x24 },
-		{ 0x46, 0x2f },
-		/* Gamma -G */
-		{ 0x50, 0x0 },
-		{ 0x51, 0x0 },
-		{ 0x52, 0x0 },
-		{ 0x53, 0x25 },
-		{ 0x54, 0x29 },
-		{ 0x55, 0x24 },
-		{ 0x56, 0x2e },
-		/* Gamma -B */
-		{ 0x60, 0x0 },
-		{ 0x61, 0x3f },
-		{ 0x62, 0x2f },
-		{ 0x63, 0x29 },
-		{ 0x64, 0x29 },
-		{ 0x65, 0x21 },
-		{ 0x66, 0x3f },
-	},
-
-	/* level 130 */
-	{
-		/* Gamma -R */
-		{ 0x40, 0x0 },
-		{ 0x41, 0x3f },
-		{ 0x42, 0x2e },
-		{ 0x43, 0x29 },
-		{ 0x44, 0x2a },
-		{ 0x45, 0x23 },
-		{ 0x46, 0x34 },
-		/* Gamma -G */
-		{ 0x50, 0x0 },
-		{ 0x51, 0x0 },
-		{ 0x52, 0xa },
-		{ 0x53, 0x25 },
-		{ 0x54, 0x28 },
-		{ 0x55, 0x23 },
-		{ 0x56, 0x33 },
-		/* Gamma -B */
-		{ 0x60, 0x0 },
-		{ 0x61, 0x3f },
-		{ 0x62, 0x2d },
-		{ 0x63, 0x28 },
-		{ 0x64, 0x27 },
-		{ 0x65, 0x20 },
-		{ 0x66, 0x46 },
-	},
-
-	/* level 160 */
-	{
-		/* Gamma -R */
-		{ 0x40, 0x0 },
-		{ 0x41, 0x3f },
-		{ 0x42, 0x2b },
-		{ 0x43, 0x29 },
-		{ 0x44, 0x28 },
-		{ 0x45, 0x23 },
-		{ 0x46, 0x38 },
-		/* Gamma -G */
-		{ 0x50, 0x0 },
-		{ 0x51, 0x0 },
-		{ 0x52, 0xb },
-		{ 0x53, 0x25 },
-		{ 0x54, 0x27 },
-		{ 0x55, 0x23 },
-		{ 0x56, 0x37 },
-		/* Gamma -B */
-		{ 0x60, 0x0 },
-		{ 0x61, 0x3f },
-		{ 0x62, 0x29 },
-		{ 0x63, 0x28 },
-		{ 0x64, 0x25 },
-		{ 0x65, 0x20 },
-		{ 0x66, 0x4b },
-	},
-
-	/* level 190 */
-	{
-		/* Gamma -R */
-		{ 0x40, 0x0 },
-		{ 0x41, 0x3f },
-		{ 0x42, 0x29 },
-		{ 0x43, 0x29 },
-		{ 0x44, 0x27 },
-		{ 0x45, 0x22 },
-		{ 0x46, 0x3c },
-		/* Gamma -G */
-		{ 0x50, 0x0 },
-		{ 0x51, 0x0 },
-		{ 0x52, 0x10 },
-		{ 0x53, 0x26 },
-		{ 0x54, 0x26 },
-		{ 0x55, 0x22 },
-		{ 0x56, 0x3b },
-		/* Gamma -B */
-		{ 0x60, 0x0 },
-		{ 0x61, 0x3f },
-		{ 0x62, 0x28 },
-		{ 0x63, 0x28 },
-		{ 0x64, 0x24 },
-		{ 0x65, 0x1f },
-		{ 0x66, 0x50 },
-	},
-
-	/* level 220 */
-	{
-		/* Gamma -R */
-		{ 0x40, 0x0 },
-		{ 0x41, 0x3f },
-		{ 0x42, 0x28 },
-		{ 0x43, 0x28 },
-		{ 0x44, 0x28 },
-		{ 0x45, 0x20 },
-		{ 0x46, 0x40 },
-		/* Gamma -G */
-		{ 0x50, 0x0 },
-		{ 0x51, 0x0 },
-		{ 0x52, 0x11 },
-		{ 0x53, 0x25 },
-		{ 0x54, 0x27 },
-		{ 0x55, 0x20 },
-		{ 0x56, 0x3f },
-		/* Gamma -B */
-		{ 0x60, 0x0 },
-		{ 0x61, 0x3f },
-		{ 0x62, 0x27 },
-		{ 0x63, 0x26 },
-		{ 0x64, 0x26 },
-		{ 0x65, 0x1c },
-		{ 0x66, 0x56 },
-	},
-
-	/* level 250 */
-	{
-		/* Gamma -R */
-		{ 0x40, 0x0 },
-		{ 0x41, 0x3f },
-		{ 0x42, 0x2a },
-		{ 0x43, 0x27 },
-		{ 0x44, 0x27 },
-		{ 0x45, 0x1f },
-		{ 0x46, 0x44 },
-		/* Gamma -G */
-		{ 0x50, 0x0 },
-		{ 0x51, 0x0 },
-		{ 0x52, 0x17 },
-		{ 0x53, 0x24 },
-		{ 0x54, 0x26 },
-		{ 0x55, 0x1f },
-		{ 0x56, 0x43 },
-		/* Gamma -B */
-		{ 0x60, 0x0 },
-		{ 0x61, 0x3f },
-		{ 0x62, 0x2a },
-		{ 0x63, 0x25 },
-		{ 0x64, 0x24 },
-		{ 0x65, 0x1b },
-		{ 0x66, 0x5c },
-	},
-};
-#define SAMSUNG_OLED_NUM_LEVELS		ARRAY_SIZE(samsung_oled_gamma_table)
-
-static DEFINE_MUTEX(panel_lock);
-static uint8_t last_level = SAMSUNG_OLED_NUM_LEVELS / 2;
-static uint8_t table_sel_vals[] = { 0x43, 0x34 };
-static int table_sel_idx = 0;
-static void gamma_table_bank_select(void)
-{
-	lcm_writeb(0x39, table_sel_vals[table_sel_idx]);
-	table_sel_idx ^= 1;
-}
-
-static void samsung_oled_set_gamma_level(int level)
-{
-	int i;
-
-	clk_enable(spi_clk);
-
-	for (i = 0; i < OLED_GAMMA_TABLE_SIZE; ++i)
-		lcm_writeb(samsung_oled_gamma_table[level][i].reg,
-			   samsung_oled_gamma_table[level][i].val);
-	gamma_table_bank_select();
-	clk_disable(spi_clk);
-	last_level = level;
-}
-
-static int samsung_oled_panel_init(struct msm_lcdc_panel_ops *ops)
-{
-	int i;
-
-	pr_info("%s: +()\n", __func__);
-	mutex_lock(&panel_lock);
-
-	clk_enable(spi_clk);
-	for (i = 0; i < ARRAY_SIZE(samsung_oled_init_table); i++)
-		lcm_writeb(samsung_oled_init_table[i].reg,
-			   samsung_oled_init_table[i].val);
-	gamma_table_bank_select();
-	clk_disable(spi_clk);
-
-	mutex_unlock(&panel_lock);
-	pr_info("%s: -()\n", __func__);
-	return 0;
-}
-
-static int samsung_oled_panel_unblank(struct msm_lcdc_panel_ops *ops)
-{
-	int i;
-
-	pr_info("%s: +()\n", __func__);
-
-	mutex_lock(&panel_lock);
-
-	gpio_set_value(MAHIMAHI_GPIO_LCD_RST_N, 1);
-	udelay(50);
-	gpio_set_value(MAHIMAHI_GPIO_LCD_RST_N, 0);
-	udelay(20);
-	gpio_set_value(MAHIMAHI_GPIO_LCD_RST_N, 1);
-	msleep(20);
-
-	clk_enable(spi_clk);
-
-	lcm_writeb(0x1d, 0xa0);
-	for (i = 0; i < ARRAY_SIZE(samsung_oled_init_table); i++)
-		lcm_writeb(samsung_oled_init_table[i].reg,
-			   samsung_oled_init_table[i].val);
-	table_sel_idx = 0;
-	gamma_table_bank_select();
-	samsung_oled_set_gamma_level(last_level);
-	msleep(200);
-	lcm_writew(0xef, 0xd0e8);
-	lcm_writeb(0x14, 0x03);
-	clk_disable(spi_clk);
-
-	mutex_unlock(&panel_lock);
-
-	pr_info("%s: -()\n", __func__);
-	return 0;
-}
-
-static int samsung_oled_panel_blank(struct msm_lcdc_panel_ops *ops)
-{
-	pr_info("%s: +()\n", __func__);
-	mutex_lock(&panel_lock);
-
-	clk_enable(spi_clk);
-	lcm_writeb(0x14, 0x1);
-	lcm_writeb(0x1d, 0xa1);
-	clk_disable(spi_clk);
-	msleep(200);
-
-	gpio_set_value(MAHIMAHI_GPIO_LCD_RST_N, 0);
-
-	mutex_unlock(&panel_lock);
-	pr_info("%s: -()\n", __func__);
-	return 0;
-}
-
-static struct msm_lcdc_panel_ops mahimahi_lcdc_panel_ops = {
-	.init		= samsung_oled_panel_init,
-	.blank		= samsung_oled_panel_blank,
-	.unblank	= samsung_oled_panel_unblank,
-};
-
-static struct msm_lcdc_timing mahimahi_lcdc_timing = {
-		.clk_rate		= 24576000,
-		.hsync_pulse_width	= 4,
-		.hsync_back_porch	= 8,
-		.hsync_front_porch	= 8,
-		.hsync_skew		= 0,
-		.vsync_pulse_width	= 2,
-		.vsync_back_porch	= 8,
-		.vsync_front_porch	= 8,
-		.vsync_act_low		= 1,
-		.hsync_act_low		= 1,
-		.den_act_low		= 1,
-};
-
-static struct msm_fb_data mahimahi_lcdc_fb_data = {
-		.xres		= 480,
-		.yres		= 800,
-		.width		= 48,
-		.height		= 80,
-		.output_format	= 0,
-};
-
-static struct msm_lcdc_platform_data mahimahi_lcdc_platform_data = {
-	.panel_ops	= &mahimahi_lcdc_panel_ops,
-	.timing		= &mahimahi_lcdc_timing,
-	.fb_id		= 0,
-	.fb_data	= &mahimahi_lcdc_fb_data,
-	.fb_resource	= &resources_msm_fb[0],
-};
-
-static struct platform_device mahimahi_lcdc_device = {
-	.name	= "msm_mdp_lcdc",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &mahimahi_lcdc_platform_data,
-	},
-};
-
-static int mahimahi_init_spi_hack(void)
-{
-	int ret;
-
-	spi_base = ioremap(MSM_SPI_PHYS, MSM_SPI_SIZE);
-	if (!spi_base)
-		return -1;
-
-	spi_clk = clk_get(&msm_device_spi.dev, "spi_clk");
-	if (IS_ERR(spi_clk)) {
-		pr_err("%s: unable to get spi_clk\n", __func__);
-		ret = PTR_ERR(spi_clk);
-		goto err_clk_get;
-	}
-
-	clk_enable(spi_clk);
-
-	printk("spi: SPI_CONFIG=%x\n", readl(spi_base + SPI_CONFIG));
-	printk("spi: SPI_IO_CONTROL=%x\n", readl(spi_base + SPI_IO_CONTROL));
-	printk("spi: SPI_OPERATIONAL=%x\n", readl(spi_base + SPI_OPERATIONAL));
-	printk("spi: SPI_ERROR_FLAGS_EN=%x\n",
-	       readl(spi_base + SPI_ERROR_FLAGS_EN));
-	printk("spi: SPI_ERROR_FLAGS=%x\n", readl(spi_base + SPI_ERROR_FLAGS));
-	printk("-%s()\n", __FUNCTION__);
-	clk_disable(spi_clk);
-
-	return 0;
-
-err_clk_get:
-	iounmap(spi_base);
-	return ret;
-}
-
-static void mahimahi_brightness_set(struct led_classdev *led_cdev,
-				    enum led_brightness val)
-{
-	uint8_t new_level = (val * (SAMSUNG_OLED_NUM_LEVELS - 1)) / LED_FULL;
-
-	mutex_lock(&panel_lock);
-	samsung_oled_set_gamma_level(new_level);
-	mutex_unlock(&panel_lock);
-}
-
-static struct led_classdev mahimahi_brightness_led = {
-	.name = "lcd-backlight",
-	.brightness = LED_FULL,
-	.brightness_set = mahimahi_brightness_set,
-};
-
-int __init mahimahi_init_panel(void)
-{
-	int ret;
-
-	if (!machine_is_mahimahi())
-		return 0;
-
-	ret = platform_device_register(&msm_device_mdp);
-	if (ret != 0)
-		return ret;
-
-	ret = mahimahi_init_spi_hack();
-	if (ret != 0)
-		return ret;
-
-	ret = platform_device_register(&mahimahi_lcdc_device);
-	if (ret != 0)
-		return ret;
-
-	ret = led_classdev_register(NULL, &mahimahi_brightness_led);
-	if (ret != 0) {
-		pr_err("%s: Cannot register brightness led\n", __func__);
-		return ret;
-	}
-
-	return 0;
-}
-
-late_initcall(mahimahi_init_panel);
diff --git a/arch/arm/mach-msm/board-mahimahi-rfkill.c b/arch/arm/mach-msm/board-mahimahi-rfkill.c
deleted file mode 100644
index 517b7f6..0000000
--- a/arch/arm/mach-msm/board-mahimahi-rfkill.c
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/rfkill.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include "board-mahimahi.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		gpio_configure(MAHIMAHI_GPIO_BT_RESET_N,
-			       GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-		gpio_configure(MAHIMAHI_GPIO_BT_SHUTDOWN_N,
-			       GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		gpio_configure(MAHIMAHI_GPIO_BT_SHUTDOWN_N,
-			       GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-		gpio_configure(MAHIMAHI_GPIO_BT_RESET_N,
-			       GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int mahimahi_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int mahimahi_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver mahimahi_rfkill_driver = {
-	.probe = mahimahi_rfkill_probe,
-	.remove = mahimahi_rfkill_remove,
-	.driver = {
-		.name = "mahimahi_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init mahimahi_rfkill_init(void)
-{
-	if (!machine_is_mahimahi())
-		return 0;
-
-	return platform_driver_register(&mahimahi_rfkill_driver);
-}
-
-static void __exit mahimahi_rfkill_exit(void)
-{
-	platform_driver_unregister(&mahimahi_rfkill_driver);
-}
-
-module_init(mahimahi_rfkill_init);
-module_exit(mahimahi_rfkill_exit);
-MODULE_DESCRIPTION("mahimahi rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-mahimahi-wifi.c b/arch/arm/mach-msm/board-mahimahi-wifi.c
deleted file mode 100644
index 4c1e903..0000000
--- a/arch/arm/mach-msm/board-mahimahi-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-mahimahi-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-mahimahi.h"
-
-int mahimahi_wifi_power(int on);
-int mahimahi_wifi_reset(int on);
-int mahimahi_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *mahimahi_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init mahimahi_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource mahimahi_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(MAHIMAHI_GPIO_WIFI_IRQ),
-		.end		= MSM_GPIO_TO_INT(MAHIMAHI_GPIO_WIFI_IRQ),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data mahimahi_wifi_control = {
-	.set_power      = mahimahi_wifi_power,
-	.set_reset      = mahimahi_wifi_reset,
-	.set_carddetect = mahimahi_wifi_set_carddetect,
-	.mem_prealloc   = mahimahi_wifi_mem_prealloc,
-};
-
-static struct platform_device mahimahi_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(mahimahi_wifi_resources),
-        .resource       = mahimahi_wifi_resources,
-        .dev            = {
-                .platform_data = &mahimahi_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned mahimahi_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init mahimahi_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_mahimahi())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	mahimahi_wifi_update_nvs("sd_oobonly=1\n");
-	mahimahi_init_wifi_mem();
-	ret = platform_device_register(&mahimahi_wifi_device);
-        return ret;
-}
-
-device_initcall(mahimahi_wifi_init);
diff --git a/arch/arm/mach-msm/board-mahimahi.c b/arch/arm/mach-msm/board-mahimahi.c
deleted file mode 100644
index 22a7350..0000000
--- a/arch/arm/mach-msm/board-mahimahi.c
+++ /dev/null
@@ -1,811 +0,0 @@
-/* linux/arch/arm/mach-msm/board-mahimahi.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/cy8c_tmg_ts.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/init.h>
-#include <linux/input.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/usb/mass_storage_function.h>
-#include <linux/android_pmem.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/a1026.h>
-#include <linux/capella_cm3602.h>
-#include <linux/akm8973.h>
-#include <linux/regulator/machine.h>
-#include <../../../drivers/staging/android/timed_gpio.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/setup.h>
-
-#include <mach/board.h>
-#include <mach/hardware.h>
-#include <mach/msm_hsusb.h>
-#include <mach/msm_iomap.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/system.h>
-
-#include "board-mahimahi.h"
-#include "devices.h"
-#include "proc_comm.h"
-#include <linux/flashlight.h>
-
-static uint debug_uart;
-
-module_param_named(debug_uart, debug_uart, uint, 0);
-
-extern void notify_usb_connected(int);
-extern void msm_init_pmic_vibrator(void);
-extern void __init mahimahi_audio_init(void);
-
-extern int microp_headset_has_mic(void);
-
-static char *mahimahi_usb_functions[] = {
-	"usb_mass_storage",
-	"adb",
-#if defined(CONFIG_USB_FUNCTION_DIAG)
-	"diag",
-#endif
-#if defined(CONFIG_USB_FUNCTION_SERIAL)
-	"fserial",
-#endif
-};
-
-static struct msm_hsusb_product mahimahi_usb_products[] = {
-	{
-		.product_id     = 0x0c01,
-		.functions      = 0x00000001, /* "usb_mass_storage" only */
-	},
-	{
-		.product_id     = 0x0c02,
-		.functions      = 0x00000003, /* "usb_mass_storage" and "adb" */
-	},
-	{
-		.product_id     = 0x0c07,
-		.functions      = 0x00000007, /* ums, usb, diag */
-	},
-	{
-		.product_id     = 0x0c04,
-		.functions      = 0x0000000b, /* ums, adb, fserial */
-	},
-	{
-		.product_id     = 0x0c09,
-		.functions      = 0x0000000f, /* ums, adb, diag, fserial */
-	},
-};
-
-static int mahimahi_phy_init_seq[] = {
-	0x0C, 0x31,
-	0x1D, 0x0D,
-	0x1D, 0x10,
-	-1 };
-
-static void mahimahi_usb_phy_reset(void)
-{
-	u32 id;
-	int ret;
-
-	id = PCOM_CLKRGM_APPS_RESET_USB_PHY;
-	ret = msm_proc_comm(PCOM_CLK_REGIME_SEC_RESET_ASSERT, &id, NULL);
-	if (ret) {
-		pr_err("%s: Cannot assert (%d)\n", __func__, ret);
-		return;
-	}
-
-	msleep(1);
-
-	id = PCOM_CLKRGM_APPS_RESET_USB_PHY;
-	ret = msm_proc_comm(PCOM_CLK_REGIME_SEC_RESET_DEASSERT, &id, NULL);
-	if (ret) {
-		pr_err("%s: Cannot assert (%d)\n", __func__, ret);
-		return;
-	}
-}
-
-static void mahimahi_usb_hw_reset(bool enable)
-{
-	u32 id;
-	int ret;
-	u32 func;
-
-	id = PCOM_CLKRGM_APPS_RESET_USBH;
-	if (enable)
-		func = PCOM_CLK_REGIME_SEC_RESET_ASSERT;
-	else
-		func = PCOM_CLK_REGIME_SEC_RESET_DEASSERT;
-	ret = msm_proc_comm(func, &id, NULL);
-	if (ret)
-		pr_err("%s: Cannot set reset to %d (%d)\n", __func__, enable,
-		       ret);
-}
-
-
-static struct msm_hsusb_platform_data msm_hsusb_pdata = {
-	.phy_init_seq		= mahimahi_phy_init_seq,
-	.phy_reset		= mahimahi_usb_phy_reset,
-	.hw_reset		= mahimahi_usb_hw_reset,
-	.usb_connected		= notify_usb_connected,
-	.vendor_id		= 0x0bb4,
-	.product_id		= 0x0c02,
-	.version		= 0x0100,
-	.product_name		= "Android Phone",
-	.manufacturer_name	= "HTC",
-
-	.functions		= mahimahi_usb_functions,
-	.num_functions		= ARRAY_SIZE(mahimahi_usb_functions),
-	.products		= mahimahi_usb_products,
-	.num_products		= ARRAY_SIZE(mahimahi_usb_products),
-};
-
-static struct usb_mass_storage_platform_data mass_storage_pdata = {
-	.nluns		= 1,
-	.buf_size	= 16384,
-	.vendor		= "Google",
-	.product	= "Android Phone",
-	.release	= 0x0100,
-};
-
-static struct platform_device usb_mass_storage_device = {
-	.name	= "usb_mass_storage",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &mass_storage_pdata,
-	},
-};
-
-static struct platform_device mahimahi_rfkill = {
-	.name = "mahimahi_rfkill",
-	.id = -1,
-};
-
-static struct resource msm_kgsl_resources[] = {
-	{
-		.name	= "kgsl_reg_memory",
-		.start	= MSM_GPU_REG_PHYS,
-		.end	= MSM_GPU_REG_PHYS + MSM_GPU_REG_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "kgsl_phys_memory",
-		.start	= MSM_GPU_MEM_BASE,
-		.end	= MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_GRAPHICS,
-		.end	= INT_GRAPHICS,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-#define PWR_RAIL_GRP_CLK		8
-static int mahimahi_kgsl_power_rail_mode(int follow_clk)
-{
-	int mode = follow_clk ? 0 : 1;
-	int rail_id = PWR_RAIL_GRP_CLK;
-
-	return msm_proc_comm(PCOM_CLKCTL_RPC_RAIL_CONTROL, &rail_id, &mode);
-}
-
-static int mahimahi_kgsl_power(bool on)
-{
-	int cmd;
-	int rail_id = PWR_RAIL_GRP_CLK;
-
-	cmd = on ? PCOM_CLKCTL_RPC_RAIL_ENABLE : PCOM_CLKCTL_RPC_RAIL_DISABLE;
-	return msm_proc_comm(cmd, &rail_id, NULL);
-}
-
-static struct platform_device msm_kgsl_device = {
-	.name		= "kgsl",
-	.id		= -1,
-	.resource	= msm_kgsl_resources,
-	.num_resources	= ARRAY_SIZE(msm_kgsl_resources),
-};
-
-static struct android_pmem_platform_data mdp_pmem_pdata = {
-	.name		= "pmem",
-	.start		= MSM_PMEM_MDP_BASE,
-	.size		= MSM_PMEM_MDP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu0_pdata = {
-	.name		= "pmem_gpu0",
-	.start		= MSM_PMEM_GPU0_BASE,
-	.size		= MSM_PMEM_GPU0_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu1_pdata = {
-	.name		= "pmem_gpu1",
-	.start		= MSM_PMEM_GPU1_BASE,
-	.size		= MSM_PMEM_GPU1_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct android_pmem_platform_data android_pmem_adsp_pdata = {
-	.name		= "pmem_adsp",
-	.start		= MSM_PMEM_ADSP_BASE,
-	.size		= MSM_PMEM_ADSP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct platform_device android_pmem_mdp_device = {
-	.name		= "android_pmem",
-	.id		= 0,
-	.dev		= {
-		.platform_data = &mdp_pmem_pdata
-	},
-};
-
-static struct platform_device android_pmem_adsp_device = {
-	.name		= "android_pmem",
-	.id		= 1,
-	.dev		= {
-		.platform_data = &android_pmem_adsp_pdata,
-	},
-};
-
-static struct platform_device android_pmem_gpu0_device = {
-	.name		= "android_pmem",
-	.id		= 2,
-	.dev		= {
-		.platform_data = &android_pmem_gpu0_pdata,
-	},
-};
-
-static struct platform_device android_pmem_gpu1_device = {
-	.name		= "android_pmem",
-	.id		= 3,
-	.dev		= {
-		.platform_data = &android_pmem_gpu1_pdata,
-	},
-};
-
-static struct resource ram_console_resources[] = {
-	{
-		.start	= MSM_RAM_CONSOLE_BASE,
-		.end	= MSM_RAM_CONSOLE_BASE + MSM_RAM_CONSOLE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device ram_console_device = {
-	.name		= "ram_console",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(ram_console_resources),
-	.resource	= ram_console_resources,
-};
-
-static int mahimahi_ts_power(int on)
-{
-	pr_info("%s: power %d\n", __func__, on);
-
-	if (on) {
-		/* level shifter should be off */
-		gpio_set_value(MAHIMAHI_GPIO_TP_EN, 1);
-		msleep(120);
-		/* enable touch panel level shift */
-		gpio_set_value(MAHIMAHI_GPIO_TP_LS_EN, 1);
-		msleep(3);
-	} else {
-		gpio_set_value(MAHIMAHI_GPIO_TP_LS_EN, 0);
-		gpio_set_value(MAHIMAHI_GPIO_TP_EN, 0);
-		udelay(50);
-	}
-
-	return 0;
-}
-
-struct cy8c_i2c_platform_data mahimahi_cy8c_ts_data = {
-	.version = 0x0001,
-	.abs_x_min = 0,
-	.abs_x_max = 479,
-	.abs_y_min = 0,
-	.abs_y_max = 799,
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-	.abs_width_min = 0,
-	.abs_width_max = 10,
-	.power = mahimahi_ts_power,
-};
-
-static struct synaptics_i2c_rmi_platform_data mahimahi_synaptics_ts_data[] = {
-	{
-		.power = mahimahi_ts_power,
-		.flags = SYNAPTICS_FLIP_Y,
-		.inactive_left = -25 * 0x10000 / 480,
-		.inactive_right = -20 * 0x10000 / 480,
-		.inactive_top = -15 * 0x10000 / 800,
-		.inactive_bottom = -40 * 0x10000 / 800,
-		.sensitivity_adjust = 12,
-	},
-};
-
-static struct a1026_platform_data a1026_data = {
-	.gpio_a1026_micsel = MAHIMAHI_AUD_MICPATH_SEL,
-	.gpio_a1026_wakeup = MAHIMAHI_AUD_A1026_WAKEUP,
-	.gpio_a1026_reset = MAHIMAHI_AUD_A1026_RESET,
-	.gpio_a1026_clk = MAHIMAHI_AUD_A1026_CLK,
-	/*.gpio_a1026_int = MAHIMAHI_AUD_A1026_INT,*/
-};
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = MAHIMAHI_LAYOUTS,
-	.project_name = MAHIMAHI_PROJECT_NAME,
-	.reset = MAHIMAHI_GPIO_COMPASS_RST_N,
-	.intr = MAHIMAHI_GPIO_COMPASS_INT_N,
-};
-
-static struct regulator_consumer_supply tps65023_dcdc1_supplies[] = {
-	{
-		.supply = "acpu_vcore",
-	},
-};
-
-static struct regulator_init_data tps65023_data[5] = {
-	{
-		.constraints = {
-			.name = "dcdc1", /* VREG_MSMC2_1V29 */
-			.min_uV = 1000000,
-			.max_uV = 1300000,
-			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
-		},
-		.consumer_supplies = tps65023_dcdc1_supplies,
-		.num_consumer_supplies = ARRAY_SIZE(tps65023_dcdc1_supplies),
-	},
-	/* dummy values for unused regulators to not crash driver: */
-	{
-		.constraints = {
-			.name = "dcdc2", /* VREG_MSMC1_1V26 */
-			.min_uV = 1260000,
-			.max_uV = 1260000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "dcdc3", /* unused */
-			.min_uV = 800000,
-			.max_uV = 3300000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo1", /* unused */
-			.min_uV = 1000000,
-			.max_uV = 3150000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo2", /* V_USBPHY_3V3 */
-			.min_uV = 3300000,
-			.max_uV = 3300000,
-		},
-	},
-};
-
-static struct i2c_board_info base_i2c_devices[] = {
-	{
-		I2C_BOARD_INFO("ds2482", 0x30 >> 1),
-	},
-	{
-		I2C_BOARD_INFO("cy8c-tmg-ts", 0x34),
-		.platform_data = &mahimahi_cy8c_ts_data,
-		.irq = MSM_GPIO_TO_INT(MAHIMAHI_GPIO_TP_INT_N),
-	},
-	{
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x40),
-		.platform_data = mahimahi_synaptics_ts_data,
-		.irq = MSM_GPIO_TO_INT(MAHIMAHI_GPIO_TP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO("mahimahi-microp", 0x66),
-		.irq = MSM_GPIO_TO_INT(MAHIMAHI_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO("s5k3e2fx", 0x20 >> 1),
-	},
-	{
-		I2C_BOARD_INFO("tps65023", 0x48),
-		.platform_data = tps65023_data,
-	},
-};
-
-static struct i2c_board_info rev1_i2c_devices[] = {
-	{
-		I2C_BOARD_INFO("audience_a1026", 0x3E),
-		.platform_data = &a1026_data,
-		/*.irq = MSM_GPIO_TO_INT(MAHIMAHI_AUD_A1026_INT)*/
-	},
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = MSM_GPIO_TO_INT(MAHIMAHI_GPIO_COMPASS_INT_N),
-	},
-};
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* VSYNC */
-/*	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_16MA),*/ /* MCLK */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* MCLK */
-	/*steven yeh: modify MCLK driving strength to avoid overshot issue*/
-};
-
-void config_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void config_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		 INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_camera_on_gpios,
-	.camera_gpio_off = config_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_s5k3e2fx_data = {
-	.sensor_name = "s5k3e2fx",
-	.sensor_reset = 144, /* CAM1_RST */
-	.sensor_pwd = 143,  /* CAM1_PWDN, enabled in a9 */
-	/*.vcm_pwd = 31, */  /* CAM1_VCM_EN, enabled in a9 */
-	.pdata = &msm_camera_device_data,
-	.resource = msm_camera_resources,
-	.num_resources = ARRAY_SIZE(msm_camera_resources),
-	.camera_flash = flashlight_control,
-	.num_flash_levels = FLASHLIGHT_NUM,
-};
-
-static struct platform_device msm_camera_sensor_s5k3e2fx = {
-	.name      = "msm_camera_s5k3e2fx",
-	.dev      = {
-		.platform_data = &msm_camera_sensor_s5k3e2fx_data,
-	},
-};
-
-static int capella_cm3602_power(int on)
-{
-	/* TODO eolsen Add Voltage reg control */
-	if (on) {
-		gpio_direction_output(MAHIMAHI_GPIO_PROXIMITY_EN, 0);
-	} else {
-		gpio_direction_output(MAHIMAHI_GPIO_PROXIMITY_EN, 1);
-	}
-
-	return 0;
-}
-
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.power = capella_cm3602_power,
-	.p_en = MAHIMAHI_GPIO_PROXIMITY_EN,
-	.p_out = MAHIMAHI_GPIO_PROXIMITY_INT_N
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.id = -1,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-
-static uint32_t flashlight_gpio_table[] = {
-	PCOM_GPIO_CFG(MAHIMAHI_GPIO_FLASHLIGHT_TORCH, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(MAHIMAHI_GPIO_FLASHLIGHT_FLASH, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-};
-
-
-static int config_mahimahi_flashlight_gpios(void)
-{
-	config_gpio_table(flashlight_gpio_table,
-		ARRAY_SIZE(flashlight_gpio_table));
-	return 0;
-}
-
-static struct flashlight_platform_data mahimahi_flashlight_data = {
-	.gpio_init  = config_mahimahi_flashlight_gpios,
-	.torch = MAHIMAHI_GPIO_FLASHLIGHT_TORCH,
-	.flash = MAHIMAHI_GPIO_FLASHLIGHT_FLASH,
-};
-
-static struct platform_device mahimahi_flashlight_device = {
-	.name = "flashlight",
-	.dev = {
-		.platform_data  = &mahimahi_flashlight_data,
-	},
-};
-static struct timed_gpio timed_gpios[] = {
-	{
-		.name = "vibrator",
-		.gpio = MAHIMAHI_GPIO_VIBRATOR_ON,
-		.max_timeout = 15000,
-	},
-};
-
-static struct timed_gpio_platform_data timed_gpio_data = {
-	.num_gpios	= ARRAY_SIZE(timed_gpios),
-	.gpios		= timed_gpios,
-};
-
-static struct platform_device mahimahi_timed_gpios = {
-	.name		= "timed-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data = &timed_gpio_data,
-	},
-};
-
-
-static struct platform_device *devices[] __initdata = {
-#if !defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	&msm_device_uart1,
-#endif
-#ifdef CONFIG_SERIAL_MSM_HS
-	&msm_device_uart_dm1,
-#endif
-	&ram_console_device,
-	&mahimahi_rfkill,
-	&msm_device_smd,
-	&msm_device_nand,
-	&msm_device_hsusb,
-	&usb_mass_storage_device,
-	&android_pmem_mdp_device,
-	&android_pmem_adsp_device,
-	&android_pmem_gpu0_device,
-	&android_pmem_gpu1_device,
-	&msm_kgsl_device,
-	&msm_device_i2c,
-	&capella_cm3602,
-	&msm_camera_sensor_s5k3e2fx,
-	&mahimahi_flashlight_device,
-};
-
-
-static uint32_t bt_gpio_table[] = {
-	PCOM_GPIO_CFG(MAHIMAHI_GPIO_BT_UART1_RTS, 2, GPIO_OUTPUT,
-		      GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(MAHIMAHI_GPIO_BT_UART1_CTS, 2, GPIO_INPUT,
-		      GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(MAHIMAHI_GPIO_BT_UART1_RX, 2, GPIO_INPUT,
-		      GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(MAHIMAHI_GPIO_BT_UART1_TX, 2, GPIO_OUTPUT,
-		      GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(MAHIMAHI_GPIO_BT_RESET_N, 0, GPIO_OUTPUT,
-		      GPIO_PULL_DOWN, GPIO_4MA),
-	PCOM_GPIO_CFG(MAHIMAHI_GPIO_BT_SHUTDOWN_N, 0, GPIO_OUTPUT,
-		      GPIO_PULL_DOWN, GPIO_4MA),
-};
-
-static uint32_t misc_gpio_table[] = {
-	PCOM_GPIO_CFG(MAHIMAHI_GPIO_LCD_RST_N, 0, GPIO_OUTPUT,
-		      GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(MAHIMAHI_GPIO_LED_3V3_EN, 0, GPIO_OUTPUT,
-		      GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(MAHIMAHI_GPIO_DOCK, 0, GPIO_OUTPUT,
-		      GPIO_NO_PULL, GPIO_4MA),
-};
-
-static int __init board_serialno_setup(char *serialno)
-{
-	msm_hsusb_pdata.serial_number = serialno;
-	return 1;
-}
-__setup("androidboot.serialno=", board_serialno_setup);
-
-static struct msm_acpu_clock_platform_data mahimahi_clock_data = {
-	.acpu_switch_time_us	= 20,
-	.max_speed_delta_khz	= 256000,
-	.vdd_switch_time_us	= 62,
-	.power_collapse_khz	= 245000,
-	.wait_for_irq_khz	= 0,
-};
-
-static ssize_t mahimahi_virtual_keys_show(struct kobject *kobj,
-			       struct kobj_attribute *attr, char *buf)
-{
-	/* center: x: home: 55, menu: 185, back: 305, search 425, y: 835 */
-	return sprintf(buf,
-		__stringify(EV_KEY) ":" __stringify(KEY_HOME)  ":55:835:70:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":185:835:100:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":305:835:70:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":425:835:70:55"
-	   "\n");
-}
-
-static struct kobj_attribute mahimahi_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.synaptics-rmi-touchscreen",
-		.mode = S_IRUGO,
-	},
-	.show = &mahimahi_virtual_keys_show,
-};
-
-static struct attribute *mahimahi_properties_attrs[] = {
-	&mahimahi_virtual_keys_attr.attr,
-	NULL
-};
-
-static struct attribute_group mahimahi_properties_attr_group = {
-	.attrs = mahimahi_properties_attrs,
-};
-
-static void mahimahi_reset(void)
-{
-	gpio_set_value(MAHIMAHI_GPIO_PS_HOLD, 0);
-}
-
-int mahimahi_init_mmc(int sysrev, unsigned debug_uart);
-
-static void __init mahimahi_init(void)
-{
-	int ret;
-	struct kobject *properties_kobj;
-
-	printk("mahimahi_init() revision=%d\n", system_rev);
-
-	msm_hw_reset_hook = mahimahi_reset;
-
-	msm_acpu_clock_init(&mahimahi_clock_data);
-
-	msm_serial_debug_init(MSM_UART1_PHYS, INT_UART1,
-			      &msm_device_uart1.dev, 1, MSM_GPIO_TO_INT(139));
-
-	config_gpio_table(misc_gpio_table, ARRAY_SIZE(misc_gpio_table));
-
-	config_gpio_table(bt_gpio_table, ARRAY_SIZE(bt_gpio_table));
-	gpio_direction_output(MAHIMAHI_GPIO_TP_LS_EN, 0);
-	gpio_direction_output(MAHIMAHI_GPIO_TP_EN, 0);
-	gpio_direction_output(MAHIMAHI_GPIO_PROXIMITY_EN, 1);
-	gpio_direction_output(MAHIMAHI_GPIO_COMPASS_RST_N, 1);
-	gpio_direction_input(MAHIMAHI_GPIO_COMPASS_INT_N);
-
-	/* set the gpu power rail to manual mode so clk en/dis will not
-	 * turn off gpu power, and hang it on resume */
-	mahimahi_kgsl_power_rail_mode(0);
-	mahimahi_kgsl_power(true);
-
-	msm_device_hsusb.dev.platform_data = &msm_hsusb_pdata;
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	i2c_register_board_info(0, base_i2c_devices,
-		ARRAY_SIZE(base_i2c_devices));
-
-	if (system_rev > 0) {
-		/* Only board after XB with Audience A1026 */
-		i2c_register_board_info(0, rev1_i2c_devices,
-			ARRAY_SIZE(rev1_i2c_devices));
-	}
-
-	ret = mahimahi_init_mmc(system_rev, debug_uart);
-	if (ret != 0)
-		pr_crit("%s: Unable to initialize MMC\n", __func__);
-
-	properties_kobj = kobject_create_and_add("board_properties", NULL);
-	if (properties_kobj)
-		ret = sysfs_create_group(properties_kobj,
-					 &mahimahi_properties_attr_group);
-	if (!properties_kobj || ret)
-		pr_err("failed to create board_properties\n");
-
-	mahimahi_audio_init();
-
-	if (system_rev > 0)
-		platform_device_register(&mahimahi_timed_gpios);
-	else
-		msm_init_pmic_vibrator();
-}
-
-static void __init mahimahi_fixup(struct machine_desc *desc, struct tag *tags,
-				 char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 1;
-	mi->bank[0].start = PHYS_OFFSET;
-	mi->bank[0].node = PHYS_TO_NID(PHYS_OFFSET);
-	mi->bank[0].size = (160*1024*1024);
-}
-
-static void __init mahimahi_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-extern struct sys_timer msm_timer;
-
-MACHINE_START(MAHIMAHI, "mahimahi")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params	= 0x20000100,
-	.fixup		= mahimahi_fixup,
-	.map_io		= mahimahi_map_io,
-	.init_irq	= msm_init_irq,
-	.init_machine	= mahimahi_init,
-	.timer		= &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-mahimahi.h b/arch/arm/mach-msm/board-mahimahi.h
deleted file mode 100644
index 6e5a9c6..0000000
--- a/arch/arm/mach-msm/board-mahimahi.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/* arch/arm/mach-msm/board-mahimahi.h
- *
- * Copyright (C) 2009 HTC Corporation.
- * Author: Haley Teng <Haley_Teng@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_MAHIMAHI_H
-#define __ARCH_ARM_MACH_MSM_BOARD_MAHIMAHI_H
-
-#include <mach/board.h>
-
-#define MSM_SMI_BASE		0x02B00000
-#define MSM_SMI_SIZE		0x01500000
-
-#define MSM_PMEM_MDP_BASE	0x03000000
-#define MSM_PMEM_MDP_SIZE	0x01000000
-
-#define MSM_EBI1_BASE		0x20000000
-#define MSM_EBI1_SIZE		0x0E000000
-
-#define MSM_PMEM_ADSP_BASE	0x2A300000
-#define MSM_PMEM_ADSP_SIZE	0x02000000
-
-#define MSM_PMEM_GPU1_BASE	0x2C300000
-#define MSM_PMEM_GPU1_SIZE	0x01400000
-
-#define MSM_PMEM_GPU0_BASE	0x2D700000
-#define MSM_PMEM_GPU0_SIZE	0x00400000
-
-#define MSM_GPU_MEM_BASE	0x2DB00000
-#define MSM_GPU_MEM_SIZE	0x00200000
-
-#define MSM_RAM_CONSOLE_BASE	0x2DD00000
-#define MSM_RAM_CONSOLE_SIZE	0x00040000
-
-#define MSM_FB_BASE		0x2DE00000
-#define MSM_FB_SIZE		0x00200000
-
-#define MAHIMAHI_GPIO_PS_HOLD		25
-
-#define MAHIMAHI_GPIO_UP_INT_N		35
-#define MAHIMAHI_GPIO_UP_RESET_N	82
-#define MAHIMAHI_GPIO_LS_EN_N		119
-
-#define MAHIMAHI_GPIO_TP_INT_N		92
-#define MAHIMAHI_GPIO_TP_LS_EN		93
-#define MAHIMAHI_GPIO_TP_EN		160
-
-#define MAHIMAHI_GPIO_POWER_KEY		94
-#define MAHIMAHI_GPIO_SDMC_CD_REV0_N	153
-
-#define MAHIMAHI_GPIO_WIFI_SHUTDOWN_N	127
-#define MAHIMAHI_GPIO_WIFI_IRQ		152
-
-#define MAHIMAHI_GPIO_BALL_UP		38
-#define MAHIMAHI_GPIO_BALL_DOWN		37
-#define MAHIMAHI_GPIO_BALL_LEFT		145
-#define MAHIMAHI_GPIO_BALL_RIGHT	21
-
-#define MAHIMAHI_GPIO_BT_UART1_RTS	43
-#define MAHIMAHI_GPIO_BT_UART1_CTS	44
-#define MAHIMAHI_GPIO_BT_UART1_RX	45
-#define MAHIMAHI_GPIO_BT_UART1_TX	46
-#define MAHIMAHI_GPIO_BT_RESET_N	146
-#define MAHIMAHI_GPIO_BT_SHUTDOWN_N	128
-
-#define MAHIMAHI_GPIO_PROXIMITY_INT_N	90
-#define MAHIMAHI_GPIO_PROXIMITY_EN	120
-
-#define MAHIMAHI_GPIO_VIBRATOR_ON	89
-/* Compass */
-#define MAHIMAHI_GPIO_COMPASS_INT_N	153
-#define MAHIMAHI_GPIO_COMPASS_RST_N	107
-#define MAHIMAHI_PROJECT_NAME          "mahimahi"
-#define MAHIMAHI_LAYOUTS { 			   \
-	{ {-1,  0, 0}, { 0, -1,  0}, {0, 0,  1} }, \
-	{ { 0, -1, 0}, { 1,  0,  0}, {0, 0, -1} }, \
-	{ { 0, -1, 0}, { 1,  0,  0}, {0, 0,  1} }, \
-	{ {-1,  0, 0}, { 0,  0, -1}, {0, 1,  0} }  \
-}
-
-/* Audio */
-#define MAHIMAHI_AUD_JACKHP_EN		157
-#define MAHIMAHI_AUD_2V5_EN		158
-#define MAHIMAHI_AUD_MICPATH_SEL 	111
-#define MAHIMAHI_AUD_A1026_INT		112
-#define MAHIMAHI_AUD_A1026_WAKEUP 	113
-#define MAHIMAHI_AUD_A1026_RESET 	129
-#define MAHIMAHI_AUD_A1026_CLK		 -1
-
-/* Bluetooth PCM */
-#define MAHIMAHI_BT_PCM_OUT		68
-#define MAHIMAHI_BT_PCM_IN		69
-#define MAHIMAHI_BT_PCM_SYNC		70
-#define MAHIMAHI_BT_PCM_CLK		71
-/* flash light */
-#define MAHIMAHI_GPIO_FLASHLIGHT_TORCH	58
-#define MAHIMAHI_GPIO_FLASHLIGHT_FLASH	84
-
-#define MAHIMAHI_GPIO_LED_3V3_EN	85
-#define MAHIMAHI_GPIO_LCD_RST_N		29
-
-#define MAHIMAHI_GPIO_DOCK		106
-
-#endif /* __ARCH_ARM_MACH_MSM_BOARD_MAHIMAHI_H */
diff --git a/arch/arm/mach-msm/board-orca-audio.c b/arch/arm/mach-msm/board-orca-audio.c
deleted file mode 100644
index 3444d22..0000000
--- a/arch/arm/mach-msm/board-orca-audio.c
+++ /dev/null
@@ -1,211 +0,0 @@
-/* arch/arm/mach-msm/board-orca-audio.c
- *
- * Copyright (C) 2009 HTC Corporation
- * Copyright (C) 2009 Google Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/gpio.h>
-#include <linux/delay.h>
-#include <mach/msm_qdsp6_audio.h>
-#include <mach/htc_acoustic_qsd.h>
-
-#include "board-orca.h"
-#include "proc_comm.h"
-#include "pmic.h"
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "Audio: "fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-static struct mutex mic_lock;
-static struct mutex bt_sco_lock;
-static int headset_status = 0;
-
-void orca_headset_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-        /* enable audio amp */
-	if (en != headset_status) {
-		headset_status = en;
-		if(en) {
-			gpio_set_value(ORCA_AUD_JACKHP_EN, 1);
-			mdelay(10);
-		} else {
-			gpio_set_value(ORCA_AUD_JACKHP_EN, 0);
-		}
-	}
-}
-
-void orca_speaker_enable(int en)
-{
-	struct spkr_config_mode scm;
-	memset(&scm, 0, sizeof(scm));
-
-	D("%s %d\n", __func__, en);
-	if (en) {
-		mdelay(30);
-		scm.is_right_chan_en = 0;
-		scm.is_left_chan_en = 1;
-		scm.is_stereo_en = 0;
-		scm.is_hpf_en = 1;
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-		pmic_spkr_en_mute(RIGHT_SPKR, 0);
-		pmic_set_spkr_configuration(&scm);
-		pmic_spkr_en(LEFT_SPKR, 1);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		/* unmute */
-		pmic_spkr_en_mute(LEFT_SPKR, 1);
-	} else {
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-
-		pmic_spkr_en(LEFT_SPKR, 0);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		pmic_set_spkr_configuration(&scm);
-	}
-	mdelay(10);
-}
-
-void orca_receiver_enable(int en)
-{
-	/* Do nothing for orca. */
-}
-
-static uint32_t bt_sco_enable[] = {
-	PCOM_GPIO_CFG(ORCA_BT_PCM_OUT, 1, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(ORCA_BT_PCM_IN, 1, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(ORCA_BT_PCM_SYNC, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(ORCA_BT_PCM_CLK, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-static uint32_t bt_sco_disable[] = {
-	PCOM_GPIO_CFG(ORCA_BT_PCM_OUT, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(ORCA_BT_PCM_IN, 0, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(ORCA_BT_PCM_SYNC, 0, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(ORCA_BT_PCM_CLK, 0, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-void orca_bt_sco_enable(int en)
-{
-	static int bt_sco_refcount;
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&bt_sco_lock);
-	if (en) {
-		if (++bt_sco_refcount == 1)
-			config_gpio_table(bt_sco_enable,
-					ARRAY_SIZE(bt_sco_enable));
-	} else {
-		if (--bt_sco_refcount == 0) {
-			config_gpio_table(bt_sco_disable,
-					ARRAY_SIZE(bt_sco_disable));
-			gpio_set_value(ORCA_BT_PCM_OUT, 0);
-		}
-	}
-	mutex_unlock(&bt_sco_lock);
-}
-
-void orca_int_mic_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	if (en)
-		pmic_mic_en(ON_CMD);
-	else
-		pmic_mic_en(OFF_CMD);
-}
-
-void orca_ext_mic_enable(int en)
-{
-	static int old_state = 0, new_state = 0;
-
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&mic_lock);
-	if (!!en)
-		new_state++;
-	else
-		new_state--;
-
-	if (new_state == 1 && old_state == 0)
-		gpio_set_value(ORCA_AUD_2V5_EN, 1);
-	else if (new_state == 0 && old_state == 1)
-		gpio_set_value(ORCA_AUD_2V5_EN, 0);
-	else
-		D("%s: do nothing %d %d\n", __func__, old_state, new_state);
-
-	old_state = new_state;
-	mutex_unlock(&mic_lock);
-}
-
-void orca_analog_init(void)
-{
-	D("%s\n", __func__);
-	/* stereo pmic init */
-	pmic_spkr_set_gain(LEFT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_set_gain(RIGHT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_en_right_chan(OFF_CMD);
-	pmic_spkr_en_left_chan(OFF_CMD);
-	pmic_spkr_add_right_left_chan(OFF_CMD);
-	pmic_spkr_en_stereo(OFF_CMD);
-	pmic_spkr_select_usb_with_hpf_20hz(OFF_CMD);
-	pmic_spkr_bypass_mux(OFF_CMD);
-	pmic_spkr_en_hpf(ON_CMD);
-	pmic_spkr_en_sink_curr_from_ref_volt_cir(OFF_CMD);
-	pmic_spkr_set_mux_hpf_corner_freq(SPKR_FREQ_0_73KHZ);
-	pmic_mic_set_volt(MIC_VOLT_1_80V);
-
-	gpio_direction_output(ORCA_AUD_JACKHP_EN, 1);
-	gpio_set_value(ORCA_AUD_JACKHP_EN, 0);
-	gpio_set_value(ORCA_AUD_2V5_EN, 0);
-
-	mutex_lock(&bt_sco_lock);
-	config_gpio_table(bt_sco_disable,
-			ARRAY_SIZE(bt_sco_disable));
-	gpio_set_value(ORCA_BT_PCM_OUT, 0);
-	mutex_unlock(&bt_sco_lock);
-}
-
-static struct qsd_acoustic_ops acoustic = {
-	.enable_mic_bias = orca_ext_mic_enable,
-};
-
-static struct q6audio_analog_ops ops = {
-	.init = orca_analog_init,
-	.speaker_enable = orca_speaker_enable,
-	.headset_enable = orca_headset_enable,
-	.receiver_enable = orca_receiver_enable,
-	.bt_sco_enable = orca_bt_sco_enable,
-	.int_mic_enable = orca_int_mic_enable,
-	.ext_mic_enable = orca_ext_mic_enable,
-};
-
-void __init orca_audio_init(void)
-{
-	mutex_init(&mic_lock);
-	mutex_init(&bt_sco_lock);
-#if defined(CONFIG_QSD_AUDIO)
-	q6audio_register_analog_ops(&ops);
-#endif
-	acoustic_register_ops(&acoustic);
-}
diff --git a/arch/arm/mach-msm/board-orca-keypad.c b/arch/arm/mach-msm/board-orca-keypad.c
deleted file mode 100644
index 2ddb6ae..0000000
--- a/arch/arm/mach-msm/board-orca-keypad.c
+++ /dev/null
@@ -1,117 +0,0 @@
-/* arch/arm/mach-msm/board-orca-keypad.c
- *
- * Copyright (C) 2009 Google, Inc
- * Copyright (C) 2009 HTC Corporation.
- *
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/gpio_event.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <mach/vreg.h>
-
-#include <asm/mach-types.h>
-
-#include "board-orca.h"
-
-static unsigned int orca_col_gpios[] = {
-	ORCA_GPIO_KP_MKOUT0,
-	ORCA_GPIO_KP_MKOUT1,
-	ORCA_GPIO_KP_MKOUT2,
-};
-
-static unsigned int orca_row_gpios[] = {
-	ORCA_GPIO_KP_MPIN0,
-	ORCA_GPIO_KP_MPIN1,
-	ORCA_GPIO_KP_MPIN2,
-};
-
-#define KEYMAP_INDEX(col, row)	((col)*ARRAY_SIZE(orca_row_gpios) + (row))
-#define KEYMAP_SIZE		(ARRAY_SIZE(orca_col_gpios) * \
-				 ARRAY_SIZE(orca_row_gpios))
-
-/* keypad */
-static const unsigned short orca_keymap[KEYMAP_SIZE] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 1)] = BTN_MOUSE, /* OJ Action Key */
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(1, 2)] = KEY_SEARCH,
-	[KEYMAP_INDEX(2, 0)] = KEY_HOME,
-};
-
-static struct gpio_event_matrix_info orca_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = orca_keymap,
-	.output_gpios = orca_col_gpios,
-	.input_gpios = orca_row_gpios,
-	.noutputs = ARRAY_SIZE(orca_col_gpios),
-	.ninputs = ARRAY_SIZE(orca_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		  GPIOKPF_REMOVE_PHANTOM_KEYS |
-		  GPIOKPF_PRINT_UNMAPPED_KEYS),
-};
-
-static struct gpio_event_direct_entry orca_keypad_nav_map[] = {
-	{ ORCA_GPIO_POWER_KEY,              KEY_POWER      },
-};
-
-static struct gpio_event_input_info orca_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.flags = 0,
-	.type = EV_KEY,
-	.keymap = orca_keypad_nav_map,
-	.debounce_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.keymap_size = ARRAY_SIZE(orca_keypad_nav_map)
-};
-
-static struct gpio_event_info *orca_keypad_info[] = {
-	&orca_keypad_matrix_info.info,
-	&orca_keypad_nav_info.info,
-};
-
-static struct gpio_event_platform_data orca_keypad_data = {
-	.name = "orca-keypad",
-	.info = orca_keypad_info,
-	.info_count = ARRAY_SIZE(orca_keypad_info)
-};
-
-static struct platform_device orca_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &orca_keypad_data,
-	},
-};
-
-static int __init orca_init_keypad(void)
-{
-	int ret;
-
-	if (!machine_is_orca())
-		return 0;
-
-	ret = platform_device_register(&orca_keypad_device);
-	if (ret != 0)
-		return ret;
-
-	return 0;
-}
-
-device_initcall(orca_init_keypad);
-
-
diff --git a/arch/arm/mach-msm/board-orca-microp.c b/arch/arm/mach-msm/board-orca-microp.c
deleted file mode 100644
index 756a549..0000000
--- a/arch/arm/mach-msm/board-orca-microp.c
+++ /dev/null
@@ -1,250 +0,0 @@
-/* arch/arm/mach-msm/board-orca-microp.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <mach/atmega_microp.h>
-#include <mach/htc_35mm_remote.h>
-#include <mach/drv_callback.h>
-
-#include "board-orca.h"
-
-#ifdef CONFIG_HTC_HEADSET
-#define notify_35mm_headset_insert(insert) \
-	htc_35mm_remote_notify_insert_ext_headset(insert)
-#else
-#define notify_35mm_headset_insert(insert) do {} while (0)
-#endif
-
-/*
-static struct led_trigger orca_als_level_trigger = {
-	.name     = "auto-backlight-trigger",
-};
-
-static int orca_als_intr_enable(struct i2c_client *client,
-		uint32_t als_func, uint8_t enable)
-{
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[2];
-	int ret = 0;
-
-	cdata = i2c_get_clientdata(client);
-	mutex_lock(&cdata->microp_i2c_mutex);
-	cdata->als_func = enable ? (cdata->als_func |= als_func)
-				: (cdata->als_func &= ~als_func);
-
-	data[0] = 0;
-	if (cdata->als_func)
-		data[1] = 1;
-	else
-		data[1] = 0;
-
-	ret = microp_i2c_write(MICROP_I2C_WCMD_AUTO_BL_CTL, data, 2);
-	if (ret != 0)
-		printk(KERN_ERR "%s: set auto light sensor fail\n", __func__);
-
-	mutex_unlock(&cdata->microp_i2c_mutex);
-
-	return ret;
-}
-*/
-
-/*
-static void orca_als_level_change(struct i2c_client *client,
-		uint8_t *data)
-{
-	struct microp_i2c_client_data *cdata  = i2c_get_clientdata(client);
-
-	if (cdata->als_func & ALS_BACKLIGHT)
-		led_trigger_event(&orca_als_level_trigger, data[2]);
-}
-*/
-/*
-static int orca_als_power(int pwr_device, uint8_t enable)
-{
-	int value;
-*/
-#if 0 /*TODO: Not ready*/
-	value = enable ? 0 : 1;
-	gpio_set_value(ORCA_GPIO_LS_EN, value);
-#endif
-/*
-	return 0;
-}
-*/
-/*
-static int orca_als_table_init(struct i2c_client *client,
-			int i, uint32_t kadc, uint32_t gadc)
-{
-	struct microp_i2c_platform_data *pdata;
-	uint8_t data[30];
-	int j;
-
-	pdata = client->dev.platform_data;
-
-	for (j = 0; j < 10; j++) {
-		data[j] = (uint8_t)(pdata->microp_function[i].dutys[j]);
-		data[j + 10] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc >> 8);
-		data[j + 20] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc);
-	}
-
-	return microp_i2c_write(MICROP_I2C_WCMD_ADC_TABLE, data, 30);
-}
-*/
-/*
-static int orca_als_power_init(struct microp_i2c_platform_data *pdata)
-{
-	int ret = 0;
-
-	ret = gpio_request(pdata->gpio_ls_on, "microp_i2c");
-	if (ret < 0) {
-		pr_err("%s: failed on request gpio ls_on\n", __func__);
-		goto exit;
-	}
-
-	ret = gpio_direction_output(pdata->gpio_ls_on, 0);
-	if (ret < 0) {
-		pr_err("%s: failed on gpio_direction_output ls_on\n", __func__);
-		goto exit;
-	}
-
-exit:
-	return ret;
-
-}
-*/
-static int orca_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Light sensor */
-/*
-	ret = microp_function_check(client, MICROP_FUNCTION_LSENSOR);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_LSENSOR] = i;
-		cdata->int_pin.int_lsensor = pdata->microp_function[i].int_pin;
-		microp_get_als_kvalue(i);
-
-		ret = orca_als_table_init(client, i, cdata->als_kadc,
-				cdata->als_gadc);
-		if (ret < 0)
-			goto exit;
-*/
-#if 0 /*TODO: Not ready*/
-		orca_als_power_init(pdata);
-#endif
-/*	}*/
-
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Headset plugin */
-	ret = microp_function_check(client, MICROP_FUNCTION_HPIN);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_hpin = pdata->microp_function[i].int_pin;
-		cdata->gpio.hpin = pdata->microp_function[i].mask_r[0] << 16
-					| pdata->microp_function[i].mask_r[1] << 8
-					| pdata->microp_function[i].mask_r[2];
-
-		wake_lock_init(&cdata->hpin_wake_lock,
-					WAKE_LOCK_SUSPEND, "microp_35mm_hpin");
-
-		microp_read_gpio_status(data);
-		cdata->headset_is_in =
-				!((data[0] << 16 | data[1] << 8 | data[2])
-				& cdata->gpio.hpin);
-		if (cdata->headset_is_in)
-			notify_35mm_headset_insert(cdata->headset_is_in);
-
-		ret = microp_write_interrupt(client,
-				cdata->int_pin.int_hpin, 1);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	data[0] = 0x08;
-	ret = microp_i2c_write(MICROP_I2C_WCMD_MISC, data, 1);
-	if (ret)
-		goto exit;
-
-	/* SD Card detect */
-	ret = microp_function_check(client, MICROP_FUNCTION_SDCARD);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_sdcard = pdata->microp_function[i].int_pin;
-		cdata->gpio.sdcard = pdata->microp_function[i].mask_r[0] << 16
-					| pdata->microp_function[i].mask_r[1] << 8
-					| pdata->microp_function[i].mask_r[2];
-
-		microp_read_gpio_status(data);
-		cdata->sdcard_is_in = ((data[0] << 16 | data[1] << 8 | data[2])
-						& cdata->gpio.sdcard) ? 1 : 0;
-		cnf_driver_event("sdcard_detect", &cdata->sdcard_is_in);
-
-		ret = microp_write_interrupt(client,
-				cdata->int_pin.int_sdcard, 1);
-		if (ret)
-			goto exit;
-	}
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = orca_microp_function_init,
-/*
-	.als_pwr_enable = orca_als_power,
-	.als_intr_enable = orca_als_intr_enable,
-	.als_level_change = orca_als_level_change,
-*/
-};
-
-void __init orca_microp_init(void)
-{
-	/*led_trigger_register(&orca_als_level_trigger);*/
-	microp_register_ops(&ops);
-}
-
-#endif
diff --git a/arch/arm/mach-msm/board-orca-mmc.c b/arch/arm/mach-msm/board-orca-mmc.c
deleted file mode 100644
index 772a8cd..0000000
--- a/arch/arm/mach-msm/board-orca-mmc.c
+++ /dev/null
@@ -1,288 +0,0 @@
-/* linux/arch/arm/mach-msm/board-orca-mmc.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-
-#include "board-orca.h"
-#include "devices.h"
-#include "proc_comm.h"
-
-#define DEBUG_SDSLOT_VDD 1
-
-static bool opt_disable_sdcard;
-static int __init orca_disablesdcard_setup(char *str)
-{
-	opt_disable_sdcard = (bool)simple_strtol(str, NULL, 0);
-	return 1;
-}
-
-__setup("board_orca.disable_sdcard=", orca_disablesdcard_setup);
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static struct vreg	*sdslot_vreg;
-static uint32_t		sdslot_vdd = 0xffffffff;
-static uint32_t		sdslot_vreg_enabled;
-
-static struct {
-	int mask;
-	int level;
-} mmc_vdd_table[] = {
-	{ MMC_VDD_27_28,	2800 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static uint32_t orca_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-	int ret;
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(sdslot_vreg);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		ret = vreg_enable(sdslot_vreg);
-		if (ret)
-			pr_err("%s: Error enabling vreg (%d)\n", __func__, ret);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask != (1 << vdd))
-			continue;
-		ret = vreg_set_level(sdslot_vreg, mmc_vdd_table[i].level);
-		if (ret)
-			pr_err("%s: Error setting level (%d)\n", __func__, ret);
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Setting level to %u (%s)\n",
-					__func__, mmc_vdd_table[i].level,
-				ret?"Failed":"Success");
-#endif
-		return 0;
-	}
-
-	pr_err("%s: Invalid VDD (%d) specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int orca_sdslot_status(struct device *dev)
-{
-	return !gpio_get_value(ORCA_GPIO_SDMC_CD_N);
-}
-
-#define ORCA_MMC_VDD	(MMC_VDD_27_28 | MMC_VDD_28_29 | \
-				 MMC_VDD_29_30)
-
-static struct mmc_platform_data orca_sdslot_data = {
-	.ocr_mask	= ORCA_MMC_VDD,
-	.status		= orca_sdslot_status,
-	.translate_vdd	= orca_sdslot_switchvdd,
-};
-
-int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-		 unsigned int stat_irq, unsigned long stat_irq_flags);
-
-
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data orca_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-orca_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static int orca_wifi_cd;	/* WiFi virtual 'card detect' status */
-
-static unsigned int orca_wifi_status(struct device *dev)
-{
-	return orca_wifi_cd;
-}
-
-static struct mmc_platform_data orca_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= orca_wifi_status,
-	.register_status_notify	= orca_wifi_status_register,
-	.embedded_sdio		= &orca_wifi_emb_data,
-};
-
-int orca_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	orca_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(orca_wifi_set_carddetect);
-
-int orca_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-
-	mdelay(100);
-	gpio_set_value(ORCA_GPIO_WIFI_SHUTDOWN_N, on); /* WIFI_SHUTDOWN */
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(orca_wifi_power);
-
-int orca_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-
-int __init orca_init_mmc(unsigned int sys_rev)
-{
-	uint32_t id;
-
-	wifi_status_cb = NULL;
-
-	printk(KERN_INFO "%s()+\n", __func__);
-
-	/* initial WIFI_SHUTDOWN# */
-	id = PCOM_GPIO_CFG(ORCA_GPIO_WIFI_SHUTDOWN_N, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	msm_add_sdcc(1, &orca_wifi_data, 0, 0);
-
-	if (opt_disable_sdcard) {
-		pr_info("%s: sdcard disabled on cmdline\n", __func__);
-		goto done;
-	}
-
-	sdslot_vreg_enabled = 0;
-
-	sdslot_vreg = vreg_get(0, "gp6");
-	if (IS_ERR(sdslot_vreg))
-		return PTR_ERR(sdslot_vreg);
-
-	set_irq_wake(MSM_GPIO_TO_INT(ORCA_GPIO_SDMC_CD_N), 1);
-
-	msm_add_sdcc(2, &orca_sdslot_data,
-		     MSM_GPIO_TO_INT(ORCA_GPIO_SDMC_CD_N),
-		     IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-
-done:
-	printk(KERN_INFO "%s()-\n", __func__);
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-orca-panel.c b/arch/arm/mach-msm/board-orca-panel.c
deleted file mode 100644
index 34477f0..0000000
--- a/arch/arm/mach-msm/board-orca-panel.c
+++ /dev/null
@@ -1,692 +0,0 @@
-/* linux/arch/arm/mach-msm/board-orca-panel.c
- *
- * Copyright (c) 2009 Google Inc.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/wakelock.h>
-#include <linux/leds.h>
-#include <linux/workqueue.h>
-#include <mach/drv_callback.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <mach/msm_fb.h>
-
-#include "board-orca.h"
-#include "devices.h"
-
-#define CLK_NS_TO_RATE(ns)			(1000000000UL / (ns))
-
-#if 0
-#define B(s...) printk(s)
-#else
-#define B(s...) do {} while(0)
-#endif
-
-int qspi_send(unsigned char id, unsigned char data);
-int qspi_send_16bit(unsigned char id, unsigned data);
-
-static struct wake_lock backlight_wakelock;
-static struct work_struct work_set_brightness;
-static int g_brightness_level;
-
-struct lcd_init_table {
-        uint32_t reg, value, delay;
-};
-#define LCD_OLED_REG struct lcd_init_table
-
-static void __set_backlight(int on)
-{
-	B(KERN_DEBUG "nita:%s: enter.\n", __func__);
-
-	if (on)
-		cnf_driver_event("enable_backlight", (void *)LED_FULL);
-	else
-		cnf_driver_event("enable_backlight", (void *)LED_OFF);
-}
-
-static struct lcd_init_table auo_init_tb[] = {
-	{0x1, 0xC0, 0},
-	{0x0, 0x0 , 0},
-	{0x2, 0x86, 0},
-	{0x1, 0xC0, 0},
-	{0x0, 0x1 , 0},
-	{0x2, 0x0 , 0},
-	{0x1, 0xC0, 0},
-	{0x0, 0x2 , 0},
-	{0x2, 0x86, 0},
-	{0x1, 0xC0, 0},
-	{0x0, 0x3 , 0},
-	{0x2, 0x0 , 0},
-	{0x1, 0xC1, 0},
-	{0x0, 0x0 , 0},
-	{0x2, 0x45, 0},
-	{0x1, 0xC2, 0},
-	{0x0, 0x0 , 0},
-	{0x2, 0x31, 1},
-	{0x1, 0xC2, 0},
-	{0x0, 0x2 , 0},
-	{0x2, 0x30, 0},
-	{0x1, 0x11, 0},
-	{0x0, 0x0 , 0},
-	{0x2, 0x0 , 120},
-	//Gamma setting
-	//{0x1, 0x36, 0},
-	//{0x0, 0x0 , 0},
-	//{0x2, 0x8 , 0},
-	{0x1, 0x3A, 0},
-	{0x0, 0x0 , 0},
-	{0x2, 0x50, 0},
-	{0x1, 0xC1, 0},
-	{0x0, 0x0 , 0},
-	{0x2, 0x40, 0},
-	{0x1, 0xC2, 0},
-	{0x0, 0x0 , 0},
-	{0x2, 0x2 , 0},
-	{0x1, 0xC2, 0},
-	{0x0, 0x2 , 0},
-	{0x2, 0x32, 120},
-	{0x1, 0x29, 0},
-	{0x0, 0x0 , 0},
-	{0x2, 0x0 , 0},
-};
-
-static struct lcd_init_table auo_deinit_tb[] = {
-	{0x1, 0x28, 0},
-	{0x0, 0x0 , 0},
-	{0x2, 0x0 , 0},
-	{0x1, 0x10, 0},
-	{0x0, 0x0 , 0},
-	{0x2, 0x0 , 35},
-};
-
-
-static const LCD_OLED_REG LCD_OLED_INIT_TABLE[]={
-        { 0x31, 0x08, 0 },
-        { 0x32, 0x14, 0 },
-        { 0x30, 0x2 , 0 },
-        { 0x27, 0x1 , 0 },
-        { 0x12, 0x8 , 0 },
-        { 0x13, 0x8 , 0 },
-        { 0x15, 0x0 , 0 },
-        { 0x16, 0x02, 0 },
-        { 0x39, 0x44, 0 },
-        { 0x17, 0x22, 0 },
-        { 0x18, 0x33, 0 },
-        { 0x19, 0x3 , 0 },
-        { 0x1A, 0x1 , 0 },
-        { 0x22, 0xA4, 0 },
-        { 0x23, 0x0 , 0 },
-        { 0x26, 0xA0, 0 },
-        { 0x1D, 0xA0, 250},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_10_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x3f, 0},
-        { 0x43,0x35, 0},
-        { 0x44,0x30, 0},
-        { 0x45,0x2c, 0},
-        { 0x46,0x13, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x0 , 0},
-        { 0x53,0x0 , 0},
-        { 0x54,0x27, 0},
-        { 0x55,0x2b, 0},
-        { 0x56,0x12, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x3f, 0},
-        { 0x63,0x34, 0},
-        { 0x64,0x2f, 0},
-        { 0x65,0x2b, 0},
-        { 0x66,0x1b, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_40_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x3e, 0},
-        { 0x43,0x2e, 0},
-        { 0x44,0x2d, 0},
-        { 0x45,0x28, 0},
-        { 0x46,0x21, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x0 , 0},
-        { 0x53,0x21, 0},
-        { 0x54,0x2a, 0},
-        { 0x55,0x28, 0},
-        { 0x56,0x20, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x3e, 0},
-        { 0x63,0x2d, 0},
-        { 0x64,0x2b, 0},
-        { 0x65,0x26, 0},
-        { 0x66,0x2d, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_70_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x35, 0},
-        { 0x43,0x2c, 0},
-        { 0x44,0x2b, 0},
-        { 0x45,0x26, 0},
-        { 0x46,0x29, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x0 , 0},
-        { 0x53,0x25, 0},
-        { 0x54,0x29, 0},
-        { 0x55,0x26, 0},
-        { 0x56,0x28, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x34, 0},
-        { 0x63,0x2b, 0},
-        { 0x64,0x2a, 0},
-        { 0x65,0x23, 0},
-        { 0x66,0x37, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_100_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x30, 0},
-        { 0x43,0x2a, 0},
-        { 0x44,0x2b, 0},
-        { 0x45,0x24, 0},
-        { 0x46,0x2f, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x0 , 0},
-        { 0x53,0x25, 0},
-        { 0x54,0x29, 0},
-        { 0x55,0x24, 0},
-        { 0x56,0x2e, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x2f, 0},
-        { 0x63,0x29, 0},
-        { 0x64,0x29, 0},
-        { 0x65,0x21, 0},
-        { 0x66,0x3f, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_130_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x2e, 0},
-        { 0x43,0x29, 0},
-        { 0x44,0x2a, 0},
-        { 0x45,0x23, 0},
-        { 0x46,0x34, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0xa , 0},
-        { 0x53,0x25, 0},
-        { 0x54,0x28, 0},
-        { 0x55,0x23, 0},
-        { 0x56,0x33, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f , 0},
-        { 0x62,0x2d, 0},
-        { 0x63,0x28, 0},
-        { 0x64,0x27, 0},
-        { 0x65,0x20, 0},
-        { 0x66,0x46, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_160_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x2b, 0},
-        { 0x43,0x29, 0},
-        { 0x44,0x28, 0},
-        { 0x45,0x23, 0},
-        { 0x46,0x38, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0xb , 0},
-        { 0x53,0x25, 0},
-        { 0x54,0x27, 0},
-        { 0x55,0x23, 0},
-        { 0x56,0x37, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f , 0},
-        { 0x62,0x29, 0},
-        { 0x63,0x28, 0},
-        { 0x64,0x25, 0},
-        { 0x65,0x20, 0},
-        { 0x66,0x4b, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_190_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x29, 0},
-        { 0x43,0x29, 0},
-        { 0x44,0x27, 0},
-        { 0x45,0x22, 0},
-        { 0x46,0x3c, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x10, 0},
-        { 0x53,0x26, 0},
-        { 0x54,0x26, 0},
-        { 0x55,0x22, 0},
-        { 0x56,0x3b, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x28, 0},
-        { 0x63,0x28, 0},
-        { 0x64,0x24, 0},
-        { 0x65,0x1f, 0},
-        { 0x66,0x50, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_220_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x28, 0},
-        { 0x43,0x28, 0},
-        { 0x44,0x28, 0},
-        { 0x45,0x20, 0},
-        { 0x46,0x40, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x11, 0},
-        { 0x53,0x25, 0},
-        { 0x54,0x27, 0},
-        { 0x55,0x20, 0},
-        { 0x56,0x3f, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x27, 0},
-        { 0x63,0x26, 0},
-        { 0x64,0x26, 0},
-        { 0x65,0x1c, 0},
-        { 0x66,0x56, 0},
-};
-
-static const LCD_OLED_REG LCD_OLED_GAMMA_250_TABLE[]={
-        //Gamma -R
-        { 0x40,0x0 , 0},
-        { 0x41,0x3f, 0},
-        { 0x42,0x2a, 0},
-        { 0x43,0x27, 0},
-        { 0x44,0x27, 0},
-        { 0x45,0x1f, 0},
-        { 0x46,0x44, 0},
-        //Gamma -G
-        { 0x50,0x0 , 0},
-        { 0x51,0x0 , 0},
-        { 0x52,0x17, 0},
-        { 0x53,0x24, 0},
-        { 0x54,0x26, 0},
-        { 0x55,0x1f, 0},
-        { 0x56,0x43, 0},
-        //Gamma -B
-        { 0x60,0x0 , 0},
-        { 0x61,0x3f, 0},
-        { 0x62,0x2a, 0},
-        { 0x63,0x25, 0},
-        { 0x64,0x24, 0},
-        { 0x65,0x1b, 0},
-        { 0x66,0x5c, 0},
-};
-
-static LCD_OLED_REG *gamma_level_table[] = {
-        LCD_OLED_GAMMA_10_TABLE,
-        LCD_OLED_GAMMA_40_TABLE,
-        LCD_OLED_GAMMA_70_TABLE,
-        LCD_OLED_GAMMA_100_TABLE,
-        LCD_OLED_GAMMA_130_TABLE,
-        LCD_OLED_GAMMA_160_TABLE,
-        LCD_OLED_GAMMA_190_TABLE,
-        LCD_OLED_GAMMA_220_TABLE,
-        LCD_OLED_GAMMA_250_TABLE
-};
-
-static int spi_write_via_i2c(unsigned char id, unsigned char data)
-{
-        qspi_send(0x0, id);
-        qspi_send(0x1, data);
-
-        return 0;
-}
-
-static int spi_write_seq_via_i2c(LCD_OLED_REG init_table[], unsigned size)
-{
-        int i;
-
-        for ( i=0; i<size; i++) {
-                spi_write_via_i2c(init_table[i].reg,
-                        init_table[i].value);
-                if (init_table[i].delay)
-                        mdelay(init_table[i].delay);
-        }
-
-        return 0 ;
-}
-
-#define ORCA_BRIGHTNESS_MAX_LEVEL            9
-
-int orca_set_backlight_level(int level)
-{
-        static int toggle = 0;
-        int value[2] = {0x43, 0x34};
-        static int first = 1;
-
-        if(level < 0 || level > ORCA_BRIGHTNESS_MAX_LEVEL - 1)
-                return -1;
-        printk("orca_set_backlight_level:%d\n", level);
-
-        if(first) {
-                spi_write_via_i2c(0x39, value[toggle]);
-                first = 0;
-        }
-        toggle = !toggle;
-        spi_write_seq_via_i2c(gamma_level_table[level],
-                ARRAY_SIZE(LCD_OLED_GAMMA_10_TABLE));
-        spi_write_via_i2c(0x39, value[toggle]);
-
-        return 0;
-}
-
-static DEFINE_MUTEX(led_value_set_lock);
-static void display_wake_up()
-{
-	int i;
-
-	mutex_lock(&led_value_set_lock);
-	for (i=0; i<ARRAY_SIZE(auo_init_tb); i++) {
-		qspi_send_16bit(auo_init_tb[i].reg, auo_init_tb[i].value) ;
-		if (auo_init_tb[i].delay)
-			mdelay(auo_init_tb[i].delay) ;
-	}
-	mutex_unlock(&led_value_set_lock);
-
-}
-
-static void display_stand_by()
-{
-	int i;
-
-        mutex_lock(&led_value_set_lock);
-
-	for (i=0; i<ARRAY_SIZE(auo_deinit_tb); i++) {
-		qspi_send_16bit(auo_deinit_tb[i].reg, auo_deinit_tb[i].value) ;
-		if (auo_deinit_tb[i].delay)
-			mdelay(auo_deinit_tb[i].delay);
-	}
-
-        mutex_unlock(&led_value_set_lock);
-}
-
-static int orca_panel_unblank(struct msm_lcdc_panel_ops *panel_data)
-{
-/*
-        struct msm_mddi_panel_info *panel = container_of(panel_data,
-                struct msm_mddi_panel_info, panel_data);
-        struct msm_mddi_client_data *cdata;
-*/
-        printk("+%s()\n", __FUNCTION__);
-
-        display_wake_up();
-
-	__set_backlight(1);
-
-        return 0 ;
-}
-
-static int orca_panel_blank(struct msm_lcdc_panel_ops *panel_data)
-{
-        printk("+%s()\n", __FUNCTION__);
-
-	__set_backlight(0);
-
-        display_stand_by();
-
-        return 0 ;
-}
-
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = 0x1fe00000,//MSM_FB_BASE,
-		.end = 0x1fffffff,//MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static int orca_panel_init(struct msm_lcdc_panel_ops *ops)
-{
-
-#if 0
-	int i;
-	pr_info("%s: +()\n", __func__);
-
-	for (i=0; i<ARRAY_SIZE(auo_init_tb); i++) {
-		qspi_send_16bit(auo_init_tb[i].reg, auo_init_tb[i].value) ;
-		if (auo_init_tb[i].delay)
-			mdelay(auo_init_tb[i].delay) ;
-	}
-
-	pr_info("%s: -()\n", __func__);
-#endif
-
-	return 0;
-}
-
-static struct msm_lcdc_panel_ops orca_lcdc_panel_ops = {
-	.init		= orca_panel_init,
-	.blank		= orca_panel_blank,
-	.unblank	= orca_panel_unblank,
-};
-
-static struct msm_lcdc_timing orca_lcdc_timing = {
-		.clk_rate		= CLK_NS_TO_RATE(26),
-		.hsync_pulse_width	= 2,
-		.hsync_back_porch	= 30,
-		.hsync_front_porch	= 10,
-		.hsync_skew		= 0,
-		.vsync_pulse_width	= 2,
-		.vsync_back_porch	= 20,
-		.vsync_front_porch	= 10,
-		.vsync_act_low		= 1,
-		.hsync_act_low		= 1,
-		.den_act_low		= 1,
-};
-
-static struct msm_fb_data orca_lcdc_fb_data = {
-		.xres		= 480,
-		.yres		= 800,
-		.width		= 48,
-		.height		= 80,
-		.output_format	= 0,
-};
-
-static struct msm_lcdc_platform_data orca_lcdc_platform_data = {
-	.panel_ops	= &orca_lcdc_panel_ops,
-	.timing		= &orca_lcdc_timing,
-	.fb_id		= 0,
-	.fb_data	= &orca_lcdc_fb_data,
-	.fb_resource	= &resources_msm_fb[0],
-};
-
-static struct platform_device orca_lcdc_device = {
-	.name	= "msm_mdp_lcdc",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &orca_lcdc_platform_data,
-	},
-};
-
-/*----------------------------------------------------------------------------*/
-static void set_brightness_work_func(struct work_struct *work)
-{
-        mutex_lock(&led_value_set_lock);
-        orca_set_backlight_level(g_brightness_level);
-        mutex_unlock(&led_value_set_lock);
-        wake_unlock(&backlight_wakelock);
-}
-#if 0
-static struct msm_mdp_platform_data orca_mdp_platform_data = {
-        .lcdc_data = &orca_lcdc_platform_data,
-};
-#endif
-
-void orca_brightness_set(
-                struct led_classdev *led_cdev,
-                unsigned int value)
-{
-#if 1 /*TODO: Orca*/
-     /*   static uint8_t last_level = ORCA_BRIGHTNESS_MAX_LEVEL;
-        uint8_t level = value * (ORCA_BRIGHTNESS_MAX_LEVEL - 1) / LED_FULL;
-
-        printk("+%s()\n", __FUNCTION__ );
-        mutex_lock(&led_value_set_lock);
-
-        if (level == last_level) {
-                mutex_unlock(&led_value_set_lock);
-                return;
-        }
-        wake_lock(&backlight_wakelock);
-        g_brightness_level = level;
-        last_level = level;
-        schedule_work(&work_set_brightness);
-        mutex_unlock(&led_value_set_lock);*/
-
-	cnf_driver_event("set_backlight_brightness", (void *)value);
-#endif
-}
-
-static struct led_classdev orca_backlight_led = {
-        .name = "lcd-backlight",
-        .brightness = LED_FULL,
-        .brightness_set = orca_brightness_set,
-};
-
-static int orca_backlight_probe(struct platform_device *pdev)
-{
-	int rc;
-
-	printk("+%s()\n", __FUNCTION__ );
-	rc = led_classdev_register(&pdev->dev, &orca_backlight_led);
-	if(rc){
-		printk("backlight: failure on register led_classdev\n");
-	}
-	INIT_WORK(&work_set_brightness, set_brightness_work_func);
-	printk("-%s()\n", __FUNCTION__ );
-	return 0;
-}
-
-static int orca_backlight_remove(struct platform_device *pdev)
-{
-        led_classdev_unregister(&orca_backlight_led);
-        return 0;
-}
-
-static struct platform_device orca_backlight = {
-        .name = "orca-backlight",
-};
-
-static struct platform_driver orca_backlight_driver = {
-        .probe          = orca_backlight_probe,
-        .remove         = orca_backlight_remove,
-        .driver         = {
-                .name           = "orca-backlight",
-                .owner          = THIS_MODULE,
-        },
-};
-
-int __init orca_init_panel(void)
-{
-	int ret;
-
-	if (!machine_is_orca())
-		return 0;
-        wake_lock_init(&backlight_wakelock, WAKE_LOCK_SUSPEND,
-                "backlight_present");
-
-	/*msm_device_mdp.dev.platform_data = &orca_mdp_platform_data;
-	ret = platform_device_register(&msm_device_mdp);
-	if (ret != 0)
-		return ret;*/
-
-	ret = platform_device_register(&orca_lcdc_device);
-	if (ret != 0)
-		return ret;
-
-        platform_device_register(&orca_backlight);
-        ret = platform_driver_register(&orca_backlight_driver);
-        if (ret)
-                return ret;
-	printk("-%s()\n", __FUNCTION__ );
-	return 0;
-}
-
-/* we have to init mdp device followed by fb init,
- *  init mdp lately would cause some mdp operation malfunction  */
-int __init orca_init_mdp(void)
-{
-        int ret;
-
-        if (!machine_is_orca())
-                return 0;
-
-        ret = platform_device_register(&msm_device_mdp);
-        if (ret != 0)
-                return ret;
-
-	return 0;
-}
-
-device_initcall(orca_init_mdp);
-
-late_initcall(orca_init_panel);
diff --git a/arch/arm/mach-msm/board-orca-rfkill.c b/arch/arm/mach-msm/board-orca-rfkill.c
deleted file mode 100644
index 65a6cc3..0000000
--- a/arch/arm/mach-msm/board-orca-rfkill.c
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for orca platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-orca.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-/* bt initial configuration */
-static uint32_t orca_bt_init_table[] = {
-
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt on configuration */
-static uint32_t orca_bt_on_table[] = {
-
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_RX, /* BT_RX */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt off configuration */
-static uint32_t orca_bt_off_table[] = {
-
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_RTS, /* BT_RTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_UART1_TX, /* BT_TX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void orca_config_bt_init(void)
-{
-	/* set bt initial configuration*/
-	config_bt_table(orca_bt_init_table,
-				ARRAY_SIZE(orca_bt_init_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(ORCA_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(ORCA_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(ORCA_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-
-}
-
-static void orca_config_bt_on(void)
-{
-	/* set bt on configuration*/
-	config_bt_table(orca_bt_on_table,
-				ARRAY_SIZE(orca_bt_on_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(ORCA_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(ORCA_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-}
-
-static void orca_config_bt_off(void)
-{
-	/* BT_SHUTDOWN_N */
-	gpio_configure(ORCA_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_RESET_N */
-	gpio_configure(ORCA_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(orca_bt_off_table,
-				ARRAY_SIZE(orca_bt_off_table));
-	mdelay(5);
-
-	/* BT_RTS */
-	gpio_configure(ORCA_GPIO_BT_UART1_RTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CTS */
-	gpio_configure(ORCA_GPIO_BT_UART1_CTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_TX */
-	gpio_configure(ORCA_GPIO_BT_UART1_TX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_RX */
-	gpio_configure(ORCA_GPIO_BT_UART1_RX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-
-	/* BT_HOST_WAKE */
-	gpio_configure(ORCA_GPIO_BT_HOST_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CHIP_WAKE */
-	gpio_configure(ORCA_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		orca_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		orca_config_bt_off();
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int orca_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	orca_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int orca_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver orca_rfkill_driver = {
-	.probe = orca_rfkill_probe,
-	.remove = orca_rfkill_remove,
-	.driver = {
-		.name = "orca_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init orca_rfkill_init(void)
-{
-	if (!machine_is_orca())
-		return 0;
-
-	return platform_driver_register(&orca_rfkill_driver);
-}
-
-static void __exit orca_rfkill_exit(void)
-{
-	platform_driver_unregister(&orca_rfkill_driver);
-}
-
-module_init(orca_rfkill_init);
-module_exit(orca_rfkill_exit);
-MODULE_DESCRIPTION("orca rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-orca-wifi.c b/arch/arm/mach-msm/board-orca-wifi.c
deleted file mode 100644
index 7bafff1..0000000
--- a/arch/arm/mach-msm/board-orca-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-orca-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-orca.h"
-
-int orca_wifi_power(int on);
-int orca_wifi_reset(int on);
-int orca_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *orca_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init orca_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource orca_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(ORCA_GPIO_WIFI_IRQ),
-		.end		= MSM_GPIO_TO_INT(ORCA_GPIO_WIFI_IRQ),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data orca_wifi_control = {
-	.set_power      = orca_wifi_power,
-	.set_reset      = orca_wifi_reset,
-	.set_carddetect = orca_wifi_set_carddetect,
-	.mem_prealloc   = orca_wifi_mem_prealloc,
-};
-
-static struct platform_device orca_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(orca_wifi_resources),
-        .resource       = orca_wifi_resources,
-        .dev            = {
-                .platform_data = &orca_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned orca_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init orca_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_orca())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	orca_wifi_update_nvs("sd_oobonly=1\n");
-	orca_init_wifi_mem();
-	ret = platform_device_register(&orca_wifi_device);
-        return ret;
-}
-
-device_initcall(orca_wifi_init);
diff --git a/arch/arm/mach-msm/board-orca.c b/arch/arm/mach-msm/board-orca.c
deleted file mode 100644
index bb1691b..0000000
--- a/arch/arm/mach-msm/board-orca.c
+++ /dev/null
@@ -1,1239 +0,0 @@
-/* linux/arch/arm/mach-msm/board-orca.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/cy8c_tmg_ts.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/usb/mass_storage_function.h>
-#include <linux/android_pmem.h>
-#include <linux/synaptics_t1007.h>
-#include <linux/input.h>
-#include <linux/elan_i2c.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-/* #include <linux/capella_cm3602.h> */
-#include <linux/regulator/machine.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/setup.h>
-
-#include <mach/board.h>
-#include <mach/hardware.h>
-#include <mach/atmega_microp.h>
-#include <mach/camera.h>
-#include <mach/msm_hsusb.h>
-#include <mach/msm_iomap.h>
-#include <mach/htc_battery.h>
-#include <mach/perflock.h>
-#include <mach/msm_serial_debugger.h>
-#include <linux/spi/spi.h>
-#include <linux/curcial_oj.h>
-
-#include "board-orca.h"
-#include "devices.h"
-#include "proc_comm.h"
-#include "smd_private.h"
-#if 1	/*allenou, bt for bcm, 2009/7/8 */
-#include <mach/msm_serial_hs.h>
-#endif
-#include <mach/tpa6130.h>
-#include <mach/msm_flashlight.h>
-#include <linux/atmel_qt602240.h>
-#include <mach/vreg.h>
-
-#define SMEM_SPINLOCK_I2C      6
-
-#ifdef CONFIG_ARCH_QSD8X50
-extern unsigned char *get_bt_bd_ram(void);
-#endif
-
-void msm_init_pmic_vibrator(void);
-extern void __init orca_audio_init(void);
-#ifdef CONFIG_MICROP_COMMON
-void __init orca_microp_init(void);
-#endif
-
-#if 0
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	/* .gpio_mbat_in = ORCA_GPIO_MBAT_IN, */
-	.gpio_mchg_en_n = ORCA_GPIO_MCHG_EN_N,
-	.gpio_iset = ORCA_GPIO_ISET,
-	.guage_driver = GUAGE_NONE,
-	.m2a_cable_detect = 1,
-	/* .charger = SMB329_SWITCH_CHARGER, */
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = 0,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-#endif
-
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0x000, 0x005, 0x007, 0x033, 0x13F, 0x1A9, 0x1F1, 0x239, 0x27E, 0x3FF },
-		.dutys = { 6, 25, 50, 76, 91, 114, 140, 165, 191, 217 },
-		.channel = 6,
-	},
-	{
-		.name   = "3button-key-value",
-		.category = MICROP_FUNCTION_RMK_VALUE,
-		.levels = {200, 0x3FF, 0, 33, 38, 82, 95, 167},
-		.channel = 7,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.gpio_reset = ORCA_GPIO_UP_RESET_N,
-	/* .gpio_ls_on = ORCA_GPIO_TP_LS_EN, */
-	.spi_devices = SPI_GSENSOR,
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "button-backlight",
-		.type = LED_PWM,
-		.mask_w = {0x02, 0x00, 0x00},
-		.led_pin = 1 << 2,
-		.init_value = 0xFF,
-		.fade_time = 1,
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct platform_device microp_leds = {
-	.name		= "leds-microp",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &microp_leds_data,
-	},
-};
-
-#ifdef CONFIG_USB_FUNCTION
-static char *orca_usb_functions[] = {
-#if defined(CONFIG_USB_FUNCTION_MASS_STORAGE) || defined(CONFIG_USB_FUNCTION_UMS)
-	"usb_mass_storage",
-#endif
-#if defined(CONFIG_USB_FUNCTION_ADB)
-	"adb",
-#endif
-#if defined(CONFIG_USB_FUNCTION_DIAG)
-	"diag",
-#endif
-#if defined(CONFIG_USB_FUNCTION_PROJECTOR)
-	"projector",
-#endif
-#if defined(CONFIG_USB_FUNCTION_MTP_TUNNEL)
-	"mtp_tunnel",
-#endif
-#if defined(CONFIG_USB_FUNCTION_ETHER)
-	"ether",
-#endif
-#if defined(CONFIG_USB_FUNCTION_MODEM)
-	"modem",
-	"nmea",
-#endif
-};
-
-static struct msm_hsusb_product orca_usb_products[] = {
-	{
-		.product_id	= 0x0c01,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c02,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* adb + mass_storage + modem */
-	},
-	{
-		.product_id = 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id = 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id = 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000303, /* adb + mass_storage + modem +nmea */
-	},
-	{
-		.product_id = 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-#endif
-
-static int orca_phy_init_seq[] = { 0x1D, 0x0D, 0x1D, 0x10, -1 };
-
-static struct msm_hsusb_platform_data msm_hsusb_pdata = {
-	.phy_init_seq		= orca_phy_init_seq,
-	.vendor_id		= 0x0bb4,
-	.product_id		= 0x0c02,
-	.version		= 0x0100,
-	.product_name		= "Android Phone",
-	.serial_number		= "42",
-	.manufacturer_name	= "HTC",
-
-	.functions		= orca_usb_functions,
-	.num_functions		= ARRAY_SIZE(orca_usb_functions),
-	.products		= orca_usb_products,
-	.num_products		= ARRAY_SIZE(orca_usb_products),
-};
-
-static struct usb_mass_storage_platform_data mass_storage_pdata = {
-	.nluns		= 2,
-	.buf_size	= 16384,
-	.vendor		= "Google",
-	.product	= "orca",
-	.release	= 0x0100,
-};
-
-static struct platform_device usb_mass_storage_device = {
-	.name	= "usb_mass_storage",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &mass_storage_pdata,
-	},
-};
-
-static struct platform_device orca_rfkill = {
-	.name = "orca_rfkill",
-	.id = -1,
-};
-
-#if 0
-static int capella_cm3602_power(int on)
-{
-	return 0;
-}
-
-/* Proximity Sensor (Capella_CM3602)*/
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.power = capella_cm3602_power,
-	.p_en = ORCA_GPIO_PROXIMITY_EN_N,
-	.p_out = 0,
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = "orca_proximity",
-	.id = -1,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-#endif
-
-static struct resource qsd_spi_resources[] = {
-	{
-		.name   = "spi_irq_in",
-		.start  = INT_SPI_INPUT,
-		.end    = INT_SPI_INPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_out",
-		.start  = INT_SPI_OUTPUT,
-		.end    = INT_SPI_OUTPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_err",
-		.start  = INT_SPI_ERROR,
-		.end    = INT_SPI_ERROR,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_base",
-		.start  = 0xA1200000,
-		.end    = 0xA1200000 + SZ_4K - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.name   = "spi_clk",
-		.start  = 17,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_mosi",
-		.start  = 18,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_miso",
-		.start  = 19,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_cs0",
-		.start  = 20,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_pwr",
-		.start  = 21,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_cs0",
-		.start  = 22,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device qsd_device_spi = {
-	.name           = "spi_qsd",
-	.id             = 0,
-	.num_resources  = ARRAY_SIZE(qsd_spi_resources),
-	.resource       = qsd_spi_resources,
-};
-
-static struct resource msm_kgsl_resources[] = {
-	{
-		.name	= "kgsl_reg_memory",
-		.start	= MSM_GPU_REG_PHYS,
-		.end	= MSM_GPU_REG_PHYS + MSM_GPU_REG_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "kgsl_phys_memory",
-		.start	= MSM_GPU_MEM_BASE,
-		.end	= MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_GRAPHICS,
-		.end	= INT_GRAPHICS,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device msm_kgsl_device = {
-	.name		= "kgsl",
-	.id		= -1,
-	.resource	= msm_kgsl_resources,
-	.num_resources	= ARRAY_SIZE(msm_kgsl_resources),
-};
-
-static struct android_pmem_platform_data mdp_pmem_pdata = {
-	.name		= "pmem",
-	.start		= MSM_PMEM_MDP_BASE,
-	.size		= MSM_PMEM_MDP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu0_pdata = {
-	.name		= "pmem_gpu0",
-	.start		= MSM_PMEM_GPU0_BASE,
-	.size		= MSM_PMEM_GPU0_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu1_pdata = {
-	.name		= "pmem_gpu1",
-	.start		= MSM_PMEM_GPU1_BASE,
-	.size		= MSM_PMEM_GPU1_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct android_pmem_platform_data android_pmem_adsp_pdata = {
-	.name		= "pmem_adsp",
-	.start		= MSM_PMEM_ADSP_BASE,
-	.size		= MSM_PMEM_ADSP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-#if 0
-static struct android_pmem_platform_data android_pmem_camera_pdata = {
-	.name		= "pmem_camera",
-	.start		= MSM_PMEM_CAMERA_BASE,
-	.size		= MSM_PMEM_CAMERA_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-#endif
-
-static struct platform_device android_pmem_mdp_device = {
-	.name		= "android_pmem",
-	.id		= 0,
-	.dev		= {
-		.platform_data = &mdp_pmem_pdata
-	},
-};
-
-static struct platform_device android_pmem_gpu0_device = {
-	.name		= "android_pmem",
-	.id		= 2,
-	.dev		= {
-		.platform_data = &android_pmem_gpu0_pdata,
-	},
-};
-
-static struct platform_device android_pmem_gpu1_device = {
-	.name		= "android_pmem",
-	.id		= 3,
-	.dev		= {
-		.platform_data = &android_pmem_gpu1_pdata,
-	},
-};
-
-static struct platform_device android_pmem_adsp_device = {
-	.name		= "android_pmem",
-	.id		= 4,
-	.dev		= {
-		.platform_data = &android_pmem_adsp_pdata,
-	},
-};
-
-#if 0
-static struct platform_device android_pmem_camera_device = {
-	.name		= "android_pmem",
-	.id		= 5,
-	.dev		= {
-		.platform_data = &android_pmem_camera_pdata,
-	},
-};
-#endif
-
-static struct synaptics_virtual_key synaptics_virt_keys[] = {
-	{
-		.keycode = KEY_HOME,
-		.range_min = 50,
-		.range_max = 700,
-	},
-	{
-		.keycode = KEY_MENU,
-		.range_min = 1250,
-		.range_max = 1900,
-	},
-	{
-		.keycode = KEY_BACK,
-		.range_min = 2350,
-		.range_max = 3000,
-	},
-	{
-		.keycode = KEY_COMPOSE,
-		.range_min = 3350,
-		.range_max = 4000,
-	},
-};
-
-static struct resource ram_console_resources[] = {
-	{
-		.start	= MSM_RAM_CONSOLE_BASE,
-		.end	= MSM_RAM_CONSOLE_BASE + MSM_RAM_CONSOLE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device ram_console_device = {
-	.name		= "ram_console",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(ram_console_resources),
-	.resource	= ram_console_resources,
-};
-
-static int orca_ts_power(int on)
-{
-	pr_info("%s: power %d\n", __func__, on);
-
-	if (on) {
-		/* level shifter should be off */
-		gpio_set_value(ORCA_GPIO_TP_EN, 1);
-		msleep(300);
-		gpio_set_value(ORCA_GPIO_TP_I2C_SEL, 1);
-	} else {
-		gpio_set_value(ORCA_GPIO_TP_I2C_SEL, 0);
-		gpio_set_value(ORCA_GPIO_TP_EN, 0);
-	}
-
-	return 0;
-}
-
-static int orca_ts_power_xc(int on)
-{
-
-	if (on) {
-		gpio_set_value(ORCA_GPIO_TP_I2C_SEL, 1);
-		gpio_set_value(ORCA_GPIO_TP_EN, 1);
-		msleep(500);
-		gpio_set_value(ORCA_GPIO_TP_I2C_SEL, 0);
-	} else {
-		gpio_set_value(ORCA_GPIO_TP_I2C_SEL, 1);
-		gpio_set_value(ORCA_GPIO_TP_EN, 0);
-	}
-
-	return 0;
-}
-
-static struct elan_i2c_platform_data elan_i2c_data[] = {
-	{
-	.version = 0x100,
-	.abs_x_min = 0,
-	.abs_y_min = 0,
-	.intr_gpio = ORCA_GPIO_TP_INT_N,
-	.power = orca_ts_power,
-	},
-};
-
-#if 0
-static struct synaptics_i2c_rmi_platform_data orca_ts_data[] = {
-	{
-		.version = 0x0100,
-		.power = orca_ts_power,
-		.virtual_key = synaptics_virt_keys,
-		.virtual_key_num = ARRAY_SIZE(synaptics_virt_keys),
-		.sensitivity = 10,
-		.gap_area = 280 * 0x10000 / 8040,
-		.key_area = 120 * 0x10000 / 8040,
-		.flags = SYNAPTICS_FLIP_Y  | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = -80 * 0x10000 / 4824,
-		.inactive_right = -80 * 0x10000 / 4824,
-		.inactive_top = -100 * 0x10000 / 8040,
-		.inactive_bottom = -10 * 0x10000 / 8040,
-		.snap_left_on = 80 * 0x10000 / 4824,
-		.snap_left_off = 90 * 0x10000 / 4824,
-		.snap_right_on = 80 * 0x10000 / 4824,
-		.snap_right_off = 90 * 0x10000 / 4824,
-		.snap_top_on = 100 * 0x10000 / 8040,
-		.snap_top_off = 110 * 0x10000 / 8040,
-		.snap_bottom_on = 120 * 0x10000 / 8040,
-		.snap_bottom_off = 140 * 0x10000 / 8040,
-	},
-};
-#endif
-
-struct cy8c_i2c_platform_data orca_cy8c_ts_data = {
-	.version = 0x0001,
-	.abs_x_min = 1,
-	.abs_x_max = 480,
-	.abs_y_min = 1,
-	.abs_y_max = 800,
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-	.abs_width_min = 0,
-	.abs_width_max = 10,
-	.power = orca_ts_power,
-};
-
-static struct regulator_consumer_supply tps65023_dcdc1_supplies[] = {
-	{
-		.supply = "acpu_vcore",
-	},
-};
-
-static struct regulator_init_data tps65023_data[5] = {
-	{
-		.constraints = {
-			.name = "dcdc1", /* VREG_MSMC2_1V29 */
-			.min_uV = 1000000,
-			.max_uV = 1300000,
-			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
-		},
-		.consumer_supplies = tps65023_dcdc1_supplies,
-		.num_consumer_supplies = ARRAY_SIZE(tps65023_dcdc1_supplies),
-	},
-	/* dummy values for unused regulators to not crash driver: */
-	{
-		.constraints = {
-			.name = "dcdc2", /* VREG_MSMC1_1V26 */
-			.min_uV = 1260000,
-			.max_uV = 1260000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "dcdc3", /* unused */
-			.min_uV = 800000,
-			.max_uV = 3300000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo1", /* unused */
-			.min_uV = 1000000,
-			.max_uV = 3150000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo2", /* V_USBPHY_3V3 */
-			.min_uV = 3300000,
-			.max_uV = 3300000,
-		},
-	},
-};
-
-#if 0
-static void set_h2w_dat(int n)
-{
-	gpio_set_value(ORCA_GPIO_H2W_DATA, n);
-}
-
-static void set_h2w_clk(int n)
-{
-	gpio_set_value(ORCA_GPIO_H2W_CLK, n);
-}
-
-static int get_h2w_dat(void)
-{
-	return gpio_get_value(ORCA_GPIO_H2W_DATA);
-}
-
-static int get_h2w_clk(void)
-{
-	return gpio_get_value(ORCA_GPIO_H2W_CLK);
-}
-
-static void h2w_dev_power_on(int on)
-{
-	if (on)
-		gpio_set_value(ORCA_GPIO_H2W_POWER, 1);
-	else
-		gpio_set_value(ORCA_GPIO_H2W_POWER, 0);
-}
-
-/* Switch between UART3 and GPIO */
-static uint32_t uart3_on_gpio_table[] = {
-	/* RX */
-	PCOM_GPIO_CFG(ORCA_GPIO_UART3_RX, 1, GPIO_INPUT, GPIO_NO_PULL, 0),
-	/* TX */
-	PCOM_GPIO_CFG(ORCA_GPIO_UART3_TX, 1, GPIO_OUTPUT, GPIO_NO_PULL, 0),
-};
-
-/* default TX,RX to GPI */
-static uint32_t uart3_off_gpi_table[] = {
-	/* RX, H2W DATA */
-	PCOM_GPIO_CFG(ORCA_GPIO_H2W_DATA, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),
-	/* TX, H2W CLK */
-	PCOM_GPIO_CFG(ORCA_GPIO_H2W_CLK, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),
-};
-
-/* set TX,RX to GPO */
-static uint32_t uart3_off_gpo_table[] = {
-	/* RX, H2W DATA */
-	PCOM_GPIO_CFG(ORCA_GPIO_H2W_DATA, 0,
-		      GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	/* TX, H2W CLK */
-	PCOM_GPIO_CFG(ORCA_GPIO_H2W_CLK, 0,
-		      GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-};
-
-static void set_h2w_dat_dir(int n)
-{
-#if 0
-	if (n == 0) /* input */
-		gpio_direction_input(ORCA_GPIO_H2W_DATA);
-	else
-		gpio_configure(ORCA_GPIO_H2W_DATA, GPIOF_DRIVE_OUTPUT);
-#else
-	if (n == 0) /* input */
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table + 0, 0);
-	else
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpo_table + 0, 0);
-#endif
-}
-
-static void set_h2w_clk_dir(int n)
-{
-#if 0
-	if (n == 0) /* input */
-		gpio_direction_input(ORCA_GPIO_H2W_CLK);
-	else
-		gpio_configure(ORCA_GPIO_H2W_CLK, GPIOF_DRIVE_OUTPUT);
-#else
-	if (n == 0) /* input */
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table + 1, 0);
-	else
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpo_table + 1, 0);
-#endif
-}
-
-static void h2w_configure(int route)
-{
-	printk(KERN_INFO "H2W route = %d \n", route);
-	switch (route) {
-	case H2W_UART3:
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_on_gpio_table + 0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_on_gpio_table + 1, 0);
-		printk(KERN_INFO "H2W -> UART3\n");
-		break;
-	case H2W_GPIO:
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table + 0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table + 1, 0);
-		printk(KERN_INFO "H2W -> GPIO\n");
-		break;
-	}
-}
-#endif
-
-static struct h2w_platform_data orca_h2w_data = {
-	.headset_mic_35mm	= ORCA_GPIO_HEADSET_MIC,
-	/* for UART, masked first
-	.debug_uart 		= H2W_UART3,
-	.config 		= h2w_configure,
-	.defconfig 		= h2w_defconfig,
-	*/
-};
-
-static struct platform_device orca_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &orca_h2w_data,
-	},
-};
-
-#if 0
-static struct audio_jack_platform_data orca_jack_data = {
-	.gpio	= ORCA_GPIO_35MM_HEADSET_DET,
-};
-
-static struct platform_device orca_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &orca_jack_data,
-	},
-};
-#endif
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = ORCA_LAYOUTS,
-	.project_name = ORCA_PROJECT_NAME,
-	.reset = ORCA_GPIO_COMPASS_RST_N,
-	/* .intr = ORCA_GPIO_COMPASS_INT_N, */
-};
-
-#define AUO_CY8C_NAME "auo_cypress-touch"
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(AUO_CY8C_NAME, 0x5C),
-		.platform_data = &orca_cy8c_ts_data,
-		.irq = MSM_GPIO_TO_INT(ORCA_GPIO_TP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(ELAN_8232_I2C_NAME, 0x15),
-		.platform_data = &elan_i2c_data,
-		.irq = MSM_GPIO_TO_INT(ORCA_GPIO_TP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = MSM_GPIO_TO_INT(ORCA_GPIO_UP_INT_N)
-	},
-#if 0 /* TODO */
-	{
-		I2C_BOARD_INFO("ds2482", 0x30 >> 1),
-		/*.platform_data = &microp_data,*/
-		/*.irq = MSM_GPIO_TO_INT(ORCA_GPIO_UP_INT_N)*/
-	},
-	{
-		I2C_BOARD_INFO("cy8c-tmg-ts", 0x34),
-		.platform_data = &orca_cy8c_ts_data,
-		.irq = MSM_GPIO_TO_INT(ORCA_GPIO_TP_INT_N),
-	},
-#endif
-	{
-		I2C_BOARD_INFO("akm8973", 0x1C),
-		.platform_data = &compass_platform_data,
-		/* .irq = MSM_GPIO_TO_INT(ORCA_GPIO_COMPASS_INT_N), */
-	},
-#ifdef CONFIG_MSM_CAMERA
-#ifdef CONFIG_OV8810
-	{
-		I2C_BOARD_INFO("ov8810", 0x6C >> 1),
-	},
-#endif
-#endif/*CONIFIG_MSM_CAMERA*/
-
-#if 0
-	{
-		I2C_BOARD_INFO("ATMEL_QT602240", 0x4a),
-		.platform_data = &orca_atmel_ts_data,
-		.irq = MSM_GPIO_TO_INT(145)
-	},
-	{
-		I2C_BOARD_INFO(TPA6130_I2C_NAME, 0xC0 >> 1),
-	},
-#endif
-	{
-		I2C_BOARD_INFO("tps65023", 0x48),
-		.platform_data = tps65023_data,
-	},
-};
-
-#ifdef CONFIG_ARCH_QSD8X50
-static char bdaddress[20];
-
-static void bt_export_bd_address(void)
- {
-	unsigned char cTemp[6];
-
-	memcpy(cTemp, get_bt_bd_ram(), 6);
-	sprintf(bdaddress, "%02x:%02x:%02x:%02x:%02x:%02x", cTemp[0], cTemp[1], cTemp[2], cTemp[3], cTemp[4], cTemp[5]);
-	printk(KERN_INFO "YoYo--BD_ADDRESS=%s\n", bdaddress);
-}
-
-module_param_string(bdaddress, bdaddress, sizeof(bdaddress), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bdaddress, "BT MAC ADDRESS");
-#endif
-
-static uint32_t camera_off_gpio_table[] = {
-
-#if 0	/* CAMERA OFF*/
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-#endif
-	/* CAMERA SUSPEND*/
-	PCOM_GPIO_CFG(0, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-	PCOM_GPIO_CFG(99, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA), /* CAM1_RST */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA ON */
-	PCOM_GPIO_CFG(0, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_16MA), /* MCLK */
-};
-
-static void config_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-static void config_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-#if 0
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		 INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_camera_on_gpios,
-	.camera_gpio_off = config_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_ov8810_data = {
-    .sensor_name    = "ov8810",
-    .sensor_reset   = 99, /* CAM1_RST */
-    .sensor_pwd     = 100,  /* CAM1_PWDN, enabled in a9 */
-    /*.vcm_pwd      = 31, */  /* CAM1_VCM_EN, enabled in a9 */
-	.pdata = &msm_camera_device_data,
-	.resource = msm_camera_resources,
-	.num_resources = ARRAY_SIZE(msm_camera_resources),
-	.camera_flash = flashlight_control,
-	.num_flash_levels = FLASHLIGHT_NUM,
-};
-
-static struct platform_device msm_camera_sensor_ov8810 = {
-    .name           = "msm_camera_ov8810",
-    .dev            = {
-    .platform_data = &msm_camera_sensor_ov8810_data,
-    },
-};
-#endif
-
-static uint32_t flashlight_gpio_table[] = {
-	PCOM_GPIO_CFG(ORCA_GPIO_FLASHLIGHT_TORCH, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(ORCA_GPIO_FLASHLIGHT_FLASH, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-};
-
-static void config_orca_flashlight_gpios(void)
-{
-	config_gpio_table(flashlight_gpio_table,
-		ARRAY_SIZE(flashlight_gpio_table));
-}
-
-static struct flashlight_platform_data orca_flashlight_data = {
-	.gpio_init  = config_orca_flashlight_gpios,
-	.torch = ORCA_GPIO_FLASHLIGHT_TORCH,
-	.flash = ORCA_GPIO_FLASHLIGHT_FLASH,
-	.flash_duration_ms = 600,
-};
-
-static struct platform_device orca_flashlight_device = {
-	.name = "flashlight",
-	.dev		= {
-		.platform_data	= &orca_flashlight_data,
-	},
-};
-
-static struct bma150_platform_data orca_g_sensor_pdata = {
-	.microp_new_cmd = 1,
-};
-
-static struct platform_device orca_g_sensor = {
-	.name		= BMA150_G_SENSOR_NAME,
-	.dev            = {
-		.platform_data = &orca_g_sensor_pdata,
-	},
-};
-
-#if 0
-static struct curcial_oj_platform_data orca_oj_data = {
-};
-
-static struct platform_device orca_oj = {
-	.name = CURCIAL_OJ_NAME,
-	.id = -1,
-	.dev = {
-		.platform_data	= &orca_oj_data,
-	}
-};
-#endif
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_uart1,
-#ifdef CONFIG_SERIAL_MSM_HS
-	&msm_device_uart_dm1,
-#endif
-	&orca_h2w,
-	/* &htc_battery_pdev, */
-	/* &orca_audio_jack, */
-	&ram_console_device,
-	&orca_rfkill,
-	&msm_device_smd,
-	&msm_device_nand,
-	&msm_device_hsusb,
-	&usb_mass_storage_device,
-	&android_pmem_mdp_device,
-	&android_pmem_gpu0_device,
-	&android_pmem_gpu1_device,
-	&android_pmem_adsp_device,
-	/* &android_pmem_camera_device, */
-	&orca_g_sensor,
-	/* &msm_camera_sensor_ov8810, */
-	&msm_kgsl_device,
-	&msm_device_i2c,
-	&orca_flashlight_device,
-	&microp_leds,
-
-#if defined(CONFIG_SPI_QSD)
-	&qsd_device_spi,
-#endif
-	/* &orca_oj,*/
-	/* &capella_cm3602 */
-};
-
-static uint32_t orca_serial_debug_table[] = {
-	/* for uart debugger. It should be removed when support usb to serial function */
-	PCOM_GPIO_CFG(ORCA_GPIO_UART3_RX, 3, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* RX */
-	PCOM_GPIO_CFG(ORCA_GPIO_UART3_TX, 3, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* TX */
-};
-
-static uint32_t orca_usb_phy_3v3_table[] = {
-	PCOM_GPIO_CFG(ORCA_USB_PHY_3V3_ENABLE, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA)
-};
-
-static void orca_config_serial_debug_gpios(void)
-{
-	config_gpio_table(orca_serial_debug_table, ARRAY_SIZE(orca_serial_debug_table));
-}
-
-static struct msm_i2c_device_platform_data msm_i2c_pdata = {
-	.i2c_clock = 100000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_8MA,
-};
-
-static void __init msm_device_i2c_init(void)
-{
-	msm_device_i2c.dev.platform_data = &msm_i2c_pdata;
-}
-
-static struct msm_acpu_clock_platform_data orca_clock_data = {
-	.acpu_switch_time_us	= 20,
-	.max_speed_delta_khz	= 256000,
-	.vdd_switch_time_us	= 62,
-	.power_collapse_khz	= 245000,
-	.wait_for_irq_khz	= 0,
-};
-
-static unsigned orca_perf_acpu_table[] = {
-	245000000,
-	576000000,
-	768000000,
-};
-
-static struct perflock_platform_data orca_perflock_data = {
-	.perf_acpu_table = orca_perf_acpu_table,
-	.table_size = ARRAY_SIZE(orca_perf_acpu_table),
-};
-
-int orca_init_mmc(int sysrev);
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(ORCA_GPIO_BT_HOST_WAKE),	/*Chip to Device*/
-	.inject_rx_on_wakeup = 0,
-	#if 1	/*bt for bcm*/
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = ORCA_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = ORCA_GPIO_BT_HOST_WAKE,
-	#endif
-};
-#endif
-
-#if 0
-static int OJ_BMA_power(void)
-{
-	int ret;
-	struct vreg *vreg = vreg_get(0, "synt");
-
-	if (!vreg) {
-		printk(KERN_ERR "%s: vreg error\n", __func__);
-		return -EIO;
-	}
-	ret = vreg_set_level(vreg, 2850);
-
-	ret = vreg_enable(vreg);
-	if (ret < 0)
-		printk(KERN_ERR "%s: vreg enable failed\n", __func__);
-
-	return 0;
-}
-#endif
-
-static void __init orca_init(void)
-{
-	int ret;
-	int rc;
-
-	printk("orca_init() revision=%d\n", system_rev);
-#if 0
-	OJ_BMA_power();
-
-	gpio_direction_output(ORCA_GPIO_PROXIMITY_EN_N, 0);
-#endif
-	msm_acpu_clock_init(&orca_clock_data);
-
-	perflock_init(&orca_perflock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	msm_serial_debug_init(MSM_UART1_PHYS, INT_UART1,
-			      &msm_device_uart1.dev, 1, MSM_GPIO_TO_INT(139));
-#endif
-
-#ifdef CONFIG_ARCH_QSD8X50
-	bt_export_bd_address();
-#endif
-
-	#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	#endif
-
-	orca_config_serial_debug_gpios();
-
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-#if 0 /* TODO */
-	gpio_direction_output(ORCA_GPIO_TP_LS_EN, 0);
-	gpio_direction_output(ORCA_GPIO_TP_EN, 0);
-#endif
-
-	orca_audio_init();
-	msm_device_i2c_init();
-#ifdef CONFIG_MICROP_COMMON
-	orca_microp_init();
-#endif
-
-	msm_device_hsusb.dev.platform_data = &msm_hsusb_pdata;
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	if (system_rev > 1) {
-		for(rc = 0 ; rc <ARRAY_SIZE(elan_i2c_data); rc++)
-			elan_i2c_data[rc].power = orca_ts_power_xc;
-		orca_cy8c_ts_data.power = orca_ts_power_xc;
-	}
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	ret = orca_init_mmc(system_rev);
-	if (ret != 0)
-		pr_crit("%s: Unable to initialize MMC\n", __func__);
-
-	msm_init_pmic_vibrator();
-
-	config_gpio_table(orca_usb_phy_3v3_table, ARRAY_SIZE(orca_usb_phy_3v3_table));
-	gpio_direction_output(ORCA_USB_PHY_3V3_ENABLE, 1);
-
-}
-
-static void __init orca_fixup(struct machine_desc *desc, struct tag *tags,
-				 char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 1;
-	mi->bank[0].start = PHYS_OFFSET;
-	mi->bank[0].node = PHYS_TO_NID(PHYS_OFFSET);
-	mi->bank[0].size = (160*1024*1024);
-}
-
-static void __init orca_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-extern struct sys_timer msm_timer;
-
-MACHINE_START(ORCA, "orca")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params	= 0x20000100,
-	.fixup		= orca_fixup,
-	.map_io		= orca_map_io,
-	.init_irq	= msm_init_irq,
-	.init_machine	= orca_init,
-	.timer		= &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-orca.h b/arch/arm/mach-msm/board-orca.h
deleted file mode 100644
index 18c1df1..0000000
--- a/arch/arm/mach-msm/board-orca.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/* arch/arm/mach-msm/board-orca.h
- *
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_ORCA_H
-#define __ARCH_ARM_MACH_MSM_BOARD_ORCA_H
-
-#include <mach/board.h>
-
-#define MSM_SMI_BASE            0x02B00000
-#define MSM_SMI_SIZE            0x01500000
-
-#define MSM_PMEM_MDP_BASE       0x03000000
-#define MSM_PMEM_MDP_SIZE       0x01000000
-
-#define MSM_EBI1_BASE           0x20000000
-#define MSM_EBI1_SIZE           0x0E000000
-
-#define MSM_PMEM_GPU0_BASE	0x2D700000
-#define MSM_PMEM_GPU0_SIZE	0x00400000
-
-#define MSM_PMEM_GPU1_BASE	0x2C300000
-#define MSM_PMEM_GPU1_SIZE	0x01400000
-
-#define MSM_GPU_MEM_BASE	0x2DB00000
-#define MSM_GPU_MEM_SIZE        0x00200000
-
-#define MSM_RAM_CONSOLE_BASE	0x2DD00000
-#define MSM_RAM_CONSOLE_SIZE    0x00040000
-
-#define MSM_FB_BASE		0x2DE00000
-#define MSM_FB_SIZE             0x00200000
-
-#if 0
-#define MSM_PMEM_CAMERA_BASE    0x31C40000
-#define MSM_PMEM_CAMERA_SIZE    0x00000000
-#endif
-
-#define MSM_PMEM_ADSP_BASE	0x2A300000
-#define MSM_PMEM_ADSP_SIZE	0x02000000
-
-#if 0
-#define MSM_TV_FB_BASE          0x34040000
-#define MSM_TV_FB_SIZE          0x00151800
-#endif
-
-#define ORCA_GPIO_UP_INT_N		90
-#define ORCA_GPIO_UP_RESET_N		91
-
-#define ORCA_GPIO_TP_INT_N		92
-/* #define ORCA_GPIO_TP_LS_EN		93 */
-#define ORCA_GPIO_TP_EN			160
-#define ORCA_GPIO_TP_I2C_SEL		108
-
-#define ORCA_GPIO_POWER_KEY		94
-#define ORCA_GPIO_SDMC_CD_N		153
-
-#define ORCA_GPIO_BT_UART1_RTS		43
-#define ORCA_GPIO_BT_UART1_CTS		44
-#define ORCA_GPIO_BT_UART1_RX		45
-#define ORCA_GPIO_BT_UART1_TX		46
-#define ORCA_GPIO_BT_RESET_N		146
-#define ORCA_GPIO_BT_SHUTDOWN_N		128
-#define ORCA_GPIO_BT_HOST_WAKE		37
-#define ORCA_GPIO_BT_CHIP_WAKE		57
-
-#define ORCA_GPIO_COMPASS_RST_N		107
-#define ORCA_GPIO_COMPASS_INT_N		39
-#define ORCA_PROJECT_NAME		"orca"
-#define ORCA_LAYOUTS			{ \
-					{ {  0,  1, 0}, { -1,  0, 0}, {0, 0, 1} }, \
-					{ {  0, -1, 0}, { -1,  0, 0}, {0, 0, 1} }, \
-					{ { -1,  0, 0}, {  0, -1, 0}, {0, 0, 1} }, \
-					{ {  1,  0, 0}, {  0,  0, 1}, {0, 1, 0} }  \
-					}
-
-/* Proximity */
-/* #define ORCA_GPIO_PROXIMITY_EN_N	120 */
-
-/* Battery */
-/* #define ORCA_GPIO_MBAT_IN		39 */
-#define ORCA_GPIO_MCHG_EN_N		22
-#define ORCA_GPIO_ISET			16
-
-/*Audio */
-#define ORCA_AUD_JACKHP_EN		157
-#define ORCA_AUD_2V5_EN			158
-
-/* Bluetooth PCM */
-#define ORCA_BT_PCM_OUT			68
-#define ORCA_BT_PCM_IN			69
-#define ORCA_BT_PCM_SYNC		70
-#define ORCA_BT_PCM_CLK			71
-
-#define ORCA_GPIO_POWER_KEY		94
-
-/* flash light */
-#define ORCA_GPIO_FLASHLIGHT_FLASH	143
-#define ORCA_GPIO_FLASHLIGHT_TORCH	159
-
-/* Headset driver */
-#define ORCA_GPIO_35MM_HEADSET_DET	153
-#define ORCA_GPIO_HEADSET_MIC		35
-#define ORCA_GPIO_UART3_RX		139
-#define ORCA_GPIO_UART3_TX		140
-
-/* Wifi */
-#define ORCA_GPIO_WIFI_SHUTDOWN_N	129
-#define ORCA_GPIO_WIFI_IRQ		152
-
-/* USB PHY 3V3 enable*/
-#define ORCA_USB_PHY_3V3_ENABLE		104
-
-/* AP Key Led turn on*/
-#define ORCA_AP_KEY_LED_EN		48
-
-/* Keypad */
-#define ORCA_GPIO_KP_MKOUT0		33
-#define ORCA_GPIO_KP_MKOUT1		32
-#define ORCA_GPIO_KP_MKOUT2		31
-#define ORCA_GPIO_KP_MPIN0		42
-#define ORCA_GPIO_KP_MPIN1		41
-#define ORCA_GPIO_KP_MPIN2		40
-
-#endif /* __ARCH_ARM_MACH_MSM_BOARD_ORCA_H */
diff --git a/arch/arm/mach-msm/board-paradise-keypad.c b/arch/arm/mach-msm/board-paradise-keypad.c
deleted file mode 100644
index da06a49..0000000
--- a/arch/arm/mach-msm/board-paradise-keypad.c
+++ /dev/null
@@ -1,234 +0,0 @@
-/* arch/arm/mach-msm/board-liberty-paradise.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <linux/keyreset.h>
-#include <asm/mach-types.h>
-
-#include <mach/board_htc.h>
-
-#include "board-paradise.h"
-#include "proc_comm.h"
-
-static char *keycaps = "--qwerty";
-#undef MODULE_PARAM_PREFIX
-#define MODULE_PARAM_PREFIX "board_paradise."
-
-module_param_named(keycaps, keycaps, charp, 0);
-
-static unsigned int paradise_col_gpios[] = {
-	PARADISE_GPIO_Q_KP_MKOUT0,
-	PARADISE_GPIO_Q_KP_MKOUT1,
-	PARADISE_GPIO_Q_KP_MKOUT2,
-	PARADISE_GPIO_Q_KP_MKOUT3,
-	PARADISE_GPIO_Q_KP_MKOUT4,
-	PARADISE_GPIO_Q_KP_MKOUT5,
-	PARADISE_GPIO_Q_KP_MKOUT6,
-};
-
-static unsigned int paradise_row_gpios[] = {
-	PARADISE_GPIO_Q_KP_MKIN0_1,
-	PARADISE_GPIO_Q_KP_MKIN1_1,
-	PARADISE_GPIO_Q_KP_MKIN2_1,
-	PARADISE_GPIO_Q_KP_MKIN3_1,
-	PARADISE_GPIO_Q_KP_MKIN4_1,
-	PARADISE_GPIO_Q_KP_MKIN5_1,
-	PARADISE_GPIO_Q_KP_MKIN6_1,
-};
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(paradise_row_gpios) + (row))
-
-/* Anthony_Chang, if Key Value is KEY_F13 ~ KEY_F24, the mean is steal key */
-static unsigned short paradise_keymap[ARRAY_SIZE(paradise_col_gpios) *
-					ARRAY_SIZE(paradise_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_W,
-	[KEYMAP_INDEX(0, 1)] = KEY_O,
-	[KEYMAP_INDEX(0, 2)] = KEY_H,
-	[KEYMAP_INDEX(0, 3)] = KEY_Z,
-	[KEYMAP_INDEX(0, 4)] = KEY_RIGHT,
-	[KEYMAP_INDEX(0, 5)] = KEY_UP,
-	[KEYMAP_INDEX(0, 6)] = KEY_Q,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_E,
-	[KEYMAP_INDEX(1, 1)] = KEY_P,
-	[KEYMAP_INDEX(1, 2)] = KEY_J,
-	[KEYMAP_INDEX(1, 3)] = KEY_X,
-	[KEYMAP_INDEX(1, 4)] = KEY_ENTER,
-	[KEYMAP_INDEX(1, 5)] = KEY_LEFT,
-	[KEYMAP_INDEX(1, 6)] = KEY_QUESTION,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_R,
-	[KEYMAP_INDEX(2, 1)] = KEY_EMAIL, 	/* @ */
-	[KEYMAP_INDEX(2, 2)] = KEY_K,
-	[KEYMAP_INDEX(2, 3)] = KEY_C,
-	[KEYMAP_INDEX(2, 4)] = KEY_LEFTALT,
-	[KEYMAP_INDEX(2, 5)] = KEY_DOWN,
-	[KEYMAP_INDEX(2, 6)] = KEY_HOME,
-
-	[KEYMAP_INDEX(3, 0)] = KEY_T,
-	[KEYMAP_INDEX(3, 1)] = KEY_S,
-	[KEYMAP_INDEX(3, 2)] = KEY_L,
-	[KEYMAP_INDEX(3, 3)] = KEY_V,
-	[KEYMAP_INDEX(3, 4)] = KEY_A,
-	[KEYMAP_INDEX(3, 5)] = KEY_DOT,
-	[KEYMAP_INDEX(3, 6)] = KEY_VOLUMEUP,
-
-	[KEYMAP_INDEX(4, 0)] = KEY_Y,
-	[KEYMAP_INDEX(4, 1)] = KEY_D,
-	[KEYMAP_INDEX(4, 2)] = KEY_APOSTROPHE,
-	[KEYMAP_INDEX(4, 3)] = KEY_B,
-	[KEYMAP_INDEX(4, 4)] = KEY_COMMA, 	/* , */
-	[KEYMAP_INDEX(4, 5)] = KEY_F14,		/* SEARCH + SYM */
-	[KEYMAP_INDEX(4, 6)] = KEY_VOLUMEDOWN,
-
-	[KEYMAP_INDEX(5, 0)] = KEY_U,
-	[KEYMAP_INDEX(5, 1)] = KEY_F,
-	[KEYMAP_INDEX(5, 2)] = KEY_BACKSPACE,
-	[KEYMAP_INDEX(5, 3)] = KEY_N,
-	[KEYMAP_INDEX(5, 4)] = KEY_MENU,
-	/* [KEYMAP_INDEX(5, 5)] = KEY_, */
-	[KEYMAP_INDEX(5, 6)] = BTN_MOUSE, 	/* for OJ_ACTION key */
-
-	[KEYMAP_INDEX(6, 0)] = KEY_I,
-	[KEYMAP_INDEX(6, 1)] = KEY_G,
-	[KEYMAP_INDEX(6, 2)] = KEY_LEFTSHIFT,
-	[KEYMAP_INDEX(6, 3)] = KEY_M,
-	[KEYMAP_INDEX(6, 4)] = KEY_SPACE,
-	/* [KEYMAP_INDEX(6, 5)] = KEY_, */
-	/* [KEYMAP_INDEX(6, 6)] = KEY_, */
-};
-
-static struct gpio_event_matrix_info paradise_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = paradise_keymap,
-	.output_gpios = paradise_col_gpios,
-	.input_gpios = paradise_row_gpios,
-	.noutputs = ARRAY_SIZE(paradise_col_gpios),
-	.ninputs = ARRAY_SIZE(paradise_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		GPIOKPF_REMOVE_PHANTOM_KEYS |
-		GPIOKPF_PRINT_UNMAPPED_KEYS /* |
-		GPIOKPF_PRINT_MAPPED_KEYS */),
-};
-
-static struct gpio_event_direct_entry paradise_keypad_nav_map[] = {
-	{ PARADISE_GPIO_POWER_KEY,               KEY_POWER    },
-};
-
-static struct gpio_event_input_info paradise_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.flags = GPIOEDF_PRINT_KEYS,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = paradise_keypad_nav_map,
-	.keymap_size = ARRAY_SIZE(paradise_keypad_nav_map)
-};
-
-static struct gpio_event_direct_entry paradise_keypad_switch_map[] = {
-	{ PARADISE_GPIO_SLIDING_DET,       SW_LID       }
-};
-
-static struct gpio_event_input_info paradise_keypad_switch_info = {
-	.info.func = gpio_event_input_func,
-#if 1
-	.flags = 0 /* GPIOEDF_PRINT_KEYS */,
-#else
-	.flags = GPIOKPF_ACTIVE_HIGH,
-	/* FIXME: since sliding is opened on Paradise barebone system,
-	* set the active direction inverse on purpose
-	* just for our convenience in current stage.
-	*/
-#endif
-	.type = EV_SW,
-	.keymap = paradise_keypad_switch_map,
-	.keymap_size = ARRAY_SIZE(paradise_keypad_switch_map)
-};
-
-static struct gpio_event_info *paradise_keypad_info[] = {
-	&paradise_keypad_matrix_info.info,
-	&paradise_keypad_nav_info.info,
-	&paradise_keypad_switch_info.info,
-};
-
-static struct gpio_event_platform_data paradise_keypad_data = {
-	.name = "paradise-keypad-v1",
-	.info = paradise_keypad_info,
-	.info_count = ARRAY_SIZE(paradise_keypad_info)
-};
-
-static struct platform_device paradise_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &paradise_keypad_data,
-	},
-};
-
-static int paradise_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0
-};
-
-static struct keyreset_platform_data paradise_reset_keys_pdata = {
-	.keys_up = paradise_reset_keys_up,
-	.keys_down = {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-struct platform_device paradise_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &paradise_reset_keys_pdata,
-};
-
-int __init paradise_init_keypad(void)
-{
-	char *get_cid, *get_carrier, *get_keycaps;
-	uint8_t cid_len;
-	board_get_cid_tag(&get_cid);
-	board_get_carrier_tag(&get_carrier);
-	board_get_keycaps_tag(&get_keycaps);
-	printk(KERN_DEBUG "%s: get CID: %s\n\tCarrier: %s, Keycaps: %s\n",
-		__func__, get_cid, get_carrier, get_keycaps);
-
-	if (!system_rev)
-		paradise_keymap[KEYMAP_INDEX(5, 5)] = KEY_END;
-
-	cid_len = strlen(get_cid);
-	if (cid_len && !strncmp(get_cid, "CWS__001", cid_len)) {
-		paradise_keymap[KEYMAP_INDEX(2, 1)] = KEY_F14;		/* SEARCH + EMAIL */
-		paradise_keymap[KEYMAP_INDEX(4, 2)] = KEY_EMAIL;	/* @ */
-		paradise_keymap[KEYMAP_INDEX(5, 4)] = KEY_HOME;
-		paradise_keymap[KEYMAP_INDEX(2, 6)] = KEY_MENU;
-		paradise_keymap[KEYMAP_INDEX(1, 6)] = KEY_SLASH;
-		paradise_keymap[KEYMAP_INDEX(4, 5)] = KEY_QUESTION;
-		paradise_keymap[KEYMAP_INDEX(2, 4)] = KEY_LEFTSHIFT;
-		paradise_keymap[KEYMAP_INDEX(6, 2)] = KEY_LEFTALT;
-		paradise_keypad_data.name = "paradise-keypad-att-v1";
-	}
-
-	if (platform_device_register(&paradise_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	return platform_device_register(&paradise_keypad_device);
-}
-
diff --git a/arch/arm/mach-msm/board-paradise-microp.c b/arch/arm/mach-msm/board-paradise-microp.c
deleted file mode 100644
index 1e63b89..0000000
--- a/arch/arm/mach-msm/board-paradise-microp.c
+++ /dev/null
@@ -1,165 +0,0 @@
-/* arch/arm/mach-msm/board-paradise-microp.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <mach/atmega_microp.h>
-#include <mach/drv_callback.h>
-
-#include "board-paradise.h"
-
-static struct i2c_client *paradise_microp_client;
-/*
-static struct led_trigger paradise_als_level_trigger = {
-	.name     = "auto-backlight-trigger",
-};
-*/
-/*
-static int paradise_als_intr_enable(struct i2c_client *client,
-		uint32_t als_func, uint8_t enable)
-{
-	struct microp_i2c_client_data *cdata;
-
-	cdata = i2c_get_clientdata(client);
-
-	return microp_write_interrupt(client,
-		cdata->int_pin.int_lsensor, enable);
-}
-
-static void paradise_als_level_change(struct i2c_client *client,
-		uint8_t *data)
-{
-	led_trigger_event(&paradise_als_level_trigger, data[2]);
-}
-
-static int paradise_als_power(int pwr_device, uint8_t enable)
-{
-	struct i2c_client *client = paradise_microp_client;
-	struct microp_i2c_platform_data *pdata;
-	int value;
-
-	pdata = client->dev.platform_data;
-	value = enable ? 1 : 0;
-	if (pdata->ls_power)
-		pdata->ls_power(value);
-
-	return 0;
-}
-
-static int paradise_als_table_init(struct i2c_client *client,
-			int i, uint32_t kadc, uint32_t gadc)
-{
-	struct microp_i2c_platform_data *pdata;
-	uint8_t data[20];
-	int j;
-
-	pdata = client->dev.platform_data;
-
-	for (j = 0; j < 10; j++) {
-		data[j] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc >> 8);
-		data[j + 10] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc);
-	}
-
-	return microp_i2c_write(MICROP_I2C_WCMD_ADC_TABLE, data, 20);
-}
-*/
-static int paradise_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	paradise_microp_client = client;
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Light sensor */
-/*
-	ret = microp_function_check(client, MICROP_FUNCTION_LSENSOR);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_LSENSOR] = i;
-		cdata->int_pin.int_lsensor = pdata->microp_function[i].int_pin;
-		microp_get_als_kvalue(i);
-
-		ret = paradise_als_table_init(client, i, cdata->als_kadc,
-				cdata->als_gadc);
-		if (ret < 0)
-			goto exit;
-
-		if (pdata->ls_power)
-			pdata->ls_power(1);
-	}
-*/
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	ret = microp_write_interrupt(client, (1<<8), 1);
-	if (ret)
-		goto exit;
-
-	/* OJ interrupt */
-	ret = microp_function_check(client, MICROP_FUNCTION_OJ);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_oj = pdata->microp_function[i].int_pin;
-
-		ret = microp_write_interrupt(client, cdata->int_pin.int_oj, 1);
-		if (ret)
-			goto exit;
-	}
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = paradise_microp_function_init,
-/*
-	.als_pwr_enable = paradise_als_power,
-	.als_intr_enable = paradise_als_intr_enable,
-	.als_level_change = paradise_als_level_change,
-*/
-};
-
-void __init paradise_microp_init(void)
-{
-	/*led_trigger_register(&paradise_als_level_trigger);*/
-	microp_register_ops(&ops);
-}
-
-#endif
diff --git a/arch/arm/mach-msm/board-paradise-mmc.c b/arch/arm/mach-msm/board-paradise-mmc.c
deleted file mode 100644
index 483f7bb..0000000
--- a/arch/arm/mach-msm/board-paradise-mmc.c
+++ /dev/null
@@ -1,293 +0,0 @@
-/* linux/arch/arm/mach-msm/board-paradise-mmc.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <asm/mach-types.h>
-
-#include <mach/vreg.h>
-
-#include <asm/mach/mmc.h>
-
-#include "devices.h"
-#include "board-paradise.h"
-#include "proc_comm.h"
-
-/* #include <linux/irq.h> */
-
-#define DEBUG_SDSLOT_VDD 1
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_16MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init paradise_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_paradise.disable_sdcard=", paradise_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t paradise_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		vreg_enable(vreg_sdslot);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-#if DEBUG_SDSLOT_VDD
-			printk(KERN_INFO "%s: Setting level to %u\n",
-					__func__, mmc_vdd_table[i].level);
-#endif
-			vreg_set_level(vreg_sdslot, mmc_vdd_table[i].level);
-			return 0;
-		}
-	}
-
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int paradise_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(PARADISE_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define PARADISE_MMC_VDD	MMC_VDD_28_29 | MMC_VDD_29_30
-
-static unsigned int paradise_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data paradise_sdslot_data = {
-	.ocr_mask	= PARADISE_MMC_VDD,
-	/* .status_irq		= MSM_GPIO_TO_INT(PARADISE_GPIO_SDMC_CD_N), */
-	.status		= paradise_sdslot_status,
-	.translate_vdd	= paradise_sdslot_switchvdd,
-	.slot_type	= &paradise_sdslot_type,
-};
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data paradise_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-static int paradise_wifi_cd;		/* WIFI virtual 'card detect' status */
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-paradise_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int paradise_wifi_status(struct device *dev)
-{
-	return paradise_wifi_cd;
-}
-
-static struct mmc_platform_data paradise_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= paradise_wifi_status,
-	.register_status_notify	= paradise_wifi_status_register,
-	.embedded_sdio		= &paradise_wifi_emb_data,
-};
-
-int paradise_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	paradise_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(paradise_wifi_set_carddetect);
-int paradise_wifi_power_state = 0;
-int paradise_bt_power_state = 0;
-
-int paradise_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-	paradise_wifi_power_state = on;
-	mdelay(100);
-	gpio_set_value(PARADISE_GPIO_WIFI_EN, on);
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(paradise_wifi_power);
-
-int paradise_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-int __init paradise_init_mmc(unsigned int sys_rev)
-{
-
-	uint32_t id;
-	sdslot_vreg_enabled = 0;
-
-	printk(KERN_INFO "%s\n", __func__);
-
-	/* initial WIFI_SHUTDOWN */
-	id = PCOM_GPIO_CFG(PARADISE_GPIO_WIFI_EN, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	wifi_status_cb = NULL;
-
-	msm_add_sdcc(1, &paradise_wifi_data, 0, 0);
-
-
-	if (opt_disable_sdcard) {
-		printk(KERN_INFO "paradise: SD-Card interface disabled\n");
-		goto done;
-	}
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-
-	set_irq_wake(MSM_GPIO_TO_INT(PARADISE_GPIO_SDMC_CD_N), 1);
-
-	msm_add_sdcc(2, &paradise_sdslot_data, MSM_GPIO_TO_INT(PARADISE_GPIO_SDMC_CD_N),
-			IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-
-done:
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-paradise-panel.c b/arch/arm/mach-msm/board-paradise-panel.c
deleted file mode 100755
index 72b5c32..0000000
--- a/arch/arm/mach-msm/board-paradise-panel.c
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- * Copyright (C) 2008 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <asm/io.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-#include <mach/msm_fb.h>
-#include <mach/vreg.h>
-#include <mach/msm_panel.h>
-#ifdef CONFIG_HTC_PWRSINK
-#include <mach/htc_pwrsink.h>
-#endif
-#include "proc_comm.h"
-#include "devices.h"
-#include "board-paradise.h"
-
-#if 1
-#define B(s...) printk("[panel]"s)
-#else
-#define B(s...) do {} while(0)
-#endif
-
-static struct vreg *vreg_lcm_2v85, *vreg_lcm_2v6;
-
-struct lcm_va_cmd lcm_init_seq[] = {
-	CMD_VECT(0xf0,  0, 0x5a, 0x00, 0x00, 0x00),
-	CMD_VECT(0xf3,  0, 0x00, 0x00, 0x00, 0x00),
-	CMD_VECT(0xf1,  0, 0x5a, 0x00, 0x00, 0x00),
-	CMD_VECT(0xff,  0, 0x00, 0x00, 0x00, 0x40),
-	CMD_VECT(0x11, 10, 0x00, 0x00, 0x00, 0x00),
-
-	CMD_VECT(0xf3,  0, 0x01, 0x00, 0x00, 0x0a, 0x33, 0x7f, 0x66, 0x2c),
-	CMD_VECT(0xf4,  0, 0x71, 0x71, 0x6a, 0x6a, 0x44, 0x00, 0x00, 0x00),
-	CMD_VECT(0xf5, 10, 0x00, 0x00, 0x00, 0x03),
-	CMD_VECT(0xf3,  5, 0x03, 0x00, 0x00, 0x0a, 0x33, 0x7f, 0x66, 0x2c),
-	CMD_VECT(0xff,  5, 0x00, 0x00, 0x00, 0x60),
-
-	CMD_VECT(0xf3, 10, 0x07, 0x00, 0x00, 0x0a, 0x33, 0x7f, 0x66, 0x2c),
-	CMD_VECT(0xff, 10, 0x00, 0x00, 0x00, 0x70),
-	CMD_VECT(0xf3, 10, 0x0f, 0x00, 0x00, 0x0a, 0x33, 0x7f, 0x66, 0x2c),
-	CMD_VECT(0xff, 10, 0x00, 0x00, 0x00, 0x78),
-	CMD_VECT(0xf3, 20, 0x1f, 0x00, 0x00, 0x0a, 0x33, 0x7f, 0x66, 0x2c),
-
-	CMD_VECT(0xf3, 30, 0x3f, 0x00, 0x00, 0x0a, 0x33, 0x7f, 0x66, 0x2c),
-	CMD_VECT(0xf6,  0, 0x00, 0x08, 0x00, 0x00),
-	CMD_VECT(0xf5, 10, 0x02, 0x00, 0x05, 0x00, 0x00, 0x1f, 0x00, 0x00),
-	CMD_VECT(0x2a,  0, 0x00, 0x00, 0x00, 0xef),
-	CMD_VECT(0x2b,  0, 0x00, 0x00, 0x01, 0x8f),
-
-	CMD_VECT(0xf7, 0, 0x00, 0x27, 0x06, 0x16, 0x1d, 0x1b, 0x1b, 0x1e,
-			0x25, 0x28, 0x2c, 0x07, 0x00, 0x22, 0x23, 0x00),
-	CMD_VECT(0xf8, 30, 0x27, 0x00, 0x06, 0x16, 0x1d, 0x1b, 0x1b, 0x1e,
-			0x25, 0x28, 0x2c, 0x07, 0x00, 0x22, 0x20, 0x00),
-
-	CMD_VECT(0xf1,  0, 0x00, 0x00, 0x00, 0x00),
-	CMD_VECT(0xf3, 30, 0x7f, 0x00, 0x00, 0x0a, 0x22, 0x7f, 0x66, 0x2c),
-	CMD_VECT(0x3a,  0, 0x06, 0x00, 0x00, 0x00),
-	CMD_VECT(0x36,  0, 0x48, 0x00, 0x00, 0x00),
-	CMD_VECT(0x29,  0, 0x00, 0x00, 0x00, 0x00),
-	CMD_VECT(0x35,  0, 0x00, 0x00, 0x00, 0x00),
-	CMD_VECT(0xf2, 0, 0x16, 0x16, 0x03, 0x14, 0x14, 0x14, 0x14, 0x10,
-			0x00, 0x16, 0x16, 0x00),
-};
-
-struct lcm_va_cmd bl_on_seq[] = {
-	CMD_VECT(0x53, 0, 0x2c, 0x00, 0x00, 0x00),
-	CMD_VECT(0xcd, 0, 0x63, 0x14, 0x00, 0x00),
-	CMD_VECT(0x51, 0, 0xff, 0x00, 0x00, 0x00),
-};
-
-struct lcm_va_cmd lcm_off_seq[] = {
-	CMD_VECT(0x53,  0, 0x53, 0x00, 0x00, 0x00),
-	CMD_VECT(0xd9,  0, 0x04, 0x00, 0x00, 0x00),
-	CMD_VECT(0x10, 120, 0x00, 0x00, 0x00, 0x00),
-};
-
-u8 pwm_wintek[] = {30, 34, 45, 61, 81, 108, 145, 182, 219, 255};
-
-static void process_mddi_table(struct msm_mddi_client_data *client_data,
-		struct lcm_va_cmd *table, ssize_t count)
-{
-	struct lcm_va_cmd *pcmd = NULL;
-
-	BUG_ON(!client_data);
-	BUG_ON(!table);
-	BUG_ON(!count);
-
-	for (pcmd = table; pcmd < table + count; pcmd++) {
-		client_data->remote_write_vals(client_data, pcmd->value,
-				pcmd->reg, pcmd->size);
-		if (pcmd->delay)
-			hr_msleep(pcmd->delay);
-	}
-}
-
-static void paradise_mddi_power_client(struct msm_mddi_client_data *cdata,
-		int on)
-{
-	B("%s(%d): enter.\n", __func__, on);
-
-        if(on) {
-                gpio_set_value(PARADISE_MDDI_RSTz, 0);
-                vreg_enable(vreg_lcm_2v85);
-                vreg_enable(vreg_lcm_2v6);
-                hr_msleep(23);
-                gpio_set_value(PARADISE_MDDI_RSTz, 1);
-                hr_msleep(2);
-        } else {
-                gpio_set_value(PARADISE_MDDI_RSTz, 0);
-                hr_msleep(120);
-                vreg_disable(vreg_lcm_2v85);
-                vreg_disable(vreg_lcm_2v6);
-        }
-}
-
-static int paradise_mddi_client_init(
-		struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B("%s: enter.\n", __func__);
-
-	client_data->auto_hibernate(client_data, 0);
-	process_mddi_table(client_data, lcm_init_seq, ARRAY_SIZE(lcm_init_seq));
-	client_data->auto_hibernate(client_data, 1);
-
-	return 0;
-}
-
-static int paradise_mddi_client_uninit(
-		struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B("%s: enter.\n", __func__);
-
-	client_data->auto_hibernate(client_data, 0);
-	process_mddi_table(client_data, lcm_off_seq, ARRAY_SIZE(lcm_off_seq));
-	client_data->auto_hibernate(client_data, 1);
-
-	return 0;
-}
-
-static int paradise_panel_unblank(
-		struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	return 0;
-}
-
-static int paradise_panel_blank(
-		struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B("%s\n", __func__);
-	return 0;
-}
-
-static int
-paradise_panel_shrink(int brightness)
-{
-	if (brightness <= 102) {
-		if (brightness <= 30)
-			brightness = 8;
-		else
-			brightness = 123 * (brightness - 30) / 72 + 8;
-	} else
-		brightness = 124 * (brightness - 102) / 153 + 131;
-
-        return brightness;
-}
-
-static int paradise_panel_shutdown(
-		struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	B("%s\n", __func__);
-	paradise_mddi_client_uninit(bridge_data, client_data);
-	paradise_mddi_power_client(client_data, 0);
-	return 0;
-}
-
-static struct lcm_va_cmd lcm_adjust_seq[] = {
-       CMD_VECT(0x2a, 0, 0x00, 0x00, 0x00, 0xef),
-       CMD_VECT(0x2b, 0, 0x00, 0x00, 0x01, 0x8f),
-};
-
-static void
-paradise_panel_adjust(struct msm_mddi_client_data *client_data)
-{
-#if 0
-	client_data->auto_hibernate(client_data, 0);
-	process_mddi_table(client_data, lcm_adjust_seq,
-		ARRAY_SIZE(lcm_adjust_seq));
-	client_data->auto_hibernate(client_data, 1);
-#endif
-}
-
-struct lcm_va_cmd lcm_cabc_seq[] = {
-	CMD_VECT(0xcb, 0, 0x03, 0x00, 0x00, 0x00),
-	CMD_VECT(0x55, 0, 0x03, 0x00, 0x00, 0x00),
-	CMD_VECT(0xcd, 0, 0x63, 0x14, 0x00, 0x00),
-	CMD_VECT(0xca, 0, 0x80, 0x00, 0x20, 0x00),
-	CMD_VECT(0xcc, 0, 0x3c, 0x01, 0xaf, 0x00, 0xef, 0x00, 0x00, 0x00),
-	CMD_VECT(0x53, 0, 0x2c, 0x00, 0x00, 0x00),
-};
-
-static int paradise_change_cabcmode(
-       struct msm_mddi_client_data *client_data, int mode, u8 dimming)
-{
-	B("%s, mode=%d, dimming=%d\n", __func__, mode, dimming);
-
-	client_data->auto_hibernate(client_data, 0);
-	process_mddi_table(client_data, lcm_cabc_seq, ARRAY_SIZE(lcm_cabc_seq));
-	client_data->auto_hibernate(client_data, 1);
-	return 0;
-}
-
-static void paradise_fixup(uint16_t *mfr_name, uint16_t *product_code)
-{
-	*mfr_name = 0x0101;
-	*product_code = 0x04d1;
-}
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct msm_mddi_bridge_platform_data samsung_client_data = {
-	.init = paradise_mddi_client_init,
-	.uninit = paradise_mddi_client_uninit,
-	.blank = paradise_panel_blank,
-	.unblank = paradise_panel_unblank,
-	.adjust = paradise_panel_adjust,
-	.shutdown = paradise_panel_shutdown,
-	.fb_data = {
-		.xres = 240,
-		.yres = 400,
-		.width = 39,
-		.height = 65,
-		.output_format = 0,
-	},
-};
-
-static struct msm_mddi_platform_data paradise_pdata = {
-	.clk_rate = 85000000,
-	.power_client = paradise_mddi_power_client,
-	.fixup = paradise_fixup,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 1,
-	.client_platform_data = {
-		{
-			.product_id = (0x0101 << 16 | 0x04d1),
-			.name = "mddi_c_0101_04d1",
-			.id = 0,
-			.client_data = &samsung_client_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-int __init paradise_panel_init(void)
-{
-	int rc;
-	struct panel_data *config = &samsung_client_data.panel_conf;
-
-	if (!machine_is_paradise())
-		return -1;
-
-	B("paradise_panel_init");
-
-	vreg_lcm_2v85 = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_lcm_2v85))
-		return PTR_ERR(vreg_lcm_2v85);
-	vreg_lcm_2v6 = vreg_get(0, "rfrx2");
-	if (IS_ERR(vreg_lcm_2v6))
-		return PTR_ERR(vreg_lcm_2v6);
-
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-
-	config->caps = MSMFB_CAP_CABC;
-	config->pwm = pwm_wintek;
-	config->min_level = 0;
-	config->shrink = 1;
-	config->shrink_br = paradise_panel_shrink;
-	config->change_cabcmode = paradise_change_cabcmode;
-
-	msm_device_mddi0.dev.platform_data = &paradise_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-
-	return 0;
-}
-
-device_initcall(paradise_panel_init);
diff --git a/arch/arm/mach-msm/board-paradise-rfkill.c b/arch/arm/mach-msm/board-paradise-rfkill.c
deleted file mode 100755
index ff2472e..0000000
--- a/arch/arm/mach-msm/board-paradise-rfkill.c
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for paradise platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-paradise.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-/* bt initial configuration */
-static uint32_t paradise_bt_init_table[] = {
-
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_TX, /* BT_TX */
-				3,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt on configuration */
-static uint32_t paradise_bt_on_table[] = {
-
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_RX, /* BT_RX */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_TX, /* BT_TX */
-				3,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt off configuration */
-static uint32_t paradise_bt_off_table[] = {
-
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_RTS, /* BT_RTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_UART1_TX, /* BT_TX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PARADISE_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void paradise_config_bt_init(void)
-{
-	/* set bt initial configuration*/
-	config_bt_table(paradise_bt_init_table,
-				ARRAY_SIZE(paradise_bt_init_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(PARADISE_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(PARADISE_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(PARADISE_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-
-}
-
-static void paradise_config_bt_on(void)
-{
-	/* set bt on configuration*/
-	config_bt_table(paradise_bt_on_table,
-				ARRAY_SIZE(paradise_bt_on_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(PARADISE_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(PARADISE_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-}
-
-static void paradise_config_bt_off(void)
-{
-	/* BT_SHUTDOWN_N */
-	gpio_configure(PARADISE_GPIO_BT_SHUTDOWN_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_RESET_N */
-	gpio_configure(PARADISE_GPIO_BT_RESET_N,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(paradise_bt_off_table,
-				ARRAY_SIZE(paradise_bt_off_table));
-	mdelay(5);
-
-	/* BT_RTS */
-	gpio_configure(PARADISE_GPIO_BT_UART1_RTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CTS */
-
-	/* BT_TX */
-	gpio_configure(PARADISE_GPIO_BT_UART1_TX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_RX */
-
-	/* BT_HOST_WAKE */
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(PARADISE_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-			paradise_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-			paradise_config_bt_off();
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int paradise_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	paradise_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int paradise_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver paradise_rfkill_driver = {
-	.probe = paradise_rfkill_probe,
-	.remove = paradise_rfkill_remove,
-	.driver = {
-		.name = "paradise_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init paradise_rfkill_init(void)
-{
-	if (!machine_is_paradise())
-		return 0;
-
-	return platform_driver_register(&paradise_rfkill_driver);
-}
-
-static void __exit paradise_rfkill_exit(void)
-{
-	platform_driver_unregister(&paradise_rfkill_driver);
-}
-
-module_init(paradise_rfkill_init);
-module_exit(paradise_rfkill_exit);
-MODULE_DESCRIPTION("paradise rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-paradise-wifi.c b/arch/arm/mach-msm/board-paradise-wifi.c
deleted file mode 100644
index a375dce..0000000
--- a/arch/arm/mach-msm/board-paradise-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-paradise-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-paradise.h"
-
-int paradise_wifi_power(int on);
-int paradise_wifi_reset(int on);
-int paradise_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *paradise_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init paradise_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource paradise_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(PARADISE_GPIO_WIFI_IRQ1),
-		.end		= MSM_GPIO_TO_INT(PARADISE_GPIO_WIFI_IRQ1),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data paradise_wifi_control = {
-	.set_power      = paradise_wifi_power,
-	.set_reset      = paradise_wifi_reset,
-	.set_carddetect = paradise_wifi_set_carddetect,
-	.mem_prealloc   = paradise_wifi_mem_prealloc,
-};
-
-static struct platform_device paradise_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(paradise_wifi_resources),
-        .resource       = paradise_wifi_resources,
-        .dev            = {
-                .platform_data = &paradise_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned paradise_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init paradise_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_paradise())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	paradise_wifi_update_nvs("sd_oobonly=1\n");
-	paradise_init_wifi_mem();
-	ret = platform_device_register(&paradise_wifi_device);
-        return ret;
-}
-
-device_initcall(paradise_wifi_init);
diff --git a/arch/arm/mach-msm/board-paradise.c b/arch/arm/mach-msm/board-paradise.c
deleted file mode 100644
index a31475a..0000000
--- a/arch/arm/mach-msm/board-paradise.c
+++ /dev/null
@@ -1,1018 +0,0 @@
-/* arch/arm/mach-msm/board-paradise.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/irq.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/akm8973.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/sysdev.h>
-#include <linux/android_pmem.h>
-
-#include <mach/board.h>
-#include <mach/camera.h>
-
-#include <linux/delay.h>
-#include <linux/gpio.h>
-
-#include <mach/hardware.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <mach/system.h>
-#include <mach/vreg.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <mach/msm_serial_debugger.h>
-
-#include <asm/io.h>
-#include <asm/delay.h>
-#include <asm/setup.h>
-
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-
-#include <asm/mach/mmc.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/curcial_oj.h>
-#include "board-paradise.h"
-#include "proc_comm.h"
-#include "gpio_chip.h"
-
-#include <mach/board_htc.h>
-#include <mach/msm_serial_hs.h>
-
-#include "devices.h"
-
-#include <mach/atmega_microp.h>
-#include <mach/msm_tssc.h>
-#include <mach/htc_battery.h>
-
-#include <mach/htc_pwrsink.h>
-#include <mach/perflock.h>
-#include <mach/drv_callback.h>
-#include <mach/msm_rpcrouter.h>
-#include <mach/msm_iomap.h>
-#include <mach/msm_hsusb.h>
-
-void msm_init_irq(void);
-void msm_init_gpio(void);
-void msm_init_pmic_vibrator(void);
-void config_paradise_camera_on_gpios(void);
-void config_paradise_camera_off_gpios(void);
-#ifdef CONFIG_MICROP_COMMON
-void __init paradise_microp_init(void);
-#endif
-static int paradise_phy_init_seq[] = {0x0C, 0x31, 0x1, 0x0D, 0x1, 0x10, -1};
-static struct msm_hsusb_product paradise_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c8c,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-
-#define HSUSB_API_INIT_PHY_PROC	2
-#define HSUSB_API_PROG		0x30000064
-#define HSUSB_API_VERS MSM_RPC_VERS(1, 1)
-
-static void Paradise_phy_reset(void)
-{
-	struct msm_rpc_endpoint *usb_ep;
-	int rc;
-	struct hsusb_phy_start_req {
-		struct rpc_request_hdr hdr;
-	} req;
-
-	printk(KERN_INFO "msm_hsusb_phy_reset\n");
-
-	usb_ep = msm_rpc_connect(HSUSB_API_PROG, HSUSB_API_VERS, 0);
-	if (IS_ERR(usb_ep)) {
-		printk(KERN_ERR "%s: init rpc failed! error: %ld\n",
-				__func__, PTR_ERR(usb_ep));
-		return;
-	}
-	rc = msm_rpc_call(usb_ep, HSUSB_API_INIT_PHY_PROC,
-			&req, sizeof(req), 5 * HZ);
-	if (rc < 0)
-		printk(KERN_ERR "%s: rpc call failed! (%d)\n", __func__, rc);
-
-close:
-	msm_rpc_close(usb_ep);
-}
-
-void config_paradise_proximity_gpios(int on);
-
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-/*	.gpio_mbat_in = PARADISE_GPIO_MBAT_IN,*/
-/*	.gpio_mchg_en_n = PARADISE_GPIO_MCHG_EN_N,*/
-/*	.gpio_iset = PARADISE_GPIO_ISET,*/
-	.guage_driver = GUAGE_MODEM,
-	.charger = LINEAR_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 1, 3, 12, 19, 36, 166, 285, 406, 527, 0x3FF },
-		.channel = 3,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xCF,
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 38, 82, 95, 167},
-		.channel = 1,
-		.int_pin = 1 << 5,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "reset-int",
-		.category = MICROP_FUNCTION_RESET_INT,
-		.int_pin = 1 << 8,
-	},
-	{
-		.name   = "oj",
-		.category = MICROP_FUNCTION_OJ,
-		.int_pin = 1 << 12,
-	},
-};
-
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "button-backlight",
-		.type = LED_GPO,
-		.mask_w = {0x00, 0x00, 0x40},
-	},
-	{
-		.name	= "keyboard-backlight",
-		.type = LED_GPO,
-		.mask_w = {0x00, 0x00, 0x04},
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev = {
-			.platform_data = &lightsensor_data,
-		},
-	},
-	{
-		.name = "leds-microp",
-		.id = -1,
-		.dev = {
-			.platform_data = &microp_leds_data,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = PARADISE_GPIO_UP_RESET_N,
-	.spi_devices = SPI_OJ,
-};
-
-static struct i2c_board_info i2c_microp_devices = {
-	I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-	.platform_data = &microp_data,
-	.irq = MSM_GPIO_TO_INT(PARADISE_GPIO_UP_INT),
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_paradise_camera_on_gpios,
-	.camera_gpio_off = config_paradise_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_mt9t013_data = {
-	.sensor_name    = "mt9t013",
-	.sensor_reset   = 118,
-	/* .sensor_pwd     = PARADISE_MT9T013_CAM_PWDN,*/
-	.vcm_pwd        = PARADISE_GPIO_VCM_PWDN,
-	.pdata          = &msm_camera_device_data,
-	.flash_type     = MSM_CAMERA_FLASH_LED
-/*	.resource       = msm_camera_resources,*/
-/*	.num_resources  = ARRAY_SIZE(msm_camera_resources)*/
-};
-
-static struct platform_device msm_camera_sensor_mt9t013 = {
-	.name      = "msm_camera_mt9t013",
-	.dev       = {
-		.platform_data = &msm_camera_sensor_mt9t013_data,
-	},
-};
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = PARADISE_LAYOUTS,
-	.project_name = PARADISE_PROJECT_NAME,
-	.reset = PARADISE_GPIO_COMPASS_RST_N,
-	.intr = PARADISE_GPIO_COMPASS_INT_N,
-};
-
-static struct bma150_platform_data gsensor_platform_data = {
-	.intr = PARADISE_GPIO_GSENSOR_INT_N,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		/*I2C_BOARD_INFO("s5k4b2fx", 0x22 >> 1),*/
-		I2C_BOARD_INFO("s5k4b2fx", 0x22),
-		/* .irq = TROUT_GPIO_TO_INT(TROUT_GPIO_CAM_BTN_STEP1_N), */
-	},
-	{
-		I2C_BOARD_INFO("mt9t013", 0x6C),   /*3M bayer sensor driver*/
-		.platform_data = &msm_camera_device_data,
-	},
-};
-static struct i2c_board_info i2c_sensor[] = {
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = MSM_GPIO_TO_INT(PARADISE_GPIO_COMPASS_INT_N),
-	},
-	{
-		I2C_BOARD_INFO(BMA150_I2C_NAME, 0x38),
-		.platform_data = &gsensor_platform_data,
-		.irq = MSM_GPIO_TO_INT(PARADISE_GPIO_GSENSOR_INT_N),
-	},
-};
-
-static struct h2w_platform_data paradise_h2w_data = {
-};
-
-static struct platform_device paradise_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &paradise_h2w_data,
-	},
-};
-
-static struct audio_jack_platform_data paradise_jack_data = {
-	.gpio	= PARADISE_GPIO_35MM_HEADSET_DET,
-};
-
-static struct platform_device paradise_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &paradise_jack_data,
-	},
-};
-
-static struct pwr_sink paradise_pwrsink_table[] = {
-	{
-		.id     = PWRSINK_AUDIO,
-		.ua_max = 100000,
-	},
-	{
-		.id     = PWRSINK_BACKLIGHT,
-		.ua_max = 125000,
-	},
-	{
-		.id     = PWRSINK_LED_BUTTON,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_LED_KEYBOARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_GP_CLK,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_BLUETOOTH,
-		.ua_max = 15000,
-	},
-	{
-		.id     = PWRSINK_CAMERA,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_SDCARD,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_VIDEO,
-		.ua_max = 0,
-	},
-	{
-		.id     = PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id     = PWRSINK_SYSTEM_LOAD,
-		.ua_max = 100000,
-		.percent_util = 38,
-	},
-};
-
-static int paradise_pwrsink_resume_early(struct platform_device *pdev)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-	return 0;
-}
-
-static void paradise_pwrsink_resume_late(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 38);
-}
-
-static void paradise_pwrsink_suspend_early(struct early_suspend *h)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 7);
-}
-
-static int paradise_pwrsink_suspend_late(struct platform_device *pdev, pm_message_t state)
-{
-	htc_pwrsink_set(PWRSINK_SYSTEM_LOAD, 1);
-	return 0;
-}
-
-static struct pwr_sink_platform_data paradise_pwrsink_data = {
-	.num_sinks      = ARRAY_SIZE(paradise_pwrsink_table),
-	.sinks          = paradise_pwrsink_table,
-	.suspend_late	= paradise_pwrsink_suspend_late,
-	.resume_early	= paradise_pwrsink_resume_early,
-	.suspend_early	= paradise_pwrsink_suspend_early,
-	.resume_late	= paradise_pwrsink_resume_late,
-};
-
-static struct platform_device paradise_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev    = {
-		.platform_data = &paradise_pwrsink_data,
-	},
-};
-
-static struct msm_pmem_setting pmem_setting = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-};
-
-static ssize_t paradise_virtual_keys_show(struct kobject *kobj,
-			       struct kobj_attribute *attr, char *buf)
-{
-	return sprintf(buf,
-		__stringify(EV_KEY) ":" __stringify(KEY_HOME)  ":7:440:50:40"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":65:440:50:40"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":174:440:50:40"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":235:440:50:40"
-	   "\n");
-}
-
-static struct kobj_attribute paradise_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.tssc-manager",
-		.mode = S_IRUGO,
-	},
-	.show = &paradise_virtual_keys_show,
-};
-
-static struct attribute *paradise_properties_attrs[] = {
-	&paradise_virtual_keys_attr.attr,
-	NULL
-};
-
-static struct attribute_group paradise_properties_attr_group = {
-	.attrs = paradise_properties_attrs,
-};
-
-static struct tssc_ts_platform_data tssc_ts_device_data = {
-	.version = 1,
-	.x_min = 0,
-	.x_max = 1023,
-	.y_min = 0,
-	.y_max = 1023,
-	.cal_range_x = 653,
-	.cal_range_y = 672,
-	.cal_err = 65,
-	.screen_width = 240,
-	.screen_height = 400,
-	.cal_x = { 15, 223, 15, 223, 119},
-	.cal_y = { 20, 20, 378, 378, 199},
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-};
-
-static struct platform_device tssc_ts_device = {
-	.name	= "tssc-manager",
-	.id	= -1,
-	.dev	= {
-		.platform_data	= &tssc_ts_device_data,
-	},
-};
-
-static struct msm_i2c_device_platform_data paradise_i2c_device_data = {
-	.i2c_clock = 400000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-static struct platform_device paradise_rfkill = {
-	.name = "paradise_rfkill",
-	.id = -1,
-};
-
-#define CURCIAL_OJ_POWER            85
-static void curcial_oj_shutdown (int	enable)
-{
-	uint8_t	cmd[3];
-	memset(cmd, 0x00, sizeof(uint8_t)*3);
-
-	cmd[2] = 0x80;
-	/* always enalbe */
-	microp_i2c_write(0x90, cmd,	3);
-
-}
-static int curcial_oj_poweron(int on)
-{
-	gpio_set_value(CURCIAL_OJ_POWER, on);
-
-	if (gpio_get_value(CURCIAL_OJ_POWER) != on) {
-		printk(KERN_ERR "%s:OJ:power status fail \n", __func__);
-		return 0;
-	}
-		printk(KERN_ERR "%s:OJ:power status ok \n", __func__);
-	return 1;
-}
-#define PARADISE_MICROP_VER	0x04
-static void curcial_oj_adjust_xy(uint8_t *data, int16_t *mSumDeltaX, int16_t *mSumDeltaY)
-{
-	int8_t 	deltaX;
-	int8_t 	deltaY;
-
-
-	if (data[2] == 0x80)
-		data[2] = 0x81;
-	if (data[1] == 0x80)
-		data[1] = 0x81;
-	if (0) {
-		deltaX = (-1)*((int8_t) data[2]); /*X=2*/
-		deltaY = (-1)*((int8_t) data[1]); /*Y=1*/
-	} else {
-		deltaX = (-1)*((int8_t) data[1]);
-		deltaY = (-1)*((int8_t) data[2]);
-	}
-	*mSumDeltaX += -((int16_t)deltaX);
-	*mSumDeltaY += -((int16_t)deltaY);
-}
-/* Proximity Sensor (Capella_CM3602)*/
-static int __capella_cm3602_power(int on)
-{
-	int rc;
-	struct vreg *vreg = vreg_get(0, "wlan");
-	if (!vreg) {
-		printk(KERN_ERR "%s: vreg error\n", __func__);
-		return -EIO;
-	}
-	rc = vreg_set_level(vreg, 2800);
-
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on) {
-		config_paradise_proximity_gpios(1);
-		gpio_direction_output(PARADISE_GPIO_PROXIMITY_EN, 1);
-		rc = vreg_enable(vreg);
-		if (rc < 0)
-			printk(KERN_ERR "%s: vreg enable failed\n", __func__);
-	} else {
-		rc = vreg_disable(vreg);
-		if (rc < 0)
-			printk(KERN_ERR "%s: vreg disable failed\n", __func__);
-		gpio_direction_output(PARADISE_GPIO_PROXIMITY_EN, 0);
-		config_paradise_proximity_gpios(0);
-	}
-
-	return rc;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static unsigned int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable)
-		als_power_control |= pwr_device;
-	else
-		als_power_control &= ~pwr_device;
-
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-		ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-}
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.p_out = PARADISE_GPIO_PROXIMITY_INT,
-	.p_en = PARADISE_GPIO_PROXIMITY_EN,
-	.power = capella_cm3602_power,
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-
-static struct curcial_oj_platform_data paradise_oj_data = {
-	.oj_poweron = curcial_oj_poweron,
-	.oj_shutdown = curcial_oj_shutdown,
-	.oj_adjust_xy = curcial_oj_adjust_xy,
-	.microp_version = PARADISE_MICROP_VER,
-	.mdelay_time = 0,
-	.msleep_time = 1,
-	.x_send_count = 3,
-	.y_send_count = 3,
-	.fast_th = 1,
-	.normal_th = 15,
-	.continue_th = 4,
-	.continue_max = 2,
-	.xy_ratio = 15,
-	.interval = 80,
-	.softclick = false,
-	.swap = true,
-	.x = -1,
-	.y = -1,
-	.share_power = false,
-	.Xsteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-	.Ysteps = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
-};
-
-static struct platform_device paradise_oj = {
-	.name = CURCIAL_OJ_NAME,
-	.id = -1,
-	.dev = {
-		.platform_data	= &paradise_oj_data,
-	}
-};
-
-static struct gpio_led paradise_led_list[] = {
-	{
-		.name = "caps",
-		.gpio = PARADISE_GPIO_LED_CAP_LED_EN,
-	},
-	{
-		.name = "func",
-		.gpio = PARADISE_GPIO_LED_FN_LED_EN,
-	},
-};
-
-static struct gpio_led_platform_data paradise_leds_data = {
-	.num_leds	= ARRAY_SIZE(paradise_led_list),
-	.leds		= paradise_led_list,
-};
-
-static struct platform_device paradise_leds = {
-	.name		= "leds-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &paradise_leds_data,
-	},
-};
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_smd,
-	&msm_device_nand,
-	&msm_device_i2c,
-	&paradise_h2w,
-	&htc_battery_pdev,
-	&paradise_audio_jack,
-	&tssc_ts_device,
-	&msm_camera_sensor_mt9t013,
-	&paradise_rfkill,
-#ifdef CONFIG_HTC_PWRSINK
-	&paradise_pwr_sink,
-#endif
-	&paradise_oj,
-#ifdef CONFIG_INPUT_CAPELLA_CM3602
-	&capella_cm3602,
-#endif
-	&paradise_leds,
-};
-
-extern struct sys_timer msm_timer;
-
-static void __init paradise_init_irq(void)
-{
-	printk("paradise_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint cpld_iset;
-static uint cpld_charger_en;
-static uint cpld_usb_h2w_sw;
-static uint opt_disable_uart3;
-static char *keycaps = "";
-
-module_param_named(iset, cpld_iset, uint, 0);
-module_param_named(charger_en, cpld_charger_en, uint, 0);
-module_param_named(usb_h2w_sw, cpld_usb_h2w_sw, uint, 0);
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-module_param_named(keycaps, keycaps, charp, 0);
-
-static char bt_chip_id[10] = "bcm4329";
-module_param_string(bt_chip_id, bt_chip_id, sizeof(bt_chip_id), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_chip_id, "BT's chip id");
-
-static char bt_fw_version[10] = "v2.0.38";
-module_param_string(bt_fw_version, bt_fw_version, sizeof(bt_fw_version), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_fw_version, "BT's fw version");
-
-static void paradise_reset(void)
-{
-	gpio_set_value(PARADISE_GPIO_PS_HOLD, 0);
-}
-
-static uint32_t proximity_on_gpio_table[] = {
-	PCOM_GPIO_CFG(PARADISE_GPIO_PROXIMITY_INT,
-		0, GPIO_INPUT, GPIO_NO_PULL, 0), /* PS_VOUT */
-};
-
-static uint32_t proximity_off_gpio_table[] = {
-	PCOM_GPIO_CFG(PARADISE_GPIO_PROXIMITY_INT,
-		0, GPIO_INPUT, GPIO_PULL_DOWN, 0) /* PS_VOUT */
-};
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-void config_paradise_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-void config_paradise_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-/* for bcm */
-static char bdaddress[20];
-extern unsigned char *get_bt_bd_ram(void);
-
-static void bt_export_bd_address(void)
-{
-	unsigned char cTemp[6];
-
-	memcpy(cTemp, get_bt_bd_ram(), 6);
-	sprintf(bdaddress, "%02x:%02x:%02x:%02x:%02x:%02x",
-		cTemp[0], cTemp[1], cTemp[2], cTemp[3], cTemp[4], cTemp[5]);
-	printk(KERN_INFO "YoYo--BD_ADDRESS=%s\n", bdaddress);
-}
-
-module_param_string(bdaddress, bdaddress, sizeof(bdaddress), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bdaddress, "BT MAC ADDRESS");
-
-void config_paradise_proximity_gpios(int on)
-{
-	if (on)
-		config_gpio_table(proximity_on_gpio_table,
-			ARRAY_SIZE(proximity_on_gpio_table));
-	else
-		config_gpio_table(proximity_off_gpio_table,
-			ARRAY_SIZE(proximity_off_gpio_table));
-}
-
-static uint32_t paradise_serial_debug_table[] = {
-	/* config as serial debug uart */
-	PCOM_GPIO_CFG(PARADISE_GPIO_UART3_RX, 1,
-			GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* UART3 RX */
-	PCOM_GPIO_CFG(PARADISE_GPIO_UART3_TX, 1,
-			GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* UART3 TX */
-};
-
-static void paradise_config_serial_debug_gpios(void)
-{
-	config_gpio_table(paradise_serial_debug_table,
-			ARRAY_SIZE(paradise_serial_debug_table));
-}
-
-
-static void __init config_gpios(void)
-{
-	paradise_config_serial_debug_gpios();
-	config_paradise_camera_off_gpios();
-}
-
-static struct msm_acpu_clock_platform_data paradise_clock_data = {
-	.acpu_switch_time_us = 50,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200,
-#if defined(CONFIG_TURBO_MODE)
-	.wait_for_irq_khz = 176000,
-#else
-	.wait_for_irq_khz = 128000,
-#endif
-};
-
-static unsigned paradise_perf_acpu_table[] = {
-	245760000,
-	480000000,
-	528000000,
-};
-
-static struct perflock_platform_data paradise_perflock_data = {
-	.perf_acpu_table = paradise_perf_acpu_table,
-	.table_size = ARRAY_SIZE(paradise_perf_acpu_table),
-};
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(PARADISE_GPIO_BT_HOST_WAKE),
-	.inject_rx_on_wakeup = 0,
-	.cpu_lock_supported = 1,
-
-	/* for bcm */
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = PARADISE_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = PARADISE_GPIO_BT_HOST_WAKE,
-
-};
-#endif
-
-static void __init paradise_init(void)
-{
-	int rc;
-	struct kobject *properties_kobj;
-
-	printk("paradise_init() revision=%d\n", system_rev);
-
-	/* for bcm */
-	bt_export_bd_address();
-
-	/*
-	 * Setup common MSM GPIOS
-	 */
-	config_gpios();
-
-	/* We need to set this pin to 0 only once on power-up; we will
-	 * not actually enable the chip until we apply power to it via
-	 * vreg.
-	 */
-	gpio_direction_output(PARADISE_GPIO_LS_EN, 0);
-	/* disable power for cm3602 chip */
-	__capella_cm3602_power(0);
-
-	msm_hw_reset_hook = paradise_reset;
-
-	msm_acpu_clock_init(&paradise_clock_data);
-	perflock_init(&paradise_perflock_data);
-	/* adjust GPIOs based on bootloader request */
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-			&msm_device_uart3.dev, 1,
-				MSM_GPIO_TO_INT(PARADISE_GPIO_UART3_RX));
-#endif
-
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_device_uart_dm1.name = "msm_serial_hs_bcm";	/* for bcm */
-	msm_add_serial_devices(3);
-#else
-	msm_add_serial_devices(0);
-#endif
-
-	msm_add_serial_devices(2);
-	msm_register_usb_phy_init_seq(paradise_phy_init_seq);
-	msm_add_usb_id_pin_gpio(PARADISE_GPIO_USB_ID_PIN);
-	msm_hsusb_set_product(paradise_usb_products,
-		ARRAY_SIZE(paradise_usb_products));
-	msm_add_usb_devices(Paradise_phy_reset, NULL);
-
-	msm_add_mem_devices(&pmem_setting);
-	msm_init_pmic_vibrator();
-#ifdef CONFIG_MICROP_COMMON
-	paradise_microp_init();
-#endif
-
-	rc = paradise_init_mmc(system_rev);
-
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-
-	properties_kobj = kobject_create_and_add("board_properties", NULL);
-
-	if (properties_kobj)
-		rc = sysfs_create_group(properties_kobj,
-					 &paradise_properties_attr_group);
-	if (!properties_kobj || rc)
-		pr_err("failed to create board_properties\n");
-
-	msm_device_i2c.dev.platform_data = &paradise_i2c_device_data;
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	i2c_register_board_info(0, i2c_sensor, ARRAY_SIZE(i2c_sensor));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-	i2c_register_board_info(0 , &i2c_microp_devices, 1);
-
-	paradise_init_keypad();
-}
-
-static void __init paradise_fixup(struct machine_desc *desc, struct tag *tags,
-				char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 2;
-	mi->bank[0].start = MSM_LINUX_BASE1;
-	mi->bank[0].node = PHYS_TO_NID(MSM_LINUX_BASE1);
-	mi->bank[0].size = MSM_LINUX_SIZE1;
-	mi->bank[1].start = MSM_LINUX_BASE2;
-	mi->bank[1].node = PHYS_TO_NID(MSM_LINUX_BASE2);
-	mi->bank[1].size = MSM_LINUX_SIZE2;
-}
-
-static void __init paradise_map_io(void)
-{
-	printk("paradise_init_map_io()\n");
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-MACHINE_START(PARADISE, "paradise")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params    = 0x02E00100,
-	.fixup          = paradise_fixup,
-	.map_io         = paradise_map_io,
-	.init_irq       = paradise_init_irq,
-	.init_machine   = paradise_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-paradise.h b/arch/arm/mach-msm/board-paradise.h
deleted file mode 100644
index 8bf90be..0000000
--- a/arch/arm/mach-msm/board-paradise.h
+++ /dev/null
@@ -1,120 +0,0 @@
-/* linux/arch/arm/mach-msm/board-paradise.h
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_PARADISE_H
-#define __ARCH_ARM_MACH_MSM_BOARD_PARADISE_H
-
-#include <mach/board.h>
-
-#define MSM_LINUX_BASE1                 0x02E00000
-#define MSM_LINUX_SIZE1                 0x0D200000
-#define MSM_LINUX_BASE2                 0x20000000
-#define MSM_LINUX_SIZE2                 0x07000000
-
-#define MSM_PMEM_MDP_BASE               0x00000000
-#define MSM_PMEM_MDP_SIZE               0x00800000
-
-#define MSM_FB_BASE                     0x02D00000
-#define MSM_FB_SIZE                     0x9b000
-
-#define MSM_RAM_CONSOLE_BASE            MSM_FB_BASE + MSM_FB_SIZE
-#define MSM_RAM_CONSOLE_SIZE            128 * SZ_1K
-
-#define MSM_PMEM_ADSP_BASE              0x27000000
-#define MSM_PMEM_ADSP_SIZE              0x00800000
-
-#define MSM_PMEM_CAMERA_BASE            0x27800000
-#define MSM_PMEM_CAMERA_SIZE            0x00800000
-
-#define PARADISE_GPIO_USB_ID_PIN          (19)
-
-/* key */
-#define PARADISE_GPIO_POWER_KEY         (20)
-#define PARADISE_GPIO_Q_KP_MKOUT0       (33)
-#define PARADISE_GPIO_Q_KP_MKOUT1       (34)
-#define PARADISE_GPIO_Q_KP_MKOUT2       (35)
-#define PARADISE_GPIO_Q_KP_MKOUT3       (90)
-#define PARADISE_GPIO_Q_KP_MKOUT4       (91)
-#define PARADISE_GPIO_Q_KP_MKOUT5       (93)
-#define PARADISE_GPIO_Q_KP_MKOUT6       (108)
-#define PARADISE_GPIO_Q_KP_MKIN0_1      (21)
-#define PARADISE_GPIO_Q_KP_MKIN1_1      (37)
-#define PARADISE_GPIO_Q_KP_MKIN2_1      (83)
-#define PARADISE_GPIO_Q_KP_MKIN3_1      (92)
-#define PARADISE_GPIO_Q_KP_MKIN4_1      (94)
-#define PARADISE_GPIO_Q_KP_MKIN5_1      (112)
-#define PARADISE_GPIO_Q_KP_MKIN6_1      (114)
-
-/* QWERTY led */
-#define PARADISE_GPIO_LED_FN_LED_EN	(111)
-#define PARADISE_GPIO_LED_CAP_LED_EN	(121)
-
-#define PARADISE_GPIO_WIFI_IRQ1         (29)
-#define PARADISE_GPIO_WIFI_EN           (116)
-#define PARADISE_GPIO_SDMC_CD_N         (38)
-#define PARADISE_GPIO_SLIDING_DET       (39)
-
-#define PARADISE_MT9T013_CAM_PWDN       (91)
-#define PARADISE_GPIO_CABLE_IN1         (18)
-#define PARADISE_GPIO_UP_INT            (36)
-#define PARADISE_GPIO_CABLE_IN2         (31)
-#define PARADISE_GPIO_UART3_RX          (86)
-#define PARADISE_GPIO_UART3_TX          (87)
-#define PARADISE_GPIO_VCM_PWDN          (1)
-#define PARADISE_GPIO_UP_RESET_N        (76)
-#define PARADISE_GPIO_PS_HOLD           (25)
-#define PARADISE_GPIO_WB_SHUT_DOWN_N    (101)
-
-/* 35mm headset */
-#define PARADISE_GPIO_35MM_HEADSET_DET  (41)
-
-#define PARADISE_GPIO_COMPASS_RST_N     (84)
-#define PARADISE_GPIO_COMPASS_INT_N     (27)
-#define PARADISE_GPIO_GSENSOR_INT_N     (18)
-#define PARADISE_PROJECT_NAME           "paradise"
-#define PARADISE_LAYOUTS		{ \
-		{ {  1,  0, 0}, {  0,  1, 0}, {0, 0,  1} },  \
-		{ {  0, -1, 0}, { -1,  0, 0}, {0, 0,  1} },  \
-		{ {  0,  1, 0}, { -1,  0, 0}, {0, 0,  1} },  \
-		{ {  1,  0, 0}, {  0,  0, 1}, {0, 1,  0} }   \
-					}
-
-/* Proximity  */
-#define PARADISE_GPIO_PROXIMITY_INT     42
-#define PARADISE_GPIO_PROXIMITY_EN      119
-
-#define PARADISE_GPIO_LS_EN             120
-
-/* BT */
-#define PARADISE_GPIO_BT_UART1_RTS      (43)
-#define PARADISE_GPIO_BT_UART1_CTS      (44)
-#define PARADISE_GPIO_BT_UART1_RX       (45)
-#define PARADISE_GPIO_BT_UART1_TX       (46)
-#define PARADISE_GPIO_BT_RESET_N        (31)
-#define PARADISE_GPIO_BT_HOST_WAKE      (17)
-#define PARADISE_GPIO_BT_CHIP_WAKE      (0)
-#define PARADISE_GPIO_BT_SHUTDOWN_N     (113)
-
-#define PARADISE_MDDI_RSTz              (82)
-#define PARADISE_V_VDDE2E_VDD2_GPIO     (0)
-//int paradise_init_panel(unsigned int sys_rev);
-int paradise_init_mmc(unsigned int);
-int __init paradise_init_keypad(void);
-
-//struct sys_device;
-unsigned int paradise_get_hwid(void);
-unsigned int paradise_get_skuid(void);
-unsigned paradise_engineerid(void);
-int paradise_is_3M_camera(void);
-
-#endif /* GUARD */
diff --git a/arch/arm/mach-msm/board-passionc-audio.c b/arch/arm/mach-msm/board-passionc-audio.c
deleted file mode 100644
index ddfcc81..0000000
--- a/arch/arm/mach-msm/board-passionc-audio.c
+++ /dev/null
@@ -1,258 +0,0 @@
-/* arch/arm/mach-msm/board-passionc-audio.c
- *
- * Copyright (C) 2009 HTC Corporation
- * Copyright (C) 2009 Google Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/gpio.h>
-#include <linux/delay.h>
-#include <mach/pmic.h>
-#include <mach/msm_qdsp6_audio.h>
-#include <mach/htc_acoustic_qsd.h>
-#include <mach/tpa2018d1.h>
-
-#include "board-passionc.h"
-#include "proc_comm.h"
-
-#if 1
-#define D(fmt, args...) printk(KERN_INFO "Audio: "fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-static struct mutex mic_lock;
-
-struct q6_gain_info {
-        int max_step;
-        int gain[10];
-};
-
-static struct q6_gain_info q6_audio_hw[Q6_HW_COUNT] = {
-	[Q6_HW_HANDSET] = {
-		.max_step = 6,
-		.gain = {-1600, -1300, -1000, -600, -300, 0, 0, 0, 0, 0},
-	},
-	[Q6_HW_HEADSET] = {
-		.max_step = 6,
-		.gain = {-2000, -1600, -1200, -800, -400, 0, 0, 0, 0, 0},
-	},
-	[Q6_HW_SPEAKER] = {
-		.max_step = 6,
-		.gain = {-1500, -1200, -900, -600, -300, 0, 0, 0, 0, 0},
-	},
-	[Q6_HW_TTY] = {
-		.max_step = 6,
-		.gain = {-2000, -1600, -1200, -800, -400, 0, 0, 0, 0, 0},
-	},
-	[Q6_HW_BT_SCO] = {
-		.max_step = 6,
-		.gain = {-2000, -1600, -1200, -800, -400, 0, 0, 0, 0, 0},
-	},
-	[Q6_HW_BT_A2DP] = {
-		.max_step = 6,
-		.gain = {-2000, -1600, -1200, -800, -400, 0, 0, 0, 0, 0},
-	},
-};
-
-void passionc_headset_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	/* enable audio amp */
-	if (en) mdelay(15);
-	gpio_set_value(PASSIONC_AUD_JACKHP_EN, !!en);
-}
-void passionc_speaker_enable(int en)
-{
-	struct spkr_config_mode scm;
-	memset(&scm, 0, sizeof(scm));
-
-	D("%s %d\n", __func__, en);
-	if (en) {
-		scm.is_right_chan_en = 0;
-		scm.is_left_chan_en = 1;
-		scm.is_stereo_en = 0;
-		scm.is_hpf_en = 1;
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-		pmic_spkr_en_mute(RIGHT_SPKR, 0);
-		pmic_set_spkr_configuration(&scm);
-		pmic_spkr_en(LEFT_SPKR, 1);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		/* unmute */
-		pmic_spkr_en_mute(LEFT_SPKR, 1);
-	} else {
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-
-		pmic_spkr_en(LEFT_SPKR, 0);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		pmic_set_spkr_configuration(&scm);
-	}
-#ifdef CONFIG_AMP_TPA2018D1
-	set_speaker_amp(en);
-#endif
-}
-
-void passionc_receiver_enable(int en)
-{
-	/* After XB*/
-	if (is_evt2() || is_evt3_1()) {
-		struct spkr_config_mode scm;
-		memset(&scm, 0, sizeof(scm));
-
-		D("%s %d\n", __func__, en);
-		if (en) {
-			scm.is_right_chan_en = 1;
-			scm.is_left_chan_en = 0;
-			scm.is_stereo_en = 0;
-			scm.is_hpf_en = 1;
-			pmic_spkr_en_mute(RIGHT_SPKR, 0);
-			pmic_set_spkr_configuration(&scm);
-			pmic_spkr_en(RIGHT_SPKR, 1);
-
-			/* unmute */
-			pmic_spkr_en_mute(RIGHT_SPKR, 1);
-		} else {
-			pmic_spkr_en_mute(RIGHT_SPKR, 0);
-
-			pmic_spkr_en(RIGHT_SPKR, 0);
-
-			pmic_set_spkr_configuration(&scm);
-		}
-	}
-}
-
-static uint32_t bt_sco_enable[] = {
-	PCOM_GPIO_CFG(PASSIONC_BT_PCM_OUT, 1, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(PASSIONC_BT_PCM_IN, 1, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(PASSIONC_BT_PCM_SYNC, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(PASSIONC_BT_PCM_CLK, 2, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-static uint32_t bt_sco_disable[] = {
-	PCOM_GPIO_CFG(PASSIONC_BT_PCM_OUT, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(PASSIONC_BT_PCM_IN, 0, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(PASSIONC_BT_PCM_SYNC, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(PASSIONC_BT_PCM_CLK, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-void passionc_bt_sco_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	if (en)
-		config_gpio_table(bt_sco_enable, ARRAY_SIZE(bt_sco_enable));
-	else {
-		config_gpio_table(bt_sco_disable, ARRAY_SIZE(bt_sco_disable));
-		gpio_set_value(PASSIONC_BT_PCM_OUT, 0);
-	}
-}
-
-
-void passionc_mic_enable(int en)
-{
-	static int old_state = 0, new_state = 0;
-
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&mic_lock);
-	if (!!en)
-		new_state++;
-	else
-		new_state--;
-
-	if (new_state == 1 && old_state == 0) {
-		gpio_set_value(PASSIONC_AUD_2V5_EN, 1);
-		mdelay(60);
-	} else if (new_state == 0 && old_state == 1)
-		gpio_set_value(PASSIONC_AUD_2V5_EN, 0);
-	else
-		D("%s: do nothing %d %d\n", __func__, old_state, new_state);
-
-	old_state = new_state;
-	mutex_unlock(&mic_lock);
-}
-
-void passionc_analog_init(void)
-{
-	D("%s\n", __func__);
-	/* stereo pmic init */
-	pmic_spkr_set_gain(LEFT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_set_gain(RIGHT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_en_right_chan(OFF_CMD);
-	pmic_spkr_en_left_chan(OFF_CMD);
-	pmic_spkr_add_right_left_chan(OFF_CMD);
-	pmic_spkr_en_stereo(OFF_CMD);
-	pmic_spkr_select_usb_with_hpf_20hz(OFF_CMD);
-	pmic_spkr_bypass_mux(OFF_CMD);
-	pmic_spkr_en_hpf(ON_CMD);
-	pmic_spkr_en_sink_curr_from_ref_volt_cir(OFF_CMD);
-	pmic_spkr_set_mux_hpf_corner_freq(SPKR_FREQ_0_73KHZ);
-	pmic_mic_set_volt(MIC_VOLT_1_80V);
-	pmic_set_speaker_delay(SPKR_DLY_100MS);
-
-	gpio_direction_output(PASSIONC_AUD_JACKHP_EN, 0);
-	gpio_set_value(PASSIONC_AUD_JACKHP_EN, 0);
-
-	config_gpio_table(bt_sco_disable,
-			ARRAY_SIZE(bt_sco_disable));
-	gpio_set_value(PASSIONC_BT_PCM_OUT, 0);
-	gpio_set_value(PASSIONC_BT_PCM_SYNC, 0);
-	gpio_set_value(PASSIONC_BT_PCM_CLK, 0);
-}
-
-int passionc_get_rx_vol(uint8_t hw, int level)
-{
-	struct q6_gain_info *info;
-	int vol;
-
-	info = &q6_audio_hw[hw];
-
-	level = (level > 100)? 100 : ((level < 0) ? 0 : level);
-	vol = info->gain[(uint32_t)((info->max_step - 1) * level / 100)];
-
-	D("%s %d\n", __func__, vol);
-	return vol;
-}
-
-static struct qsd_acoustic_ops acoustic = {
-	.enable_mic_bias = passionc_mic_enable,
-};
-
-static struct q6audio_analog_ops ops = {
-	.init = passionc_analog_init,
-	.speaker_enable = passionc_speaker_enable,
-	.headset_enable = passionc_headset_enable,
-	.receiver_enable = passionc_receiver_enable,
-	.bt_sco_enable = passionc_bt_sco_enable,
-	.int_mic_enable = passionc_mic_enable,
-	.ext_mic_enable = passionc_mic_enable,
-	.get_rx_vol = passionc_get_rx_vol,
-};
-
-void __init passionc_audio_init(void)
-{
-	mutex_init(&mic_lock);
-#if defined(CONFIG_QSD_AUDIO)
-	q6audio_register_analog_ops(&ops);
-#endif
-	acoustic_register_ops(&acoustic);
-}
-
diff --git a/arch/arm/mach-msm/board-passionc-keypad.c b/arch/arm/mach-msm/board-passionc-keypad.c
deleted file mode 100644
index 6095e18..0000000
--- a/arch/arm/mach-msm/board-passionc-keypad.c
+++ /dev/null
@@ -1,278 +0,0 @@
-/* arch/arm/mach-msm/board-passionc-keypad.c
- *
- * Copyright (C) 2009 Google, Inc
- * Copyright (C) 2009 HTC Corporation.
- *
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/gpio_event.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/keyreset.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-passionc.h"
-
-struct jog_axis_info {
-	struct gpio_event_axis_info	info;
-	uint16_t			in_state;
-	uint16_t			out_state;
-};
-
-static bool jog_just_on;
-static unsigned long jog_on_jiffies;
-
-static unsigned int passionc_col_gpios[] = {
-	PASSIONC_GPIO_KP_MKOUT0,
-	PASSIONC_GPIO_KP_MKOUT1,
-	PASSIONC_GPIO_KP_MKOUT2,
-};
-static unsigned int passionc_row_gpios[] = {
-	PASSIONC_GPIO_KP_MPIN0,
-	PASSIONC_GPIO_KP_MPIN1,
-	PASSIONC_GPIO_KP_MPIN2,
-};
-
-#define KEYMAP_INDEX(col, row)	((col)*ARRAY_SIZE(passionc_row_gpios) + (row))
-#define KEYMAP_SIZE		(ARRAY_SIZE(passionc_col_gpios) * \
-				 ARRAY_SIZE(passionc_row_gpios))
-
-/* keypad */
-static const unsigned short passionc_keymap[KEYMAP_SIZE] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(1, 1)] = MATRIX_KEY(1, BTN_MOUSE),
-};
-
-static struct gpio_event_matrix_info passionc_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = passionc_keymap,
-	.output_gpios = passionc_col_gpios,
-	.input_gpios = passionc_row_gpios,
-	.noutputs = ARRAY_SIZE(passionc_col_gpios),
-	.ninputs = ARRAY_SIZE(passionc_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 5 * NSEC_PER_MSEC,
-	.notintr_gpios = PASSIONC_GPIO_KP_MPIN1,
-	.flags = (GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		  GPIOKPF_REMOVE_PHANTOM_KEYS |
-		  GPIOKPF_PRINT_UNMAPPED_KEYS),
-};
-
-static struct gpio_event_direct_entry passionc_keypad_key_map[] = {
-	{
-		.gpio	= PASSIONC_GPIO_POWER_KEY,
-		.code	= KEY_POWER,
-	},
-};
-
-static struct gpio_event_input_info passionc_keypad_key_info = {
-	.info.func = gpio_event_input_func,
-	.info.no_suspend = true,
-	.flags = 0,
-	.type = EV_KEY,
-	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
-	.keymap = passionc_keypad_key_map,
-	.keymap_size = ARRAY_SIZE(passionc_keypad_key_map)
-};
-
-/* jogball */
-static uint16_t jogball_axis_map(struct gpio_event_axis_info *info, uint16_t in)
-{
-	struct jog_axis_info *ai =
-		container_of(info, struct jog_axis_info, info);
-	uint16_t out = ai->out_state;
-
-	if (jog_just_on) {
-		if (jiffies == jog_on_jiffies || jiffies == jog_on_jiffies + 1)
-			goto ignore;
-		jog_just_on = 0;
-	}
-	if((ai->in_state ^ in) & 1)
-		out--;
-	if((ai->in_state ^ in) & 2)
-		out++;
-	ai->out_state = out;
-ignore:
-	ai->in_state = in;
-	return out;
-}
-
-static uint32_t jogball_x_gpios[] = {
-	PASSIONC_GPIO_BALL_LEFT, PASSIONC_GPIO_BALL_RIGHT,
-};
-
-static uint32_t jogball_y_gpios[] = {
-	PASSIONC_GPIO_BALL_UP, PASSIONC_GPIO_BALL_DOWN,
-};
-
-static void passionc_nav_power_initialize(void)
-{
-	static uint32_t jogball_power_setup[] = {
-		PCOM_GPIO_CFG(PASSIONC_GPIO_JOGBALL_POWER, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_4MA),
-	};
-	config_gpio_table(jogball_power_setup,
-					ARRAY_SIZE(jogball_power_setup));
-}
-
-static int passionc_nav_power(const struct gpio_event_platform_data *pdata,
-								bool on)
-{
-	gpio_set_value(PASSIONC_GPIO_JOGBALL_POWER, on);
-	if (on) {
-		jog_just_on = 1;
-		jog_on_jiffies = jiffies;
-	}
-	return 0;
-}
-
-
-static void passionc_jogball_x_set_gpio(void)
-{
-	static uint32_t jogball_x_gpio_table[] = {
-		PCOM_GPIO_CFG(PASSIONC_GPIO_BALL_LEFT, 0, GPIO_INPUT,
-						GPIO_NO_PULL, GPIO_4MA),
-		PCOM_GPIO_CFG(PASSIONC_GPIO_BALL_RIGHT, 0, GPIO_INPUT,
-						GPIO_NO_PULL, GPIO_4MA),
-	};
-	config_gpio_table(jogball_x_gpio_table,
-		ARRAY_SIZE(jogball_x_gpio_table));
-}
-
-static void passionc_jogball_y_set_gpio(void)
-{
-	static uint32_t jogball_y_gpio_table[] = {
-		PCOM_GPIO_CFG(PASSIONC_GPIO_BALL_UP, 0, GPIO_INPUT,
-						GPIO_NO_PULL, GPIO_4MA),
-		PCOM_GPIO_CFG(PASSIONC_GPIO_BALL_DOWN, 0, GPIO_INPUT,
-						GPIO_NO_PULL, GPIO_4MA),
-	};
-	config_gpio_table(jogball_y_gpio_table,
-		ARRAY_SIZE(jogball_y_gpio_table));
-}
-
-static struct jog_axis_info jogball_x_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(jogball_x_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_X,
-		.decoded_size = 1U << ARRAY_SIZE(jogball_x_gpios),
-		.map = jogball_axis_map,
-		.gpio = jogball_x_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION,
-	}
-};
-
-static struct jog_axis_info jogball_y_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(jogball_y_gpios),
-		.dev = 1,
-		.type = EV_REL,
-		.code = REL_Y,
-		.decoded_size = 1U << ARRAY_SIZE(jogball_y_gpios),
-		.map = jogball_axis_map,
-		.gpio = jogball_y_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION,
-	}
-};
-
-static struct gpio_event_info *passionc_input_info[] = {
-	&passionc_keypad_matrix_info.info,
-	&passionc_keypad_key_info.info,
-	&jogball_x_axis.info.info,
-	&jogball_y_axis.info.info,
-};
-
-static struct gpio_event_platform_data passionc_input_data = {
-	.names = {
-		"passionc-keypad",
-		"passionc-nav",
-		NULL,
-	},
-	.info = passionc_input_info,
-	.info_count = ARRAY_SIZE(passionc_input_info),
-	.power = passionc_nav_power,
-};
-
-static struct platform_device passionc_input_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev = {
-		.platform_data = &passionc_input_data,
-	},
-};
-
-static int passionc_reset_keys_up[] = {
-	KEY_VOLUMEUP,
-	0,
-};
-
-static struct keyreset_platform_data passionc_reset_keys_pdata = {
-	.keys_up	= passionc_reset_keys_up,
-	.keys_down	= {
-		KEY_POWER,
-		KEY_VOLUMEDOWN,
-		BTN_MOUSE,
-		0
-	},
-};
-
-struct platform_device passionc_reset_keys_device = {
-	.name	= KEYRESET_NAME,
-	.dev	= {
-		.platform_data = &passionc_reset_keys_pdata,
-	},
-};
-
-static void passionc_reset_btn_initialize(void)
-{
-	static uint32_t reset_btn_setup[] = {
-		PCOM_GPIO_CFG(PASSIONC_GPIO_RESET_BTN, 0, GPIO_INPUT,
-						GPIO_NO_PULL, GPIO_4MA),
-	};
-	config_gpio_table(reset_btn_setup, ARRAY_SIZE(reset_btn_setup));
-
-}
-
-static int __init passionc_init_keypad_jogball(void)
-{
-	int ret;
-
-	if (!machine_is_passionc())
-		return 0;
-
-	ret = platform_device_register(&passionc_reset_keys_device);
-	if (ret != 0)
-		return ret;
-	passionc_reset_btn_initialize();
-	passionc_nav_power_initialize();
-	passionc_jogball_x_set_gpio();
-	passionc_jogball_y_set_gpio();
-
-	ret = platform_device_register(&passionc_input_device);
-	if (ret != 0)
-		return ret;
-
-	return 0;
-}
-
-device_initcall(passionc_init_keypad_jogball);
diff --git a/arch/arm/mach-msm/board-passionc-microp.c b/arch/arm/mach-msm/board-passionc-microp.c
deleted file mode 100644
index 7b19a30..0000000
--- a/arch/arm/mach-msm/board-passionc-microp.c
+++ /dev/null
@@ -1,242 +0,0 @@
-/* arch/arm/mach-msm/board-passionc-microp.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <mach/atmega_microp.h>
-#include <mach/htc_35mm_remote.h>
-#include <mach/drv_callback.h>
-
-#include "board-passionc.h"
-
-#ifdef CONFIG_HTC_HEADSET
-#define notify_35mm_headset_insert(insert) \
-	htc_35mm_remote_notify_insert_ext_headset(insert)
-#else
-#define notify_35mm_headset_insert(insert) do {} while (0)
-#endif
-
-/*
-static struct led_trigger passionc_als_level_trigger = {
-	.name     = "auto-backlight-trigger",
-};
-*/
-
-/*
-static int passionc_als_intr_enable(struct i2c_client *client,
-		uint32_t als_func, uint8_t enable)
-{
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[2];
-	int ret = 0;
-
-	cdata = i2c_get_clientdata(client);
-	mutex_lock(&cdata->microp_i2c_mutex);
-	cdata->als_func = enable ? (cdata->als_func |= als_func)
-				: (cdata->als_func &= ~als_func);
-
-	data[0] = 0;
-	if (cdata->als_func)
-		data[1] = 1;
-	else
-		data[1] = 0;
-
-	ret = microp_i2c_write(MICROP_I2C_WCMD_AUTO_BL_CTL, data, 2);
-	if (ret != 0)
-		printk(KERN_ERR "%s: set auto light sensor fail\n", __func__);
-
-	mutex_unlock(&cdata->microp_i2c_mutex);
-
-	return ret;
-}
-
-static void passionc_als_level_change(struct i2c_client *client,
-		uint8_t *data)
-{
-	struct microp_i2c_client_data *cdata  = i2c_get_clientdata(client);
-
-	if (cdata->als_func & ALS_BACKLIGHT)
-		led_trigger_event(&passionc_als_level_trigger, data[2]);
-}
-
-static int passionc_als_power(int pwr_device, uint8_t enable)
-{
-	int value;
-
-	value = enable ? 0 : 1;
-	gpio_set_value(PASSIONC_GPIO_LS_EN, value);
-
-	return 0;
-}
-
-static int passionc_als_table_init(struct i2c_client *client,
-			int i, uint32_t kadc, uint32_t gadc)
-{
-	struct microp_i2c_platform_data *pdata;
-	uint8_t data[20];
-	int j;
-
-	pdata = client->dev.platform_data;
-
-	for (j = 0; j < 10; j++) {
-		data[j] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc >> 8);
-		data[j + 10] = (uint8_t)(pdata->microp_function[i].levels[j]
-				* kadc / gadc);
-	}
-
-	return microp_i2c_write(MICROP_I2C_WCMD_ADC_TABLE, data, 20);
-}
-
-static int passionc_als_power_init(struct microp_i2c_platform_data *pdata)
-{
-	int ret = 0;
-
-	ret = gpio_request(pdata->gpio_ls_on, "microp_i2c");
-	if (ret < 0) {
-		pr_err("%s: failed on request gpio ls_on\n", __func__);
-		goto exit;
-	}
-
-	ret = gpio_direction_output(pdata->gpio_ls_on, 0);
-	if (ret < 0) {
-		pr_err("%s: failed on gpio_direction_output ls_on\n", __func__);
-		goto exit;
-	}
-
-exit:
-	return ret;
-
-}
-*/
-static int passionc_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Light sensor */
-/*
-	ret = microp_function_check(client, MICROP_FUNCTION_LSENSOR);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_LSENSOR] = i;
-		cdata->int_pin.int_lsensor = pdata->microp_function[i].int_pin;
-		microp_get_als_kvalue(i);
-
-		ret = passionc_als_table_init(client, i, cdata->als_kadc,
-				cdata->als_gadc);
-		if (ret < 0)
-			goto exit;
-
-		passionc_als_power_init(pdata);
-	}
-*/
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Headset plugin */
-	ret = microp_function_check(client, MICROP_FUNCTION_HPIN);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_hpin = pdata->microp_function[i].int_pin;
-		cdata->gpio.hpin = pdata->microp_function[i].mask_r[0] << 16
-					| pdata->microp_function[i].mask_r[1] << 8
-					| pdata->microp_function[i].mask_r[2];
-
-		wake_lock_init(&cdata->hpin_wake_lock,
-					WAKE_LOCK_SUSPEND, "microp_35mm_hpin");
-
-		microp_read_gpio_status(data);
-		cdata->headset_is_in =
-				!((data[0] << 16 | data[1] << 8 | data[2])
-				& cdata->gpio.hpin);
-		if (cdata->headset_is_in)
-			notify_35mm_headset_insert(cdata->headset_is_in);
-
-		ret = microp_write_interrupt(client,
-				cdata->int_pin.int_hpin, 1);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	data[0] = 0x08;
-	ret = microp_i2c_write(MICROP_I2C_WCMD_MISC, data, 1);
-	if (ret)
-		goto exit;
-
-	/* SD Card detect */
-	ret = microp_function_check(client, MICROP_FUNCTION_SDCARD);
-	if (ret >= 0) {
-		i = ret;
-		cdata->int_pin.int_sdcard = pdata->microp_function[i].int_pin;
-		cdata->gpio.sdcard = pdata->microp_function[i].mask_r[0] << 16
-					| pdata->microp_function[i].mask_r[1] << 8
-					| pdata->microp_function[i].mask_r[2];
-
-		microp_read_gpio_status(data);
-		cdata->sdcard_is_in = ((data[0] << 16 | data[1] << 8 | data[2])
-						& cdata->gpio.sdcard) ? 1 : 0;
-		cnf_driver_event("sdcard_detect", &cdata->sdcard_is_in);
-
-		ret = microp_write_interrupt(client,
-				cdata->int_pin.int_sdcard, 1);
-		if (ret)
-			goto exit;
-	}
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = passionc_microp_function_init,
-/*
-	.als_pwr_enable = passionc_als_power,
-	.als_intr_enable = passionc_als_intr_enable,
-	.als_level_change = passionc_als_level_change,
-*/
-};
-
-void __init passionc_microp_init(void)
-{
-	/*led_trigger_register(&passionc_als_level_trigger);*/
-	microp_register_ops(&ops);
-}
-
-#endif
diff --git a/arch/arm/mach-msm/board-passionc-mmc.c b/arch/arm/mach-msm/board-passionc-mmc.c
deleted file mode 100644
index c4d87f9..0000000
--- a/arch/arm/mach-msm/board-passionc-mmc.c
+++ /dev/null
@@ -1,303 +0,0 @@
-/* linux/arch/arm/mach-msm/board-passionc-mmc.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-
-#include "board-passionc.h"
-#include "devices.h"
-#include "proc_comm.h"
-
-#include <mach/drv_callback.h>
-
-#define DEBUG_SDSLOT_VDD 1
-
-static bool opt_disable_sdcard;
-static int __init passionc_disablesdcard_setup(char *str)
-{
-	opt_disable_sdcard = (bool)simple_strtol(str, NULL, 0);
-	return 1;
-}
-
-__setup("board_passionc.disable_sdcard=", passionc_disablesdcard_setup);
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t		sdslot_vdd = 0xffffffff;
-static uint32_t		sdslot_vreg_enabled;
-
-static struct {
-	int mask;
-	int level;
-} mmc_vdd_table[] = {
-	{ MMC_VDD_27_28,	2800 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static uint32_t passionc_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = (vdd == 0) ? 0 : 2850;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		gpio_set_value(100, 0); /* PWR OFF */
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		gpio_set_value(100, 1); /* PWR ON */
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-#if DEBUG_SDSLOT_VDD
-	printk(KERN_INFO "%s: Setting level to %u\n", __func__, sdslot_vdd);
-#endif
-	return 0;
-
-}
-
-static unsigned int passionc_sd_status;
-
-static void (*sdslot_status_cb)(int card_present, void *dev_id);
-static void *sdslot_status_cb_devid;
-
-static int microp_check_status(int *st)
-{
-	passionc_sd_status = !((unsigned) *st);
-
-	if (sdslot_status_cb)
-		sdslot_status_cb(passionc_sd_status, sdslot_status_cb_devid);
-
-	return 0;
-}
-
-static unsigned int passionc_sdslot_status(struct device *dev)
-{
-	return passionc_sd_status;
-}
-
-#define PASSIONC_MMC_VDD	(MMC_VDD_27_28 | MMC_VDD_28_29 | \
-				 MMC_VDD_29_30)
-
-static int
-passionc_sdslot_register_cb(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (sdslot_status_cb)
-		return -EAGAIN;
-
-	sdslot_status_cb = callback;
-	sdslot_status_cb_devid = dev_id;
-	return 0;
-}
-
-static struct mmc_platform_data passionc_sdslot_data = {
-	.ocr_mask		= PASSIONC_MMC_VDD,
-	.status			= passionc_sdslot_status,
-	.translate_vdd		= passionc_sdslot_switchvdd,
-	.register_status_notify = passionc_sdslot_register_cb,
-};
-
-int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-		 unsigned int stat_irq, unsigned long stat_irq_flags);
-
-
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data passionc_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-passionc_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static int passionc_wifi_cd;	/* WiFi virtual 'card detect' status */
-
-static unsigned int passionc_wifi_status(struct device *dev)
-{
-	return passionc_wifi_cd;
-}
-
-static struct mmc_platform_data passionc_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= passionc_wifi_status,
-	.register_status_notify	= passionc_wifi_status_register,
-	.embedded_sdio		= &passionc_wifi_emb_data,
-};
-
-int passionc_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	passionc_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(passionc_wifi_set_carddetect);
-
-int passionc_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-
-	mdelay(100);
-	gpio_set_value(127, on); /* WIFI_SHUTDOWN */
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(passionc_wifi_power);
-
-int passionc_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-int __init passionc_init_mmc(unsigned int sys_rev)
-{
-	uint32_t id;
-	struct cnf_driver *microp_sdcard_detect;
-
-	wifi_status_cb = NULL;
-
-	printk(KERN_INFO "%s()+\n", __func__);
-
-	/* initial WIFI_SHUTDOWN# */
-	id = PCOM_GPIO_CFG(127, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	msm_add_sdcc(1, &passionc_wifi_data, 0, 0);
-
-	if (opt_disable_sdcard) {
-		pr_info("%s: sdcard disabled on cmdline\n", __func__);
-		goto done;
-	}
-
-	sdslot_vreg_enabled = 0;
-
-	microp_sdcard_detect = kzalloc(sizeof(struct cnf_driver), GFP_KERNEL);
-	if (microp_sdcard_detect) {
-		microp_sdcard_detect->name = "sdcard_detect";
-		microp_sdcard_detect->func = &microp_check_status;
-	} else {
-		printk(KERN_ERR "%s: Alloc SD callback func error\n", __func__);
-		goto done;
-	}
-	cnf_driver_register(microp_sdcard_detect);
-
-	msm_add_sdcc(2, &passionc_sdslot_data, 0, 0);
-
-done:
-	printk(KERN_INFO "%s()-\n", __func__);
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-passionc-rfkill.c b/arch/arm/mach-msm/board-passionc-rfkill.c
deleted file mode 100644
index 1664bef..0000000
--- a/arch/arm/mach-msm/board-passionc-rfkill.c
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for passionc platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-passionc.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-/* bt initial configuration */
-static uint32_t passionc_bt_init_table[] = {
-
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt on configuration */
-static uint32_t passionc_bt_on_table[] = {
-
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_RX, /* BT_RX */
-				2,
-				GPIO_INPUT,
-				GPIO_PULL_UP,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_TX, /* BT_TX */
-				2,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_INPUT,
-				GPIO_PULL_DOWN,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_PULL_UP,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-/* bt off configuration */
-static uint32_t passionc_bt_off_table[] = {
-
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_RTS, /* BT_RTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_CTS, /* BT_CTS */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_RX, /* BT_RX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_UART1_TX, /* BT_TX */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_8MA),
-
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_RESET_N, /* BT_RESET_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_SHUTDOWN_N, /* BT_SHUTDOWN_N */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_HOST_WAKE, /* BT_HOST_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-	PCOM_GPIO_CFG(PASSIONC_GPIO_BT_CHIP_WAKE, /* BT_CHIP_WAKE */
-				0,
-				GPIO_OUTPUT,
-				GPIO_NO_PULL,
-				GPIO_4MA),
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for (n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void passionc_config_bt_init(void)
-{
-	/* set bt initial configuration*/
-	config_bt_table(passionc_bt_init_table,
-				ARRAY_SIZE(passionc_bt_init_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(PASSIONC_GPIO_BT_RESET_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(PASSIONC_GPIO_BT_SHUTDOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* BT_CHIP_WAKE */
-	gpio_configure(PASSIONC_GPIO_BT_CHIP_WAKE,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-
-}
-
-static void passionc_config_bt_on(void)
-{
-	/* set bt on configuration*/
-	config_bt_table(passionc_bt_on_table,
-			ARRAY_SIZE(passionc_bt_on_table));
-	mdelay(5);
-
-	/* BT_RESET_N */
-	gpio_configure(PASSIONC_GPIO_BT_RESET_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-	/* BT_SHUTDOWN_N */
-	gpio_configure(PASSIONC_GPIO_BT_SHUTDOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	mdelay(2);
-}
-
-static void passionc_config_bt_off(void)
-{
-	/* BT_SHUTDOWN_N */
-	gpio_configure(PASSIONC_GPIO_BT_SHUTDOWN_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-	/* BT_RESET_N */
-	gpio_configure(PASSIONC_GPIO_BT_RESET_N,
-			GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	mdelay(2);
-
-	/* set bt off configuration*/
-	config_bt_table(passionc_bt_off_table,
-			ARRAY_SIZE(passionc_bt_off_table));
-	mdelay(5);
-
-	/* BT_RTS */
-	gpio_configure(PASSIONC_GPIO_BT_UART1_RTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CTS */
-	gpio_configure(PASSIONC_GPIO_BT_UART1_CTS,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_TX */
-	gpio_configure(PASSIONC_GPIO_BT_UART1_TX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_RX */
-	gpio_configure(PASSIONC_GPIO_BT_UART1_RX,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-
-	/* BT_HOST_WAKE */
-	gpio_configure(PASSIONC_GPIO_BT_HOST_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	/* BT_CHIP_WAKE */
-	gpio_configure(PASSIONC_GPIO_BT_CHIP_WAKE,
-				GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		passionc_config_bt_on();
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		passionc_config_bt_off();
-		break;
-	default:
-		pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int passionc_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	passionc_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int passionc_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver passionc_rfkill_driver = {
-	.probe = passionc_rfkill_probe,
-	.remove = passionc_rfkill_remove,
-	.driver = {
-		.name = "passionc_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init passionc_rfkill_init(void)
-{
-	if (!machine_is_passionc())
-		return 0;
-
-	return platform_driver_register(&passionc_rfkill_driver);
-}
-
-static void __exit passionc_rfkill_exit(void)
-{
-	platform_driver_unregister(&passionc_rfkill_driver);
-}
-
-module_init(passionc_rfkill_init);
-module_exit(passionc_rfkill_exit);
-MODULE_DESCRIPTION("passionc rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-passionc-wifi.c b/arch/arm/mach-msm/board-passionc-wifi.c
deleted file mode 100644
index 92be539..0000000
--- a/arch/arm/mach-msm/board-passionc-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-passionc-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-passionc.h"
-
-int passionc_wifi_power(int on);
-int passionc_wifi_reset(int on);
-int passionc_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *passionc_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init passionc_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource passionc_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(PASSIONC_GPIO_WIFI_IRQ),
-		.end		= MSM_GPIO_TO_INT(PASSIONC_GPIO_WIFI_IRQ),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data passionc_wifi_control = {
-	.set_power      = passionc_wifi_power,
-	.set_reset      = passionc_wifi_reset,
-	.set_carddetect = passionc_wifi_set_carddetect,
-	.mem_prealloc   = passionc_wifi_mem_prealloc,
-};
-
-static struct platform_device passionc_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(passionc_wifi_resources),
-        .resource       = passionc_wifi_resources,
-        .dev            = {
-                .platform_data = &passionc_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned passionc_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init passionc_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_passionc())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	passionc_wifi_update_nvs("sd_oobonly=1\n");
-	passionc_init_wifi_mem();
-	ret = platform_device_register(&passionc_wifi_device);
-        return ret;
-}
-
-device_initcall(passionc_wifi_init);
diff --git a/arch/arm/mach-msm/board-passionc.c b/arch/arm/mach-msm/board-passionc.c
deleted file mode 100755
index b2ee3c1..0000000
--- a/arch/arm/mach-msm/board-passionc.c
+++ /dev/null
@@ -1,1283 +0,0 @@
-/* linux/arch/arm/mach-msm/board-passionc.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/cy8c_tmg_ts.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/android_pmem.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/input.h>
-#include <mach/htc_headset_common.h>
-#include <mach/htc_one_wire.h>
-#include <mach/audio_jack.h>
-#include <mach/tpa2018d1.h>
-#include <linux/akm8973.h>
-#include <linux/a1026.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/regulator/machine.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/setup.h>
-#include <../../../drivers/staging/android/timed_gpio.h>
-
-#include <mach/board.h>
-#include <mach/board_htc.h>
-#include <mach/hardware.h>
-#include <mach/atmega_microp.h>
-#include <mach/camera.h>
-#include <mach/msm_iomap.h>
-#include <mach/htc_battery.h>
-#include <linux/spi/spi.h>
-#include <mach/perflock.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/msm_panel.h>
-#include <mach/system.h>
-#include "board-passionc.h"
-#include "devices.h"
-#include "proc_comm.h"
-#include "smd_private.h"
-#if 1	/*allenou, bt for bcm, 2009/7/8*/
-#include <mach/msm_serial_hs.h>
-#endif
-
-#include <linux/mfd/tps65023.h>
-#include <mach/msm_flashlight.h>
-#include <mach/msm_hsusb.h>
-#define SMEM_SPINLOCK_I2C      6
-
-#ifdef CONFIG_ARCH_QSD8X50
-extern unsigned char *get_bt_bd_ram(void);
-#endif
-
-void msm_init_pmic_vibrator(void);
-extern void __init passionc_audio_init(void);
-#ifdef CONFIG_MICROP_COMMON
-void __init passionc_microp_init(void);
-#endif
-
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-/*	.gpio_mbat_in = PASSIONC_GPIO_MBAT_IN,*/
-/*	.gpio_mchg_en_n = PASSIONC_GPIO_MCHG_EN_N,*/
-/*	.gpio_iset = PASSIONC_GPIO_ISET,*/
-	.guage_driver = GUAGE_DS2784,
-	.charger = SWITCH_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 0, 0, 0x52, 0x52, 0x14D, 0x213, 0x213, 0x3FF, 0x3FF, 0x3FF },
-		.channel = 6,
-		.int_pin = 1 << 9,
-		.golden_adc = 0xC0,
-		/*.ls_gpio_on = PASSIONC_GPIO_LS_EN,*/
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 50, 110, 160, 220},
-		.channel = 7,
-		.int_pin = 1 << 7,
-	},
-	{
-		.name   = "microp_intrrupt",
-		.category = MICROP_FUNCTION_INTR,
-	},
-	{
-		.name   = "headset-in",
-		.category = MICROP_FUNCTION_HPIN,
-		.int_pin = 1 << 2,
-		.mask_r = {0x00, 0x04, 0x00},
-	},
-	{
-		.name   = "sdcard-detect",
-		.category = MICROP_FUNCTION_SDCARD,
-		.int_pin = 1 << 0,
-		.mask_r = {0x00, 0x01, 0x00},
-	},
-};
-
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-	.old_intr_cmd = 1,
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name   = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "green",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "blue",
-		.type = LED_RGB,
-	},
-	{
-		.name   = "jogball-backlight",
-		.type = LED_JOGBALL,
-	},
-	{
-		.name   = "button-backlight",
-		.type = LED_PWM,
-		.mask_w = {0x02, 0x00, 0x00},
-		.led_pin = 1 << 2,
-		.init_value = 0xFF,
-		.fade_time = 1,
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct bma150_platform_data passionc_g_sensor_pdata = {
-	.microp_new_cmd = 0,
-	.chip_layout = 1,
-};
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev		= {
-			.platform_data	= &lightsensor_data,
-		},
-	},
-	{
-		.name = "leds-microp",
-		.id = -1,
-		.dev = {
-			.platform_data = &microp_leds_data,
-		},
-	},
-	{
-		.name = BMA150_G_SENSOR_NAME,
-		.dev = {
-			.platform_data = &passionc_g_sensor_pdata,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = PASSIONC_GPIO_UP_RESET_N,
-	.cmd_diff = CMD_83_DIFF,
-	.spi_devices = SPI_GSENSOR,
-};
-
-static int passionc_phy_init_seq[] = { 0x1D, 0x0D, 0x1D, 0x10, -1 };
-static struct msm_hsusb_product passionc_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c8e,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-
-static struct platform_device passionc_rfkill = {
-	.name = "passionc_rfkill",
-	.id = -1,
-};
-
-static int __capella_cm3602_power(int on)
-{
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on)
-		gpio_direction_output(PASSIONC_GPIO_LS_EN, 0);
-		/*gpio_set_value(PASSIONC_GPIO_LS_EN, 0);*/
-	else
-		gpio_direction_output(PASSIONC_GPIO_LS_EN, 1);
-		/*gpio_set_value(PASSIONC_GPIO_LS_EN, 1);*/
-	return 0;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	/* TODO eolsen Add Voltage reg control */
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable) {
-		if (pwr_device == PS_PWR_ON)
-			gpio_direction_output(PASSIONC_GPIO_PROXIMITY_EN, 0);
-			/*gpio_set_value(PASSIONC_GPIO_PROXIMITY_EN, 0);*/
-			als_power_control |= pwr_device;
-		} else {
-		if (pwr_device == PS_PWR_ON)
-			gpio_direction_output(PASSIONC_GPIO_PROXIMITY_EN, 1);
-			/*gpio_set_value(PASSIONC_GPIO_PROXIMITY_EN, 1);*/
-			als_power_control &= ~pwr_device;
-	}
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-		ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-}
-
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.p_out = PASSIONC_GPIO_PROXIMITY_INT,
-	.p_en = PASSIONC_GPIO_PROXIMITY_EN,
-	.power = capella_cm3602_power,
-};
-
-static struct platform_device capella_cm3602 = {
-	.name = CAPELLA_CM3602,
-	.dev = {
-		.platform_data = &capella_cm3602_pdata
-	}
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-
-static struct resource qsd_spi_resources[] = {
-	{
-		.name   = "spi_irq_in",
-		.start  = INT_SPI_INPUT,
-		.end    = INT_SPI_INPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_out",
-		.start  = INT_SPI_OUTPUT,
-		.end    = INT_SPI_OUTPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_err",
-		.start  = INT_SPI_ERROR,
-		.end    = INT_SPI_ERROR,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_base",
-		.start  = 0xA1200000,
-		.end    = 0xA1200000 + SZ_4K - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.name   = "spi_clk",
-		.start  = 17,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_mosi",
-		.start  = 18,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_miso",
-		.start  = 19,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_cs0",
-		.start  = 20,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_pwr",
-		.start  = 21,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_cs0",
-		.start  = 22,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device qsd_device_spi = {
-	.name           = "spi_qsd",
-	.id             = 0,
-	.num_resources  = ARRAY_SIZE(qsd_spi_resources),
-	.resource       = qsd_spi_resources,
-};
-
-static struct resource msm_kgsl_resources[] = {
-	{
-		.name	= "kgsl_reg_memory",
-		.start	= MSM_GPU_REG_PHYS,
-		.end	= MSM_GPU_REG_PHYS + MSM_GPU_REG_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "kgsl_phys_memory",
-		.start	= MSM_GPU_MEM_BASE,
-		.end	= MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_GRAPHICS,
-		.end	= INT_GRAPHICS,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device msm_kgsl_device = {
-	.name		= "kgsl",
-	.id		= -1,
-	.resource	= msm_kgsl_resources,
-	.num_resources	= ARRAY_SIZE(msm_kgsl_resources),
-};
-
-static struct android_pmem_platform_data mdp_pmem_pdata = {
-	.name		= "pmem",
-	.start		= MSM_PMEM_MDP_BASE,
-	.size		= MSM_PMEM_MDP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu0_pdata = {
-	.name		= "pmem_gpu0",
-	.start		= MSM_PMEM_GPU0_BASE,
-	.size		= MSM_PMEM_GPU0_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu1_pdata = {
-	.name		= "pmem_gpu1",
-	.start		= MSM_PMEM_GPU1_BASE,
-	.size		= MSM_PMEM_GPU1_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct android_pmem_platform_data android_pmem_adsp_pdata = {
-	.name		= "pmem_adsp",
-	.start		= MSM_PMEM_ADSP_BASE,
-	.size		= MSM_PMEM_ADSP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-
-static struct android_pmem_platform_data android_pmem_camera_pdata = {
-	.name		= "pmem_camera",
-	.start		= MSM_PMEM_CAMERA_BASE,
-	.size		= MSM_PMEM_CAMERA_SIZE,
-	.no_allocator	= 0,
-	.cached		= 0,
-};
-
-static struct platform_device android_pmem_mdp_device = {
-	.name		= "android_pmem",
-	.id		= 0,
-	.dev		= {
-		.platform_data = &mdp_pmem_pdata
-	},
-};
-
-static struct platform_device android_pmem_gpu0_device = {
-	.name		= "android_pmem",
-	.id		= 2,
-	.dev		= {
-		.platform_data = &android_pmem_gpu0_pdata,
-	},
-};
-
-static struct platform_device android_pmem_gpu1_device = {
-	.name		= "android_pmem",
-	.id		= 3,
-	.dev		= {
-		.platform_data = &android_pmem_gpu1_pdata,
-	},
-};
-
-static struct platform_device android_pmem_adsp_device = {
-	.name		= "android_pmem",
-	.id		= 4,
-	.dev		= {
-		.platform_data = &android_pmem_adsp_pdata,
-	},
-};
-
-static struct platform_device android_pmem_camera_device = {
-	.name		= "android_pmem",
-	.id		= 5,
-	.dev		= {
-		.platform_data = &android_pmem_camera_pdata,
-	},
-};
-
-static struct resource ram_console_resources[] = {
-	{
-		.start	= MSM_RAM_CONSOLE_BASE,
-		.end	= MSM_RAM_CONSOLE_BASE + MSM_RAM_CONSOLE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device ram_console_device = {
-	.name		= "ram_console",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(ram_console_resources),
-	.resource	= ram_console_resources,
-};
-
-static int passionc_ts_power(int on)
-{
-	pr_info("%s: power %d\n", __func__, on);
-
-	if (on) {
-		/* level shifter should be off */
-		gpio_set_value(PASSIONC_GPIO_TP_EN, 1);
-		msleep(120);
-		/* enable touch panel level shift */
-		gpio_set_value(PASSIONC_GPIO_TP_LS_EN, 1);
-		msleep(3);
-	} else {
-		gpio_set_value(PASSIONC_GPIO_TP_LS_EN, 0);
-		gpio_set_value(PASSIONC_GPIO_TP_EN, 0);
-		udelay(50);
-	}
-
-	return 0;
-}
-
-static struct synaptics_i2c_rmi_platform_data passionc_ts_data[] = {
-	{
-		.version = 0x0104,
-		.power = passionc_ts_power,
-		.sensitivity_adjust = 10,
-		.flags = SYNAPTICS_FLIP_Y,
-		.inactive_left = -1 * 0x10000 / 480,
-		.inactive_right = -1 * 0x10000 / 480,
-		.inactive_top = -5 * 0x10000 / 800,
-		.inactive_bottom = -20 * 0x10000 / 800,
-	},
-	{
-		.version = 0x0100,
-		.power = passionc_ts_power,
-		.sensitivity_adjust = 10,
-		.flags = SYNAPTICS_FLIP_Y,
-		.inactive_left = -5 * 0x10000 / 480,
-		.inactive_right = -5 * 0x10000 / 480,
-		.inactive_top = -10 * 0x10000 / 800,
-		.inactive_bottom = -30 * 0x10000 / 800,
-	},
-};
-
-struct cy8c_i2c_platform_data passionc_cy8c_ts_data = {
-	.version = 0x0001,
-	.abs_x_min = 0,
-	.abs_x_max = 479,
-	.abs_y_min = 0,
-	.abs_y_max = 799,
-	.abs_pressure_min = 0,
-	.abs_pressure_max = 255,
-	.abs_width_min = 0,
-	.abs_width_max = 10,
-	.power = passionc_ts_power,
-};
-
-static struct regulator_consumer_supply tps65023_dcdc1_supplies[] = {
-	{
-		.supply = "acpu_vcore",
-	},
-};
-
-static struct regulator_init_data tps65023_data[5] = {
-	{
-		.constraints = {
-			.name = "dcdc1", /* VREG_MSMC2_1V29 */
-			.min_uV = 1000000,
-			.max_uV = 1300000,
-			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
-		},
-		.consumer_supplies = tps65023_dcdc1_supplies,
-		.num_consumer_supplies = ARRAY_SIZE(tps65023_dcdc1_supplies),
-	},
-	/* dummy values for unused regulators to not crash driver: */
-	{
-		.constraints = {
-			.name = "dcdc2", /* VREG_MSMC1_1V26 */
-			.min_uV = 1260000,
-			.max_uV = 1260000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "dcdc3", /* unused */
-			.min_uV = 800000,
-			.max_uV = 3300000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo1", /* unused */
-			.min_uV = 1000000,
-			.max_uV = 3150000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo2", /* V_USBPHY_3V3 */
-			.min_uV = 3300000,
-			.max_uV = 3300000,
-		},
-	},
-};
-
-static struct msm_onewire_platform_data passionc_onewire_data = {
-	.gpio_one_wire = PASSIONC_GPIO_DOCK,
-	.delay_ns	= 10000,
-};
-
-static struct platform_device passionc_onewire = {
-	.name		= "htc_onewire",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &passionc_onewire_data,
-	},
-};
-
-
-static struct h2w_platform_data passionc_h2w_data = {
-
-};
-
-static struct platform_device passionc_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &passionc_h2w_data,
-	},
-};
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = PASSIONC_LAYOUTS,
-	.project_name = PASSIONC_PROJECT_NAME,
-	.reset = PASSIONC_GPIO_COMPASS_RST_N,
-	.intr = PASSIONC_GPIO_COMPASS_INT_N,
-};
-
-static struct a1026_platform_data a1026_data = {
-	.gpio_a1026_micsel = PASSIONC_AUD_MICPATH_SEL,
-	.gpio_a1026_wakeup = PASSIONC_AUD_A1026_WAKEUP,
-	.gpio_a1026_reset = PASSIONC_AUD_A1026_RESET,
-	.gpio_a1026_clk = PASSIONC_AUD_A1026_CLK,
-	/*.gpio_a1026_int = PASSIONC_AUD_A1026_INT,*/
-};
-
-static struct tpa2018d1_platform_data tpa2018_data = {
-	.gpio_tpa2018_spk_en = PASSIONC_AUD_SPK_EN,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x28),
-		.platform_data = &passionc_ts_data,
-		.irq = MSM_GPIO_TO_INT(PASSIONC_GPIO_TP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x40),
-		.platform_data = &passionc_ts_data,
-		.irq = MSM_GPIO_TO_INT(PASSIONC_GPIO_TP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = MSM_GPIO_TO_INT(PASSIONC_GPIO_UP_INT_N)
-	},
-	{
-		I2C_BOARD_INFO("smb329", 0x6E >> 1),
-	},
-	{
-		I2C_BOARD_INFO("ds2482", 0x30 >> 1),
-		/*.platform_data = &microp_data,*/
-		/*.irq = MSM_GPIO_TO_INT(PASSION_GPIO_UP_INT_N)*/
-	},
-	{
-		I2C_BOARD_INFO("audience_a1026", 0x3E),
-		.platform_data = &a1026_data,
-		/*.irq = MSM_GPIO_TO_INT(PASSIONC_AUD_A1026_INT)*/
-	},
-	{
-		I2C_BOARD_INFO("tpa2018d1", 0x58),
-		.platform_data = &tpa2018_data,
-	},
-	{
-		I2C_BOARD_INFO("cy8c-tmg-ts", 0x34),
-		.platform_data = &passionc_cy8c_ts_data,
-		.irq = MSM_GPIO_TO_INT(PASSIONC_GPIO_TP_INT_N),
-	},
-	{
-		I2C_BOARD_INFO(AKM8973_I2C_NAME, 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = MSM_GPIO_TO_INT(PASSIONC_GPIO_COMPASS_INT_N),
-	},
-#ifdef CONFIG_MSM_CAMERA
-#ifdef CONFIG_S5K3E2FX
-	{
-		I2C_BOARD_INFO("s5k3e2fx", 0x20 >> 1),
-	},
-#endif
-#endif/*CONIFIG_MSM_CAMERA*/
-	{
-		I2C_BOARD_INFO("tps65023", 0x48),
-		.platform_data = tps65023_data,
-	},
-};
-
-#ifdef CONFIG_ARCH_QSD8X50
-static char bdaddress[20];
-
-static void bt_export_bd_address(void)
-{
-	unsigned char cTemp[6];
-
-	memcpy(cTemp, get_bt_bd_ram(), 6);
-	sprintf(bdaddress, "%02x:%02x:%02x:%02x:%02x:%02x",
-		cTemp[0], cTemp[1], cTemp[2], cTemp[3], cTemp[4], cTemp[5]);
-	printk(KERN_INFO "YoYo--BD_ADDRESS=%s\n", bdaddress);
-}
-
-module_param_string(bdaddress, bdaddress, sizeof(bdaddress), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bdaddress, "BT MAC ADDRESS");
-#endif
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* VSYNC */
-/*	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_16MA),*/ /* MCLK */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* MCLK */
-	/*steven yeh: modify MCLK driving strength to avoid overshot issue*/
-};
-
-static void config_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-static void config_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-#ifdef CONFIG_MSM_CAMERA
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		 INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_camera_on_gpios,
-	.camera_gpio_off = config_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
-	.camera_flash		= flashlight_control,
-	.num_flash_levels	= FLASHLIGHT_NUM,
-	.low_temp_limit		= 5,
-	.low_cap_limit		= 15,
-};
-
-#ifdef CONFIG_S5K3E2FX
-static struct msm_camera_sensor_info msm_camera_sensor_s5k3e2fx_data = {
-	.sensor_name = "s5k3e2fx",
-	.sensor_reset = 144, /* CAM1_RST */
-	.sensor_pwd = 143,  /* CAM1_PWDN, enabled in a9 */
-	/*.vcm_pwd = 31, */  /* CAM1_VCM_EN, enabled in a9 */
-	.pdata = &msm_camera_device_data,
-	.resource = msm_camera_resources,
-	.num_resources = ARRAY_SIZE(msm_camera_resources),
-	.flash_cfg	= &msm_camera_sensor_flash_cfg,
-};
-
-static struct platform_device msm_camera_sensor_s5k3e2fx = {
-	.name		= "msm_camera_s5k3e2fx",
-	.dev		= {
-	.platform_data = &msm_camera_sensor_s5k3e2fx_data,
-	},
-};
-#endif
-#endif/*CONFIG_MSM_CAMERA*/
-
-static void config_passionc_flashlight_gpios(void)
-{
-	static uint32_t flashlight_gpio_table[] = {
-		PCOM_GPIO_CFG(PASSIONC_GPIO_FLASHLIGHT_TORCH, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-		PCOM_GPIO_CFG(PASSIONC_GPIO_FLASHLIGHT_FLASH, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_2MA),
-	};
-
-	config_gpio_table(flashlight_gpio_table,
-		ARRAY_SIZE(flashlight_gpio_table));
-}
-
-static struct flashlight_platform_data passionc_flashlight_data = {
-	.gpio_init  = config_passionc_flashlight_gpios,
-	.torch = PASSIONC_GPIO_FLASHLIGHT_TORCH,
-	.flash = PASSIONC_GPIO_FLASHLIGHT_FLASH,
-	.flash_duration_ms = 600,
-};
-
-static struct platform_device passionc_flashlight_device = {
-	.name = FLASHLIGHT_NAME,
-	.dev		= {
-		.platform_data	= &passionc_flashlight_data,
-	},
-};
-
-static struct timed_gpio timed_gpios[] = {
-	{
-		.name = "vibrator",
-		.gpio = PASSIONC_VIB_3V3_EN,
-		.max_timeout = 15000,
-	},
-};
-
-static struct timed_gpio_platform_data timed_gpio_data = {
-	.num_gpios	= ARRAY_SIZE(timed_gpios),
-	.gpios		= timed_gpios,
-};
-
-static struct platform_device android_timed_gpios = {
-	.name		= "timed-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data = &timed_gpio_data,
-	},
-};
-
-static int amoled_power(int on)
-{
-	/* FIXME: power? */
-	if (on) {
-		gpio_set_value(PASSIONC_LCD_RSTz, 1);
-		mdelay(25);
-		gpio_set_value(PASSIONC_LCD_RSTz, 0);
-		mdelay(10);
-		gpio_set_value(PASSIONC_LCD_RSTz, 1);
-		mdelay(20);
-	} else {
-		gpio_set_value(PASSIONC_LCD_RSTz, 0);
-	}
-	return 0;
-}
-
-#define LCM_GPIO_CFG(gpio, func) \
-PCOM_GPIO_CFG(gpio, func, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA)
-static uint32_t display_on_gpio_table[] = {
-	LCM_GPIO_CFG(PASSIONC_LCD_R0, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_B0, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_R1, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_R2, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_R3, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_R4, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_R5, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_G0, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_G1, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_G2, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_G3, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_G4, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_G5, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_B1, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_B2, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_B3, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_B4, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_B5, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_PCLK, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_VSYNC, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_HSYNC, 1),
-	LCM_GPIO_CFG(PASSIONC_LCD_DE, 1),
-};
-
-static uint32_t display_off_gpio_table[] = {
-	LCM_GPIO_CFG(PASSIONC_LCD_R0, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_B0, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_R1, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_R2, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_R3, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_R4, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_R5, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_G0, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_G1, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_G2, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_G3, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_G4, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_G5, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_B1, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_B2, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_B3, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_B4, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_B5, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_PCLK, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_VSYNC, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_HSYNC, 0),
-	LCM_GPIO_CFG(PASSIONC_LCD_DE, 0),
-};
-
-static int panel_gpio_switch(int on)
-{
-	if (on) {
-		u32 *table = display_on_gpio_table;
-		int len = ARRAY_SIZE(display_on_gpio_table);
-
-		if (is_evt1()) {
-			table = &display_on_gpio_table[2];
-			len -= 2;
-		}
-		config_gpio_table(table, len);
-	} else {
-		u32 *table = display_off_gpio_table;
-		int len = ARRAY_SIZE(display_off_gpio_table);
-		int i;
-
-		if (is_evt1()) {
-			table = &display_off_gpio_table[2];
-			len -= 2;
-		}
-		config_gpio_table(table, len);
-
-		for (i = PASSIONC_LCD_R0; i <= PASSIONC_LCD_R5; i++) {
-			/* skip R0 for XA */
-			if (is_evt1())
-				continue;
-			gpio_set_value(i, 0);
-		}
-		for (i = PASSIONC_LCD_G0; i <= PASSIONC_LCD_G5; i++)
-			gpio_set_value(i, 0);
-		for (i = PASSIONC_LCD_B0; i <= PASSIONC_LCD_DE; i++) {
-			/* skip B0 for XA */
-			if (is_evt1())
-				continue;
-			gpio_set_value(i, 0);
-		}
-	}
-	return 0;
-}
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct panel_platform_data amoled_data = {
-	.fb_res = &resources_msm_fb[0],
-	.power = amoled_power,
-	.gpio_switch = panel_gpio_switch,
-};
-
-static struct platform_device amoled_panel = {
-	.name = "amoled-panel",
-	.id = -1,
-	.dev = {
-		.platform_data = &amoled_data,
-	},
-};
-
-static struct platform_device *devices[] __initdata = {
-	&amoled_panel,
-	&msm_device_uart1,
-#ifdef CONFIG_SERIAL_MSM_HS
-	&msm_device_uart_dm1,
-#endif
-	&passionc_onewire,
-	&passionc_h2w,
-	&htc_battery_pdev,
-	&ram_console_device,
-	&passionc_rfkill,
-	&msm_device_smd,
-	&msm_device_nand,
-	/*&msm_device_hsusb,*/
-	/*&usb_mass_storage_device,*/
-	&android_pmem_mdp_device,
-	&android_pmem_gpu0_device,
-	&android_pmem_gpu1_device,
-	&android_pmem_adsp_device,
-	/*&android_pmem_camera_device,*/
-#ifdef CONFIG_MSM_CAMERA
-#ifdef CONFIG_S5K3E2FX
-	&msm_camera_sensor_s5k3e2fx,
-#endif
-#endif
-	&msm_kgsl_device,
-	&msm_device_i2c,
-	&passionc_flashlight_device,
-
-#if defined(CONFIG_SPI_QSD)
-	&qsd_device_spi,
-#endif
-#ifdef CONFIG_INPUT_CAPELLA_CM3602
-	&capella_cm3602,
-#endif
-};
-
-
-static uint32_t passionc_serial_debug_table[] = {
-	/* for uart debugger.
-	 * It should be removed when support usb to serial function.
-	 * */
-	PCOM_GPIO_CFG(PASSIONC_GPIO_UART3_RX, 3, GPIO_INPUT,
-			GPIO_NO_PULL, GPIO_4MA), /* RX */
-	PCOM_GPIO_CFG(PASSIONC_GPIO_UART3_TX, 3, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_4MA), /* TX */
-};
-
-static void passionc_config_serial_debug_gpios(void)
-{
-	config_gpio_table(passionc_serial_debug_table,
-				ARRAY_SIZE(passionc_serial_debug_table));
-}
-
-static struct msm_i2c_device_platform_data msm_i2c_pdata = {
-	.i2c_clock = 100000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_8MA,
-};
-
-static void __init msm_device_i2c_init(void)
-{
-	msm_device_i2c.dev.platform_data = &msm_i2c_pdata;
-}
-
-static struct msm_acpu_clock_platform_data passionc_clock_data = {
-	.acpu_switch_time_us	= 20,
-	.max_speed_delta_khz	= 256000,
-	.vdd_switch_time_us	= 62,
-	.power_collapse_khz	= 245000,
-	.wait_for_irq_khz	= 245000,
-};
-
-static unsigned passionc_perf_acpu_table[] = {
-	245000000,
-	576000000,
-	998400000,
-};
-
-static struct perflock_platform_data passionc_perflock_data = {
-	.perf_acpu_table = passionc_perf_acpu_table,
-	.table_size = ARRAY_SIZE(passionc_perf_acpu_table),
-};
-
-static ssize_t passionc_synaptics_virtual_keys_show(struct kobject *kobj,
-			       struct kobj_attribute *attr, char *buf)
-{
-	if (!is_evt1()) { /* XB */
-		/* center: x: BACK: 55, menu: 180, MENU: 308, HOME: 308, SEARCH: 425 */
-		return sprintf(buf,
-			__stringify(EV_KEY) ":" __stringify(KEY_BACK)  ":55:835:110:55"
-		   ":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":180:835:120:55"
-		   ":" __stringify(EV_KEY) ":" __stringify(KEY_HOME)   ":308:835:125:55"
-		   ":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":425:835:110:55"
-		   "\n");
-	}
-	/* center: x: home: 60, menu: 180, back: 308, search 425, y: 835 */
-	return sprintf(buf,
-		__stringify(EV_KEY) ":" __stringify(KEY_HOME)  ":60:835:100:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":180:835:120:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":308:835:125:55"
-	   ":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":425:835:110:55"
-	   "\n");
-}
-
-static struct kobj_attribute passionc_synaptics_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.synaptics-rmi-touchscreen",
-		.mode = S_IRUGO,
-	},
-	.show = &passionc_synaptics_virtual_keys_show,
-};
-
-static struct attribute *passionc_properties_attrs[] = {
-	&passionc_synaptics_virtual_keys_attr.attr,
-	NULL
-};
-
-static struct attribute_group passionc_properties_attr_group = {
-	.attrs = passionc_properties_attrs,
-};
-
-int passionc_init_mmc(int sysrev);
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(PASSIONC_GPIO_BT_HOST_WAKE),
-	.inject_rx_on_wakeup = 0,
-	#if 1	/* bt for bcm */
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = PASSIONC_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = PASSIONC_GPIO_BT_HOST_WAKE,
-	#endif
-};
-#endif
-
-static void passionc_reset(void)
-{
-	gpio_set_value(PASSIONC_GPIO_PS_HOLD, 0);
-}
-
-static void __init passionc_init(void)
-{
-	int ret;
-	struct kobject *properties_kobj;
-
-	printk("passionc_init() revision=%d\n", system_rev);
-	printk(KERN_INFO "%s: microp version = %s\n", __func__, microp_ver);
-
-	msm_hw_reset_hook = passionc_reset;
-
-	msm_acpu_clock_init(&passionc_clock_data);
-	perflock_init(&passionc_perflock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	msm_serial_debug_init(MSM_UART1_PHYS, INT_UART1,
-			      &msm_device_uart1.dev, 1, MSM_GPIO_TO_INT(139));
-#endif
-
-#ifdef CONFIG_ARCH_QSD8X50
-	bt_export_bd_address();
-#endif
-
-	#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	#endif
-
-	passionc_config_serial_debug_gpios();
-
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-	gpio_direction_output(PASSIONC_GPIO_TP_LS_EN, 0);
-	gpio_direction_output(PASSIONC_GPIO_TP_EN, 0);
-
-	passionc_audio_init();
-	msm_device_i2c_init();
-#ifdef CONFIG_MICROP_COMMON
-	passionc_microp_init();
-#endif
-
-	msm_register_usb_phy_init_seq(passionc_phy_init_seq);
-	msm_register_uart_usb_switch(NULL);
-	msm_add_usb_id_pin_gpio(PASSIONC_GPIO_USB_ID_PIN);
-	msm_hsusb_set_product(passionc_usb_products,
-		ARRAY_SIZE(passionc_usb_products));
-	msm_add_usb_devices(NULL, NULL);
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	for (ret = 0; ret < ARRAY_SIZE(i2c_devices); ret++) {
-		if (!strcmp(i2c_devices[ret].type, AKM8973_I2C_NAME))
-			i2c_devices[ret].irq = MSM_GPIO_TO_INT(PASSIONC_GPIO_COMPASS_INT_N);
-	}
-	compass_platform_data.intr = PASSIONC_GPIO_COMPASS_INT_N;
-
-	if (!is_evt1()) {
-		a1026_data.gpio_a1026_wakeup = PASSIONC_XB_AUD_A1026_WAKEUP;
-		a1026_data.gpio_a1026_reset = PASSIONC_XB_AUD_A1026_RESET;
-		a1026_data.gpio_a1026_clk = PASSIONC_XB_AUD_A1026_CLK;
-	}
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	ret = passionc_init_mmc(system_rev);
-	if (ret != 0)
-		pr_crit("%s: Unable to initialize MMC\n", __func__);
-	properties_kobj = kobject_create_and_add("board_properties", NULL);
-	if (properties_kobj)
-		ret = sysfs_create_group(properties_kobj,
-					 &passionc_properties_attr_group);
-	if (!properties_kobj || ret)
-		pr_err("failed to create board_properties\n");
-
-	ret = platform_device_register(&android_timed_gpios);
-	if (ret != 0)
-		pr_err("failed to register vibrator\n");
-
-	if ((microp_ver[0] >= '0' && microp_ver[1] >= '6') ||
-	    microp_ver[0] >= '1' &&
-	    (microp_ver[2] == '1' && microp_ver[3] == '5'))
-		passionc_g_sensor_pdata.microp_new_cmd = 1;
-
-}
-
-static void __init passionc_fixup(struct machine_desc *desc, struct tag *tags,
-				 char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 1;
-	mi->bank[0].start = PHYS_OFFSET;
-	mi->bank[0].node = PHYS_TO_NID(PHYS_OFFSET);
-	mi->bank[0].size = (195*1024*1024);
-}
-
-static void __init passionc_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-extern struct sys_timer msm_timer;
-
-MACHINE_START(PASSIONC, "passionc")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params	= 0x20000100,
-	.fixup		= passionc_fixup,
-	.map_io		= passionc_map_io,
-	.init_irq	= msm_init_irq,
-	.init_machine	= passionc_init,
-	.timer		= &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-passionc.h b/arch/arm/mach-msm/board-passionc.h
deleted file mode 100755
index a941d2f..0000000
--- a/arch/arm/mach-msm/board-passionc.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/* arch/arm/mach-msm/board-passionc.h
- *
- * Copyright (C) 2009 HTC Corporation.
- * Author: Haley Teng <Haley_Teng@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_PASSIONC_H
-#define __ARCH_ARM_MACH_MSM_BOARD_PASSIONC_H
-
-#include <mach/board.h>
-
-#define MSM_SMI_BASE		0x02B00000
-#define MSM_SMI_SIZE		0x01500000
-
-#define MSM_RAM_CONSOLE_BASE	0x03A00000
-#define MSM_RAM_CONSOLE_SIZE	0x00040000
-
-#define MSM_FB_BASE		0x03B00000
-#define MSM_FB_SIZE		0x00465000
-
-#define MSM_EBI1_BASE		0x20000000
-#define MSM_EBI1_SIZE		0x0E000000
-
-#define MSM_PMEM_GPU0_BASE	0x2C300000
-#define MSM_PMEM_GPU0_SIZE	0x01000000
-
-#define MSM_PMEM_GPU1_BASE	0x2D300000
-#define MSM_PMEM_GPU1_SIZE	0x00800000
-
-#define MSM_GPU_MEM_BASE	0x2DB00000
-#define MSM_GPU_MEM_SIZE	0x00200000
-
-#define MSM_EBI1_BANK1_BASE     0x30000000
-#define MSM_EBI1_BANK1_SIZE     0x10000000
-
-#define MSM_PMEM_MDP_BASE	0x30000000
-#define MSM_PMEM_MDP_SIZE	0x01000000
-
-#define MSM_PMEM_ADSP_BASE      0x32000000
-#define MSM_PMEM_ADSP_SIZE      0x02400000
-
-#define MSM_PMEM_CAMERA_BASE    0x34900000
-#define MSM_PMEM_CAMERA_SIZE    0x00000000
-
-#define	PASSIONC_GPIO_PS_HOLD		25
-
-#define PASSIONC_GPIO_UP_INT_N		35
-#define PASSIONC_GPIO_UP_RESET_N	82
-#define PASSIONC_GPIO_LS_EN		119
-
-#define PASSIONC_GPIO_TP_INT_N		92
-#define PASSIONC_GPIO_TP_LS_EN		93
-#define PASSIONC_GPIO_TP_EN		160
-
-#define PASSIONC_GPIO_POWER_KEY		94
-
-#define PASSIONC_GPIO_RESET_BTN		27
-#define PASSIONC_GPIO_WIFI_SHUTDOWN_N	127
-#define PASSIONC_GPIO_WIFI_IRQ		152
-#define PASSIONC_GPIO_BALL_UP		38
-#define PASSIONC_GPIO_BALL_DOWN		37
-#define PASSIONC_GPIO_BALL_LEFT		145
-#define PASSIONC_GPIO_BALL_RIGHT	21
-#define PASSIONC_GPIO_JOGBALL_POWER	150
-
-#define PASSIONC_GPIO_KP_MPIN0		42
-#define PASSIONC_GPIO_KP_MPIN1		41
-#define PASSIONC_GPIO_KP_MPIN2		40
-#define PASSIONC_GPIO_KP_MKOUT0		33
-#define PASSIONC_GPIO_KP_MKOUT1		32
-#define PASSIONC_GPIO_KP_MKOUT2		31
-
-/* Bluetooth */
-#define PASSIONC_GPIO_BT_UART1_RTS	43
-#define PASSIONC_GPIO_BT_UART1_CTS	44
-#define PASSIONC_GPIO_BT_UART1_RX	45
-#define PASSIONC_GPIO_BT_UART1_TX	46
-#define PASSIONC_GPIO_BT_RESET_N	146
-#define PASSIONC_GPIO_BT_SHUTDOWN_N	128
-#define PASSIONC_GPIO_BT_HOST_WAKE	86
-#define PASSIONC_GPIO_BT_CHIP_WAKE	28
-
-#define PASSIONC_GPIO_UART3_RX 139
-#define PASSIONC_GPIO_UART3_TX 140
-
-#define PASSIONC_GPIO_COMPASS_RST_N	107
-#define PASSIONC_GPIO_COMPASS_INT_N	153
-#define PASSIONC_PROJECT_NAME		"passionc"
-#define PASSIONC_LAYOUTS		{ \
-		{ {-1,  0, 0}, { 0, -1,  0}, {0, 0,  1} }, /*cspec_Hlayout*/ \
-		{ { 0, -1, 0}, { 1,  0,  0}, {0, 0, -1} }, /*cspec_Alayout*/ \
-		{ { 0, -1, 0}, { 1,  0,  0}, {0, 0,  1} }, /*m_Hlayout*/ \
-		{ {-1,  0, 0}, { 0,  0, -1}, {0, 1,  0} }  /*m_Alayout*/ \
-					}
-
-/* Proximity */
-#define PASSIONC_GPIO_PROXIMITY_INT	90
-#define PASSIONC_GPIO_PROXIMITY_EN	120
-
-/* Battery */
-#define PASSIONC_GPIO_MBAT_IN		39
-#define PASSIONC_GPIO_MCHG_EN_N		22
-#define PASSIONC_GPIO_ISET		16
-#define PASSIONC_GPIO_DQ_PWRDN_N	87
-
-/*Audio */
-#define PASSIONC_AUD_JACKHP_EN		157
-#define PASSIONC_AUD_2V5_EN		158
-#define PASSIONC_AUD_MICPATH_SEL 	111
-#define PASSIONC_AUD_A1026_INT		112
-#define PASSIONC_AUD_A1026_WAKEUP 	113
-#define PASSIONC_AUD_A1026_RESET 	129
-#define PASSIONC_AUD_A1026_CLK		105
-#define PASSIONC_XB_AUD_A1026_WAKEUP	16
-#define PASSIONC_XB_AUD_A1026_RESET	19
-#define PASSIONC_XB_AUD_A1026_CLK	-1
-#define PASSIONC_AUD_SPK_EN		104
-
-
-/* Bluetooth PCM */
-#define PASSIONC_BT_PCM_OUT		68
-#define PASSIONC_BT_PCM_IN		69
-#define PASSIONC_BT_PCM_SYNC		70
-#define PASSIONC_BT_PCM_CLK		71
-
-#define PASSIONC_VIB_3V3_EN		89
-
-/* flash light */
-#define PASSIONC_GPIO_FLASHLIGHT_TORCH (26)
-#define PASSIONC_GPIO_FLASHLIGHT_FLASH (84)
-#define PASSIONC_GPIO_DOCK		106
-/* LCM */
-#define PASSIONC_LCD_RSTz		(29)
-#define PASSIONC_LCD_R0			(113) /* XB new added */
-#define PASSIONC_LCD_R1			(114)
-#define PASSIONC_LCD_R2			(115)
-#define PASSIONC_LCD_R3			(116)
-#define PASSIONC_LCD_R4			(117)
-#define PASSIONC_LCD_R5			(118)
-#define PASSIONC_LCD_G0			(121)
-#define PASSIONC_LCD_G1			(122)
-#define PASSIONC_LCD_G2			(123)
-#define PASSIONC_LCD_G3			(124)
-#define PASSIONC_LCD_G4			(125)
-#define PASSIONC_LCD_G5			(126)
-#define PASSIONC_LCD_B0			(129) /* XB new added*/
-#define PASSIONC_LCD_B1			(130)
-#define PASSIONC_LCD_B2			(131)
-#define PASSIONC_LCD_B3			(132)
-#define PASSIONC_LCD_B4			(133)
-#define PASSIONC_LCD_B5			(134)
-#define PASSIONC_LCD_PCLK		(135)
-#define PASSIONC_LCD_VSYNC		(136)
-#define PASSIONC_LCD_HSYNC		(137)
-#define PASSIONC_LCD_DE			(138)
-
-#define PASSIONC_GPIO_USB_ID_PIN          (36)
-
-#define is_evt1() ((system_rev == 0xC0) || (system_rev == 0x0))
-#define is_evt2() ((system_rev == 0xC1) || (system_rev == 0x1))
-#define is_evt3_1() ((system_rev == 0xC2) || (system_rev == 0x2))
-#define is_evt3_2() ((system_rev == 0xC3) || (system_rev == 0x3))
-
-#endif /* __ARCH_ARM_MACH_MSM_BOARD_PASSIONC_H */
diff --git a/arch/arm/mach-msm/board-sapphire-gpio.c b/arch/arm/mach-msm/board-sapphire-gpio.c
deleted file mode 100644
index 28fe77e..0000000
--- a/arch/arm/mach-msm/board-sapphire-gpio.c
+++ /dev/null
@@ -1,381 +0,0 @@
-/* arch/arm/mach-msm/board-sapphire-gpio.c
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Thomas Tsai <thomas_tsai@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/irq.h>
-#include <linux/pm.h>
-#include <linux/sysdev.h>
-
-#include <linux/io.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-#include <mach/vreg.h>
-#include "gpio_chip.h"
-#include "board-sapphire.h"
-
-#ifdef DEBUG_SAPPHIRE_GPIO
-#define DBG(fmt, arg...) printk(KERN_INFO "%s: " fmt "\n", __func__, ## arg)
-#else
-#define DBG(fmt, arg...) do {} while (0)
-#endif
-
-#define	SAPPHIRE_CPLD_INT_STATUS	(SAPPHIRE_CPLD_BASE + 0x0E)
-#define	SAPPHIRE_CPLD_INT_LEVEL		(SAPPHIRE_CPLD_BASE + 0x08)
-#define	SAPPHIRE_CPLD_INT_MASK		(SAPPHIRE_CPLD_BASE + 0x0C)
-
-/*CPLD misc reg offset*/
-static const int _g_CPLD_MISCn_Offset[] = {	0x0A,		/*misc1 reg*/
-						0x00,		/*misc2 reg*/
-						0x02,		/*misc3 reg*/
-						0x04,		/*misc4 reg*/
-						0x06};		/*misc5 reg*/
-/*CPLD INT Bank*/
-/*BANK0: int1 status, int2 level, int3 mask*/
-static const int _g_INT_BANK_Offset[][3] = {{0x0E, 0x08, 0x0C} };
-
-static uint8_t sapphire_cpld_initdata[4]  = {
-	[0] = 0x80, /* for serial debug UART3, low current	misc2*/
-	[1] = 0x34, /* jog & tp enable, I2C pull		misc3*/
-	[3] = 0x04, /* mmdi 32k en				misc5*/
-};
-
-/*save current working int mask, so the value can be restored after resume.
-Sapphire has only bank0.*/
-static uint8_t sapphire_int_mask[] = {
-	[0] = 0xfb, /* enable all interrupts, bit 2 is not used */
-};
-
-/*Sleep have to prepare the wake up source in advance.
-default to disable all wakeup sources when suspend.*/
-static uint8_t sapphire_sleep_int_mask[] = {
-	[0] = 0x00,	/* bit2 is not used */
-};
-
-static int sapphire_suspended;
-
-static int sapphire_gpio_read(struct gpio_chip *chip, unsigned n)
-{
-	if (n < SAPPHIRE_GPIO_INT_B0_BASE)	/*MISCn*/
-		return !!(readb(CPLD_GPIO_REG(n)) & CPLD_GPIO_BIT_POS_MASK(n));
-	else if (n <= SAPPHIRE_GPIO_END)	/*gpio n is INT pin*/
-		return !!(readb(CPLD_INT_LEVEL_REG_G(n)) &
-						CPLD_GPIO_BIT_POS_MASK(n));
-	return 0;
-}
-
-/*CPLD Write only register :MISC2, MISC3, MISC4, MISC5 => reg=0,2,4,6
-Reading from write-only registers is undefined, so the writing value
-should be kept in shadow for later usage.*/
-int sapphire_gpio_write(struct gpio_chip *chip, unsigned n, unsigned on)
-{
-	unsigned long flags;
-	uint8_t reg_val;
-	if (n > SAPPHIRE_GPIO_END)
-		return -1;
-
-	local_irq_save(flags);
-	reg_val = readb(CPLD_GPIO_REG(n));
-	if (on)
-		reg_val |= CPLD_GPIO_BIT_POS_MASK(n);
-	else
-		reg_val &= ~CPLD_GPIO_BIT_POS_MASK(n);
-	writeb(reg_val, CPLD_GPIO_REG(n));
-
-	DBG("gpio=%d, l=0x%x\r\n", n, readb(SAPPHIRE_CPLD_INT_LEVEL));
-
-	local_irq_restore(flags);
-
-	return 0;
-}
-
-static int sapphire_gpio_configure(struct gpio_chip *chip, unsigned int gpio,
-				   unsigned long flags)
-{
-	if (flags & (GPIOF_OUTPUT_LOW | GPIOF_OUTPUT_HIGH))
-		sapphire_gpio_write(chip, gpio, flags & GPIOF_OUTPUT_HIGH);
-
-	DBG("gpio=%d, l=0x%x\r\n", gpio, readb(SAPPHIRE_CPLD_INT_LEVEL));
-
-	return 0;
-}
-
-static int sapphire_gpio_get_irq_num(struct gpio_chip *chip, unsigned int gpio,
-				unsigned int *irqp, unsigned long *irqnumflagsp)
-{
-	DBG("gpio=%d, l=0x%x\r\n", gpio, readb(SAPPHIRE_CPLD_INT_LEVEL));
-	DBG("SAPPHIRE_GPIO_INT_B0_BASE=%d, SAPPHIRE_GPIO_LAST_INT=%d\r\n",
-	    SAPPHIRE_GPIO_INT_B0_BASE, SAPPHIRE_GPIO_LAST_INT);
-	if ((gpio < SAPPHIRE_GPIO_INT_B0_BASE) ||
-	     (gpio > SAPPHIRE_GPIO_LAST_INT))
-		return -ENOENT;
-	*irqp = SAPPHIRE_GPIO_TO_INT(gpio);
-	DBG("*irqp=%d\r\n", *irqp);
-	if (irqnumflagsp)
-		*irqnumflagsp = 0;
-	return 0;
-}
-
-/*write 1 to clear INT status bit.*/
-static void sapphire_gpio_irq_ack(unsigned int irq)
-{
-	/*write 1 to clear*/
-	writeb(SAPPHIRE_INT_BIT_MASK(irq), CPLD_INT_STATUS_REG(irq));
-}
-
-/*unmask/enable the INT
-static void sapphire_gpio_irq_unmask(unsigned int irq)*/
-static void sapphire_gpio_irq_enable(unsigned int irq)
-{
-	unsigned long flags;
-	uint8_t reg_val;
-
-	local_irq_save(flags);	/*disabling all interrupts*/
-
-	reg_val = readb(CPLD_INT_MASK_REG(irq)) | SAPPHIRE_INT_BIT_MASK(irq);
-	DBG("(irq=%d,0x%x, 0x%x)\r\n", irq, CPLD_INT_MASK_REG(irq),
-	    SAPPHIRE_INT_BIT_MASK(irq));
-	DBG("sapphire_suspended=%d\r\n", sapphire_suspended);
-	/*printk(KERN_INFO "sapphire_gpio_irq_mask irq %d => %d:%02x\n",
-	       irq, bank, reg_val);*/
-	if (!sapphire_suspended)
-		writeb(reg_val, CPLD_INT_MASK_REG(irq));
-
-	reg_val = readb(CPLD_INT_MASK_REG(irq));
-	DBG("reg_val= 0x%x\r\n", reg_val);
-	DBG("l=0x%x\r\n", readb(SAPPHIRE_CPLD_INT_LEVEL));
-
-	local_irq_restore(flags); /*restore the interrupts*/
-}
-
-/*mask/disable INT
-static void sapphire_gpio_irq_mask(unsigned int irq)*/
-static void sapphire_gpio_irq_disable(unsigned int irq)
-{
-	unsigned long flags;
-	uint8_t reg_val;
-
-	local_irq_save(flags);
-	reg_val = readb(CPLD_INT_MASK_REG(irq)) & ~SAPPHIRE_INT_BIT_MASK(irq);
-	/*CPLD INT MASK is r/w now.*/
-
-	/*printk(KERN_INFO "sapphire_gpio_irq_unmask irq %d => %d:%02x\n",
-	       irq, bank, reg_val);*/
-	DBG("(%d,0x%x, 0x%x, 0x%x)\r\n", irq, reg_val, CPLD_INT_MASK_REG(irq),
-	    SAPPHIRE_INT_BIT_MASK(irq));
-	DBG("sapphire_suspended=%d\r\n", sapphire_suspended);
-	if (!sapphire_suspended)
-		writeb(reg_val, CPLD_INT_MASK_REG(irq));
-
-	reg_val = readb(CPLD_INT_MASK_REG(irq));
-	DBG("reg_val= 0x%x\r\n", reg_val);
-	DBG("l=0x%x\r\n", readb(SAPPHIRE_CPLD_INT_LEVEL));
-
-	local_irq_restore(flags);
-}
-
-/*preparing enable/disable wake source before sleep*/
-int sapphire_gpio_irq_set_wake(unsigned int irq, unsigned int on)
-{
-	unsigned long flags;
-	uint8_t mask = SAPPHIRE_INT_BIT_MASK(irq);
-
-	local_irq_save(flags);
-
-	if (on)	/*wake on -> mask the bit*/
-		sapphire_sleep_int_mask[CPLD_INT_TO_BANK(irq)] |= mask;
-	else	/*no wake -> unmask the bit*/
-		sapphire_sleep_int_mask[CPLD_INT_TO_BANK(irq)] &= ~mask;
-	local_irq_restore(flags);
-	return 0;
-}
-
-/*Sapphire has only one INT Bank.*/
-static void sapphire_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
-{
-	int j;
-	unsigned v;
-	int int_base = SAPPHIRE_INT_START;
-
-	v = readb(SAPPHIRE_CPLD_INT_STATUS);	/*INT1 status reg, BANK0*/
-
-	for (j = 0; j < 8 ; j++) {	/*8 bit per bank*/
-		if (v & (1U << j)) {	/*got the INT Bit*/
-			DBG("generic_handle_irq j=0x%x\r\n", j);
-			generic_handle_irq(int_base + j);
-		}
-	}
-
-	desc->chip->ack(irq);	/*clear CPLD INT in SOC side.*/
-	DBG("irq=%d, l=0x%x\r\n", irq, readb(SAPPHIRE_CPLD_INT_LEVEL));
-}
-
-/*Save current working sources before sleep, so we can restore it after
- * resume.*/
-static int sapphire_sysdev_suspend(struct sys_device *dev, pm_message_t state)
-{
-	sapphire_suspended = 1;
-	/*save current masking*/
-	sapphire_int_mask[0] = readb(SAPPHIRE_CPLD_BASE +
-					SAPPHIRE_GPIO_INT_B0_MASK_REG);
-
-	/*set waking source before sleep.*/
-	writeb(sapphire_sleep_int_mask[0],
-	       SAPPHIRE_CPLD_BASE +  SAPPHIRE_GPIO_INT_B0_MASK_REG);
-
-	return 0;
-}
-
-/*All the registers will be kept till a power loss...*/
-int sapphire_sysdev_resume(struct sys_device *dev)
-{
-	/*restore the working mask saved before sleep*/
-	writeb(sapphire_int_mask[0], SAPPHIRE_CPLD_BASE +
-					SAPPHIRE_GPIO_INT_B0_MASK_REG);
-	sapphire_suspended = 0;
-	return 0;
-}
-
-/**
- * linux/irq.h :: struct irq_chip
- * @enable:		enable the interrupt (defaults to chip->unmask if NULL)
- * @disable:	disable the interrupt (defaults to chip->mask if NULL)
- * @ack:		start of a new interrupt
- * @mask:		mask an interrupt source
- * @mask_ack:		ack and mask an interrupt source
- * @unmask:		unmask an interrupt source
- */
-static struct irq_chip sapphire_gpio_irq_chip = {
-	.name      = "sapphiregpio",
-	.ack       = sapphire_gpio_irq_ack,
-	.mask      = sapphire_gpio_irq_disable,	/*sapphire_gpio_irq_mask,*/
-	.unmask    = sapphire_gpio_irq_enable,	/*sapphire_gpio_irq_unmask,*/
-	.set_wake  = sapphire_gpio_irq_set_wake,
-	/*.set_type  = sapphire_gpio_irq_set_type,*/
-};
-
-/*Thomas:For CPLD*/
-static struct gpio_chip sapphire_gpio_chip = {
-	.start = SAPPHIRE_GPIO_START,
-	.end = SAPPHIRE_GPIO_END,
-	.configure = sapphire_gpio_configure,
-	.get_irq_num = sapphire_gpio_get_irq_num,
-	.read = sapphire_gpio_read,
-	.write = sapphire_gpio_write,
-/*	.read_detect_status = sapphire_gpio_read_detect_status,
-	.clear_detect_status = sapphire_gpio_clear_detect_status */
-};
-
-struct sysdev_class sapphire_sysdev_class = {
-	.name = "sapphiregpio_irq",
-	.suspend = sapphire_sysdev_suspend,
-	.resume = sapphire_sysdev_resume,
-};
-
-static struct sys_device sapphire_irq_device = {
-	.cls    = &sapphire_sysdev_class,
-};
-
-/*Farmer:For H2W power*/
-static struct vreg *vreg_h2w;
-static int h2w_power_configure(struct gpio_chip *chip,
-			       unsigned int gpio,
-			       unsigned long flags)
-{
-	if ((flags & GPIOF_DRIVE_OUTPUT) && !vreg_h2w)
-		vreg_h2w = vreg_get(0, SAPPHIRE_H2W_POWER_NAME);
-
-	if ((flags & GPIOF_OUTPUT_HIGH) && vreg_h2w) {
-		vreg_enable(vreg_h2w);
-		vreg_set_level(vreg_h2w, 3000);
-	}
-	else if ((flags & GPIOF_OUTPUT_LOW) && vreg_h2w)
-		vreg_disable(vreg_h2w);
-
-	return 0;
-}
-
-static int h2w_power_get_irq_num(struct gpio_chip *chip,
-				 unsigned int gpio,
-				 unsigned int *irqp,
-				 unsigned long *irqnumflagsp)
-{
-	return -1;
-}
-
-static int h2w_power_read(struct gpio_chip *chip, unsigned n)
-{
-	return -1;
-}
-static int h2w_power_write(struct gpio_chip *chip, unsigned n, unsigned on)
-{
-	if (!vreg_h2w)
-		return -1;
-
-	if (on) {
-		vreg_enable(vreg_h2w);
-		vreg_set_level(vreg_h2w, 3000);
-	}
-	else
-		vreg_disable(vreg_h2w);
-	return 0;
-}
-
-static struct gpio_chip sapphire_h2w_gpio_chip = {
-	.start = SAPPHIRE_GPIO_H2W_POWER,
-	.end = SAPPHIRE_GPIO_H2W_POWER,
-	.configure = h2w_power_configure,
-	.get_irq_num = h2w_power_get_irq_num,
-	.read = h2w_power_read,
-	.write = h2w_power_write,
-};
-
-int sapphire_init_gpio(void)
-{
-	int i;
-	if (!machine_is_sapphire())
-		return 0;
-
-	DBG("%d,%d\r\n", SAPPHIRE_INT_START, SAPPHIRE_INT_END);
-	DBG("NR_MSM_IRQS=%d, NR_GPIO_IRQS=%d\r\n", NR_MSM_IRQS, NR_GPIO_IRQS);
-	for (i = SAPPHIRE_INT_START; i <= SAPPHIRE_INT_END; i++) {
-		set_irq_chip(i, &sapphire_gpio_irq_chip);
-		set_irq_handler(i, handle_edge_irq);
-		set_irq_flags(i, IRQF_VALID);
-	}
-
-	register_gpio_chip(&sapphire_gpio_chip);
-	register_gpio_chip(&sapphire_h2w_gpio_chip);
-
-	/*setup CPLD INT connecting to SOC's gpio 17 */
-	set_irq_type(MSM_GPIO_TO_INT(17), IRQF_TRIGGER_HIGH);
-	set_irq_chained_handler(MSM_GPIO_TO_INT(17), sapphire_gpio_irq_handler);
-	set_irq_wake(MSM_GPIO_TO_INT(17), 1);
-
-	if (sysdev_class_register(&sapphire_sysdev_class) == 0)
-		sysdev_register(&sapphire_irq_device);
-
-	return 0;
-}
-
-int sapphire_init_cpld(unsigned int sys_rev)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(sapphire_cpld_initdata); i++)
-		writeb(sapphire_cpld_initdata[i], SAPPHIRE_CPLD_BASE + i * 2);
-	return 0;
-}
-
-postcore_initcall(sapphire_init_gpio);
diff --git a/arch/arm/mach-msm/board-sapphire-h2w.c b/arch/arm/mach-msm/board-sapphire-h2w.c
deleted file mode 100644
index aa83e21..0000000
--- a/arch/arm/mach-msm/board-sapphire-h2w.c
+++ /dev/null
@@ -1,545 +0,0 @@
-/*
- *  H2W device detection driver.
- *
- * Copyright (C) 2008 HTC Corporation.
- * Copyright (C) 2008 Google, Inc.
- *
- * Authors:
- *  Laurence Chen <Laurence_Chen@htc.com>
- *  Nick Pelly <npelly@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/*  For detecting HTC 2 Wire devices, such as wired headset.
-
-    Logically, the H2W driver is always present, and H2W state (hi->state)
-    indicates what is currently plugged into the H2W interface.
-
-    When the headset is plugged in, CABLE_IN1 is pulled low. When the headset
-    button is pressed, CABLE_IN2 is pulled low. These two lines are shared with
-    the TX and RX (respectively) of UART3 - used for serial debugging.
-
-    This headset driver keeps the CPLD configured as UART3 for as long as
-    possible, so that we can do serial FIQ debugging even when the kernel is
-    locked and this driver no longer runs. So it only configures the CPLD to
-    GPIO while the headset is plugged in, and for 10ms during detection work.
-
-    Unfortunately we can't leave the CPLD as UART3 while a headset is plugged
-    in, UART3 is pullup on TX but the headset is pull-down, causing a 55 mA
-    drain on sapphire.
-
-    The headset detection work involves setting CPLD to GPIO, and then pulling
-    CABLE_IN1 high with a stronger pullup than usual. A H2W headset will still
-    pull this line low, whereas other attachments such as a serial console
-    would get pulled up by this stronger pullup.
-
-    Headset insertion/removal causes UEvent's to be sent, and
-    /sys/class/switch/h2w/state to be updated.
-
-    Button presses are interpreted as input event (KEY_MEDIA). Button presses
-    are ignored if the headset is plugged in, so the buttons on 11 pin -> 3.5mm
-    jack adapters do not work until a headset is plugged into the adapter. This
-    is to avoid serial RX traffic causing spurious button press events.
-
-    We tend to check the status of CABLE_IN1 a few more times than strictly
-    necessary during headset detection, to avoid spurious headset insertion
-    events caused by serial debugger TX traffic.
-*/
-
-
-#include <linux/module.h>
-#include <linux/sysdev.h>
-#include <linux/fs.h>
-#include <linux/interrupt.h>
-#include <linux/workqueue.h>
-#include <linux/irq.h>
-#include <linux/delay.h>
-#include <linux/types.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/errno.h>
-#include <linux/err.h>
-#include <linux/hrtimer.h>
-#include <linux/switch.h>
-#include <linux/input.h>
-#include <linux/debugfs.h>
-#include <linux/gpio.h>
-#include <asm/atomic.h>
-#include <mach/board.h>
-#include <mach/vreg.h>
-#include <asm/mach-types.h>
-#include "board-sapphire.h"
-
-#ifdef CONFIG_DEBUG_SAPPHIRE_H2W
-#define H2W_DBG(fmt, arg...) printk(KERN_INFO "[H2W] %s " fmt "\n", __FUNCTION__, ## arg)
-#else
-#define H2W_DBG(fmt, arg...) do {} while (0)
-#endif
-
-static struct workqueue_struct *g_detection_work_queue;
-static void detection_work(struct work_struct *work);
-static DECLARE_WORK(g_detection_work, detection_work);
-enum {
-	NO_DEVICE	= 0,
-	HTC_HEADSET	= 1,
-};
-
-enum {
-	UART3		= 0,
-	GPIO		= 1,
-};
-
-struct h2w_info {
-	struct switch_dev sdev;
-	struct input_dev *input;
-
-	atomic_t btn_state;
-	int ignore_btn;
-
-	unsigned int irq;
-	unsigned int irq_btn;
-
-	struct hrtimer timer;
-	ktime_t debounce_time;
-
-	struct hrtimer btn_timer;
-	ktime_t btn_debounce_time;
-};
-static struct h2w_info *hi;
-
-static ssize_t sapphire_h2w_print_name(struct switch_dev *sdev, char *buf)
-{
-	switch (switch_get_state(&hi->sdev)) {
-	case NO_DEVICE:
-		return sprintf(buf, "No Device\n");
-	case HTC_HEADSET:
-		return sprintf(buf, "Headset\n");
-	}
-	return -EINVAL;
-}
-
-static void configure_cpld(int route)
-{
-	H2W_DBG(" route = %s", route == UART3 ? "UART3" : "GPIO");
-	switch (route) {
-	case UART3:
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL0, 0);
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL1, 1);
-		break;
-	case GPIO:
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL0, 0);
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL1, 0);
-		break;
-	}
-}
-
-static void button_pressed(void)
-{
-	H2W_DBG("");
-	atomic_set(&hi->btn_state, 1);
-	input_report_key(hi->input, KEY_MEDIA, 1);
-	input_sync(hi->input);
-}
-
-static void button_released(void)
-{
-	H2W_DBG("");
-	atomic_set(&hi->btn_state, 0);
-	input_report_key(hi->input, KEY_MEDIA, 0);
-	input_sync(hi->input);
-}
-
-#ifdef CONFIG_MSM_SERIAL_DEBUGGER
-extern void msm_serial_debug_enable(int);
-#endif
-
-static void insert_headset(void)
-{
-	unsigned long irq_flags;
-
-	H2W_DBG("");
-
-	switch_set_state(&hi->sdev, HTC_HEADSET);
-	configure_cpld(GPIO);
-
-#ifdef CONFIG_MSM_SERIAL_DEBUGGER
-	msm_serial_debug_enable(false);
-#endif
-
-
-	/* On some non-standard headset adapters (usually those without a
-	 * button) the btn line is pulled down at the same time as the detect
-	 * line. We can check here by sampling the button line, if it is
-	 * low then it is probably a bad adapter so ignore the button.
-	 * If the button is released then we stop ignoring the button, so that
-	 * the user can recover from the situation where a headset is plugged
-	 * in with button held down.
-	 */
-	hi->ignore_btn = !gpio_get_value(SAPPHIRE_GPIO_CABLE_IN2);
-
-	/* Enable button irq */
-	local_irq_save(irq_flags);
-	enable_irq(hi->irq_btn);
-	local_irq_restore(irq_flags);
-
-	hi->debounce_time = ktime_set(0, 20000000);  /* 20 ms */
-}
-
-static void remove_headset(void)
-{
-	unsigned long irq_flags;
-
-	H2W_DBG("");
-
-	switch_set_state(&hi->sdev, NO_DEVICE);
-	configure_cpld(UART3);
-
-	/* Disable button */
-	local_irq_save(irq_flags);
-	disable_irq(hi->irq_btn);
-	local_irq_restore(irq_flags);
-
-	if (atomic_read(&hi->btn_state))
-		button_released();
-
-	hi->debounce_time = ktime_set(0, 100000000);  /* 100 ms */
-}
-
-static void detection_work(struct work_struct *work)
-{
-	unsigned long irq_flags;
-	int clk, cable_in1;
-
-	H2W_DBG("");
-
-	if (gpio_get_value(SAPPHIRE_GPIO_CABLE_IN1) != 0) {
-		/* Headset not plugged in */
-		if (switch_get_state(&hi->sdev) == HTC_HEADSET)
-			remove_headset();
-		return;
-	}
-
-	/* Something plugged in, lets make sure its a headset */
-
-	/* Switch CPLD to GPIO to do detection */
-	configure_cpld(GPIO);
-	/* Disable headset interrupt while detecting.*/
-	local_irq_save(irq_flags);
-	disable_irq(hi->irq);
-	local_irq_restore(irq_flags);
-
-	/* Set GPIO_CABLE_IN1 as output high */
-	gpio_direction_output(SAPPHIRE_GPIO_CABLE_IN1, 1);
-	/* Delay 10ms for pin stable. */
-	msleep(10);
-	/* Save H2W_CLK */
-	clk = gpio_get_value(SAPPHIRE_GPIO_H2W_CLK_GPI);
-	/* Set GPIO_CABLE_IN1 as input */
-	gpio_direction_input(SAPPHIRE_GPIO_CABLE_IN1);
-
-	/* Restore IRQs */
-	local_irq_save(irq_flags);
-	enable_irq(hi->irq);
-	local_irq_restore(irq_flags);
-
-	cable_in1 = gpio_get_value(SAPPHIRE_GPIO_CABLE_IN1);
-
-	if (cable_in1 == 0 && clk == 0) {
-		if (switch_get_state(&hi->sdev) == NO_DEVICE)
-			insert_headset();
-	} else {
-		configure_cpld(UART3);
-		H2W_DBG("CABLE_IN1 was low, but not a headset "
-			"(recent cable_in1 = %d, clk = %d)", cable_in1, clk);
-	}
-}
-
-static enum hrtimer_restart button_event_timer_func(struct hrtimer *data)
-{
-	H2W_DBG("");
-
-	if (switch_get_state(&hi->sdev) == HTC_HEADSET) {
-		if (gpio_get_value(SAPPHIRE_GPIO_CABLE_IN2)) {
-			if (hi->ignore_btn)
-				hi->ignore_btn = 0;
-			else if (atomic_read(&hi->btn_state))
-				button_released();
-		} else {
-			if (!hi->ignore_btn && !atomic_read(&hi->btn_state))
-				button_pressed();
-		}
-	}
-
-	return HRTIMER_NORESTART;
-}
-
-static enum hrtimer_restart detect_event_timer_func(struct hrtimer *data)
-{
-	H2W_DBG("");
-
-	queue_work(g_detection_work_queue, &g_detection_work);
-	return HRTIMER_NORESTART;
-}
-
-static irqreturn_t detect_irq_handler(int irq, void *dev_id)
-{
-	int value1, value2;
-	int retry_limit = 10;
-
-	H2W_DBG("");
-	do {
-		value1 = gpio_get_value(SAPPHIRE_GPIO_CABLE_IN1);
-		set_irq_type(hi->irq, value1 ?
-				IRQF_TRIGGER_LOW : IRQF_TRIGGER_HIGH);
-		value2 = gpio_get_value(SAPPHIRE_GPIO_CABLE_IN1);
-	} while (value1 != value2 && retry_limit-- > 0);
-
-	H2W_DBG("value2 = %d (%d retries)", value2, (10-retry_limit));
-
-	if ((switch_get_state(&hi->sdev) == NO_DEVICE) ^ value2) {
-		if (switch_get_state(&hi->sdev) == HTC_HEADSET)
-			hi->ignore_btn = 1;
-		/* Do the rest of the work in timer context */
-		hrtimer_start(&hi->timer, hi->debounce_time, HRTIMER_MODE_REL);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t button_irq_handler(int irq, void *dev_id)
-{
-	int value1, value2;
-	int retry_limit = 10;
-
-	H2W_DBG("");
-	do {
-		value1 = gpio_get_value(SAPPHIRE_GPIO_CABLE_IN2);
-		set_irq_type(hi->irq_btn, value1 ?
-				IRQF_TRIGGER_LOW : IRQF_TRIGGER_HIGH);
-		value2 = gpio_get_value(SAPPHIRE_GPIO_CABLE_IN2);
-	} while (value1 != value2 && retry_limit-- > 0);
-
-	H2W_DBG("value2 = %d (%d retries)", value2, (10-retry_limit));
-
-	hrtimer_start(&hi->btn_timer, hi->btn_debounce_time, HRTIMER_MODE_REL);
-
-	return IRQ_HANDLED;
-}
-
-#if defined(CONFIG_DEBUG_FS)
-static void h2w_debug_set(void *data, u64 val)
-{
-	switch_set_state(&hi->sdev, (int)val);
-}
-
-static u64 h2w_debug_get(void *data)
-{
-	return 0;
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(h2w_debug_fops, h2w_debug_get, h2w_debug_set, "%llu\n");
-static int __init h2w_debug_init(void)
-{
-	struct dentry *dent;
-
-	dent = debugfs_create_dir("h2w", 0);
-	if (IS_ERR(dent))
-		return PTR_ERR(dent);
-
-	debugfs_create_file("state", 0644, dent, NULL, &h2w_debug_fops);
-
-	return 0;
-}
-
-device_initcall(h2w_debug_init);
-#endif
-
-static int sapphire_h2w_probe(struct platform_device *pdev)
-{
-	int ret;
-	unsigned long irq_flags;
-
-	printk(KERN_INFO "H2W: Registering H2W (headset) driver\n");
-	hi = kzalloc(sizeof(struct h2w_info), GFP_KERNEL);
-	if (!hi)
-		return -ENOMEM;
-
-	atomic_set(&hi->btn_state, 0);
-	hi->ignore_btn = 0;
-
-	hi->debounce_time = ktime_set(0, 100000000);  /* 100 ms */
-	hi->btn_debounce_time = ktime_set(0, 10000000); /* 10 ms */
-	hi->sdev.name = "h2w";
-	hi->sdev.print_name = sapphire_h2w_print_name;
-
-	ret = switch_dev_register(&hi->sdev);
-	if (ret < 0)
-		goto err_switch_dev_register;
-
-	g_detection_work_queue = create_workqueue("detection");
-	if (g_detection_work_queue == NULL) {
-		ret = -ENOMEM;
-		goto err_create_work_queue;
-	}
-
-	ret = gpio_request(SAPPHIRE_GPIO_CABLE_IN1, "h2w_detect");
-	if (ret < 0)
-		goto err_request_detect_gpio;
-
-	ret = gpio_request(SAPPHIRE_GPIO_CABLE_IN2, "h2w_button");
-	if (ret < 0)
-		goto err_request_button_gpio;
-
-	ret = gpio_direction_input(SAPPHIRE_GPIO_CABLE_IN1);
-	if (ret < 0)
-		goto err_set_detect_gpio;
-
-	ret = gpio_direction_input(SAPPHIRE_GPIO_CABLE_IN2);
-	if (ret < 0)
-		goto err_set_button_gpio;
-
-	hi->irq = gpio_to_irq(SAPPHIRE_GPIO_CABLE_IN1);
-	if (hi->irq < 0) {
-		ret = hi->irq;
-		goto err_get_h2w_detect_irq_num_failed;
-	}
-
-	hi->irq_btn = gpio_to_irq(SAPPHIRE_GPIO_CABLE_IN2);
-	if (hi->irq_btn < 0) {
-		ret = hi->irq_btn;
-		goto err_get_button_irq_num_failed;
-	}
-
-	/* Set CPLD MUX to H2W <-> CPLD GPIO */
-	configure_cpld(UART3);
-	/* Set the CPLD connected H2W GPIO's to input */
-	gpio_set_value(SAPPHIRE_GPIO_H2W_CLK_DIR, 0);
-	gpio_set_value(SAPPHIRE_GPIO_H2W_DAT_DIR, 0);
-
-	hrtimer_init(&hi->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	hi->timer.function = detect_event_timer_func;
-	hrtimer_init(&hi->btn_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	hi->btn_timer.function = button_event_timer_func;
-
-	ret = request_irq(hi->irq, detect_irq_handler,
-			  IRQF_TRIGGER_LOW, "h2w_detect", NULL);
-	if (ret < 0)
-		goto err_request_detect_irq;
-
-	/* Disable button until plugged in */
-	set_irq_flags(hi->irq_btn, IRQF_VALID | IRQF_NOAUTOEN);
-	ret = request_irq(hi->irq_btn, button_irq_handler,
-			  IRQF_TRIGGER_LOW, "h2w_button", NULL);
-	if (ret < 0)
-		goto err_request_h2w_headset_button_irq;
-
-	ret = set_irq_wake(hi->irq, 1);
-	if (ret < 0)
-		goto err_request_input_dev;
-	ret = set_irq_wake(hi->irq_btn, 1);
-	if (ret < 0)
-		goto err_request_input_dev;
-
-	hi->input = input_allocate_device();
-	if (!hi->input) {
-		ret = -ENOMEM;
-		goto err_request_input_dev;
-	}
-
-	hi->input->name = "h2w headset";
-	hi->input->evbit[0] = BIT_MASK(EV_KEY);
-	hi->input->keybit[BIT_WORD(KEY_MEDIA)] = BIT_MASK(KEY_MEDIA);
-
-	ret = input_register_device(hi->input);
-	if (ret < 0)
-		goto err_register_input_dev;
-
-	return 0;
-
-err_register_input_dev:
-	input_free_device(hi->input);
-err_request_input_dev:
-	free_irq(hi->irq_btn, 0);
-err_request_h2w_headset_button_irq:
-	free_irq(hi->irq, 0);
-err_request_detect_irq:
-err_get_button_irq_num_failed:
-err_get_h2w_detect_irq_num_failed:
-err_set_button_gpio:
-err_set_detect_gpio:
-	gpio_free(SAPPHIRE_GPIO_CABLE_IN2);
-err_request_button_gpio:
-	gpio_free(SAPPHIRE_GPIO_CABLE_IN1);
-err_request_detect_gpio:
-	destroy_workqueue(g_detection_work_queue);
-err_create_work_queue:
-	switch_dev_unregister(&hi->sdev);
-err_switch_dev_register:
-	printk(KERN_ERR "H2W: Failed to register driver\n");
-
-	return ret;
-}
-
-static int sapphire_h2w_remove(struct platform_device *pdev)
-{
-	H2W_DBG("");
-	if (switch_get_state(&hi->sdev))
-		remove_headset();
-	input_unregister_device(hi->input);
-	gpio_free(SAPPHIRE_GPIO_CABLE_IN2);
-	gpio_free(SAPPHIRE_GPIO_CABLE_IN1);
-	free_irq(hi->irq_btn, 0);
-	free_irq(hi->irq, 0);
-	destroy_workqueue(g_detection_work_queue);
-	switch_dev_unregister(&hi->sdev);
-
-	return 0;
-}
-
-static struct platform_device sapphire_h2w_device = {
-	.name		= "sapphire-h2w",
-};
-
-static struct platform_driver sapphire_h2w_driver = {
-	.probe		= sapphire_h2w_probe,
-	.remove		= sapphire_h2w_remove,
-	.driver		= {
-		.name		= "sapphire-h2w",
-		.owner		= THIS_MODULE,
-	},
-};
-
-static int __init sapphire_h2w_init(void)
-{
-	if (!machine_is_sapphire())
-		return 0;
-	int ret;
-	H2W_DBG("");
-	ret = platform_driver_register(&sapphire_h2w_driver);
-	if (ret)
-		return ret;
-	return platform_device_register(&sapphire_h2w_device);
-}
-
-static void __exit sapphire_h2w_exit(void)
-{
-	platform_device_unregister(&sapphire_h2w_device);
-	platform_driver_unregister(&sapphire_h2w_driver);
-}
-
-module_init(sapphire_h2w_init);
-module_exit(sapphire_h2w_exit);
-
-MODULE_AUTHOR("Laurence Chen <Laurence_Chen@htc.com>");
-MODULE_DESCRIPTION("HTC 2 Wire detection driver for sapphire");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-sapphire-keypad.c b/arch/arm/mach-msm/board-sapphire-keypad.c
deleted file mode 100644
index 320874f..0000000
--- a/arch/arm/mach-msm/board-sapphire-keypad.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/* arch/arm/mach-msm/board-sapphire-keypad.c
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Thomas Tsai <thomas_tsai@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <asm/mach-types.h>
-#include "gpio_chip.h"
-#include "board-sapphire.h"
-static char *keycaps = "--qwerty";
-#undef MODULE_PARAM_PREFIX
-#define MODULE_PARAM_PREFIX "board_sapphire."
-module_param_named(keycaps, keycaps, charp, 0);
-
-
-static unsigned int sapphire_col_gpios[] = { 35, 34 };
-
-/* KP_MKIN2 (GPIO40) is not used? */
-static unsigned int sapphire_row_gpios[] = { 42, 41 };
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(sapphire_row_gpios) + (row))
-
-/*scan matrix key*/
-/* HOME(up) + MENU (down)*/
-static const unsigned short sapphire_keymap1[ARRAY_SIZE(sapphire_col_gpios) * ARRAY_SIZE(sapphire_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_BACK,
-	[KEYMAP_INDEX(0, 1)] = KEY_HOME,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(1, 1)] = KEY_SEND,
-};
-
-/* MENU(up) + HOME (down)*/
-static const unsigned short sapphire_keymap0[ARRAY_SIZE(sapphire_col_gpios) * ARRAY_SIZE(sapphire_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_BACK,
-	[KEYMAP_INDEX(0, 1)] = KEY_MENU,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_HOME,
-	[KEYMAP_INDEX(1, 1)] = KEY_SEND,
-};
-
-static const unsigned short sapphire_keymap2[ARRAY_SIZE(sapphire_col_gpios) * ARRAY_SIZE(sapphire_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_COMPOSE,
-	[KEYMAP_INDEX(0, 1)] = KEY_BACK,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(1, 1)] = KEY_SEND,
-};
-
-static struct gpio_event_matrix_info sapphire_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = sapphire_keymap2,
-	.output_gpios = sapphire_col_gpios,
-	.input_gpios = sapphire_row_gpios,
-	.noutputs = ARRAY_SIZE(sapphire_col_gpios),
-	.ninputs = ARRAY_SIZE(sapphire_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.debounce_delay.tv.nsec = 50 * NSEC_PER_MSEC,
-	.flags = GPIOKPF_LEVEL_TRIGGERED_IRQ |
-		 GPIOKPF_REMOVE_PHANTOM_KEYS |
-		 GPIOKPF_PRINT_UNMAPPED_KEYS /*| GPIOKPF_PRINT_MAPPED_KEYS*/
-};
-
-static struct gpio_event_direct_entry sapphire_keypad_nav_map[] = {
-	{ SAPPHIRE_POWER_KEY,              KEY_END        },
-	{ SAPPHIRE_VOLUME_UP,              KEY_VOLUMEUP   },
-	{ SAPPHIRE_VOLUME_DOWN,            KEY_VOLUMEDOWN },
-};
-
-static struct gpio_event_input_info sapphire_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.flags = 0,
-	.type = EV_KEY,
-	.keymap = sapphire_keypad_nav_map,
-	.debounce_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.keymap_size = ARRAY_SIZE(sapphire_keypad_nav_map)
-};
-
-static struct gpio_event_info *sapphire_keypad_info[] = {
-	&sapphire_keypad_matrix_info.info,
-	&sapphire_keypad_nav_info.info,
-};
-
-static struct gpio_event_platform_data sapphire_keypad_data = {
-	.name = "sapphire-keypad",
-	.info = sapphire_keypad_info,
-	.info_count = ARRAY_SIZE(sapphire_keypad_info)
-};
-
-static struct platform_device sapphire_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &sapphire_keypad_data,
-	},
-};
-
-static int __init sapphire_init_keypad(void)
-{
-	if (!machine_is_sapphire())
-		return 0;
-
-
-		if(!sapphire_get_hwid())/* hwid == 0, MENU key is up */
-			sapphire_keypad_matrix_info.keymap = sapphire_keymap1;
-		else /* hwid == 1 */
-			if( (sapphire_get_skuid() != 0x22800) &&
-				(system_rev != 0x80) &&
-				(sapphire_get_skuid() != 0x1E303) &&
-				(sapphire_get_skuid() != 0x1FF01) &&
-				((sapphire_get_skuid() & 0xFFFFFF00) != 0x00021400))
-				sapphire_keypad_matrix_info.keymap = sapphire_keymap0;
-	return platform_device_register(&sapphire_keypad_device);
-}
-
-device_initcall(sapphire_init_keypad);
-
diff --git a/arch/arm/mach-msm/board-sapphire-mmc.c b/arch/arm/mach-msm/board-sapphire-mmc.c
deleted file mode 100644
index d0c81f9..0000000
--- a/arch/arm/mach-msm/board-sapphire-mmc.c
+++ /dev/null
@@ -1,469 +0,0 @@
-/* linux/arch/arm/mach-msm/board-sapphire-mmc.c
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Thomas Tsai <thomas_tsai@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <asm/mach-types.h>
-
-#include <mach/vreg.h>
-#include <mach/htc_pwrsink.h>
-
-#include <asm/mach/mmc.h>
-
-#include "devices.h"
-#include "gpio_chip.h"
-#include "board-sapphire.h"
-#include "proc_comm.h"
-
-#define DEBUG_SDSLOT_VDD 0
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- SDCARD ---- */
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init sapphire_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_sapphire.disable_sdcard=", sapphire_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_27_28,	2800 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t sapphire_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i, rc;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_DEBUG "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		msleep(5);
-		rc = vreg_enable(vreg_sdslot);
-		if (rc) {
-			printk(KERN_ERR "%s: Error enabling vreg (%d)\n",
-			       __func__, rc);
-		}
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-#if DEBUG_SDSLOT_VDD
-			printk(KERN_DEBUG "%s: Setting level to %u\n",
-				__func__, mmc_vdd_table[i].level);
-#endif
-			rc = vreg_set_level(vreg_sdslot,
-					    mmc_vdd_table[i].level);
-			if (rc) {
-				printk(KERN_ERR
-				       "%s: Error setting vreg level (%d)\n",
-				       __func__, rc);
-			}
-			return 0;
-		}
-	}
-
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int sapphire_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(SAPPHIRE_GPIO_SDMC_CD_N);
-	return !status;
-}
-
-#define SAPPHIRE_MMC_VDD	MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
-
-static struct mmc_platform_data sapphire_sdslot_data = {
-	.ocr_mask	= SAPPHIRE_MMC_VDD,
-	.status_irq	= SAPPHIRE_GPIO_TO_INT(SAPPHIRE_GPIO_SDMC_CD_N),
-	.status		= sapphire_sdslot_status,
-	.translate_vdd	= sapphire_sdslot_switchvdd,
-};
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static struct vreg *vreg_wifi_osc;	/* WIFI 32khz oscilator */
-static int sapphire_wifi_cd = 0;	/* WIFI virtual 'card detect' status */
-
-static struct sdio_embedded_func wifi_func = {
-	.f_class	= SDIO_CLASS_WLAN,
-	.f_maxblksize	= 512,
-};
-
-static struct embedded_sdio_data sapphire_wifi_emb_data = {
-	.cis	= {
-		.vendor		= 0x104c,
-		.device		= 0x9066,
-		.blksize	= 512,
-		/*.max_dtr	= 24000000,  Max of chip - no worky on Sapphire */
-		.max_dtr	= 20000000,
-	},
-	.cccr	= {
-		.multi_block	= 0,
-		.low_speed	= 0,
-		.wide_bus	= 1,
-		.high_power	= 0,
-		.high_speed	= 0,
-	},
-	.funcs	= &wifi_func,
-	.num_funcs = 1,
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int sapphire_wifi_status_register(void (*callback)(int card_present,
-							  void *dev_id),
-					 void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int sapphire_wifi_status(struct device *dev)
-{
-	return sapphire_wifi_cd;
-}
-
-static struct mmc_platform_data sapphire_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= sapphire_wifi_status,
-	.register_status_notify	= sapphire_wifi_status_register,
-	.embedded_sdio		= &sapphire_wifi_emb_data,
-};
-
-int sapphire_wifi_set_carddetect(int val)
-{
-	printk(KERN_DEBUG "%s: %d\n", __func__, val);
-	sapphire_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-#ifndef CONFIG_WIFI_CONTROL_FUNC
-EXPORT_SYMBOL(sapphire_wifi_set_carddetect);
-#endif
-
-int sapphire_wifi_power_state=0;
-int sapphire_bt_power_state=0;
-
-int sapphire_wifi_power(int on)
-{
-	int rc;
-
-	printk(KERN_DEBUG "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		rc = vreg_enable(vreg_wifi_osc);
-		if (rc)
-			return rc;
-		htc_pwrsink_set(PWRSINK_WIFI, 70);
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-		htc_pwrsink_set(PWRSINK_WIFI, 0);
-	}
-	gpio_set_value(SAPPHIRE_GPIO_MAC_32K_EN, on);
-	mdelay(100);
-	gpio_set_value(SAPPHIRE_GPIO_WIFI_EN, on);
-	mdelay(100);
-	if (!on) {
-		if(!sapphire_bt_power_state)
-		{
-		vreg_disable(vreg_wifi_osc);
-			printk("WiFi disable vreg_wifi_osc.\n");
-		}
-		else
-			printk("WiFi shouldn't disable vreg_wifi_osc. BT is using it!!\n");
-	}
-	sapphire_wifi_power_state = on;
-	return 0;
-}
-#ifndef CONFIG_WIFI_CONTROL_FUNC
-EXPORT_SYMBOL(sapphire_wifi_power);
-#endif
-
-/* Eenable VREG_MMC pin to turn on fastclock oscillator : colin */
-int sapphire_bt_fastclock_power(int on)
-{
-	int rc;
-
-	printk(KERN_DEBUG "sapphire_bt_fastclock_power on = %d\n", on);
-	if (vreg_wifi_osc) {
-		if (on) {
-			rc = vreg_enable(vreg_wifi_osc);
-			printk(KERN_DEBUG "BT vreg_enable vreg_mmc, rc=%d\n",
-			       rc);
-			if (rc) {
-				printk("Error turn sapphire_bt_fastclock_power rc=%d\n", rc);
-				return rc;
-			}
-		} else {
-			if (!sapphire_wifi_power_state) {
-				vreg_disable(vreg_wifi_osc);
-				printk(KERN_DEBUG "BT disable vreg_wifi_osc.\n");
-			} else
-				printk(KERN_DEBUG "BT shouldn't disable vreg_wifi_osc. WiFi is using it!!\n");
-		}
-	}
-	sapphire_bt_power_state = on;
-	return 0;
-}
-EXPORT_SYMBOL(sapphire_bt_fastclock_power);
-
-static int sapphire_wifi_reset_state;
-void sapphire_wifi_reset(int on)
-{
-	printk(KERN_DEBUG "%s: %d\n", __func__, on);
-	gpio_set_value(SAPPHIRE_GPIO_WIFI_PA_RESETX, !on);
-	sapphire_wifi_reset_state = on;
-	mdelay(50);
-}
-#ifndef CONFIG_WIFI_CONTROL_FUNC
-EXPORT_SYMBOL(sapphire_wifi_reset);
-#endif
-
-
-int __init sapphire_init_mmc(unsigned int sys_rev)
-{
-	wifi_status_cb = NULL;
-
-	sdslot_vreg_enabled = 0;
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-	vreg_wifi_osc = vreg_get(0, "mmc");
-	if (IS_ERR(vreg_wifi_osc))
-		return PTR_ERR(vreg_wifi_osc);
-
-	set_irq_wake(SAPPHIRE_GPIO_TO_INT(SAPPHIRE_GPIO_SDMC_CD_N), 1);
-
-	msm_add_sdcc(1, &sapphire_wifi_data, 0, 0);
-
-	if (!opt_disable_sdcard)
-		msm_add_sdcc(2, &sapphire_sdslot_data,
-			     SAPPHIRE_GPIO_TO_INT(SAPPHIRE_GPIO_SDMC_CD_N), 0);
-	else
-		printk(KERN_INFO "sapphire: SD-Card interface disabled\n");
-	return 0;
-}
-
-#if defined(CONFIG_DEBUG_FS)
-static int sapphiremmc_dbg_wifi_reset_set(void *data, u64 val)
-{
-	sapphire_wifi_reset((int) val);
-	return 0;
-}
-
-static int sapphiremmc_dbg_wifi_reset_get(void *data, u64 *val)
-{
-	*val = sapphire_wifi_reset_state;
-	return 0;
-}
-
-static int sapphiremmc_dbg_wifi_cd_set(void *data, u64 val)
-{
-	sapphire_wifi_set_carddetect((int) val);
-	return 0;
-}
-
-static int sapphiremmc_dbg_wifi_cd_get(void *data, u64 *val)
-{
-	*val = sapphire_wifi_cd;
-	return 0;
-}
-
-static int sapphiremmc_dbg_wifi_pwr_set(void *data, u64 val)
-{
-	sapphire_wifi_power((int) val);
-	return 0;
-}
-
-static int sapphiremmc_dbg_wifi_pwr_get(void *data, u64 *val)
-{
-
-	*val = sapphire_wifi_power_state;
-	return 0;
-}
-
-static int sapphiremmc_dbg_sd_pwr_set(void *data, u64 val)
-{
-	sapphire_sdslot_switchvdd(NULL, (unsigned int) val);
-	return 0;
-}
-
-static int sapphiremmc_dbg_sd_pwr_get(void *data, u64 *val)
-{
-	*val = sdslot_vdd;
-	return 0;
-}
-
-static int sapphiremmc_dbg_sd_cd_set(void *data, u64 val)
-{
-	return -ENOSYS;
-}
-
-static int sapphiremmc_dbg_sd_cd_get(void *data, u64 *val)
-{
-	*val = sapphire_sdslot_status(NULL);
-	return 0;
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(sapphiremmc_dbg_wifi_reset_fops,
-			sapphiremmc_dbg_wifi_reset_get,
-			sapphiremmc_dbg_wifi_reset_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(sapphiremmc_dbg_wifi_cd_fops,
-			sapphiremmc_dbg_wifi_cd_get,
-			sapphiremmc_dbg_wifi_cd_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(sapphiremmc_dbg_wifi_pwr_fops,
-			sapphiremmc_dbg_wifi_pwr_get,
-			sapphiremmc_dbg_wifi_pwr_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(sapphiremmc_dbg_sd_pwr_fops,
-			sapphiremmc_dbg_sd_pwr_get,
-			sapphiremmc_dbg_sd_pwr_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(sapphiremmc_dbg_sd_cd_fops,
-			sapphiremmc_dbg_sd_cd_get,
-			sapphiremmc_dbg_sd_cd_set, "%llu\n");
-
-static int __init sapphiremmc_dbg_init(void)
-{
-	struct dentry *dent;
-
-	if (!machine_is_sapphire())
-		return 0;
-
-	dent = debugfs_create_dir("sapphiremmc_dbg", 0);
-	if (IS_ERR(dent))
-		return PTR_ERR(dent);
-
-	debugfs_create_file("wifi_reset", 0644, dent, NULL,
-			    &sapphiremmc_dbg_wifi_reset_fops);
-	debugfs_create_file("wifi_cd", 0644, dent, NULL,
-			    &sapphiremmc_dbg_wifi_cd_fops);
-	debugfs_create_file("wifi_pwr", 0644, dent, NULL,
-			    &sapphiremmc_dbg_wifi_pwr_fops);
-
-	debugfs_create_file("sd_pwr", 0644, dent, NULL,
-			    &sapphiremmc_dbg_sd_pwr_fops);
-	debugfs_create_file("sd_cd", 0644, dent, NULL,
-			    &sapphiremmc_dbg_sd_cd_fops);
-
-	return 0;
-}
-
-device_initcall(sapphiremmc_dbg_init);
-
-#endif
diff --git a/arch/arm/mach-msm/board-sapphire-panel.c b/arch/arm/mach-msm/board-sapphire-panel.c
deleted file mode 100644
index 2f165d3..0000000
--- a/arch/arm/mach-msm/board-sapphire-panel.c
+++ /dev/null
@@ -1,1376 +0,0 @@
-/* linux/arch/arm/mach-msm/board-sapphire-panel.c
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Thomas Tsai <thomas_tsai@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-
-#include <linux/io.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-#include <mach/vreg.h>
-#include <mach/pmic.h>
-#include <mach/htc_pwrsink.h>
-
-#include "gpio_chip.h"
-#include "board-sapphire.h"
-#include "proc_comm.h"
-#include "devices.h"
-
-#define DEBUG_SAPPHIRE_PANEL 0
-#define userid 0xD10
-
-enum sapphire_panel_type {
-	SAPPHIRE_PANEL_SHARP = 0,
-	SAPPHIRE_PANEL_TOPPOLY,
-	NUM_OF_SAPPHIRE_PANELS,
-};
-static int g_panel_id = -1 ;
-static int g_panel_inited = 0 ;
-
-#define SAPPHIRE_DEFAULT_BACKLIGHT_BRIGHTNESS	132
-
-static int sapphire_backlight_off;
-static int sapphire_backlight_brightness = SAPPHIRE_DEFAULT_BACKLIGHT_BRIGHTNESS;
-
-static uint8_t sapphire_backlight_last_level = 33;
-static DEFINE_MUTEX(sapphire_backlight_lock);
-
-/* Divide dimming level into 12 sections, and restrict maximum level to 27 */
-#define DIMMING_STEPS       12
-static unsigned dimming_levels[NUM_OF_SAPPHIRE_PANELS][DIMMING_STEPS] = {
-	{0, 1, 2, 3, 6, 9, 11, 13, 16, 19, 22, 25},         /* Sharp */
-	{0, 1, 2, 4, 7, 10, 13, 15, 18, 21, 24, 27},        /* Toppolly */
-};
-static unsigned pwrsink_percents[] = {0, 6, 8, 15, 26, 34, 46, 54, 65, 77, 87,
-				      100};
-
-static void sapphire_set_backlight_level(uint8_t level)
-{
-	unsigned dimming_factor = 255/DIMMING_STEPS + 1;
-        unsigned percent = ((int)level * 100) / 255;
-        unsigned long flags;
-        int i = 0;
-
-	printk(KERN_INFO "level=%d, new level=dimming_levels[%d]=%d\n",
-		level, level/dimming_factor,
-		dimming_levels[g_panel_id][level/dimming_factor]) ;
-        percent = pwrsink_percents[level/dimming_factor] ;
-        level = dimming_levels[g_panel_id][level/dimming_factor] ;
-
-	if (sapphire_backlight_last_level == level)
-		return;
-
-	if (level == 0) {
-		gpio_set_value(27, 0);
-		msleep(2);
-	} else {
-		local_irq_save(flags);
-		if (sapphire_backlight_last_level == 0) {
-			gpio_set_value(27, 1);
-			udelay(40);
-			sapphire_backlight_last_level = 33;
-		}
-		i = (sapphire_backlight_last_level - level + 33) % 33;
-		while (i-- > 0) {
-			gpio_set_value(27, 0);
-			udelay(1);
-			gpio_set_value(27, 1);
-			udelay(1);
-		}
-		local_irq_restore(flags);
-	}
-	sapphire_backlight_last_level = level;
-	htc_pwrsink_set(PWRSINK_BACKLIGHT, percent);
-}
-
-#define MDDI_CLIENT_CORE_BASE  0x108000
-#define LCD_CONTROL_BLOCK_BASE 0x110000
-#define SPI_BLOCK_BASE         0x120000
-#define I2C_BLOCK_BASE         0x130000
-#define PWM_BLOCK_BASE         0x140000
-#define GPIO_BLOCK_BASE        0x150000
-#define SYSTEM_BLOCK1_BASE     0x160000
-#define SYSTEM_BLOCK2_BASE     0x170000
-
-
-#define	DPSUS       (MDDI_CLIENT_CORE_BASE|0x24)
-#define	SYSCLKENA   (MDDI_CLIENT_CORE_BASE|0x2C)
-#define	PWM0OFF	      (PWM_BLOCK_BASE|0x1C)
-
-#define V_VDDE2E_VDD2_GPIO 0
-#define V_VDDE2E_VDD2_GPIO_5M 89
-#define MDDI_RST_N 82
-
-#define	MDDICAP0    (MDDI_CLIENT_CORE_BASE|0x00)
-#define	MDDICAP1    (MDDI_CLIENT_CORE_BASE|0x04)
-#define	MDDICAP2    (MDDI_CLIENT_CORE_BASE|0x08)
-#define	MDDICAP3    (MDDI_CLIENT_CORE_BASE|0x0C)
-#define	MDCAPCHG    (MDDI_CLIENT_CORE_BASE|0x10)
-#define	MDCRCERC    (MDDI_CLIENT_CORE_BASE|0x14)
-#define	TTBUSSEL    (MDDI_CLIENT_CORE_BASE|0x18)
-#define	DPSET0      (MDDI_CLIENT_CORE_BASE|0x1C)
-#define	DPSET1      (MDDI_CLIENT_CORE_BASE|0x20)
-#define	DPSUS       (MDDI_CLIENT_CORE_BASE|0x24)
-#define	DPRUN       (MDDI_CLIENT_CORE_BASE|0x28)
-#define	SYSCKENA    (MDDI_CLIENT_CORE_BASE|0x2C)
-#define	TESTMODE    (MDDI_CLIENT_CORE_BASE|0x30)
-#define	FIFOMONI    (MDDI_CLIENT_CORE_BASE|0x34)
-#define	INTMONI     (MDDI_CLIENT_CORE_BASE|0x38)
-#define	MDIOBIST    (MDDI_CLIENT_CORE_BASE|0x3C)
-#define	MDIOPSET    (MDDI_CLIENT_CORE_BASE|0x40)
-#define	BITMAP0     (MDDI_CLIENT_CORE_BASE|0x44)
-#define	BITMAP1     (MDDI_CLIENT_CORE_BASE|0x48)
-#define	BITMAP2     (MDDI_CLIENT_CORE_BASE|0x4C)
-#define	BITMAP3     (MDDI_CLIENT_CORE_BASE|0x50)
-#define	BITMAP4     (MDDI_CLIENT_CORE_BASE|0x54)
-
-#define	SRST        (LCD_CONTROL_BLOCK_BASE|0x00)
-#define	PORT_ENB    (LCD_CONTROL_BLOCK_BASE|0x04)
-#define	START       (LCD_CONTROL_BLOCK_BASE|0x08)
-#define	PORT        (LCD_CONTROL_BLOCK_BASE|0x0C)
-#define	CMN         (LCD_CONTROL_BLOCK_BASE|0x10)
-#define	GAMMA       (LCD_CONTROL_BLOCK_BASE|0x14)
-#define	INTFLG      (LCD_CONTROL_BLOCK_BASE|0x18)
-#define	INTMSK      (LCD_CONTROL_BLOCK_BASE|0x1C)
-#define	MPLFBUF     (LCD_CONTROL_BLOCK_BASE|0x20)
-#define	HDE_LEFT    (LCD_CONTROL_BLOCK_BASE|0x24)
-#define	VDE_TOP     (LCD_CONTROL_BLOCK_BASE|0x28)
-#define	PXL         (LCD_CONTROL_BLOCK_BASE|0x30)
-#define	HCYCLE      (LCD_CONTROL_BLOCK_BASE|0x34)
-#define	HSW         (LCD_CONTROL_BLOCK_BASE|0x38)
-#define	HDE_START   (LCD_CONTROL_BLOCK_BASE|0x3C)
-#define	HDE_SIZE    (LCD_CONTROL_BLOCK_BASE|0x40)
-#define	VCYCLE      (LCD_CONTROL_BLOCK_BASE|0x44)
-#define	VSW         (LCD_CONTROL_BLOCK_BASE|0x48)
-#define	VDE_START   (LCD_CONTROL_BLOCK_BASE|0x4C)
-#define	VDE_SIZE    (LCD_CONTROL_BLOCK_BASE|0x50)
-#define	WAKEUP      (LCD_CONTROL_BLOCK_BASE|0x54)
-#define	WSYN_DLY    (LCD_CONTROL_BLOCK_BASE|0x58)
-#define	REGENB      (LCD_CONTROL_BLOCK_BASE|0x5C)
-#define	VSYNIF      (LCD_CONTROL_BLOCK_BASE|0x60)
-#define	WRSTB       (LCD_CONTROL_BLOCK_BASE|0x64)
-#define	RDSTB       (LCD_CONTROL_BLOCK_BASE|0x68)
-#define	ASY_DATA    (LCD_CONTROL_BLOCK_BASE|0x6C)
-#define	ASY_DATB    (LCD_CONTROL_BLOCK_BASE|0x70)
-#define	ASY_DATC    (LCD_CONTROL_BLOCK_BASE|0x74)
-#define	ASY_DATD    (LCD_CONTROL_BLOCK_BASE|0x78)
-#define	ASY_DATE    (LCD_CONTROL_BLOCK_BASE|0x7C)
-#define	ASY_DATF    (LCD_CONTROL_BLOCK_BASE|0x80)
-#define	ASY_DATG    (LCD_CONTROL_BLOCK_BASE|0x84)
-#define	ASY_DATH    (LCD_CONTROL_BLOCK_BASE|0x88)
-#define	ASY_CMDSET  (LCD_CONTROL_BLOCK_BASE|0x8C)
-
-#define	SSICTL      (SPI_BLOCK_BASE|0x00)
-#define	SSITIME     (SPI_BLOCK_BASE|0x04)
-#define	SSITX       (SPI_BLOCK_BASE|0x08)
-#define	SSIRX       (SPI_BLOCK_BASE|0x0C)
-#define	SSIINTC     (SPI_BLOCK_BASE|0x10)
-#define	SSIINTS     (SPI_BLOCK_BASE|0x14)
-#define	SSIDBG1     (SPI_BLOCK_BASE|0x18)
-#define	SSIDBG2     (SPI_BLOCK_BASE|0x1C)
-#define	SSIID       (SPI_BLOCK_BASE|0x20)
-
-#define	WKREQ       (SYSTEM_BLOCK1_BASE|0x00)
-#define	CLKENB      (SYSTEM_BLOCK1_BASE|0x04)
-#define	DRAMPWR     (SYSTEM_BLOCK1_BASE|0x08)
-#define	INTMASK     (SYSTEM_BLOCK1_BASE|0x0C)
-#define	GPIOSEL     (SYSTEM_BLOCK2_BASE|0x00)
-
-#define	GPIODATA    (GPIO_BLOCK_BASE|0x00)
-#define	GPIODIR     (GPIO_BLOCK_BASE|0x04)
-#define	GPIOIS      (GPIO_BLOCK_BASE|0x08)
-#define	GPIOIBE     (GPIO_BLOCK_BASE|0x0C)
-#define	GPIOIEV     (GPIO_BLOCK_BASE|0x10)
-#define	GPIOIE      (GPIO_BLOCK_BASE|0x14)
-#define	GPIORIS     (GPIO_BLOCK_BASE|0x18)
-#define	GPIOMIS     (GPIO_BLOCK_BASE|0x1C)
-#define	GPIOIC      (GPIO_BLOCK_BASE|0x20)
-#define	GPIOOMS     (GPIO_BLOCK_BASE|0x24)
-#define	GPIOPC      (GPIO_BLOCK_BASE|0x28)
-#define	GPIOID      (GPIO_BLOCK_BASE|0x30)
-
-#define SPI_WRITE(reg, val) \
-	{ SSITX,        0x00010000 | (((reg) & 0xff) << 8) | ((val) & 0xff) }, \
-	{ 0, 5 },
-
-#define SPI_WRITE1(reg) \
-	{ SSITX,        (reg) & 0xff }, \
-	{ 0, 5 },
-
-struct mddi_table {
-	uint32_t reg;
-	uint32_t value;
-};
-static struct mddi_table mddi_toshiba_init_table[] = {
-	{ DPSET0,       0x09e90046 },
-	{ DPSET1,       0x00000118 },
-	{ DPSUS,        0x00000000 },
-	{ DPRUN,        0x00000001 },
-	{ 1,            14         }, /* msleep 14 */
-	{ SYSCKENA,     0x00000001 },
-	/*{ CLKENB,       0x000000EF } */
-	{ CLKENB,       0x0000A1EF },  /*    # SYS.CLKENB  # Enable clocks for each module (without DCLK , i2cCLK) */
-	/*{ CLKENB,       0x000025CB },  Clock enable register */
-
-	{ GPIODATA,     0x02000200 },  /*   # GPI .GPIODATA  # GPIO2(RESET_LCD_N) set to 0 , GPIO3(eDRAM_Power) set to 0 */
-	{ GPIODIR,      0x000030D  },  /* 24D   # GPI .GPIODIR  # Select direction of GPIO port (0,2,3,6,9 output) */
-	{ GPIOSEL,      0/*0x00000173*/},  /*   # SYS.GPIOSEL  # GPIO port multiplexing control */
-	{ GPIOPC,       0x03C300C0 },  /*   # GPI .GPIOPC  # GPIO2,3 PD cut */
-	{ WKREQ,        0x00000000 },  /*   # SYS.WKREQ  # Wake-up request event is VSYNC alignment */
-
-	{ GPIOIBE,      0x000003FF },
-	{ GPIOIS,       0x00000000 },
-	{ GPIOIC,       0x000003FF },
-	{ GPIOIE,       0x00000000 },
-
-	{ GPIODATA,     0x00040004 },  /*   # GPI .GPIODATA  # eDRAM VD supply */
-	{ 1,            1          }, /* msleep 1 */
-	{ GPIODATA,     0x02040004 },  /*   # GPI .GPIODATA  # eDRAM VD supply */
-	{ DRAMPWR,      0x00000001 }, /* eDRAM power */
-};
-
-static struct mddi_table mddi_toshiba_panel_init_table[] = {
-	{ SRST,         0x00000003 }, /* FIFO/LCDC not reset */
-	{ PORT_ENB,     0x00000001 }, /* Enable sync. Port */
-	{ START,        0x00000000 }, /* To stop operation */
-	/*{ START,        0x00000001 }, To start operation */
-	{ PORT,         0x00000004 }, /* Polarity of VS/HS/DE. */
-	{ CMN,          0x00000000 },
-	{ GAMMA,        0x00000000 }, /* No Gamma correction */
-	{ INTFLG,       0x00000000 }, /* VSYNC interrupt flag clear/status */
-	{ INTMSK,       0x00000000 }, /* VSYNC interrupt mask is off. */
-	{ MPLFBUF,      0x00000000 }, /* Select frame buffer's base address. */
-	{ HDE_LEFT,     0x00000000 }, /* The value of HDE_LEFT. */
-	{ VDE_TOP,      0x00000000 }, /* The value of VDE_TPO. */
-	{ PXL,          0x00000001 }, /* 1. RGB666 */
-				      /* 2. Data is valid from 1st frame of beginning. */
-	{ HDE_START,    0x00000006 }, /* HDE_START= 14 PCLK */
-	{ HDE_SIZE,     0x0000009F }, /* HDE_SIZE=320 PCLK */
-	{ HSW,          0x00000004 }, /* HSW= 10 PCLK */
-	{ VSW,          0x00000001 }, /* VSW=2 HCYCLE */
-	{ VDE_START,    0x00000003 }, /* VDE_START=4 HCYCLE */
-	{ VDE_SIZE,     0x000001DF }, /* VDE_SIZE=480 HCYCLE */
-	{ WAKEUP,       0x000001e2 }, /* Wakeup position in VSYNC mode. */
-	{ WSYN_DLY,     0x00000000 }, /* Wakeup position in VSIN mode. */
-	{ REGENB,       0x00000001 }, /* Set 1 to enable to change the value of registers. */
-	{ CLKENB,       0x000025CB }, /* Clock enable register */
-
-	{ SSICTL,       0x00000170 }, /* SSI control register */
-	{ SSITIME,      0x00000250 }, /* SSI timing control register */
-	{ SSICTL,       0x00000172 }, /* SSI control register */
-};
-
-
-static struct mddi_table mddi_sharp_init_table[] = {
-	{ VCYCLE,       0x000001eb },
-	{ HCYCLE,       0x000000ae },
-	{ REGENB,       0x00000001 }, /* Set 1 to enable to change the value of registers. */
-	{ GPIODATA,     0x00040000 }, /* GPIO2 low */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ 1,            1          }, /* msleep 1 */
-	{ GPIODATA,     0x00040004 }, /* GPIO2 high */
-	{ 1,            10         }, /* msleep 10 */
-	SPI_WRITE(0x5f, 0x01)
-	SPI_WRITE1(0x11)
-	{ 1,            200        }, /* msleep 200 */
-	SPI_WRITE1(0x29)
-	SPI_WRITE1(0xde)
-	{ START,        0x00000001 }, /* To start operation */
-};
-
-static struct mddi_table mddi_sharp_deinit_table[] = {
-	{ 1,            200        }, /* msleep 200 */
-	SPI_WRITE(0x10, 0x1)
-	{ 1,            100        }, /* msleep 100 */
-	{ GPIODATA,     0x00040004 }, /* GPIO2 high */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ GPIODATA,     0x00040000 }, /* GPIO2 low */
-	{ 1,            10         }, /* msleep 10 */
-};
-
-static struct mddi_table mddi_tpo_init_table[] = {
-	{ VCYCLE,       0x000001e5 },
-	{ HCYCLE,       0x000000ac },
-	{ REGENB,       0x00000001 }, /* Set 1 to enable to change the value of registers. */
-	{ 0,            20         }, /* udelay 20 */
-	{ GPIODATA,     0x00000004 }, /* GPIO2 high */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ 0,            20         }, /* udelay 20 */
-
-	SPI_WRITE(0x08, 0x01)
-	{ 0,            500        }, /* udelay 500 */
-	SPI_WRITE(0x08, 0x00)
-	SPI_WRITE(0x02, 0x00)
-	SPI_WRITE(0x03, 0x04)
-	SPI_WRITE(0x04, 0x0e)
-	SPI_WRITE(0x09, 0x02)
-	SPI_WRITE(0x0b, 0x08)
-	SPI_WRITE(0x0c, 0x53)
-	SPI_WRITE(0x0d, 0x01)
-	SPI_WRITE(0x0e, 0xe0)
-	SPI_WRITE(0x0f, 0x01)
-	SPI_WRITE(0x10, 0x58)
-	SPI_WRITE(0x20, 0x1e)
-	SPI_WRITE(0x21, 0x0a)
-	SPI_WRITE(0x22, 0x0a)
-	SPI_WRITE(0x23, 0x1e)
-	SPI_WRITE(0x25, 0x32)
-	SPI_WRITE(0x26, 0x00)
-	SPI_WRITE(0x27, 0xac)
-	SPI_WRITE(0x29, 0x06)
-	SPI_WRITE(0x2a, 0xa4)
-	SPI_WRITE(0x2b, 0x45)
-	SPI_WRITE(0x2c, 0x45)
-	SPI_WRITE(0x2d, 0x15)
-	SPI_WRITE(0x2e, 0x5a)
-	SPI_WRITE(0x2f, 0xff)
-	SPI_WRITE(0x30, 0x6b)
-	SPI_WRITE(0x31, 0x0d)
-	SPI_WRITE(0x32, 0x48)
-	SPI_WRITE(0x33, 0x82)
-	SPI_WRITE(0x34, 0xbd)
-	SPI_WRITE(0x35, 0xe7)
-	SPI_WRITE(0x36, 0x18)
-	SPI_WRITE(0x37, 0x94)
-	SPI_WRITE(0x38, 0x01)
-	SPI_WRITE(0x39, 0x5d)
-	SPI_WRITE(0x3a, 0xae)
-	SPI_WRITE(0x3b, 0xff)
-	SPI_WRITE(0x07, 0x09)
-	{ 0,            10         }, /* udelay 10 */
-	{ START,        0x00000001 }, /* To start operation */
-};
-
-static struct mddi_table mddi_tpo_deinit_table[] = {
-	SPI_WRITE(0x07, 0x19)
-	{ START,        0x00000000 }, /* To stop operation */
-	{ GPIODATA,     0x00040004 }, /* GPIO2 high */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ GPIODATA,     0x00040000 }, /* GPIO2 low */
-	{ 0,            5        }, /* usleep 5 */
-};
-
-
-#define GPIOSEL_VWAKEINT (1U << 0)
-#define INTMASK_VWAKEOUT (1U << 0)
-
-static void sapphire_process_mddi_table(
-				     struct msm_mddi_client_data *client_data,
-				     const struct mddi_table *table,
-				     size_t count)
-{
-	int i;
-	for (i = 0; i < count; i++) {
-		uint32_t reg = table[i].reg;
-		uint32_t value = table[i].value;
-
-		if (reg == 0)
-			udelay(value);
-		else if (reg == 1)
-			msleep(value);
-		else
-			client_data->remote_write(client_data, value, reg);
-	}
-}
-
-static struct vreg *vreg_lcm_2v85;
-
-static void sapphire_mddi_power_client(struct msm_mddi_client_data *client_data,
-				    int on)
-{
-	unsigned id, on_off;
-#if DEBUG_SAPPHIRE_PANEL
-	printk(KERN_INFO "sapphire_mddi_client_power:%d\r\n", on);
-#endif
-	if (on) {
-		on_off = 0;
-		id = PM_VREG_PDOWN_MDDI_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-
-		gpio_set_value(SAPPHIRE_MDDI_1V5_EN, 1);
-		mdelay(5); /* delay time >5ms and <10ms */
-
-		if  (is_sapphire_gpiov20())
-			gpio_set_value(V_VDDE2E_VDD2_GPIO_5M, 1);
-		else
-			gpio_set_value(V_VDDE2E_VDD2_GPIO, 1);
-
-		gpio_set_value(SAPPHIRE_GPIO_MDDI_32K_EN, 1);
-		msleep(3);
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v85);
-		msleep(3);
-	} else {
-		gpio_set_value(SAPPHIRE_GPIO_MDDI_32K_EN, 0);
-		gpio_set_value(MDDI_RST_N, 0);
-		msleep(10);
-		vreg_disable(vreg_lcm_2v85);
-		on_off = 1;
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		msleep(5);
-		if  (is_sapphire_gpiov20())
-			gpio_set_value(V_VDDE2E_VDD2_GPIO_5M, 0);
-		else
-			gpio_set_value(V_VDDE2E_VDD2_GPIO, 0);
-
-		msleep(200);
-		gpio_set_value(SAPPHIRE_MDDI_1V5_EN, 0);
-		id = PM_VREG_PDOWN_MDDI_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-	}
-}
-
-static int sapphire_mddi_toshiba_client_init(
-			struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *client_data)
-{
-	int panel_id;
-
-	/* Set the MDDI_RST_N accroding to MDDI client repectively(
-	 * been set in sapphire_mddi_power_client() originally)
-	 */
-	gpio_set_value(MDDI_RST_N, 1);
-	msleep(10);
-
-	client_data->auto_hibernate(client_data, 0);
-	sapphire_process_mddi_table(client_data, mddi_toshiba_init_table,
-				 ARRAY_SIZE(mddi_toshiba_init_table));
-	client_data->auto_hibernate(client_data, 1);
-	g_panel_id = panel_id =
-		(client_data->remote_read(client_data, GPIODATA) >> 4) & 3;
-	if (panel_id > 1) {
-#if DEBUG_SAPPHIRE_PANEL
-		printk(KERN_ERR "unknown panel id at mddi_enable\n");
-#endif
-		return -1;
-	}
-	return 0;
-}
-
-static int sapphire_mddi_toshiba_client_uninit(
-			struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *client_data)
-{
-	gpio_set_value(MDDI_RST_N, 0);
-	msleep(10);
-
-	return 0;
-}
-
-static int sapphire_mddi_panel_unblank(
-			struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *client_data)
-{
-	int panel_id, ret = 0;
-
-	sapphire_set_backlight_level(0);
-	client_data->auto_hibernate(client_data, 0);
-	sapphire_process_mddi_table(client_data, mddi_toshiba_panel_init_table,
-		ARRAY_SIZE(mddi_toshiba_panel_init_table));
-	panel_id = (client_data->remote_read(client_data, GPIODATA) >> 4) & 3;
-	switch (panel_id) {
-	case 0:
-#if DEBUG_SAPPHIRE_PANEL
-		printk(KERN_DEBUG "init sharp panel\n");
-#endif
-		sapphire_process_mddi_table(client_data,
-					 mddi_sharp_init_table,
-					 ARRAY_SIZE(mddi_sharp_init_table));
-		break;
-	case 1:
-#if DEBUG_SAPPHIRE_PANEL
-		printk(KERN_DEBUG "init tpo panel\n");
-#endif
-		sapphire_process_mddi_table(client_data,
-					 mddi_tpo_init_table,
-					 ARRAY_SIZE(mddi_tpo_init_table));
-		break;
-	default:
-
-		printk(KERN_DEBUG "unknown panel_id: %d\n", panel_id);
-		ret = -1;
-	};
-	mutex_lock(&sapphire_backlight_lock);
-	sapphire_set_backlight_level(sapphire_backlight_brightness);
-	sapphire_backlight_off = 0;
-	mutex_unlock(&sapphire_backlight_lock);
-	client_data->auto_hibernate(client_data, 1);
-	/* reenable vsync */
-	client_data->remote_write(client_data, GPIOSEL_VWAKEINT,
-				  GPIOSEL);
-	client_data->remote_write(client_data, INTMASK_VWAKEOUT,
-				  INTMASK);
-	return ret;
-
-}
-
-static int sapphire_mddi_panel_blank(
-			struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *client_data)
-{
-	int panel_id, ret = 0;
-
-	panel_id = (client_data->remote_read(client_data, GPIODATA) >> 4) & 3;
-	client_data->auto_hibernate(client_data, 0);
-	switch (panel_id) {
-	case 0:
-		printk(KERN_DEBUG "deinit sharp panel\n");
-		sapphire_process_mddi_table(client_data,
-					 mddi_sharp_deinit_table,
-					 ARRAY_SIZE(mddi_sharp_deinit_table));
-		break;
-	case 1:
-		printk(KERN_DEBUG "deinit tpo panel\n");
-		sapphire_process_mddi_table(client_data,
-					 mddi_tpo_deinit_table,
-					 ARRAY_SIZE(mddi_tpo_deinit_table));
-		break;
-	default:
-		printk(KERN_DEBUG "unknown panel_id: %d\n", panel_id);
-		ret = -1;
-	};
-	client_data->auto_hibernate(client_data, 1);
-	mutex_lock(&sapphire_backlight_lock);
-	sapphire_set_backlight_level(0);
-	sapphire_backlight_off = 1;
-	mutex_unlock(&sapphire_backlight_lock);
-	client_data->remote_write(client_data, 0, SYSCLKENA);
-	client_data->remote_write(client_data, 1, DPSUS);
-
-	return ret;
-}
-#if 0
-extern char* __iomem mdp_base;
-static int setup_mdp_sync_config(void)
-{
-	uint32_t i, reg, vsync_count;
-
-	printk("+%s()\n", __FUNCTION__) ;
-	printk("mdp_base=%x, phys_to_virt=%x\n", mdp_base,
-			phys_to_virt(MSM_MDP_PHYS)) ;
-	//0. Enable the necessary clock
-	i = readl(MSM_CLK_CTL_BASE+0);
-	i |= (1<<9) ;
-	printk("Enabling MDP_CLK; GLBL_CLK_ENA=%x \n", i);
-	writel(i, MSM_CLK_CTL_BASE+0) ;
-
-	reg = mdp_base + 0;
-	/* 1. MDP_SYNC_CONFIG_0  */
-	i = readl( reg ) ;
-	vsync_count = 4498 ;           // 128M / (57.84*492)
-	//vsync_count = 4509 ;         // 128M / (57.69*492)
-	//vsync_count = 4598 ;         // 128M / (58*480) ;
-	i = ((492-1) << 22) | (1<<21) | (1<<20) | vsync_count ;
-	printk("set MDP_SYNC_CONFIG_0 from %x to %x\n", readl(reg), i);
-	writel( i, reg ) ;
-
-#ifdef MDP_VSYNC_OUT
-	/* 2. MDP_PRIMARY_VSYNC_OUT_CTRL */
-	reg = mdp_base+0x80;
-	i = 1 ;                                // pulse width
-	printk("set MDP_PRIMARY_VSYNC_OUT_CTRL from %x to %x\n",
-			readl(reg), i );
-	writel(i, reg);
-#endif
-
-	/* 4. MDP_SYNC_THRESH_0 */
-	reg = mdp_base+0x18;
-	i = ( (12-1)<<8) | (12-1);      // recommand: back porch - 1
-	printk("set MDP_SYNC_THRESH_0 from %x to %x\n", readl(reg), i);
-	writel(i, reg) ;
-
-	return 0 ;
-}
-#endif
-static spinlock_t g_list_lock = SPIN_LOCK_UNLOCKED;
-static ssize_t panel_show(struct kobject *kobj, struct kobj_attribute *attr, char * buf)
-{
-	char * s = buf;
-	unsigned long irqflags;
-
-	spin_lock_irqsave(&g_list_lock, irqflags);
-	switch(g_panel_id) {
-		case SAPPHIRE_PANEL_SHARP:
-			s += sprintf(s, "verdor:sharp\n");
-			break ;
-		case  SAPPHIRE_PANEL_TOPPOLY:
-			s += sprintf(s, "vendor:toppoly\n");
-			break ;
-		default:
-			s += sprintf(s, "vendor:unknown\n");
-			break ;
-	}
-	spin_unlock_irqrestore(&g_list_lock, irqflags);
-	return (s - buf);
-}
-
-#define android_display_ro_attr(_name) \
-	static struct kobj_attribute _name##_attr = {   \
-		.attr   = {                 \
-			.name = __stringify(_name), \
-			.mode = 0444,           \
-		},                      \
-		.show   = _name##_show,     \
-		.store  = NULL, \
-	}
-
-android_display_ro_attr(panel);
-
-static struct attribute * attrs[] = {
-	&panel_attr.attr,
-	NULL ,
-} ;
-
-static struct attribute_group attr_group = {
-	.attrs = attrs,
-};
-
-static struct kobject *android_display_kobj = NULL;
-#define GPIO_BLOCK_BASE         0x150000
-#define GPIODATA                (GPIO_BLOCK_BASE|0x00)
-static int display_sysfs_init(void)
-{
-	int ret ;
-
-	android_display_kobj = kobject_create_and_add("android_display", NULL);
-	if ( android_display_kobj == NULL ) {
-		printk("msmfb_sysfs_init: subsystem_register failed\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-	ret = sysfs_create_group(android_display_kobj, &attr_group);
-	if(ret) {
-		printk("msmfb_sysfs_init: sysfs_create_group failed\n");
-		goto err4;
-	}
-	return 0 ;
-err4:
-	kobject_del(android_display_kobj);
-err:
-	return ret ;
-}
-
-/* Initial sequence of TPO panel with Novatek NT35399 MDDI client */
-
-#undef TPO2_ONE_GAMMA
-
-/* Initial sequence of sharp panel with Novatek NT35399 MDDI client */
-static const struct mddi_table sharp2_init_table[] = {
-	{ 0x02A0, 0x00 },
-	{ 0x02A1, 0x00 },
-	{ 0x02A2, 0x3F },
-	{ 0x02A3, 0x01 },
-	{ 0x02B0, 0x00 },
-	{ 0x02B1, 0x00 },
-	{ 0x02B2, 0xDF },
-	{ 0x02B3, 0x01 },
-	{ 0x02D0, 0x00 },
-	{ 0x02D1, 0x00 },
-	{ 0x02D2, 0x00 },
-	{ 0x02D3, 0x00 },
-	{ 0x0350, 0x80 },	/* Set frame tearing effect(FTE) position */
-	{ 0x0351, 0x00 },
-	{ 0x0360, 0x30 },
-	{ 0x0361, 0xC1 },
-	{ 0x0362, 0x00 },
-	{ 0x0370, 0x00 },
-	{ 0x0371, 0xEF },
-	{ 0x0372, 0x01 },
-
-	{ 0x0B00, 0x10 },
-
-	{ 0x0B10, 0x00 },
-	{ 0x0B20, 0x22 },
-	{ 0x0B30, 0x46 },
-	{ 0x0B40, 0x07 },
-	{ 0x0B41, 0x1C },
-	{ 0x0B50, 0x0F },
-	{ 0x0B51, 0x7A },
-	{ 0x0B60, 0x16 },
-	{ 0x0B70, 0x0D },
-	{ 0x0B80, 0x04 },
-	{ 0x0B90, 0x07 },
-	{ 0x0BA0, 0x04 },
-	{ 0x0BA1, 0x86 },
-	{ 0x0BB0, 0xFF },
-	{ 0x0BB1, 0x01 },
-	{ 0x0BB2, 0xF7 },
-	{ 0x0BB3, 0x01 },
-	{ 0x0BC0, 0x00 },
-	{ 0x0BC1, 0x00 },
-	{ 0x0BC2, 0x00 },
-	{ 0x0BC3, 0x00 },
-	{ 0x0BE0, 0x01 },
-	{ 0x0BE1, 0x3F },
-
-	{ 0x0BF0, 0x03 },
-
-	{ 0x0C10, 0x02 },
-
-	{ 0x0C30, 0x22 },
-	{ 0x0C31, 0x20 },
-	{ 0x0C40, 0x48 },
-	{ 0x0C41, 0x06 },
-
-	{ 0xE00, 0x0028},
-	{ 0xE01, 0x002F},
-	{ 0xE02, 0x0032},
-	{ 0xE03, 0x000A},
-	{ 0xE04, 0x0023},
-	{ 0xE05, 0x0024},
-	{ 0xE06, 0x0022},
-	{ 0xE07, 0x0012},
-	{ 0xE08, 0x000D},
-	{ 0xE09, 0x0035},
-	{ 0xE0A, 0x000E},
-	{ 0xE0B, 0x001A},
-	{ 0xE0C, 0x003C},
-	{ 0xE0D, 0x003A},
-	{ 0xE0E, 0x0050},
-	{ 0xE0F, 0x0069},
-	{ 0xE10, 0x0006},
-	{ 0xE11, 0x001F},
-	{ 0xE12, 0x0035},
-	{ 0xE13, 0x0020},
-	{ 0xE14, 0x0043},
-	{ 0xE15, 0x0030},
-	{ 0xE16, 0x003C},
-	{ 0xE17, 0x0010},
-	{ 0xE18, 0x0009},
-	{ 0xE19, 0x0051},
-	{ 0xE1A, 0x001D},
-	{ 0xE1B, 0x003C},
-	{ 0xE1C, 0x0053},
-	{ 0xE1D, 0x0041},
-	{ 0xE1E, 0x0045},
-	{ 0xE1F, 0x004B},
-	{ 0xE20, 0x000A},
-	{ 0xE21, 0x0014},
-	{ 0xE22, 0x001C},
-	{ 0xE23, 0x0013},
-	{ 0xE24, 0x002E},
-	{ 0xE25, 0x0029},
-	{ 0xE26, 0x001B},
-	{ 0xE27, 0x0014},
-	{ 0xE28, 0x000E},
-	{ 0xE29, 0x0032},
-	{ 0xE2A, 0x000D},
-	{ 0xE2B, 0x001B},
-	{ 0xE2C, 0x0033},
-	{ 0xE2D, 0x0033},
-	{ 0xE2E, 0x005B},
-	{ 0xE2F, 0x0069},
-	{ 0xE30, 0x0006},
-	{ 0xE31, 0x0014},
-	{ 0xE32, 0x003D},
-	{ 0xE33, 0x0029},
-	{ 0xE34, 0x0042},
-	{ 0xE35, 0x0032},
-	{ 0xE36, 0x003F},
-	{ 0xE37, 0x000E},
-	{ 0xE38, 0x0008},
-	{ 0xE39, 0x0059},
-	{ 0xE3A, 0x0015},
-	{ 0xE3B, 0x002E},
-	{ 0xE3C, 0x0049},
-	{ 0xE3D, 0x0058},
-	{ 0xE3E, 0x0061},
-	{ 0xE3F, 0x006B},
-	{ 0xE40, 0x000A},
-	{ 0xE41, 0x001A},
-	{ 0xE42, 0x0022},
-	{ 0xE43, 0x0014},
-	{ 0xE44, 0x002F},
-	{ 0xE45, 0x002A},
-	{ 0xE46, 0x001A},
-	{ 0xE47, 0x0014},
-	{ 0xE48, 0x000E},
-	{ 0xE49, 0x002F},
-	{ 0xE4A, 0x000F},
-	{ 0xE4B, 0x001B},
-	{ 0xE4C, 0x0030},
-	{ 0xE4D, 0x002C},
-	{ 0xE4E, 0x0051},
-	{ 0xE4F, 0x0069},
-	{ 0xE50, 0x0006},
-	{ 0xE51, 0x001E},
-	{ 0xE52, 0x0043},
-	{ 0xE53, 0x002F},
-	{ 0xE54, 0x0043},
-	{ 0xE55, 0x0032},
-	{ 0xE56, 0x0043},
-	{ 0xE57, 0x000D},
-	{ 0xE58, 0x0008},
-	{ 0xE59, 0x0059},
-	{ 0xE5A, 0x0016},
-	{ 0xE5B, 0x0030},
-	{ 0xE5C, 0x004B},
-	{ 0xE5D, 0x0051},
-	{ 0xE5E, 0x005A},
-	{ 0xE5F, 0x006B},
-
-        { 0x0290, 0x01 },
-};
-
-#undef TPO2_ONE_GAMMA
-/* Initial sequence of TPO panel with Novatek NT35399 MDDI client */
-
-static const struct mddi_table tpo2_init_table[] = {
-	/* Panel interface control */
-	{ 0xB30, 0x44 },
-	{ 0xB40, 0x00 },
-	{ 0xB41, 0x87 },
-	{ 0xB50, 0x06 },
-	{ 0xB51, 0x7B },
-	{ 0xB60, 0x0E },
-	{ 0xB70, 0x0F },
-	{ 0xB80, 0x03 },
-	{ 0xB90, 0x00 },
-	{ 0x350, 0x70 },        /* FTE is at line 0x70 */
-
-	/* Entry Mode */
-	{ 0x360, 0x30 },
-	{ 0x361, 0xC1 },
-	{ 0x362, 0x04 },
-
-/* 0x2 for gray scale gamma correction, 0x12 for RGB gamma correction  */
-#ifdef TPO2_ONE_GAMMA
-	{ 0xB00, 0x02 },
-#else
-	{ 0xB00, 0x12 },
-#endif
-	/* Driver output control */
-	{ 0x371, 0xEF },
-	{ 0x372, 0x03 },
-
-	/* DCDC on glass control */
-	{ 0xC31, 0x10 },
-	{ 0xBA0, 0x00 },
-	{ 0xBA1, 0x86 },
-
-	/* VCOMH voltage control */
-	{ 0xC50, 0x3b },
-
-	/* Special function control */
-	{ 0xC10, 0x82 },
-
-	/* Power control */
-	{ 0xC40, 0x44 },
-	{ 0xC41, 0x02 },
-
-	/* Source output control */
-	{ 0xBE0, 0x01 },
-	{ 0xBE1, 0x00 },
-
-	/* Windows address setting */
-	{ 0x2A0, 0x00 },
-	{ 0x2A1, 0x00 },
-	{ 0x2A2, 0x3F },
-	{ 0x2A3, 0x01 },
-	{ 0x2B0, 0x00 },
-	{ 0x2B1, 0x00 },
-	{ 0x2B2, 0xDF },
-	{ 0x2B3, 0x01 },
-
-	/* RAM address setting */
-	{ 0x2D0, 0x00 },
-	{ 0x2D1, 0x00 },
-	{ 0x2D2, 0x00 },
-	{ 0x2D3, 0x00 },
-
-	{ 0xF20, 0x55 },
-	{ 0xF21, 0xAA },
-	{ 0xF22, 0x66 },
-	{ 0xF57, 0x45 },
-
-/*
- * The NT35399 provides gray or RGB gamma correction table,
- * which determinated by register-0xb00, and following table
- */
-#ifdef TPO2_ONE_GAMMA
-	/* Positive Gamma setting */
-	{ 0xE00, 0x04 },
-	{ 0xE01, 0x12 },
-	{ 0xE02, 0x18 },
-	{ 0xE03, 0x10 },
-	{ 0xE04, 0x29 },
-	{ 0xE05, 0x26 },
-	{ 0xE06, 0x1f },
-	{ 0xE07, 0x11 },
-	{ 0xE08, 0x0c },
-	{ 0xE09, 0x3a },
-	{ 0xE0A, 0x0d },
-	{ 0xE0B, 0x28 },
-	{ 0xE0C, 0x40 },
-	{ 0xE0D, 0x4e },
-	{ 0xE0E, 0x6f },
-	{ 0xE0F, 0x5E },
-
-	/* Negative Gamma setting */
-	{ 0xE10, 0x0B },
-	{ 0xE11, 0x00 },
-	{ 0xE12, 0x00 },
-	{ 0xE13, 0x1F },
-	{ 0xE14, 0x4b },
-	{ 0xE15, 0x33 },
-	{ 0xE16, 0x13 },
-	{ 0xE17, 0x12 },
-	{ 0xE18, 0x0d },
-	{ 0xE19, 0x2f },
-	{ 0xE1A, 0x16 },
-	{ 0xE1B, 0x2e },
-	{ 0xE1C, 0x49 },
-	{ 0xE1D, 0x41 },
-	{ 0xE1E, 0x46 },
-	{ 0xE1F, 0x55 },
-#else
-	/* Red Positive Gamma  */
-	{0xE00, 0x001A },
-	{0xE01, 0x001F },
-	{0xE02, 0x0022 },
-	{0xE03, 0x0009 },
-	{0xE04, 0x0023 },
-	{0xE05, 0x0023 },
-	{0xE06, 0x002B },
-	{0xE07, 0x0013 },
-	{0xE08, 0x000B },
-	{0xE09, 0x0049 },
-	{0xE0A, 0x0019 },
-	{0xE0B, 0x0026 },
-	{0xE0C, 0x0059 },
-	{0xE0D, 0x003B },
-	{0xE0E, 0x0045 },
-	{0xE0F, 0x0062 },
-
-	/* Red Negative Gamma   */
-	{0xE10, 0x001D },
-	{0xE11, 0x003A },
-	{0xE12, 0x0043 },
-	{0xE13, 0x0009 },
-	{0xE14, 0x0038 },
-	{0xE15, 0x0024 },
-	{0xE16, 0x0034 },
-	{0xE17, 0x0010 },
-	{0xE18, 0x0009 },
-	{0xE19, 0x0051 },
-	{0xE1A, 0x001B },
-	{0xE1B, 0x0036 },
-	{0xE1C, 0x0054 },
-	{0xE1D, 0x0059 },
-	{0xE1E, 0x005C },
-	{0xE1F, 0x0060 },
-
-	/* Green Positive Gamma */
-	{0xE20, 0x0005 },
-	{0xE21, 0x000E },
-	{0xE22, 0x0017 },
-	{0xE23, 0x0010 },
-	{0xE24, 0x0026 },
-	{0xE25, 0x0027 },
-	{0xE26, 0x0028 },
-	{0xE27, 0x0013 },
-	{0xE28, 0x000E },
-	{0xE29, 0x0049 },
-	{0xE2A, 0x0012 },
-	{0xE2B, 0x001D },
-	{0xE2C, 0x0035 },
-	{0xE2D, 0x0047 },
-	{0xE2E, 0x004F },
-	{0xE2F, 0x0062 },
-
-	/* Green Negative Gamma */
-	{0xE30, 0x001D },
-	{0xE31, 0x0030 },
-	{0xE32, 0x0036 },
-	{0xE33, 0x0029 },
-	{0xE34, 0x0043 },
-	{0xE35, 0x002e },
-	{0xE36, 0x0035 },
-	{0xE37, 0x0011 },
-	{0xE38, 0x000B },
-	{0xE39, 0x0053 },
-	{0xE3A, 0x0016 },
-	{0xE3B, 0x0035 },
-	{0xE3C, 0x004F },
-	{0xE3D, 0x0063 },
-	{0xE3E, 0x006D },
-	{0xE3F, 0x0076 },
-
-	/* Blue Positive Gamma */
-	{0xE40, 0x0029 },
-	{0xE41, 0x002A },
-	{0xE42, 0x002C },
-	{0xE43, 0x0003 },
-	{0xE44, 0x0019 },
-	{0xE45, 0x0017 },
-	{0xE46, 0x0023 },
-	{0xE47, 0x0012 },
-	{0xE48, 0x000B },
-	{0xE49, 0x0044 },
-	{0xE4A, 0x0016 },
-	{0xE4B, 0x0027 },
-	{0xE4C, 0x0041 },
-	{0xE4D, 0x0032 },
-	{0xE4E, 0x003C },
-	{0xE4F, 0x0062 },
-
-	/* Blue Negative Gamma */
-	{0xE50, 0x0019 },
-	{0xE51, 0x0042 },
-	{0xE52, 0x004B },
-	{0xE53, 0x001C },
-	{0xE54, 0x0036 },
-	{0xE55, 0x0028 },
-	{0xE56, 0x003C },
-	{0xE57, 0x0011 },
-	{0xE58, 0x0009 },
-	{0xE59, 0x005A },
-	{0xE5A, 0x002A },
-	{0xE5B, 0x0043 },
-	{0xE5C, 0x0058 },
-	{0xE5D, 0x0052 },
-	{0xE5E, 0x0053 },
-	{0xE5F, 0x0054 },
-#endif
-	/* Sleep in mode 		*/
-	{ 0x110, 0x00 },
-	{ 0x1,   0x23 },
-	/* Display on mode 		*/
-	{ 0x290, 0x00 },
-	{ 0x1,   0x27 },
-	/* Driver output control	*/
-	{ 0x372, 0x01 },
-	{ 0x1,   0x40 },
-	/* Display on mode		*/
-	{ 0x290, 0x01 },
-};
-
-static const struct mddi_table tpo2_display_on[] = {
-	{ 0x290, 0x01 },
-};
-
-static const struct mddi_table tpo2_display_off[] = {
-	{ 0x110, 0x01 },
-	{ 0x290, 0x00 },
-	{ 0x1,   100 },
-};
-
-static const struct mddi_table tpo2_power_off[] = {
-	{ 0x0110, 0x01 },
-};
-
-static int nt35399_detect_panel(struct msm_mddi_client_data *client_data)
-{
-	int id = -1, i ;
-
-	/* If the MDDI client is failed to report the panel ID,
-	 * perform retrial 5 times.
-	 */
-	for( i=0; i < 5; i++ ) {
-		client_data->remote_write(client_data, 0, 0x110);
-		msleep(5);
-		id = client_data->remote_read(client_data, userid) ;
-		if( id == 0 || id == 1 ) {
-			if(i==0) {
-				printk(KERN_ERR "%s: got valid panel ID=%d, "
-						"without retry\n",
-						__FUNCTION__, id);
-			}
-			else {
-				printk(KERN_ERR "%s: got valid panel ID=%d, "
-						"after %d retry\n",
-						__FUNCTION__, id, i+1);
-			}
-			break ;
-		}
-		printk(KERN_ERR "%s: got invalid panel ID:%d, trial #%d\n",
-				__FUNCTION__, id, i+1);
-
-		gpio_set_value(MDDI_RST_N, 0);
-		msleep(5);
-
-		gpio_set_value(MDDI_RST_N, 1);
-		msleep(10);
-		gpio_set_value(MDDI_RST_N, 0);
-		udelay(100);
-		gpio_set_value(MDDI_RST_N, 1);
-		mdelay(10);
-	}
-	printk(KERN_INFO "%s: final panel id=%d\n", __FUNCTION__, id);
-
-	switch(id) {
-	case 0:
-		return SAPPHIRE_PANEL_TOPPOLY;
-	case 1:
-		return SAPPHIRE_PANEL_SHARP;
-	default :
-		printk(KERN_ERR "%s(): Invalid panel ID: %d, "
-				"treat as sharp panel.", __FUNCTION__, id);
-		return SAPPHIRE_PANEL_SHARP;
-	}
-}
-
-static int nt35399_client_init(
-		struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	int panel_id;
-
-	if (g_panel_inited == 0) {
-		g_panel_id = panel_id = nt35399_detect_panel(client_data);
-		g_panel_inited = 1 ;
-	} else {
-		gpio_set_value(MDDI_RST_N, 1);
-		msleep(10);
-		gpio_set_value(MDDI_RST_N, 0);
-		udelay(100);
-		gpio_set_value(MDDI_RST_N, 1);
-		mdelay(10);
-
-		g_panel_id = panel_id = nt35399_detect_panel(client_data);
-		if (panel_id == -1) {
-			printk("Invalid panel id\n");
-			return -1;
-		}
-
-		client_data->auto_hibernate(client_data, 0);
-		if (panel_id == SAPPHIRE_PANEL_TOPPOLY) {
-			sapphire_process_mddi_table(client_data, tpo2_init_table,
-						    ARRAY_SIZE(tpo2_init_table));
-		} else if(panel_id == SAPPHIRE_PANEL_SHARP) {
-			sapphire_process_mddi_table(client_data, sharp2_init_table,
-						    ARRAY_SIZE(sharp2_init_table));
-		}
-
-		client_data->auto_hibernate(client_data, 1);
-	}
-
-	return 0;
-}
-
-static int nt35399_client_uninit(
-		struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *cdata)
-{
-	return 0;
-}
-
-static int nt35399_panel_unblank(
-		struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	int ret = 0;
-
-	mdelay(20);
-	sapphire_set_backlight_level(0);
-	client_data->auto_hibernate(client_data, 0);
-
-	mutex_lock(&sapphire_backlight_lock);
-	sapphire_set_backlight_level(sapphire_backlight_brightness);
-	sapphire_backlight_off = 0;
-	mutex_unlock(&sapphire_backlight_lock);
-
-	client_data->auto_hibernate(client_data, 1);
-
-	return ret;
-}
-
-static int nt35399_panel_blank(
-		struct msm_mddi_bridge_platform_data *bridge_data,
-		struct msm_mddi_client_data *client_data)
-{
-	int ret = 0;
-
-	client_data->auto_hibernate(client_data, 0);
-	sapphire_process_mddi_table(client_data, tpo2_display_off,
-			ARRAY_SIZE(tpo2_display_off));
-	client_data->auto_hibernate(client_data, 1);
-
-	mutex_lock(&sapphire_backlight_lock);
-	sapphire_set_backlight_level(0);
-	sapphire_backlight_off = 1;
-	mutex_unlock(&sapphire_backlight_lock);
-
-	return ret;
-}
-
-static void sapphire_brightness_set(struct led_classdev *led_cdev, enum led_brightness value)
-{
-	mutex_lock(&sapphire_backlight_lock);
-	sapphire_backlight_brightness = value;
-	if (!sapphire_backlight_off)
-		sapphire_set_backlight_level(sapphire_backlight_brightness);
-	mutex_unlock(&sapphire_backlight_lock);
-}
-
-static struct led_classdev sapphire_backlight_led = {
-	.name			= "lcd-backlight",
-	.brightness = SAPPHIRE_DEFAULT_BACKLIGHT_BRIGHTNESS,
-	.brightness_set = sapphire_brightness_set,
-};
-
-static int sapphire_backlight_probe(struct platform_device *pdev)
-{
-	led_classdev_register(&pdev->dev, &sapphire_backlight_led);
-	return 0;
-}
-
-static int sapphire_backlight_remove(struct platform_device *pdev)
-{
-	led_classdev_unregister(&sapphire_backlight_led);
-	return 0;
-}
-
-static struct platform_driver sapphire_backlight_driver = {
-	.probe		= sapphire_backlight_probe,
-	.remove		= sapphire_backlight_remove,
-	.driver		= {
-		.name		= "sapphire-backlight",
-		.owner		= THIS_MODULE,
-	},
-};
-
-static struct resource resources_msm_fb_smi32[] = {
-	{
-		.start = SMI32_MSM_FB_BASE,
-		.end = SMI32_MSM_FB_BASE + SMI32_MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = SMI64_MSM_FB_BASE,
-		.end = SMI64_MSM_FB_BASE + SMI64_MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct msm_mddi_bridge_platform_data toshiba_client_data = {
-	.init = sapphire_mddi_toshiba_client_init,
-	.uninit = sapphire_mddi_toshiba_client_uninit,
-	.blank = sapphire_mddi_panel_blank,
-	.unblank = sapphire_mddi_panel_unblank,
-	.fb_data = {
-		.xres = 320,
-		.yres = 480,
-		.width = 45,
-		.height = 67,
-		.output_format = 0,
-	},
-};
-
-#define NT35399_MFR_NAME	0x0bda
-#define NT35399_PRODUCT_CODE 	0x8a47
-
-static void nt35399_fixup(uint16_t * mfr_name, uint16_t * product_code)
-{
-	printk(KERN_DEBUG "%s: enter.\n", __func__);
-	*mfr_name = NT35399_MFR_NAME ;
-	*product_code= NT35399_PRODUCT_CODE ;
-}
-
-static struct msm_mddi_bridge_platform_data nt35399_client_data = {
-
-	.init = nt35399_client_init,
-	.uninit = nt35399_client_uninit,
-	.blank = nt35399_panel_blank,
-	.unblank = nt35399_panel_unblank,
-	.fb_data = {
-		.xres = 320,
-		.yres = 480,
-		.output_format = 0,
-	},
-};
-
-static struct msm_mddi_platform_data mddi_pdata = {
-	.clk_rate = 122880000,
-	.power_client = sapphire_mddi_power_client,
-	.fixup = nt35399_fixup,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 2,
-	.client_platform_data = {
-		{
-			.product_id = (0xd263 << 16 | 0),
-			.name = "mddi_c_d263_0000",
-			.id = 0,
-			.client_data = &toshiba_client_data,
-			.clk_rate = 0,
-		},
-		{
-			.product_id =
-				(NT35399_MFR_NAME << 16 | NT35399_PRODUCT_CODE),
-			.name = "mddi_c_0bda_8a47" ,
-			.id = 0,
-			.client_data = &nt35399_client_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-static struct platform_device sapphire_backlight = {
-	.name = "sapphire-backlight",
-};
-
-int __init sapphire_init_panel(void)
-{
-	int rc = -1;
-	uint32_t config = PCOM_GPIO_CFG(27, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA); /* GPIO27 */
-
-	if (!machine_is_sapphire())
-		return 0;
-
-	/* checking board as soon as possible */
-	printk("sapphire_init_panel:machine_is_sapphire=%d, machine_arch_type=%d, MACH_TYPE_SAPPHIRE=%d\r\n", machine_is_sapphire(), machine_arch_type, MACH_TYPE_SAPPHIRE);
-
-	vreg_lcm_2v85 = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_lcm_2v85))
-		return PTR_ERR(vreg_lcm_2v85);
-
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &config, 0);
-
-	/* setup FB by SMI size */
-	if (sapphire_get_smi_size() == 32)
-		mddi_pdata.fb_resource = resources_msm_fb_smi32;
-
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-	msm_device_mddi0.dev.platform_data = &mddi_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-	platform_device_register(&sapphire_backlight);
-
-	rc = platform_driver_register(&sapphire_backlight_driver);
-	if (rc)
-		return rc ;
-
-	if ( (rc = display_sysfs_init()) )
-		return rc ;
-//	setup_mdp_sync_config() ;
-
-	return(rc) ;
-}
-
-device_initcall(sapphire_init_panel);
diff --git a/arch/arm/mach-msm/board-sapphire-rfkill.c b/arch/arm/mach-msm/board-sapphire-rfkill.c
deleted file mode 100644
index 7f5b04d..0000000
--- a/arch/arm/mach-msm/board-sapphire-rfkill.c
+++ /dev/null
@@ -1,111 +0,0 @@
-/* linux/arch/arm/mach-msm/board-sapphire-rfkill.c
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Thomas Tsai <thomas_tsai@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-/* Control bluetooth power for sapphire platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-#include "gpio_chip.h"
-#include "board-sapphire.h"
-void rfkill_switch_all(enum rfkill_type type, enum rfkill_state state);
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "brf6300";
-
-extern int sapphire_bt_fastclock_power(int on);
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		sapphire_bt_fastclock_power(1);
-		gpio_set_value(SAPPHIRE_GPIO_BT_32K_EN, 1);
-		udelay(10);
-		gpio_configure(101, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		gpio_configure(101, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-		gpio_set_value(SAPPHIRE_GPIO_BT_32K_EN, 0);
-		sapphire_bt_fastclock_power(0);
-		break;
-	default:
-		printk(KERN_ERR "bad bluetooth rfkill state %d\n", state);
-	}
-	return 0;
-}
-
-static int __init sapphire_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-
-	/* default to bluetooth off */
-	rfkill_switch_all(RFKILL_TYPE_BLUETOOTH, RFKILL_STATE_SOFT_BLOCKED);
-	bluetooth_set_power(NULL, RFKILL_STATE_SOFT_BLOCKED);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = RFKILL_STATE_SOFT_BLOCKED;
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;  /* user data */
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-
-	if (rc)
-		rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int sapphire_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver sapphire_rfkill_driver = {
-	.probe = sapphire_rfkill_probe,
-	.remove = sapphire_rfkill_remove,
-	.driver = {
-		.name = "sapphire_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init sapphire_rfkill_init(void)
-{
-	return platform_driver_register(&sapphire_rfkill_driver);
-}
-
-static void __exit sapphire_rfkill_exit(void)
-{
-	platform_driver_unregister(&sapphire_rfkill_driver);
-}
-
-module_init(sapphire_rfkill_init);
-module_exit(sapphire_rfkill_exit);
-MODULE_DESCRIPTION("sapphire rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-sapphire-wifi.c b/arch/arm/mach-msm/board-sapphire-wifi.c
deleted file mode 100644
index 43f827c..0000000
--- a/arch/arm/mach-msm/board-sapphire-wifi.c
+++ /dev/null
@@ -1,74 +0,0 @@
-/* arch/arm/mach-msm/board-sapphire-wifi.c
- *
- * Copyright (C) 2008 Google, Inc.
- * Author: Dmitry Shmidt <dimitrysh@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/vmalloc.h>
-#include <linux/err.h>
-#include <linux/wifi_tiwlan.h>
-
-extern int sapphire_wifi_set_carddetect(int val);
-extern int sapphire_wifi_power(int on);
-extern int sapphire_wifi_reset(int on);
-
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[WMPA_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WMPA_SECTION_SIZE_0 + WMPA_SECTION_HEADER) },
-	{ NULL, (WMPA_SECTION_SIZE_1 + WMPA_SECTION_HEADER) },
-	{ NULL, (WMPA_SECTION_SIZE_2 + WMPA_SECTION_HEADER) }
-};
-
-static void *sapphire_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if ((section < 0) || (section >= WMPA_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init sapphire_init_wifi_mem (void)
-{
-	int i;
-
-	for (i = 0; (i < WMPA_NUMBER_OF_SECTIONS); i++) {
-		wifi_mem_array[i].mem_ptr = vmalloc(wifi_mem_array[i].size);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-#endif
-
-struct wifi_platform_data sapphire_wifi_control = {
-	.set_power		= sapphire_wifi_power,
-	.set_reset		= sapphire_wifi_reset,
-	.set_carddetect		= sapphire_wifi_set_carddetect,
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-	.mem_prealloc		= sapphire_wifi_mem_prealloc,
-#else
-	.mem_prealloc		= NULL,
-#endif
-};
-
-#endif
diff --git a/arch/arm/mach-msm/board-sapphire.c b/arch/arm/mach-msm/board-sapphire.c
deleted file mode 100644
index c68440e..0000000
--- a/arch/arm/mach-msm/board-sapphire.c
+++ /dev/null
@@ -1,1259 +0,0 @@
-/* linux/arch/arm/mach-msm/board-sapphire.c
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Thomas Tsai <thomas_tsai@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/irq.h>
-#include <linux/keyreset.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/elan_i2c.h>
-#include <linux/akm8976.h>
-#include <linux/sysdev.h>
-
-#include <linux/delay.h>
-#include <linux/gpio.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/setup.h>
-
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-#include <linux/mmc/sdio_ids.h>
-
-#include <mach/system.h>
-#include <mach/gpio_chip.h>
-#include <mach/vreg.h>
-#include "board-sapphire.h"
-
-#include <mach/hardware.h>
-#include <mach/board_htc.h>
-#include <mach/msm_serial_hs.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/msm_fb.h>
-#include <mach/h2w_v1.h>
-#include <mach/microp_i2c.h>
-#include <mach/htc_battery.h>
-#include <mach/htc_pwrsink.h>
-#include <mach/perflock.h>
-#include <mach/drv_callback.h>
-
-
-#include "proc_comm.h"
-#include "devices.h"
-
-void msm_init_irq(void);
-void msm_init_gpio(void);
-void msm_init_pmic_vibrator(void);
-
-extern int sapphire_init_mmc(unsigned int);
-
-struct sapphire_axis_info {
-	struct gpio_event_axis_info info;
-	uint16_t in_state;
-	uint16_t out_state;
-	uint16_t temp_state;
-	uint16_t threshold;
-};
-static bool nav_just_on;
-static int nav_on_jiffies;
-static unsigned int hwid = 0;
-static unsigned int skuid = 0;
-static unsigned engineerid = (0x01 << 1);	/* default is 3M sensor */
-#if	defined(CONFIG_MSM_AMSS_SUPPORT_256MB_EBI1)
-static int smi_sz = 32;
-#else
-static int smi_sz = 64;
-#endif
-uint16_t sapphire_axis_map(struct gpio_event_axis_info *info, uint16_t in)
-{
-	struct sapphire_axis_info *ai = container_of(info, struct sapphire_axis_info, info);
-	uint16_t out = ai->out_state;
-
-	if (nav_just_on) {
-		if (jiffies == nav_on_jiffies || jiffies == nav_on_jiffies + 1)
-			goto ignore;
-		nav_just_on = 0;
-	}
-	if ((ai->in_state ^ in) & 1)
-		out--;
-	if ((ai->in_state ^ in) & 2)
-		out++;
-	ai->out_state = out;
-ignore:
-	ai->in_state = in;
-	if (ai->out_state - ai->temp_state == ai->threshold) {
-		ai->temp_state++;
-		ai->out_state = ai->temp_state;
-	} else if (ai->temp_state - ai->out_state == ai->threshold) {
-		ai->temp_state--;
-		ai->out_state = ai->temp_state;
-	} else if (abs(ai->out_state - ai->temp_state) > ai->threshold)
-		ai->temp_state = ai->out_state;
-
-	return ai->temp_state;
-}
-
-int sapphire_nav_power(const struct gpio_event_platform_data *pdata, bool on)
-{
-	gpio_set_value(SAPPHIRE_GPIO_JOG_EN, on);
-	if (on) {
-		nav_just_on = 1;
-		nav_on_jiffies = jiffies;
-	}
-	return 0;
-}
-
-static uint32_t sapphire_x_axis_gpios[] = {
-	SAPPHIRE_BALL_LEFT_0, SAPPHIRE_BALL_RIGHT_0
-};
-
-static struct sapphire_axis_info sapphire_x_axis = {
-	.threshold = 2,
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(sapphire_x_axis_gpios),
-		.type = EV_REL,
-		.code = REL_X,
-		.decoded_size = 1U << ARRAY_SIZE(sapphire_x_axis_gpios),
-		.map = sapphire_axis_map,
-		.gpio = sapphire_x_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION /*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT */
-	}
-};
-
-static uint32_t sapphire_y_axis_gpios[] = {
-	SAPPHIRE_BALL_UP_0, SAPPHIRE_BALL_DOWN_0
-};
-
-static struct sapphire_axis_info sapphire_y_axis = {
-	.threshold = 2,
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(sapphire_y_axis_gpios),
-		.type = EV_REL,
-		.code = REL_Y,
-		.decoded_size = 1U << ARRAY_SIZE(sapphire_y_axis_gpios),
-		.map = sapphire_axis_map,
-		.gpio = sapphire_y_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION /*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT  */
-	}
-};
-
-static struct gpio_event_direct_entry sapphire_nav_buttons[] = {
-	{ SAPPHIRE_GPIO_NAVI_ACT_N, BTN_MOUSE },
-};
-
-static struct gpio_event_input_info sapphire_nav_button_info = {
-	.info.func = gpio_event_input_func,
-	.flags = GPIOEDF_PRINT_KEYS | GPIOEDF_PRINT_KEY_DEBOUNCE,
-	.poll_time.tv.nsec = 40 * NSEC_PER_MSEC,
-	.type = EV_KEY,
-	.keymap = sapphire_nav_buttons,
-	.keymap_size = ARRAY_SIZE(sapphire_nav_buttons)
-};
-
-static struct gpio_event_info *sapphire_nav_info[] = {
-	&sapphire_x_axis.info.info,
-	&sapphire_y_axis.info.info,
-	&sapphire_nav_button_info.info
-};
-
-static struct gpio_event_platform_data sapphire_nav_data = {
-	.name = "sapphire-nav",
-	.info = sapphire_nav_info,
-	.info_count = ARRAY_SIZE(sapphire_nav_info),
-	.power = sapphire_nav_power,
-};
-
-static struct platform_device sapphire_nav_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 2,
-	.dev = {
-		.platform_data = &sapphire_nav_data,
-	},
-};
-
-/* a new search button to be a wake-up source */
-static struct gpio_event_direct_entry sapphire_search_button_v1[] = {
-	{ SAPPHIRE_GPIO_SEARCH_ACT_N, KEY_COMPOSE }, /* CPLD Key Search*/
-};
-
-static struct gpio_event_direct_entry sapphire_search_button_v2[] = {
-	{ SAPPHIRE_GPIO_SEARCH_ACT_N, KEY_HOME }, /* CPLD Key Home */
-};
-
-static struct gpio_event_input_info sapphire_search_button_info = {
-	.info.func = gpio_event_input_func,
-	/* .flags = GPIOEDF_PRINT_KEYS | GPIOEDF_PRINT_KEY_DEBOUNCE, */
-	.flags = 0,
-	.poll_time.tv.nsec = 40 * NSEC_PER_MSEC,
-	.type = EV_KEY,
-	.keymap = sapphire_search_button_v2,
-	.keymap_size = ARRAY_SIZE(sapphire_search_button_v2)
-};
-
-static struct gpio_event_info *sapphire_search_info[] = {
-	&sapphire_search_button_info.info
-};
-
-static struct gpio_event_platform_data sapphire_search_button_data = {
-	.name = "sapphire-nav-button",
-	.info = sapphire_search_info,
-	.info_count = ARRAY_SIZE(sapphire_search_info),
-};
-
-static struct platform_device sapphire_search_button_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 1,
-	.dev = {
-		.platform_data = &sapphire_search_button_data,
-	},
-};
-
-static int sapphire_reset_keys_up[] = {
-	BTN_MOUSE,
-	0
-};
-
-static struct keyreset_platform_data sapphire_reset_keys_pdata = {
-	.keys_up = sapphire_reset_keys_up,
-	.keys_down = {
-		KEY_SEND,
-		KEY_MENU,
-		KEY_END,
-		0
-	},
-};
-
-struct platform_device sapphire_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &sapphire_reset_keys_pdata,
-};
-static ssize_t htc_battery_show_attr(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf);
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.func_show_batt_attr = htc_battery_show_attr,
-	.guage_driver = GUAGE_MODEM,
-	.charger = LINEAR_CHARGER,
-	.m2a_cable_detect = 1,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-
-
-static int sapphire_ts_power(int on)
-{
-	int gpio_tp_ls_en = SAPPHIRE_TP_LS_EN;
-	if (is_sapphire_gpiov20())
-		gpio_tp_ls_en = SAPPHIRE20_TP_LS_EN;
-
-	if (on) {
-		sapphire_gpio_write(NULL, SAPPHIRE_GPIO_TP_EN, 1);
-		/* touchscreen must be powered before we enable i2c pullup */
-		msleep(2);
-		/* enable touch panel level shift */
-		gpio_set_value(gpio_tp_ls_en, 1);
-		msleep(2);
-	}
-	else {
-		gpio_set_value(gpio_tp_ls_en, 0);
-		sapphire_gpio_write(NULL, SAPPHIRE_GPIO_TP_EN, 0);
-	}
-
-	return 0;
-}
-
-static struct synaptics_i2c_rmi_platform_data sapphire_ts_data[] = {
-{
-		.version = 0x0101,
-		.power = sapphire_ts_power,
-		.sensitivity = 7,
-		.flags = SYNAPTICS_FLIP_Y | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = -50 * 0x10000 / 4334,
-		.inactive_right = -50 * 0x10000 / 4334,
-		.inactive_top = -40 * 0x10000 / 6696,
-		.inactive_bottom = -40 * 0x10000 / 6696,
-		.snap_left_on = 50 * 0x10000 / 4334,
-		.snap_left_off = 60 * 0x10000 / 4334,
-		.snap_right_on = 50 * 0x10000 / 4334,
-		.snap_right_off = 60 * 0x10000 / 4334,
-		.snap_top_on = 100 * 0x10000 / 6696,
-		.snap_top_off = 110 * 0x10000 / 6696,
-		.snap_bottom_on = 100 * 0x10000 / 6696,
-		.snap_bottom_off = 110 * 0x10000 / 6696,
-		.display_width = 320,
-		.display_height = 480,
-	},
-	{
-		.flags = SYNAPTICS_FLIP_Y | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = ((4674 - 4334) / 2 + 200) * 0x10000 / 4334,
-		.inactive_right = ((4674 - 4334) / 2 + 200) * 0x10000 / 4334,
-		.inactive_top = ((6946 - 6696) / 2) * 0x10000 / 6696,
-		.inactive_bottom = ((6946 - 6696) / 2) * 0x10000 / 6696,
-		.display_width = 320,
-		.display_height = 480,
-	}
-};
-
-static struct akm8976_platform_data compass_platform_data = {
-	.reset = SAPPHIRE_GPIO_COMPASS_RST_N,
-	.clk_on = SAPPHIRE_GPIO_COMPASS_32K_EN,
-	.intr = SAPPHIRE_GPIO_COMPASS_IRQ,
-};
-
-static struct elan_i2c_platform_data elan_i2c_data[] = {
-	{
-		.version = 0x104,
-		.abs_x_min = 0,
-		.abs_y_min = 0,
-		.intr_gpio = SAPPHIRE_GPIO_TP_ATT_N,
-		.power = sapphire_ts_power,
-		.display_width = 320,
-		.display_height = 480,
-	},
-	{
-		.version = 0x103,
-		.abs_x_min = 0,
-		.abs_x_max = 512 * 2,
-		.abs_y_min = 0,
-		.abs_y_max = 896 * 2,
-		.intr_gpio = SAPPHIRE_GPIO_TP_ATT_N,
-		.power = sapphire_ts_power,
-		.display_width = 320,
-		.display_height = 480,
-	},
-	{
-		.version = 0x102,
-		.abs_x_min = 0,
-		.abs_x_max = 384,
-		.abs_y_min = 0,
-		.abs_y_max = 576,
-		.intr_gpio = SAPPHIRE_GPIO_TP_ATT_N,
-		.power = sapphire_ts_power,
-		.display_width = 320,
-		.display_height = 480,
-	},
-	{
-		.version = 0x101,
-		.abs_x_min = 32 + 1,
-		.abs_x_max = 352 - 1,
-		.abs_y_min = 32 + 1,
-		.abs_y_max = 544 - 1,
-		.intr_gpio = SAPPHIRE_GPIO_TP_ATT_N,
-		.power = sapphire_ts_power,
-		.display_width = 320,
-		.display_height = 480,
-	}
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x20),
-		.platform_data = sapphire_ts_data,
-		.irq = SAPPHIRE_GPIO_TO_INT(SAPPHIRE_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO(ELAN_8232_I2C_NAME, 0x10),
-		.platform_data = &elan_i2c_data,
-		.irq = SAPPHIRE_GPIO_TO_INT(SAPPHIRE_GPIO_TP_ATT_N),
-	},
-	{
-		I2C_BOARD_INFO("akm8976", 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = SAPPHIRE_GPIO_TO_INT(SAPPHIRE_GPIO_COMPASS_IRQ),
-	},
-};
-
-static struct i2c_board_info i2c_mt9p012 = {
-	I2C_BOARD_INFO("mt9p012", 0x6C >> 1),
-};
-
-static struct i2c_board_info i2c_mt9t013 = {
-	I2C_BOARD_INFO("mt9t013", 0x6C >> 1),
-};
-
-#ifdef CONFIG_LEDS_CPLD
-static struct resource cpldled_resources[] = {
-	{
-		.start	= SAPPHIRE_CPLD_LED_BASE,
-		.end	= SAPPHIRE_CPLD_LED_BASE + SAPPHIRE_CPLD_LED_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device android_CPLD_leds = {
-	.name		= "leds-cpld",
-	.id			= -1,
-	.num_resources	= ARRAY_SIZE(cpldled_resources),
-	.resource	= cpldled_resources,
-};
-#endif
-
-static struct gpio_led android_led_list[] = {
-	{
-		.name = "button-backlight",
-		.gpio = SAPPHIRE_GPIO_APKEY_LED_EN,
-	},
-};
-
-static struct gpio_led_platform_data android_leds_data = {
-	.num_leds	= ARRAY_SIZE(android_led_list),
-	.leds		= android_led_list,
-};
-
-static struct platform_device android_leds = {
-	.name		= "leds-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data = &android_leds_data,
-	},
-};
-
-#ifdef CONFIG_HTC_HEADSET
-/* RTS/CTS to GPO/GPI. */
-static uint32_t uart1_on_gpio_table[] = {
-	/* allenou, uart hs test, 2008/11/18 */
-	#ifdef CONFIG_SERIAL_MSM_HS
-	/* RTS */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_UART1_RTS, 2,
-		      GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	/* CTS */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_UART1_CTS, 2,
-		      GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),
-	#else
-	/* RTS */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_UART1_RTS, 1,
-		      GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA),
-	/* CTS */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_UART1_CTS, 1,
-		      GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA),
-	#endif
-};
-
-/* RTS,CTS to BT. */
-static uint32_t uart1_off_gpio_table[] = {
-	/* RTS */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_UART1_RTS, 0,
-		      GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	/* CTS */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_UART1_CTS, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),
-};
-
-/* Sapphire: Switch between UART3 and GPIO */
-static uint32_t uart3_on_gpio_table[] = {
-	/* RX */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_UART3_RX, 1,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),
-	/* TX */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_UART3_TX, 1,
-		      GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-};
-
-/* set TX,RX to GPI */
-static uint32_t uart3_off_gpi_table[] = {
-	/* RX, H2W DATA */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_H2W_DATA, 0,
-		      GPIO_INPUT, GPIO_NO_PULL, GPIO_2MA),
-	/* TX, H2W CLK */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_H2W_CLK, 0,
-		      GPIO_INPUT, GPIO_KEEPER, GPIO_2MA),
-};
-
-/* set TX,RX to GPO */
-static uint32_t uart3_off_gpo_table[] = {
-	/* RX, H2W DATA */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_H2W_DATA, 0,
-		      GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	/* TX, H2W CLK */
-	PCOM_GPIO_CFG(SAPPHIRE_GPIO_H2W_CLK, 0,
-		      GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-};
-
-static int sapphire_h2w_path = H2W_GPIO;
-
-static void configure_cpld(int route)
-{
-	switch (route) {
-	case H2W_UART1:
-		/* Make sure uart1 funtion pin opened. */
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart1_on_gpio_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart1_on_gpio_table+1, 0);
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL0, 1);
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL1, 0);
-		sapphire_h2w_path = H2W_UART1;
-		printk(KERN_INFO "H2W route = H2W-UART1, BT-X, UART3-X \n");
-		break;
-	case H2W_BT:
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL0, 1);
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL1, 1);
-		/* UART1 RTS/CTS to GPO/GPI. */
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart1_off_gpio_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart1_off_gpio_table+1, 0);
-		sapphire_h2w_path = H2W_BT;
-		printk(KERN_INFO "H2W route = H2W-BT, UART1-X, UART3-X \n");
-		break;
-	case H2W_GPIO: /*H2W_UART3 TX,RX are changed to H2W_GPIO */
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL0, 0);
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL1, 0);
-		/* Set the CPLD connected H2W GPIO's to input */
-		gpio_set_value(SAPPHIRE_GPIO_H2W_CLK_DIR, 0);
-		gpio_set_value(SAPPHIRE_GPIO_H2W_DAT_DIR, 0);
-		/* TX,RX GPI first. */
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_off_gpi_table+1, 0);
-		/* Make sure uart1 funtion pin opened. */
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart1_on_gpio_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart1_on_gpio_table+1, 0);
-		sapphire_h2w_path = H2W_GPIO;
-		printk(KERN_INFO "H2W route = H2W-GPIO, BT-UART1 \n");
-		break;
-	case H2W_UART3:
-	default:
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_on_gpio_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart3_on_gpio_table+1, 0);
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL0, 0);
-		gpio_set_value(SAPPHIRE_GPIO_H2W_SEL1, 1);
-		/* Make sure uart1 funtion pin opened. */
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart1_on_gpio_table+0, 0);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX,
-			      uart1_on_gpio_table+1, 0);
-		sapphire_h2w_path = H2W_UART3;
-		printk(KERN_INFO "H2W route = H2W-UART3, BT-UART1 \n");
-		break;
-	}
-}
-
-static void h2w_defconfig(void)
-{
-	configure_cpld(H2W_GPIO);
-}
-
-static void set_h2w_dat(int n)
-{
-	gpio_set_value(SAPPHIRE_GPIO_H2W_DATA, n);
-}
-
-static void set_h2w_clk(int n)
-{
-	gpio_set_value(SAPPHIRE_GPIO_H2W_CLK, n);
-}
-
-static void set_h2w_dat_dir(int n)
-{
-	if (n == 0) /* input */
-		gpio_direction_input(SAPPHIRE_GPIO_H2W_DATA);
-	else
-		gpio_configure(SAPPHIRE_GPIO_H2W_DATA, GPIOF_DRIVE_OUTPUT);
-
-	gpio_set_value(SAPPHIRE_GPIO_H2W_DAT_DIR, n);
-
-}
-
-static void set_h2w_clk_dir(int n)
-{
-	if (n == 0) /* input */
-		gpio_direction_input(SAPPHIRE_GPIO_H2W_CLK);
-	else
-		gpio_configure(SAPPHIRE_GPIO_H2W_CLK, GPIOF_DRIVE_OUTPUT);
-
-	gpio_set_value(SAPPHIRE_GPIO_H2W_CLK_DIR, n);
-}
-
-static int get_h2w_dat(void)
-{
-	return gpio_get_value(SAPPHIRE_GPIO_H2W_DATA);
-}
-
-static int get_h2w_clk(void)
-{
-	return gpio_get_value(SAPPHIRE_GPIO_H2W_CLK);
-}
-
-#ifdef CONFIG_HTC_HEADSET
-static int set_h2w_path(const char *val, struct kernel_param *kp)
-{
-	int ret = -EINVAL;
-
-	ret = param_set_int(val, kp);
-	if (ret)
-		return ret;
-
-	switch (sapphire_h2w_path) {
-	case H2W_GPIO:
-	case H2W_UART1:
-	case H2W_UART3:
-	case H2W_BT:
-		break;
-	default:
-		sapphire_h2w_path = -1;
-		return -EINVAL;
-	}
-
-	configure_cpld(sapphire_h2w_path);
-	return ret;
-}
-module_param_call(h2w_path, set_h2w_path, param_get_int,
-		&sapphire_h2w_path, S_IWUSR | S_IRUGO);
-#endif
-
-static struct h2w_platform_data sapphire_h2w_data = {
-	.h2w_power		= SAPPHIRE_GPIO_H2W_POWER,
-	.cable_in1		= SAPPHIRE_GPIO_CABLE_IN1,
-	.cable_in2		= SAPPHIRE_GPIO_CABLE_IN2,
-	.h2w_clk		= SAPPHIRE_GPIO_H2W_CLK,
-	.h2w_data		= SAPPHIRE_GPIO_H2W_DATA,
-	.headset_mic_35mm	= SAPPHIRE_GPIO_AUD_HSMIC_DET_N,
-	.debug_uart 		= H2W_UART3,
-	.config 		= configure_cpld,
-	.defconfig 		= h2w_defconfig,
-	.set_dat		= set_h2w_dat,
-	.set_clk		= set_h2w_clk,
-	.set_dat_dir		= set_h2w_dat_dir,
-	.set_clk_dir		= set_h2w_clk_dir,
-	.get_dat		= get_h2w_dat,
-	.get_clk		= get_h2w_clk,
-};
-
-static struct platform_device sapphire_h2w = {
-	.name		= "h2w",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &sapphire_h2w_data,
-	},
-};
-#endif	//CONFIG_HTC_HEADSET
-
-static void sapphire_phy_reset(void)
-{
-	gpio_set_value(SAPPHIRE_GPIO_USB_PHY_RST_N, 0);
-	mdelay(10);
-	gpio_set_value(SAPPHIRE_GPIO_USB_PHY_RST_N, 1);
-	mdelay(10);
-}
-
-
-static struct pwr_sink sapphire_pwrsink_table[] = {
-	{
-		.id	= PWRSINK_AUDIO,
-		.ua_max	= 100000,
-	},
-	{
-		.id	= PWRSINK_BACKLIGHT,
-		.ua_max	= 125000,
-	},
-	{
-		.id	= PWRSINK_LED_BUTTON,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_LED_KEYBOARD,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_GP_CLK,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_BLUETOOTH,
-		.ua_max	= 15000,
-	},
-	{
-		.id	= PWRSINK_CAMERA,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_SDCARD,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_VIDEO,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id	= PWRSINK_SYSTEM_LOAD,
-		.ua_max	= 100000,
-		.percent_util = 38,
-	},
-};
-
-
-static struct pwr_sink_platform_data sapphire_pwrsink_data = {
-	.num_sinks	= ARRAY_SIZE(sapphire_pwrsink_table),
-	.sinks		= sapphire_pwrsink_table,
-};
-
-static struct platform_device sapphire_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev	= {
-		.platform_data = &sapphire_pwrsink_data,
-	},
-};
-
-static int sapphire_phy_init_seq[] = {0x40, 0x31, 0x1, 0x0D, 0x1, 0x10, -1};
-
-static struct platform_device sapphire_rfkill = {
-	.name = "sapphire_rfkill",
-	.id = -1,
-};
-
-static struct msm_pmem_setting pmem_setting_32 = {
-	.pmem_start = SMI32_MSM_PMEM_MDP_BASE,
-	.pmem_size = SMI32_MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = SMI32_MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = SMI32_MSM_PMEM_ADSP_SIZE,
-	.pmem_gpu0_start = MSM_PMEM_GPU0_BASE,
-	.pmem_gpu0_size = MSM_PMEM_GPU0_SIZE,
-	.pmem_gpu1_start = SMI32_MSM_PMEM_GPU1_BASE,
-	.pmem_gpu1_size = SMI32_MSM_PMEM_GPU1_SIZE,
-	.pmem_camera_start = SMI32_MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = SMI32_MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = SMI32_MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = SMI32_MSM_RAM_CONSOLE_SIZE,
-};
-
-static struct msm_pmem_setting pmem_setting_64 = {
-	.pmem_start = SMI64_MSM_PMEM_MDP_BASE,
-	.pmem_size = SMI64_MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = SMI64_MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = SMI64_MSM_PMEM_ADSP_SIZE,
-	.pmem_gpu0_start = MSM_PMEM_GPU0_BASE,
-	.pmem_gpu0_size = MSM_PMEM_GPU0_SIZE,
-	.pmem_gpu1_start = SMI64_MSM_PMEM_GPU1_BASE,
-	.pmem_gpu1_size = SMI64_MSM_PMEM_GPU1_SIZE,
-	.pmem_camera_start = SMI64_MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = SMI64_MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = SMI64_MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = SMI64_MSM_RAM_CONSOLE_SIZE,
-};
-
-static struct msm_i2c_device_platform_data sapphire_i2c_device_data = {
-	.i2c_clock = 100000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_4MA,
-};
-
-#ifdef CONFIG_MSM_CAMERA
-void config_sapphire_camera_on_gpios(void);
-void config_sapphire_camera_on_gpios(void);
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_sapphire_camera_on_gpios,
-	.camera_gpio_off = config_sapphire_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-#ifdef CONFIG_MT9T013
-static struct msm_camera_sensor_info msm_camera_sensor_mt9t013_data = {
-	.sensor_name    = "mt9t013",
-	.sensor_reset   = 108,
-	.sensor_pwd     = 85,
-	.vcm_pwd        = SAPPHIRE_GPIO_VCM_PWDN,
-	.pdata          = &msm_camera_device_data,
-};
-
-static struct platform_device msm_camera_sensor_mt9t013 = {
-	.name           = "msm_camera_mt9t013",
-	.dev            = {
-		.platform_data = &msm_camera_sensor_mt9t013_data,
-	},
-};
-#endif
-
-#ifdef CONFIG_MT9P012
-static struct msm_camera_sensor_info msm_camera_sensor_mt9p012_data = {
-	.sensor_name	= "mt9p012",
-	.sensor_reset	= 108,
-	.sensor_pwd	= 85,
-	.vcm_pwd        = SAPPHIRE_GPIO_VCM_PWDN,
-	.pdata		= &msm_camera_device_data,
-};
-
-static struct platform_device msm_camera_sensor_mt9p012 = {
-	.name           = "msm_camera_mt9p012",
-	.dev            = {
-		.platform_data = &msm_camera_sensor_mt9p012_data,
-	},
-};
-#endif
-
-#endif/*CONFIG_MSM_CAMERA*/
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_i2c,
-	&htc_battery_pdev,
-	&sapphire_nav_device,
-	&sapphire_search_button_device,
-	&sapphire_reset_keys_device,
-	&android_leds,
-#ifdef CONFIG_LEDS_CPLD
-	&android_CPLD_leds,
-#endif
-#ifdef CONFIG_MT9T013
-	&msm_camera_sensor_mt9t013,
-#endif
-#ifdef CONFIG_MT9P012
-	&msm_camera_sensor_mt9p012,
-#endif
-	&sapphire_rfkill,
-
-#ifdef CONFIG_HTC_PWRSINK
-	&sapphire_pwr_sink,
-#endif
-};
-
-extern struct sys_timer msm_timer;
-
-static void __init sapphire_init_irq(void)
-{
-	printk(KERN_DEBUG "sapphire_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint cpld_iset;
-static uint cpld_charger_en;
-static uint cpld_usb_h2w_sw;
-static uint opt_disable_uart3;
-
-module_param_named(iset, cpld_iset, uint, 0);
-module_param_named(charger_en, cpld_charger_en, uint, 0);
-module_param_named(usb_h2w_sw, cpld_usb_h2w_sw, uint, 0);
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-static char bt_chip_id[10] = "brfxxxx";
-module_param_string(bt_chip_id, bt_chip_id, sizeof(bt_chip_id), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_chip_id, "BT's chip id");
-
-static char bt_fw_version[10] = "v2.0.38";
-module_param_string(bt_fw_version, bt_fw_version, sizeof(bt_fw_version), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bt_fw_version, "BT's fw version");
-
-static void sapphire_reset(void)
-{
-	gpio_set_value(SAPPHIRE_GPIO_PS_HOLD, 0);
-}
-
-static uint32_t gpio_table[] = {
-	/* BLUETOOTH */
-#ifdef CONFIG_SERIAL_MSM_HS
-	PCOM_GPIO_CFG(43, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* RTS */
-	PCOM_GPIO_CFG(44, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* CTS */
-	PCOM_GPIO_CFG(45, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* RX */
-	PCOM_GPIO_CFG(46, 3, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* TX */
-#else
-	PCOM_GPIO_CFG(43, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* RTS */
-	PCOM_GPIO_CFG(44, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* CTS */
-	PCOM_GPIO_CFG(45, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* RX */
-	PCOM_GPIO_CFG(46, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* TX */
-#endif
-};
-
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-static uint32_t camera_off_gpio_12pins_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_12pins_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-void config_sapphire_camera_on_gpios(void)
-{
-	/*Add for judage it's 10 pins or 12 pins platform ----->*/
-	if  (is_12pin_camera()) {
-		config_gpio_table(camera_on_gpio_12pins_table,
-				ARRAY_SIZE(camera_on_gpio_12pins_table));
-	} else {
-		config_gpio_table(camera_on_gpio_table,
-				ARRAY_SIZE(camera_on_gpio_table));
-	}
-	/*End Of Add for judage it's 10 pins or 12 pins platform*/
-}
-
-void config_sapphire_camera_off_gpios(void)
-{
-	/*Add for judage it's 10 pins or 12 pins platform ----->*/
-	if (is_12pin_camera()) {
-		config_gpio_table(camera_off_gpio_12pins_table,
-		ARRAY_SIZE(camera_off_gpio_12pins_table));
-	} else {
-		config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-	}
-	/*End Of Add for judage it's 10 pins or 12 pins platform*/
-}
-
-static void __init config_gpios(void)
-{
-	config_gpio_table(gpio_table, ARRAY_SIZE(gpio_table));
-	config_sapphire_camera_off_gpios();
-}
-
-static struct msm_acpu_clock_platform_data sapphire_clock_data = {
-	.acpu_switch_time_us = 20,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200000,
-#if defined(CONFIG_TURBO_MODE)
-	.wait_for_irq_khz = 176000000,
-#else
-	.wait_for_irq_khz = 128000000,
-#endif
-};
-
-static unsigned sapphire_perf_acpu_table[] = {
-	245760000,
-	480000000,
-	528000000,
-};
-
-static struct perflock_platform_data sapphire_perflock_data = {
-	.perf_acpu_table = sapphire_perf_acpu_table,
-	.table_size = ARRAY_SIZE(sapphire_perf_acpu_table),
-};
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(45),
-	.inject_rx_on_wakeup = 1,
-	.rx_to_inject = 0x32,
-	.cpu_lock_supported = 1,
-};
-#endif
-
-static void __init sapphire_init(void)
-{
-	int rc;
-	printk("sapphire_init() revision = 0x%X\n", system_rev);
-	config_gpios();
-
-	msm_hw_reset_hook = sapphire_reset;
-
-	msm_acpu_clock_init(&sapphire_clock_data);
-	perflock_init(&sapphire_perflock_data);
-
-	/* adjust GPIOs based on bootloader request */
-	printk("sapphire_init: cpld_usb_hw2_sw = %d\n", cpld_usb_h2w_sw);
-	gpio_set_value(SAPPHIRE_GPIO_USB_H2W_SW, cpld_usb_h2w_sw);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-				      &msm_device_uart3.dev, 1, INT_UART3_RX);
-#endif
-
-	/* H2W pins <-> UART3, Bluetooth <-> UART1 */
-	gpio_set_value(SAPPHIRE_GPIO_H2W_SEL0, 0);
-	gpio_set_value(SAPPHIRE_GPIO_H2W_SEL1, 1);
-	/* put the AF VCM in powerdown mode to avoid noise */
-	if (sapphire_is_5M_camera())
-		sapphire_gpio_write(NULL, SAPPHIRE_GPIO_VCM_PWDN, 0);
-	else
-		sapphire_gpio_write(NULL, SAPPHIRE_GPIO_VCM_PWDN, 1);
-	mdelay(100);
-	msm_add_devices();
-
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_add_serial_devices(MSM_SERIAL_UART1DM);
-	#else
-	msm_add_serial_devices(MSM_SERIAL_UART1);
-#endif
-
-	msm_add_serial_devices(MSM_SERIAL_UART3);
-
-	msm_register_usb_phy_init_seq(sapphire_phy_init_seq);
-	msm_add_usb_devices(sapphire_phy_reset, NULL);
-
-	if (32 == smi_sz)
-		msm_add_mem_devices(&pmem_setting_32);
-	else
-		msm_add_mem_devices(&pmem_setting_64);
-
-	msm_init_pmic_vibrator();
-
-	rc = sapphire_init_mmc(system_rev);
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-
-	msm_device_i2c.dev.platform_data = &sapphire_i2c_device_data;
-
-	if( (sapphire_get_skuid() != 0x22800) &&
-		(system_rev != 0x80) &&
-		((sapphire_get_skuid() & 0xFFFFFF00) != 0x00021400) &&
-		(sapphire_get_skuid() != 0x1E303) &&
-		(sapphire_get_skuid() != 0x1FF01))
-		sapphire_search_button_info.keymap = sapphire_search_button_v1;
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-	if  (sapphire_is_5M_camera())
-		i2c_register_board_info(0, &i2c_mt9p012, 1);
-	else
-		i2c_register_board_info(0, &i2c_mt9t013, 1);
-
-	if (is_sapphire_gpiov20())
-		gpio_direction_output(SAPPHIRE20_TP_LS_EN, 0);
-	else
-		gpio_direction_output(SAPPHIRE_TP_LS_EN, 0);
-}
-
-static struct map_desc sapphire_io_desc[] __initdata = {
-	{
-		.virtual = SAPPHIRE_CPLD_BASE,
-		.pfn     = __phys_to_pfn(SAPPHIRE_CPLD_START),
-		.length  = SAPPHIRE_CPLD_SIZE,
-		.type    = MT_DEVICE_NONSHARED
-	}
-};
-
-
-unsigned int sapphire_get_hwid(void)
-{
-	printk("sapphire_get_hwid=0x%x\r\n", hwid);
-	return hwid;
-}
-
-unsigned int sapphire_get_skuid(void)
-{
-	printk("sapphire_get_skuid=0x%x\r\n", skuid);
-	return skuid;
-}
-
-unsigned sapphire_engineerid(void)
-{
-	printk("sapphire_engineerid=0x%x\r\n", engineerid);
-	return engineerid;
-}
-
-int sapphire_is_5M_camera(void)
-{
-	int ret = 0;
-	if (sapphire_get_skuid() == 0x1FF00 && !(sapphire_engineerid() & 0x02))
-		ret = 1;
-	else if (sapphire_get_skuid() == 0x20100 && !(sapphire_engineerid() & 0x02))
-		ret = 1;
-	printk("sapphire_is_5M_camera=%d\n", ret);
-	return ret;
-}
-
-/* it can support 3M and 5M sensor */
-unsigned int is_12pin_camera(void)
-{
-	unsigned int ret = 0;
-
-    if (sapphire_get_skuid() == 0x1FF00 ||
-    	sapphire_get_skuid() == 0x20100)
-		ret = 1;
-	else
-		ret = 0;
-    printk("is_12pin_camera=%d\r\n", ret);
-	return ret;
-}
-
-unsigned int is_sapphire_gpiov20(void)
-{
-    unsigned int ret = 0;
-
-    if (sapphire_get_skuid() == 0x1FF00 ||
-    	sapphire_get_skuid() == 0x20100 ||
-    	sapphire_get_skuid() == 0x22800
-    	)
-        ret = 1;
-    else
-        ret = 0;
-    printk("is_sapphire_gpiov20=%d\r\n", ret);
-    return ret;
-}
-
-int sapphire_get_smi_size(void)
-{
-	printk(KERN_DEBUG "get_smi_size=%d\n", smi_sz);
-	return smi_sz;
-}
-
-static void __init sapphire_fixup(struct machine_desc *desc, struct tag *tags,
-				  char **cmdline, struct meminfo *mi)
-{
-	smi_sz = parse_tag_smi((const struct tag *)tags);
-	printk("sapphire_fixup:smisize=%d\n", smi_sz);
-	hwid = parse_tag_hwid((const struct tag *)tags);
-	printk("sapphire_fixup:hwid=0x%x\n", hwid);
-	skuid = parse_tag_skuid((const struct tag *)tags);
-	printk("sapphire_fixup:skuid=0x%x\n", skuid);
-	engineerid = parse_tag_engineerid((const struct tag *)tags);
-	printk("sapphire_fixup:engineerid=0x%x\n", engineerid);
-
-	mi->nr_banks = 1;
-	mi->bank[0].start = PHYS_OFFSET;
-	mi->bank[0].node = PHYS_TO_NID(PHYS_OFFSET);
-#if	defined(CONFIG_MSM_AMSS_SUPPORT_256MB_EBI1)
-	if (32 == smi_sz) {
-		mi->bank[0].size = MSM_EBI_SMI32_256MB_SIZE;
-	} else if (64 == smi_sz){
-		mi->bank[0].size = MSM_EBI_SMI64_128MB_SIZE;
-	} else {
-		printk(KERN_ERR "can not get smi size\n");
-
-		/*Give a default value when not get smi size*/
-		smi_sz = 64;
-		mi->bank[0].size = MSM_EBI_SMI64_128MB_SIZE;
-		printk(KERN_ERR "use default  :  smisize=%d\n", smi_sz);
-	}
-#else
-	if (32 == smi_sz) {
-		mi->bank[0].size = (84*1024*1024);
-	} else if (64 == smi_sz){
-		mi->bank[0].size = SMI64_MSM_LINUX_SIZE;	//(101*1024*1024);
-	} else {
-		printk(KERN_ERR "can not get smi size\n");
-
-		/*Give a default value when not get smi size*/
-		smi_sz = 64;
-		mi->bank[0].size = SMI64_MSM_LINUX_SIZE;	//(101*1024*1024);
-		printk(KERN_ERR "use default  :  smisize=%d\n", smi_sz);
-	}
-#endif
-	printk("sapphire_fixup:bank size=0x%x\n", mi->bank[0].size);
-}
-
-static void __init sapphire_map_io(void)
-{
-	msm_map_common_io();
-	iotable_init(sapphire_io_desc, ARRAY_SIZE(sapphire_io_desc));
-	msm_clock_init();
-}
-
-MACHINE_START(SAPPHIRE, "sapphire")
-/* Maintainer: Brian Swetland <swetland@google.com> */
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-#if defined(CONFIG_MSM_AMSS_SUPPORT_256MB_EBI1)
-	.boot_params    = 0x19200100,
-#else
-	.boot_params    = 0x10000100,
-#endif
-	.fixup          = sapphire_fixup,
-	.map_io         = sapphire_map_io,
-	.init_irq       = sapphire_init_irq,
-	.init_machine   = sapphire_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-sapphire.h b/arch/arm/mach-msm/board-sapphire.h
deleted file mode 100644
index e2cd665..0000000
--- a/arch/arm/mach-msm/board-sapphire.h
+++ /dev/null
@@ -1,266 +0,0 @@
-/* linux/arch/arm/mach-msm/board-sapphire.h
- * Copyright (C) 2007-2009 HTC Corporation.
- * Author: Thomas Tsai <thomas_tsai@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_SAPPHIRE_H
-#define __ARCH_ARM_MACH_MSM_BOARD_SAPPHIRE_H
-
-#include <mach/board.h>
-
-#define MSM_SMI_BASE		0x00000000
-#define MSM_SMI_SIZE		0x00800000
-
-#define MSM_PMEM_GPU0_BASE	0x00000000
-#define MSM_PMEM_GPU0_SIZE	0x00700000
-
-#if defined(CONFIG_MSM_AMSS_SUPPORT_256MB_EBI1)
-/* AMSS supports unified 128/256MB EBI1 */
-#define MSM_EBI_BASE				0x19200000
-#define MSM_EBI_SMI64_128MB_SIZE	0x06600000
-#define MSM_EBI_SMI32_256MB_SIZE	0x0C600000
-
-#define SMI64_MSM_FB_BASE			0x00700000
-#define SMI64_MSM_FB_SIZE			0x0009B000
-
-#define SMI64_MSM_RAM_CONSOLE_BASE	0x007A0000
-#define SMI64_MSM_RAM_CONSOLE_SIZE	128 * SZ_1K
-
-#define SMI64_MSM_PMEM_MDP_BASE		0x02000000
-#define SMI64_MSM_PMEM_MDP_SIZE		0x00800000
-
-#define SMI64_MSM_PMEM_ADSP_BASE    0x02800000
-#define SMI64_MSM_PMEM_ADSP_SIZE	0x00800000
-
-#define SMI64_MSM_PMEM_CAMERA_BASE	0x03000000
-#define SMI64_MSM_PMEM_CAMERA_SIZE	0x01000000
-
-#define SMI64_MSM_PMEM_GPU1_BASE	0x1F800000
-#define SMI64_MSM_PMEM_GPU1_SIZE	0x800000
-
-#define SMI32_MSM_FB_BASE			0x00700000
-#define SMI32_MSM_FB_SIZE			0x0009B000
-
-#define SMI32_MSM_RAM_CONSOLE_BASE	0x007A0000
-#define SMI32_MSM_RAM_CONSOLE_SIZE	128 * SZ_1K
-
-#define SMI32_MSM_PMEM_GPU1_BASE	0x25800000
-#define SMI32_MSM_PMEM_GPU1_SIZE	0x00800000
-
-#define SMI32_MSM_PMEM_MDP_BASE		0x26000000
-#define SMI32_MSM_PMEM_MDP_SIZE		0x00800000
-
-#define SMI32_MSM_PMEM_ADSP_BASE	0x26800000
-#define SMI32_MSM_PMEM_ADSP_SIZE	0x00800000
-
-#define SMI32_MSM_PMEM_CAMERA_BASE	0x27000000
-#define SMI32_MSM_PMEM_CAMERA_SIZE	0x01000000
-
-#else
-/* AMSS supports only 128MB EBI1. */
-#define SMI64_MSM_FB_BASE			0x00700000
-#define SMI64_MSM_FB_SIZE			0x00100000
-
-#define SMI64_MSM_PMEM_MDP_BASE		0x02000000
-#define SMI64_MSM_PMEM_MDP_SIZE		0x00800000
-
-#define SMI64_MSM_PMEM_ADSP_BASE    0x02800000
-#define SMI64_MSM_PMEM_ADSP_SIZE	0x00800000
-
-#define SMI64_MSM_PMEM_CAMERA_BASE	0x03000000
-#define SMI64_MSM_PMEM_CAMERA_SIZE	0x01000000
-
-#define SMI64_MSM_LINUX_BASE		MSM_EBI_BASE
-#define SMI64_MSM_LINUX_SIZE		0x06500000
-
-#define SMI64_MSM_RAM_CONSOLE_BASE	MSM_EBI_BASE + 0x06D00000
-#define SMI64_MSM_RAM_CONSOLE_SIZE	128 * SZ_1K
-
-#define SMI64_MSM_PMEM_GPU1_SIZE	0x800000
-#define SMI64_MSM_PMEM_GPU1_BASE	(SMI64_MSM_RAM_CONSOLE_BASE - SMI64_MSM_PMEM_GPU1_SIZE)
-
-#define SMI32_MSM_LINUX_BASE		MSM_EBI_BASE
-#define SMI32_MSM_LINUX_SIZE		0x5400000
-
-#define SMI32_MSM_PMEM_MDP_BASE		(SMI32_MSM_LINUX_BASE + SMI32_MSM_LINUX_SIZE)
-#define SMI32_MSM_PMEM_MDP_SIZE		0x800000
-
-#define SMI32_MSM_PMEM_ADSP_BASE	(SMI32_MSM_PMEM_MDP_BASE + SMI32_MSM_PMEM_MDP_SIZE)
-#define SMI32_MSM_PMEM_ADSP_SIZE	0x800000
-
-#define SMI32_MSM_FB_BASE			(SMI32_MSM_PMEM_ADSP_BASE + SMI32_MSM_PMEM_ADSP_SIZE)
-#define SMI32_MSM_FB_SIZE			0x9b000
-
-#define SMI32_MSM_RAM_CONSOLE_BASE	(MSM_EBI_BASE + 0x6d00000)
-#define SMI32_MSM_RAM_CONSOLE_SIZE	128 * SZ_1K
-
-#define SMI32_MSM_PMEM_GPU1_SIZE	0x800000
-#define SMI32_MSM_PMEM_GPU1_BASE	(SMI32_MSM_RAM_CONSOLE_BASE - SMI32_MSM_PMEM_GPU1_SIZE)
-
-#define SMI32_MSM_PMEM_CAMERA_BASE	0
-#define SMI32_MSM_PMEM_CAMERA_SIZE	0
-
-#endif
-
-#define DECLARE_MSM_IOMAP
-#include <mach/msm_iomap.h>
-
-/*
-** SOC GPIO
-*/
-#define SAPPHIRE_BALL_UP_0     94
-#define SAPPHIRE_BALL_LEFT_0   18
-#define SAPPHIRE_BALL_DOWN_0   49
-#define SAPPHIRE_BALL_RIGHT_0  19
-
-#define SAPPHIRE_POWER_KEY     20
-#define SAPPHIRE_VOLUME_UP     36
-#define SAPPHIRE_VOLUME_DOWN   39
-
-#define SAPPHIRE_GPIO_PS_HOLD   (25)
-#define SAPPHIRE_MDDI_1V5_EN	(28)
-#define SAPPHIRE_BL_PWM			(27)
-#define SAPPHIRE_TP_LS_EN    	(1)
-#define SAPPHIRE20_TP_LS_EN			(88)
-
-/* H2W */
-#define SAPPHIRE_GPIO_CABLE_IN1		(83)
-#define SAPPHIRE_GPIO_CABLE_IN2		(37)
-#define SAPPHIRE_GPIO_UART3_RX		(86)
-#define SAPPHIRE_GPIO_UART3_TX		(87)
-#define SAPPHIRE_GPIO_H2W_DATA		(86)
-#define SAPPHIRE_GPIO_H2W_CLK		(87)
-#define SAPPHIRE_GPIO_AUD_EXTMIC_SEL    (33)
-#define SAPPHIRE_GPIO_35MM_HEADSET_DET  (90)
-#define SAPPHIRE_GPIO_UART1_RTS		(43)
-#define SAPPHIRE_GPIO_UART1_CTS		(44)
-
-#define SAPPHIRE_GPIO_H2W_POWER		(513)
-#define SAPPHIRE_H2W_POWER_NAME		"wlan"
-/*
-** CPLD GPIO
-**
-** Sapphire Altera CPLD can keep the registers value and
-** doesn't need a shadow to backup.
-**/
-#define SAPPHIRE_CPLD_BASE   0xE8100000	/* VA */
-#define SAPPHIRE_CPLD_START  0x98000000	/* PA */
-#define SAPPHIRE_CPLD_SIZE   SZ_4K
-
-#define SAPPHIRE_GPIO_START (128)				/* Pseudo GPIO number */
-
-/* Sapphire has one INT BANK only. */
-#define SAPPHIRE_GPIO_INT_B0_MASK_REG           (0x0c)	/*INT3 MASK*/
-#define SAPPHIRE_GPIO_INT_B0_STAT_REG           (0x0e)	/*INT1 STATUS*/
-
-/* LED control register */
-#define SAPPHIRE_CPLD_LED_BASE									(SAPPHIRE_CPLD_BASE + 0x10)		/* VA */
-#define SAPPHIRE_CPLD_LED_START									(SAPPHIRE_CPLD_START + 0x10)	/* PA */
-#define SAPPHIRE_CPLD_LED_SIZE									0x08
-
-/* MISCn: GPO pin to Enable/Disable some functions. */
-#define SAPPHIRE_GPIO_MISC1_BASE               	(SAPPHIRE_GPIO_START + 0x00)
-#define SAPPHIRE_GPIO_MISC2_BASE               	(SAPPHIRE_GPIO_START + 0x08)
-#define SAPPHIRE_GPIO_MISC3_BASE               	(SAPPHIRE_GPIO_START + 0x10)
-#define SAPPHIRE_GPIO_MISC4_BASE               	(SAPPHIRE_GPIO_START + 0x18)
-#define SAPPHIRE_GPIO_MISC5_BASE               	(SAPPHIRE_GPIO_START + 0x20)
-
-/* INT BANK0: INT1: int status, INT2: int level, INT3: int Mask */
-#define SAPPHIRE_GPIO_INT_B0_BASE              	(SAPPHIRE_GPIO_START + 0x28)
-
-/* MISCn GPIO: */
-#define SAPPHIRE_GPIO_CPLD128_VER_0            	(SAPPHIRE_GPIO_MISC1_BASE + 4)
-#define SAPPHIRE_GPIO_CPLD128_VER_1            	(SAPPHIRE_GPIO_MISC1_BASE + 5)
-#define SAPPHIRE_GPIO_CPLD128_VER_2            	(SAPPHIRE_GPIO_MISC1_BASE + 6)
-#define SAPPHIRE_GPIO_CPLD128_VER_3            	(SAPPHIRE_GPIO_MISC1_BASE + 7)
-
-#define SAPPHIRE_GPIO_H2W_DAT_DIR              	(SAPPHIRE_GPIO_MISC2_BASE + 2)
-#define SAPPHIRE_GPIO_H2W_CLK_DIR              	(SAPPHIRE_GPIO_MISC2_BASE + 3)
-#define SAPPHIRE_GPIO_H2W_SEL0                 	(SAPPHIRE_GPIO_MISC2_BASE + 6)
-#define SAPPHIRE_GPIO_H2W_SEL1                 	(SAPPHIRE_GPIO_MISC2_BASE + 7)
-
-#define SAPPHIRE_GPIO_I2C_PULL                 	(SAPPHIRE_GPIO_MISC3_BASE + 2)
-#define SAPPHIRE_GPIO_TP_EN                    	(SAPPHIRE_GPIO_MISC3_BASE + 4)
-#define SAPPHIRE_GPIO_JOG_EN                   	(SAPPHIRE_GPIO_MISC3_BASE + 5)
-#define SAPPHIRE_GPIO_JOG_LED_EN               	(SAPPHIRE_GPIO_MISC3_BASE + 6)
-#define SAPPHIRE_GPIO_APKEY_LED_EN             	(SAPPHIRE_GPIO_MISC3_BASE + 7)
-
-#define SAPPHIRE_GPIO_VCM_PWDN                 	(SAPPHIRE_GPIO_MISC4_BASE + 0)
-#define SAPPHIRE_GPIO_USB_H2W_SW               	(SAPPHIRE_GPIO_MISC4_BASE + 1)
-#define SAPPHIRE_GPIO_COMPASS_RST_N            	(SAPPHIRE_GPIO_MISC4_BASE + 2)
-#define SAPPHIRE_GPIO_USB_PHY_RST_N            	(SAPPHIRE_GPIO_MISC4_BASE + 5)
-#define SAPPHIRE_GPIO_WIFI_PA_RESETX           	(SAPPHIRE_GPIO_MISC4_BASE + 6)
-#define SAPPHIRE_GPIO_WIFI_EN                  	(SAPPHIRE_GPIO_MISC4_BASE + 7)
-
-#define SAPPHIRE_GPIO_BT_32K_EN                	(SAPPHIRE_GPIO_MISC5_BASE + 0)
-#define SAPPHIRE_GPIO_MAC_32K_EN               	(SAPPHIRE_GPIO_MISC5_BASE + 1)
-#define SAPPHIRE_GPIO_MDDI_32K_EN              	(SAPPHIRE_GPIO_MISC5_BASE + 2)
-#define SAPPHIRE_GPIO_COMPASS_32K_EN           	(SAPPHIRE_GPIO_MISC5_BASE + 3)
-
-/* INT STATUS/LEVEL/MASK : INT GPIO should be the last. */
-#define SAPPHIRE_GPIO_NAVI_ACT_N           		(SAPPHIRE_GPIO_INT_B0_BASE + 0)
-#define SAPPHIRE_GPIO_COMPASS_IRQ         		(SAPPHIRE_GPIO_INT_B0_BASE + 1)
-#define SAPPHIRE_GPIO_SEARCH_ACT_N			(SAPPHIRE_GPIO_INT_B0_BASE + 2)
-#define SAPPHIRE_GPIO_AUD_HSMIC_DET_N      		(SAPPHIRE_GPIO_INT_B0_BASE + 3)
-#define SAPPHIRE_GPIO_SDMC_CD_N      			(SAPPHIRE_GPIO_INT_B0_BASE + 4)
-#define SAPPHIRE_GPIO_CAM_BTN_STEP1_N          	(SAPPHIRE_GPIO_INT_B0_BASE + 5)
-#define SAPPHIRE_GPIO_CAM_BTN_STEP2_N          	(SAPPHIRE_GPIO_INT_B0_BASE + 6)
-#define SAPPHIRE_GPIO_TP_ATT_N            		(SAPPHIRE_GPIO_INT_B0_BASE + 7)
-
-#define	SAPPHIRE_GPIO_END						SAPPHIRE_GPIO_TP_ATT_N
-#define	SAPPHIRE_GPIO_LAST_INT					(SAPPHIRE_GPIO_TP_ATT_N)
-
-/* Bit position in the CPLD MISCn by the CPLD GPIOn: only bit0-7 is used. */
-#define	CPLD_GPIO_BIT_POS_MASK(n)		(1U << ((n) & 7))
-#define	CPLD_GPIO_REG_OFFSET(n)			_g_CPLD_MISCn_Offset[((n)-SAPPHIRE_GPIO_START) >> 3]
-#define	CPLD_GPIO_REG(n)				(CPLD_GPIO_REG_OFFSET(n) + SAPPHIRE_CPLD_BASE)
-
-/*
-** CPLD INT Start
-*/
-#define SAPPHIRE_INT_START 					(NR_MSM_IRQS + NR_GPIO_IRQS)	/* pseudo number for CPLD INT */
-/* Using INT status/Bank0 for GPIO to INT */
-#define	SAPPHIRE_GPIO_TO_INT(n)				((n-SAPPHIRE_GPIO_INT_B0_BASE) + SAPPHIRE_INT_START)
-#define SAPPHIRE_INT_END 					(SAPPHIRE_GPIO_TO_INT(SAPPHIRE_GPIO_END))
-
-/* get the INT reg by GPIO number */
-#define	CPLD_INT_GPIO_TO_BANK(n)			(((n)-SAPPHIRE_GPIO_INT_B0_BASE) >> 3)
-#define	CPLD_INT_STATUS_REG_OFFSET_G(n)		_g_INT_BANK_Offset[CPLD_INT_GPIO_TO_BANK(n)][0]
-#define	CPLD_INT_LEVEL_REG_OFFSET_G(n)		_g_INT_BANK_Offset[CPLD_INT_GPIO_TO_BANK(n)][1]
-#define	CPLD_INT_MASK_REG_OFFSET_G(n)		_g_INT_BANK_Offset[CPLD_INT_GPIO_TO_BANK(n)][2]
-#define	CPLD_INT_STATUS_REG_G(n)			(SAPPHIRE_CPLD_BASE + CPLD_INT_STATUS_REG_OFFSET_G(n))
-#define	CPLD_INT_LEVEL_REG_G(n)				(SAPPHIRE_CPLD_BASE + CPLD_INT_LEVEL_REG_OFFSET_G(n))
-#define	CPLD_INT_MASK_REG_G(n)				(SAPPHIRE_CPLD_BASE + CPLD_INT_MASK_REG_OFFSET_G(n))
-
-/* get the INT reg by INT number */
-#define	CPLD_INT_TO_BANK(i)					((i-SAPPHIRE_INT_START) >> 3)
-#define	CPLD_INT_STATUS_REG_OFFSET(i)		_g_INT_BANK_Offset[CPLD_INT_TO_BANK(i)][0]
-#define	CPLD_INT_LEVEL_REG_OFFSET(i)		_g_INT_BANK_Offset[CPLD_INT_TO_BANK(i)][1]
-#define	CPLD_INT_MASK_REG_OFFSET(i)			_g_INT_BANK_Offset[CPLD_INT_TO_BANK(i)][2]
-#define	CPLD_INT_STATUS_REG(i)				(SAPPHIRE_CPLD_BASE + CPLD_INT_STATUS_REG_OFFSET(i))
-#define	CPLD_INT_LEVEL_REG(i)				(SAPPHIRE_CPLD_BASE + CPLD_INT_LEVEL_REG_OFFSET(i))
-#define	CPLD_INT_MASK_REG(i)				(SAPPHIRE_CPLD_BASE + CPLD_INT_MASK_REG_OFFSET(i) )
-
-/* return the bit mask by INT number */
-#define SAPPHIRE_INT_BIT_MASK(i) 			(1U << ((i - SAPPHIRE_INT_START) & 7))
-
-void config_sapphire_camera_on_gpios(void);
-void config_sapphire_camera_off_gpios(void);
-int sapphire_get_smi_size(void);
-unsigned int sapphire_get_hwid(void);
-unsigned int sapphire_get_skuid(void);
-unsigned sapphire_engineerid(void);
-unsigned int is_12pin_camera(void);
-unsigned int is_sapphire_gpiov20(void);
-int sapphire_is_5M_camera(void);
-int sapphire_gpio_write(struct gpio_chip *chip, unsigned n, unsigned on);
-
-#endif /* GUARD */
diff --git a/arch/arm/mach-msm/board-supersonic-audio.c b/arch/arm/mach-msm/board-supersonic-audio.c
deleted file mode 100644
index f049dec..0000000
--- a/arch/arm/mach-msm/board-supersonic-audio.c
+++ /dev/null
@@ -1,320 +0,0 @@
-/* arch/arm/mach-msm/board-supersonic-audio.c
- *
- * Copyright (C) 2009 HTC Corporation
- * Copyright (C) 2009 Google Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/gpio.h>
-#include <linux/err.h>
-#include <linux/delay.h>
-#include <mach/pmic.h>
-#include <mach/msm_qdsp6_audio.h>
-#include <mach/htc_acoustic_qsd.h>
-#include <mach/tpa6130.h>
-#include <mach/tpa2018d1.h>
-#include <mach/vreg.h>
-
-#include "board-supersonic.h"
-#include "proc_comm.h"
-
-#if 1
-#define D(fmt, args...) printk(KERN_INFO "Audio: "fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-static struct mutex mic_lock;
-static struct mutex bt_sco_lock;
-static struct mutex hdmi_i2s_lock;
-static int headset_status = 0;
-
-static struct q6_hw_info q6_audio_hw[Q6_HW_COUNT] = {
-	[Q6_HW_HANDSET] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_HEADSET] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_SPEAKER] = {
-		.min_gain = -1500,
-		.max_gain = 0,
-	},
-	[Q6_HW_TTY] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_BT_SCO] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_BT_A2DP] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-};
-
-void supersonic_headset_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-        /* enable audio amp */
-	if (en != headset_status) {
-		headset_status = en;
-		if(en) {
-			gpio_set_value(SUPERSONIC_AUD_JACKHP_EN, 1);
-			mdelay(10);
-			if (system_rev == 0)
-				set_headset_amp(1);
-		} else {
-			if (system_rev == 0)
-				set_headset_amp(0);
-			gpio_set_value(SUPERSONIC_AUD_JACKHP_EN, 0);
-		}
-	}
-}
-
-void supersonic_speaker_enable(int en)
-{
-	struct spkr_config_mode scm;
-	memset(&scm, 0, sizeof(scm));
-
-	D("%s %d\n", __func__, en);
-	if (en) {
-		scm.is_right_chan_en = 0;
-		scm.is_left_chan_en = 1;
-		scm.is_stereo_en = 0;
-		scm.is_hpf_en = 1;
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-		pmic_set_spkr_configuration(&scm);
-		pmic_spkr_en(LEFT_SPKR, 1);
-
-		/* unmute */
-		pmic_spkr_en_mute(LEFT_SPKR, 1);
-	} else {
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-
-		pmic_spkr_en(LEFT_SPKR, 0);
-
-		pmic_set_spkr_configuration(&scm);
-	}
-	set_speaker_amp(en);
-
-}
-
-void supersonic_receiver_enable(int en)
-{
-	/* After XB*/
-	if (system_rev >= 1) {
-		struct spkr_config_mode scm;
-		memset(&scm, 0, sizeof(scm));
-
-		D("%s %d\n", __func__, en);
-		if (en) {
-			scm.is_right_chan_en = 1;
-			scm.is_left_chan_en = 0;
-			scm.is_stereo_en = 0;
-			scm.is_hpf_en = 1;
-			pmic_spkr_en_mute(RIGHT_SPKR, 0);
-			pmic_set_spkr_configuration(&scm);
-			pmic_spkr_en(RIGHT_SPKR, 1);
-
-			/* unmute */
-			pmic_spkr_en_mute(RIGHT_SPKR, 1);
-		} else {
-			pmic_spkr_en_mute(RIGHT_SPKR, 0);
-
-			pmic_spkr_en(RIGHT_SPKR, 0);
-
-			pmic_set_spkr_configuration(&scm);
-		}
-	}
-}
-
-static uint32_t hdmi_i2s_enable[] = {
-	PCOM_GPIO_CFG(SUPERSONIC_I2S_CLK, 2, GPIO_OUTPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_I2S_WS, 1, GPIO_OUTPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_I2S_DOUT, 1, GPIO_OUTPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-};
-
-static uint32_t hdmi_i2s_disable[] = {
-	PCOM_GPIO_CFG(SUPERSONIC_I2S_CLK, 0, GPIO_OUTPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_I2S_WS, 0, GPIO_OUTPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_I2S_DOUT, 0, GPIO_OUTPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-};
-
-void supersonic_hdmi_i2s_enable(int en)
-{
-	static int hdmi_i2s_refcount;
-	D("%s %d\n", __func__, en);
-	mutex_lock(&hdmi_i2s_lock);
-	if (en) {
-		if (++hdmi_i2s_refcount == 1)
-			config_gpio_table(hdmi_i2s_enable,
-					ARRAY_SIZE(hdmi_i2s_enable));
-	} else {
-		if (--hdmi_i2s_refcount == 0) {
-			config_gpio_table(hdmi_i2s_disable, ARRAY_SIZE(hdmi_i2s_disable));
-		}
-	}
-	mutex_unlock(&hdmi_i2s_lock);
-}
-
-
-static uint32_t bt_sco_enable[] = {
-	PCOM_GPIO_CFG(SUPERSONIC_BT_PCM_OUT, 1, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_BT_PCM_IN, 1, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_BT_PCM_SYNC, 2, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_BT_PCM_CLK, 2, GPIO_INPUT,
-			GPIO_PULL_DOWN, GPIO_2MA),
-};
-
-static uint32_t bt_sco_disable[] = {
-	PCOM_GPIO_CFG(SUPERSONIC_BT_PCM_OUT, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_BT_PCM_IN, 0, GPIO_INPUT,
-			GPIO_PULL_UP, GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_BT_PCM_SYNC, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_BT_PCM_CLK, 0, GPIO_OUTPUT,
-			GPIO_NO_PULL, GPIO_2MA),
-};
-
-void supersonic_bt_sco_enable(int en)
-{
-	static int bt_sco_refcount;
-	D("%s %d\n", __func__, en);
-	mutex_lock(&bt_sco_lock);
-	if (en) {
-		if (++bt_sco_refcount == 1)
-			config_gpio_table(bt_sco_enable,
-					ARRAY_SIZE(bt_sco_enable));
-	} else {
-		if (--bt_sco_refcount == 0) {
-			config_gpio_table(bt_sco_disable, ARRAY_SIZE(bt_sco_disable));
-			gpio_set_value(SUPERSONIC_BT_PCM_OUT, 0);
-			gpio_set_value(SUPERSONIC_BT_PCM_SYNC,0);
-			gpio_set_value(SUPERSONIC_BT_PCM_CLK,0);
-		}
-	}
-	mutex_unlock(&bt_sco_lock);
-}
-
-void supersonic_int_mic_enable(int en)
-{
-	D("%s %d\n", __func__, en);
-	if (en)
-		pmic_mic_en(ON_CMD);
-	else
-		pmic_mic_en(OFF_CMD);
-}
-
-void supersonic_ext_mic_enable(int en)
-{
-	static int old_state = 0, new_state = 0;
-
-	D("%s %d\n", __func__, en);
-
-	mutex_lock(&mic_lock);
-	if (!!en)
-		new_state++;
-	else
-		new_state--;
-
-	if (new_state == 1 && old_state == 0) {
-		gpio_set_value(SUPERSONIC_AUD_2V5_EN, 1);
-	} else if (new_state == 0 && old_state == 1)
-		gpio_set_value(SUPERSONIC_AUD_2V5_EN, 0);
-	else
-		D("%s: do nothing %d %d\n", __func__, old_state, new_state);
-
-	old_state = new_state;
-	mutex_unlock(&mic_lock);
-}
-
-void supersonic_analog_init(void)
-{
-	D("%s\n", __func__);
-	/* stereo pmic init */
-	pmic_spkr_set_gain(LEFT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_set_gain(RIGHT_SPKR, SPKR_GAIN_00DB);
-	pmic_spkr_en_right_chan(OFF_CMD);
-	pmic_spkr_en_left_chan(OFF_CMD);
-	pmic_spkr_add_right_left_chan(OFF_CMD);
-	pmic_spkr_en_stereo(OFF_CMD);
-	pmic_spkr_select_usb_with_hpf_20hz(OFF_CMD);
-	pmic_spkr_bypass_mux(OFF_CMD);
-	pmic_spkr_en_hpf(ON_CMD);
-	pmic_spkr_en_sink_curr_from_ref_volt_cir(OFF_CMD);
-	pmic_spkr_set_mux_hpf_corner_freq(SPKR_FREQ_0_73KHZ);
-	pmic_mic_set_volt(MIC_VOLT_1_80V);
-	pmic_set_speaker_delay(SPKR_DLY_100MS);
-
-	gpio_direction_output(SUPERSONIC_AUD_JACKHP_EN, 0);
-	gpio_set_value(SUPERSONIC_AUD_JACKHP_EN, 0);
-
-	mutex_lock(&bt_sco_lock);
-	config_gpio_table(bt_sco_disable, ARRAY_SIZE(bt_sco_disable));
-	gpio_set_value(SUPERSONIC_BT_PCM_OUT, 0);
-	gpio_set_value(SUPERSONIC_BT_PCM_SYNC,0);
-	gpio_set_value(SUPERSONIC_BT_PCM_CLK,0);
-	mutex_unlock(&bt_sco_lock);
-}
-
-int supersonic_get_rx_vol(uint8_t hw, int level)
-{
-	struct q6_hw_info *info;
-	int vol;
-
-	info = &q6_audio_hw[hw];
-	vol = info->min_gain + ((info->max_gain - info->min_gain) * level) / 100;
-	D("%s %d\n", __func__, vol);
-	return vol;
-}
-
-static struct qsd_acoustic_ops acoustic = {
-	.enable_mic_bias = supersonic_ext_mic_enable,
-};
-
-static struct q6audio_analog_ops ops = {
-	.init = supersonic_analog_init,
-	.speaker_enable = supersonic_speaker_enable,
-	.headset_enable = supersonic_headset_enable,
-	.receiver_enable = supersonic_receiver_enable,
-	.bt_sco_enable = supersonic_bt_sco_enable,
-	.int_mic_enable = supersonic_int_mic_enable,
-	.ext_mic_enable = supersonic_ext_mic_enable,
-	.i2s_enable = supersonic_hdmi_i2s_enable,
-	.get_rx_vol = supersonic_get_rx_vol,
-};
-
-void __init supersonic_audio_init(void)
-{
-	mutex_init(&mic_lock);
-	mutex_init(&bt_sco_lock);
-	mutex_init(&hdmi_i2s_lock);
-#if defined(CONFIG_QSD_AUDIO)
-	q6audio_register_analog_ops(&ops);
-#endif
-	acoustic_register_ops(&acoustic);
-}
-
diff --git a/arch/arm/mach-msm/board-supersonic-keypad.c b/arch/arm/mach-msm/board-supersonic-keypad.c
deleted file mode 100644
index 3132719..0000000
--- a/arch/arm/mach-msm/board-supersonic-keypad.c
+++ /dev/null
@@ -1,96 +0,0 @@
-/* arch/arm/mach-msm/board-supersonic-keypad.c
- *
- * Copyright (C) 2009 Google, Inc
- * Copyright (C) 2009 HTC Corporation.
- *
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/gpio_event.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <mach/vreg.h>
-#include <linux/keyreset.h>
-
-#include <asm/mach-types.h>
-
-#include "board-supersonic.h"
-
-
-static struct gpio_event_direct_entry supersonic_keypad_nav_map[] = {
-	{ SUPERSONIC_POWER_KEY,              KEY_POWER      },
-	{ SUPERSONIC_VOLUME_UP,              KEY_VOLUMEUP   },
-	{ SUPERSONIC_VOLUME_DOWN,            KEY_VOLUMEDOWN },
-};
-
-static struct gpio_event_input_info supersonic_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.flags = GPIOEDF_PRINT_KEYS,
-	.type = EV_KEY,
-	.keymap = supersonic_keypad_nav_map,
-	.debounce_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.keymap_size = ARRAY_SIZE(supersonic_keypad_nav_map)
-};
-
-static struct gpio_event_info *supersonic_keypad_info[] = {
-	&supersonic_keypad_nav_info.info,
-};
-
-static struct gpio_event_platform_data supersonic_keypad_data = {
-	.name = "supersonic-keypad",
-	.info = supersonic_keypad_info,
-	.info_count = ARRAY_SIZE(supersonic_keypad_info)
-};
-
-static struct platform_device supersonic_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &supersonic_keypad_data,
-	},
-};
-
-static struct keyreset_platform_data supersonic_reset_keys_pdata = {
-	.keys_down = {
-		KEY_POWER,
-		KEY_VOLUMEUP,
-		KEY_VOLUMEDOWN,
-		0
-	},
-};
-
-static struct platform_device supersonic_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &supersonic_reset_keys_pdata,
-};
-
-static int __init supersonic_init_keypad(void)
-{
-	int ret;
-
-	if (!machine_is_supersonic())
-		return 0;
-
-	if (platform_device_register(&supersonic_reset_keys_device))
-		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
-
-	ret = platform_device_register(&supersonic_keypad_device);
-	if (ret != 0)
-		return ret;
-
-	return 0;
-}
-
-device_initcall(supersonic_init_keypad);
-
-
diff --git a/arch/arm/mach-msm/board-supersonic-microp.c b/arch/arm/mach-msm/board-supersonic-microp.c
deleted file mode 100644
index 19f10e3..0000000
--- a/arch/arm/mach-msm/board-supersonic-microp.c
+++ /dev/null
@@ -1,446 +0,0 @@
-/* arch/arm/mach-msm/board-supersonic-microp.c
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-#ifdef CONFIG_MICROP_COMMON
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <asm/mach-types.h>
-#include <mach/atmega_microp.h>
-#include <linux/capella_cm3602.h>
-#include <linux/input.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <mach/vreg.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-
-#include "board-supersonic.h"
-
-#define INT_PSENSOR	(1<<4)
-
-static int misc_opened;
-static unsigned int als_power_control;
-static struct mutex als_power_lock;
-
-static void p_sensor_do_work(struct work_struct *w);
-static DECLARE_WORK(p_sensor_work, p_sensor_do_work);
-
-struct wake_lock proximity_wake_lock;
-
-static struct capella_cm3602_data {
-	struct input_dev *input_dev;
-	struct capella_cm3602_platform_data *pdata;
-	int enabled;
-	struct workqueue_struct *p_sensor_wq;
-} the_data;
-
-static int psensor_intr_enable(uint8_t enable)
-{
-	int ret;
-	uint8_t addr, data[2];
-
-	if (enable)
-		addr = MICROP_I2C_WCMD_GPI_INT_CTL_EN;
-	else
-		addr = MICROP_I2C_WCMD_GPI_INT_CTL_DIS;
-
-	data[0] = INT_PSENSOR >> 8;
-	data[1] = INT_PSENSOR & 0xFF;
-	ret = microp_i2c_write(addr, data, 2);
-	if (ret < 0)
-		pr_err("%s: %s p-sensor interrupt failed\n",
-			__func__, (enable ? "enable" : "disable"));
-
-	return ret;
-}
-
-static int supersonic_microp_function_init(struct i2c_client *client)
-{
-	struct microp_i2c_platform_data *pdata;
-	struct microp_i2c_client_data *cdata;
-	uint8_t data[20];
-	int i, j;
-	int ret;
-
-	pdata = client->dev.platform_data;
-	cdata = i2c_get_clientdata(client);
-
-	/* Headset remote key */
-	ret = microp_function_check(client, MICROP_FUNCTION_REMOTEKEY);
-	if (ret >= 0) {
-		i = ret;
-		pdata->function_node[MICROP_FUNCTION_REMOTEKEY] = i;
-		cdata->int_pin.int_remotekey =
-			pdata->microp_function[i].int_pin;
-
-		for (j = 0; j < 6; j++) {
-			data[j] = (uint8_t)(pdata->microp_function[i].levels[j] >> 8);
-			data[j + 6] = (uint8_t)(pdata->microp_function[i].levels[j]);
-		}
-		ret = microp_i2c_write(MICROP_I2C_WCMD_REMOTEKEY_TABLE,
-				data, 12);
-		if (ret)
-			goto exit;
-	}
-
-	/* Reset button interrupt */
-	ret = microp_write_interrupt(client, (1<<8), 1);
-	if (ret)
-		goto exit;
-
-	/* HDMI interrupt */
-	ret = microp_write_interrupt(client, (1 << 1), 1);
-	if (ret)
-		goto exit;
-
-	return 0;
-
-exit:
-	return ret;
-}
-
-static int report_psensor_data(void)
-{
-	int ret, ps_data = 0;
-	uint8_t data[3] = {0, 0, 0};
-
-	ret = microp_i2c_read(MICROP_I2C_RCMD_GPIO_STATUS, data, 3);
-	if (ret < 0)
-		pr_err("%s: read data failed\n", __func__);
-	else {
-		ps_data = (data[2] & 0x10) ? 1 : 0;
-		pr_info("proximity %s\n", ps_data ? "FAR" : "NEAR");
-
-		/* 0 is close, 1 is far */
-		input_report_abs(the_data.input_dev, ABS_DISTANCE, ps_data);
-		input_sync(the_data.input_dev);
-
-		wake_lock_timeout(&proximity_wake_lock, 2*HZ);
-	}
-
-	return ret;
-}
-
-static int capella_cm3602_enable(struct capella_cm3602_data *data)
-{
-	int rc;
-	pr_info("%s\n", __func__);
-	if (data->enabled) {
-		pr_info("%s: already enabled\n", __func__);
-		return 0;
-	}
-
-	/* dummy report */
-	input_report_abs(data->input_dev, ABS_DISTANCE, -1);
-	input_sync(data->input_dev);
-
-	rc = data->pdata->power(PS_PWR_ON, 1);
-	if (rc < 0)
-		return -EIO;
-
-	rc = gpio_direction_output(data->pdata->p_en, 0);
-	if (rc < 0) {
-		pr_err("%s: set psesnor enable failed!!",
-			__func__);
-		return -EIO;
-	}
-	msleep(220);
-	rc = psensor_intr_enable(1);
-	if (rc < 0)
-		return -EIO;
-
-	data->enabled = 1;
-	report_psensor_data();
-
-	return rc;
-}
-
-static int capella_cm3602_disable(struct capella_cm3602_data *data)
-{
-	int rc = -EIO;
-	pr_info("%s\n", __func__);
-	if (!data->enabled) {
-		pr_info("%s: already disabled\n", __func__);
-		return 0;
-	}
-
-	rc = psensor_intr_enable(0);
-	if (rc < 0)
-		return -EIO;
-
-	rc = gpio_direction_output(data->pdata->p_en, 1);
-	if (rc < 0) {
-		pr_err("%s: set GPIO failed!!", __func__);
-		return -EIO;
-	}
-
-	rc = data->pdata->power(PS_PWR_ON, 0);
-	if (rc < 0)
-		return -EIO;
-
-	data->enabled = 0;
-	return rc;
-}
-
-static ssize_t capella_cm3602_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
-{
-	int ret;
-
-	ret = sprintf(buf, "proximity enabled = %d\n", the_data.enabled);
-
-	return ret;
-}
-
-static ssize_t capella_cm3602_store(struct device *dev,
-			struct device_attribute *attr,
-			const char              *buf,
-			size_t                  count
-			)
-{
-	ssize_t val;
-
-	val = -1;
-	sscanf(buf, "%u", &val);
-	if (val < 0 || val > 1)
-		return -EINVAL;
-
-	/* Enable capella_cm3602*/
-	if (val == 1)
-		capella_cm3602_enable(&the_data);
-
-	/* Disable capella_cm3602*/
-	if (val == 0)
-		capella_cm3602_disable(&the_data);
-
-	return count;
-}
-
-static DEVICE_ATTR(proximity, 0644, capella_cm3602_show, capella_cm3602_store);
-
-static int capella_cm3602_open(struct inode *inode, struct file *file)
-{
-	pr_info("%s\n", __func__);
-	if (misc_opened)
-		return -EBUSY;
-	misc_opened = 1;
-	return 0;
-}
-
-static int capella_cm3602_release(struct inode *inode, struct file *file)
-{
-	pr_info("%s\n", __func__);
-	misc_opened = 0;
-	return capella_cm3602_disable(&the_data);
-}
-
-static long capella_cm3602_ioctl(struct file *file,
-			unsigned int cmd, unsigned long arg)
-{
-	int val;
-	pr_info("%s cmd %d\n", __func__, _IOC_NR(cmd));
-	switch (cmd) {
-	case CAPELLA_CM3602_IOCTL_ENABLE:
-		if (get_user(val, (unsigned long __user *)arg))
-			return -EFAULT;
-		if (val)
-			return capella_cm3602_enable(&the_data);
-		else
-			return capella_cm3602_disable(&the_data);
-		break;
-	case CAPELLA_CM3602_IOCTL_GET_ENABLED:
-		return put_user(the_data.enabled, (unsigned long __user *)arg);
-		break;
-	default:
-		pr_err("%s: invalid cmd %d\n", __func__, _IOC_NR(cmd));
-		return -EINVAL;
-	}
-}
-
-static void p_sensor_do_work(struct work_struct *w)
-{
-	report_psensor_data();
-}
-
-static irqreturn_t p_sensor_irq_handler(int irq, void *data)
-{
-	struct capella_cm3602_data *ip = data;
-	queue_work(ip->p_sensor_wq, &p_sensor_work);
-
-	return IRQ_HANDLED;
-}
-
-static struct file_operations capella_cm3602_fops = {
-	.owner = THIS_MODULE,
-	.open = capella_cm3602_open,
-	.release = capella_cm3602_release,
-	.unlocked_ioctl = capella_cm3602_ioctl
-};
-
-static struct miscdevice capella_cm3602_misc = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "cm3602",
-	.fops = &capella_cm3602_fops
-};
-
-static int capella_cm3602_probe(struct platform_device *pdev)
-{
-	int rc = -1;
-	struct input_dev *input_dev;
-	struct capella_cm3602_data *ip;
-	struct capella_cm3602_platform_data *pdata;
-
-	struct class  *proximity_attr_class;
-	struct device *proximity_attr_dev;
-
-	pr_info("%s: probe\n", __func__);
-
-	pdata = pdev->dev.platform_data;
-
-	ip = &the_data;
-	platform_set_drvdata(pdev, ip);
-
-	input_dev = input_allocate_device();
-	if (!input_dev) {
-		pr_err("%s: could not allocate input device\n", __func__);
-		rc = -ENOMEM;
-		goto done;
-	}
-	ip->input_dev = input_dev;
-	ip->pdata = pdata;
-	input_set_drvdata(input_dev, ip);
-
-	input_dev->name = "proximity";
-
-	set_bit(EV_ABS, input_dev->evbit);
-	input_set_abs_params(input_dev, ABS_DISTANCE, 0, 1, 0, 0);
-
-	rc = input_register_device(input_dev);
-	if (rc < 0) {
-		pr_err("%s: could not register input device\n", __func__);
-		goto err_free_input_device;
-	}
-
-	rc = misc_register(&capella_cm3602_misc);
-	if (rc < 0) {
-		pr_err("%s: could not register misc device\n", __func__);
-		goto err_unregister_input_device;
-	}
-
-	wake_lock_init(&proximity_wake_lock, WAKE_LOCK_SUSPEND, "proximity");
-
-	proximity_attr_class = class_create(THIS_MODULE, "sensors");
-	if (IS_ERR(proximity_attr_class)) {
-		pr_err("%s: class_create failed\n", __func__);
-		rc = PTR_ERR(proximity_attr_class);
-		proximity_attr_class = NULL;
-		goto err_create_class;
-	}
-
-	proximity_attr_dev = device_create(proximity_attr_class,
-					NULL, 0, "%s", "proximity_sensor");
-	if (unlikely(IS_ERR(proximity_attr_dev))) {
-		pr_err("%s: device create failed\n", __func__);
-		rc = PTR_ERR(proximity_attr_dev);
-		proximity_attr_dev = NULL;
-		goto err_create_proximity_attr_device;
-	}
-
-	rc = device_create_file(proximity_attr_dev, &dev_attr_proximity);
-	if (rc) {
-		pr_err("%s: device_create_file failed\n", __func__);
-		goto err_create_proximity_device_file;
-	}
-
-	ip->p_sensor_wq = create_workqueue("p-sensor_microp_wq");
-	if (ip->p_sensor_wq == NULL) {
-		pr_err("%s: create_workqueue failed\n", __func__);
-		goto err_create_workqueue;
-	}
-
-	rc = gpio_request(pdata->p_en, "gpio_proximity_en");
-	if (rc < 0) {
-		pr_err("%s: gpio %d request failed (%d)\n",
-			__func__, pdata->p_en, rc);
-		goto err_request_proximity_en;
-	}
-
-	rc = request_irq(pdata->p_out, p_sensor_irq_handler,
-					IRQF_TRIGGER_NONE, "p-sensor_microp", ip);
-	if (rc < 0) {
-		pr_err("%s: request_irq(%d) failed for (%d)\n",
-				__func__, pdata->p_out, rc);
-		goto err_request_proximity_irq;
-	}
-
-	goto done;
-
-err_request_proximity_irq:
-	gpio_free(pdata->p_en);
-err_request_proximity_en:
-	destroy_workqueue(ip->p_sensor_wq);
-err_create_workqueue:
-	device_remove_file(proximity_attr_dev, &dev_attr_proximity);
-err_create_proximity_device_file:
-	device_unregister(proximity_attr_dev);
-err_create_proximity_attr_device:
-	class_destroy(proximity_attr_class);
-err_create_class:
-	misc_deregister(&capella_cm3602_misc);
-err_unregister_input_device:
-	input_unregister_device(input_dev);
-err_free_input_device:
-	input_free_device(input_dev);
-done:
-	return rc;
-}
-
-static struct microp_ops ops = {
-	.init_microp_func = supersonic_microp_function_init,
-/*
-	.als_pwr_enable = supersonic_als_power,
-	.als_intr_enable = supersonic_als_intr_enable,
-	.als_level_change = supersonic_als_level_change,
-*/
-};
-
-void __init supersonic_microp_init(void)
-{
-/*
-	mutex_init(&als_power_lock);
-	led_trigger_register(&supersonic_als_level_trigger);
-*/
-	microp_register_ops(&ops);
-}
-
-static struct platform_driver capella_cm3602_driver = {
-	.probe = capella_cm3602_probe,
-	.driver = {
-		.name = "supersonic_proximity",
-		.owner = THIS_MODULE
-	},
-};
-
-static int __init supersonic_capella_cm3602_init(void)
-{
-	if (!machine_is_supersonic())
-		return 0;
-
-	return platform_driver_register(&capella_cm3602_driver);
-}
-
-device_initcall(supersonic_capella_cm3602_init);
-
-#endif
diff --git a/arch/arm/mach-msm/board-supersonic-mmc.c b/arch/arm/mach-msm/board-supersonic-mmc.c
deleted file mode 100644
index adb3adf..0000000
--- a/arch/arm/mach-msm/board-supersonic-mmc.c
+++ /dev/null
@@ -1,455 +0,0 @@
-/* linux/arch/arm/mach-msm/board-supersonic-mmc.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-
-#include "board-supersonic.h"
-#include "devices.h"
-#include "proc_comm.h"
-
-#define DEBUG_SDSLOT_VDD 1
-
-static bool opt_disable_sdcard;
-static int __init supersonic_disablesdcard_setup(char *str)
-{
-	opt_disable_sdcard = (bool)simple_strtol(str, NULL, 0);
-	return 1;
-}
-
-__setup("board_supersonic.disable_sdcard=", supersonic_disablesdcard_setup);
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static struct vreg	*sdslot_vreg;
-static uint32_t		sdslot_vdd = 0xffffffff;
-static uint32_t		sdslot_vreg_enabled;
-
-static struct {
-	int mask;
-	int level;
-} mmc_vdd_table[] = {
-	{ MMC_VDD_27_28,	2800 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2900 },
-};
-
-static uint32_t supersonic_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-	int ret;
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(sdslot_vreg);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		ret = vreg_enable(sdslot_vreg);
-		if (ret)
-			pr_err("%s: Error enabling vreg (%d)\n", __func__, ret);
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask != (1 << vdd))
-			continue;
-		ret = vreg_set_level(sdslot_vreg, mmc_vdd_table[i].level);
-		if (ret)
-			pr_err("%s: Error setting level (%d)\n", __func__, ret);
-#if DEBUG_SDSLOT_VDD
-		printk(KERN_INFO "%s: Setting level to %u (%s)\n",
-					__func__, mmc_vdd_table[i].level,
-				ret?"Failed":"Success");
-#endif
-		return 0;
-	}
-
-	pr_err("%s: Invalid VDD (%d) specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int supersonic_sdslot_status(struct device *dev)
-{
-	return (system_rev > 0)?1:!gpio_get_value(SUPERSONIC_GPIO_SDMC_CD_N);
-}
-
-#define SUPERSONIC_MMC_VDD	(MMC_VDD_27_28 | MMC_VDD_28_29 | \
-				 MMC_VDD_29_30)
-
-static unsigned int supersonic_sdslot_type = MMC_TYPE_SD;
-
-static struct mmc_platform_data supersonic_sdslot_data = {
-	.ocr_mask	= SUPERSONIC_MMC_VDD,
-	.status		= supersonic_sdslot_status,
-	.translate_vdd	= supersonic_sdslot_switchvdd,
-	.slot_type	= &supersonic_sdslot_type,
-};
-
-int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-		 unsigned int stat_irq, unsigned long stat_irq_flags);
-
-
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(152, 0, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_4MA), /* WLAN IRQ */
-};
-
-/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
- * we use predefined value (sdio_vsn=2) here to initial sdio driver well
- */
-static struct embedded_sdio_data supersonic_wifi_emb_data = {
-	.cccr	= {
-		.sdio_vsn	= 2,
-		.multi_block	= 1,
-		.low_speed	= 0,
-		.wide_bus	= 0,
-		.high_power	= 1,
-		.high_speed	= 1,
-	},
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int
-supersonic_wifi_status_register(void (*callback)(int card_present, void *dev_id),
-				void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static int supersonic_wifi_cd;	/* WiFi virtual 'card detect' status */
-
-static unsigned int supersonic_wifi_status(struct device *dev)
-{
-	return supersonic_wifi_cd;
-}
-
-static struct mmc_platform_data supersonic_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= supersonic_wifi_status,
-	.register_status_notify	= supersonic_wifi_status_register,
-	.embedded_sdio		= &supersonic_wifi_emb_data,
-};
-
-int supersonic_wifi_set_carddetect(int val)
-{
-	printk(KERN_INFO "%s: %d\n", __func__, val);
-	supersonic_wifi_cd = val;
-	if (wifi_status_cb)
-		wifi_status_cb(val, wifi_status_cb_devid);
-	else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-EXPORT_SYMBOL(supersonic_wifi_set_carddetect);
-
-int supersonic_wifi_power(int on)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		mdelay(50);
-		if (rc)
-			return rc;
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-	}
-
-	mdelay(100);
-	gpio_set_value(SUPERSONIC_GPIO_WIFI_SHUTDOWN_N, on); /* WIFI_SHUTDOWN */
-	mdelay(100);
-	return 0;
-}
-EXPORT_SYMBOL(supersonic_wifi_power);
-
-int supersonic_wifi_reset(int on)
-{
-	printk(KERN_INFO "%s: do nothing\n", __func__);
-	return 0;
-}
-
-
-/* ---------------- WiMAX GPIO Settings --------------- */
-static uint32_t wimax_power_pin_gpio_table[] = {
-	PCOM_GPIO_CFG(48, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),
-	PCOM_GPIO_CFG(106, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),
-	PCOM_GPIO_CFG(154, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),
-	PCOM_GPIO_CFG(155, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),
-    PCOM_GPIO_CFG(156, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA)
-};
-
-static uint32_t wimax_on_gpio_table[] = {
-	PCOM_GPIO_CFG(88, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(89, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(90, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(91, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(92, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(93, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT0 */
-	 /*WiMax_Host_2*/
-	PCOM_GPIO_CFG(159, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),
-};
-
-static uint32_t wimax_off_gpio_table[] = {
-	PCOM_GPIO_CFG(88, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(89, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(90, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(91, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(92, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT1 */
-	PCOM_GPIO_CFG(93, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* DAT0 */
-	/*WiMax_Host_2*/
-	PCOM_GPIO_CFG(159, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),
-};
-
-
-static void (*wimax_status_cb)(int card_present, void *dev_id);
-static void *wimax_status_cb_devid;
-static int supersonic_wimax_cd = 0;
-static int supersonic_wimax_sdio_status = 0;
-
-static int supersonic_wimax_status_register(void (*callback)(int card_present, void *dev_id), void *dev_id)
-{
-	if (wimax_status_cb)
-		return -EAGAIN;
-	printk("%s\n", __func__);
-	wimax_status_cb = callback;
-	wimax_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int supersonic_wimax_status(struct device *dev)
-{
-	printk("%s\n", __func__);
-	return supersonic_wimax_cd;
-}
-
-void supersonic_wimax_set_carddetect(int val)
-{
-	printk("%s: %d\n", __func__, val);
-	supersonic_wimax_cd = val;
-	if (wimax_status_cb) {
-		wimax_status_cb(val, wimax_status_cb_devid);
-	} else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-}
-EXPORT_SYMBOL(supersonic_wimax_set_carddetect);
-
-static struct mmc_platform_data supersonic_wimax_data = {
-	.ocr_mask		= MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30,
-	.status			= supersonic_wimax_status,
-	.register_status_notify	= supersonic_wimax_status_register,
-	.embedded_sdio		= NULL,
-};
-
-struct _vreg
-{
-	const char *name;
-	unsigned id;
-};
-
-
-/* 2 : wimax UART, 1 : CPU uart, 0 : usb
-CPU_WIMAX_SW -> GPIO160  (SUPERSONIC_WIMAX_CPU_UARTz_SW)
-USB_UART#_SW -> GPIO33  (SUPERSONIC_USB_UARTz_SW)
-
-XA : GPIO33 = 0 -> USB
-    GPIO33 = 1 -> CPU UART
-
-XB : GPIO33 = 0 -> USB
-    GPIO33 = 1 , GPIO160 = 0 -> CPU UART
-    GPIO33 = 1 , GPIO160 = 1 -> Wimax UART
-*/
-int supersonic_wimax_uart_switch(int uart)
-{
-	printk("%s uart:%d\n", __func__, uart);
-	
-	gpio_set_value(SUPERSONIC_USB_UARTz_SW, uart?1:0);
-	if(system_rev && uart)
-		gpio_set_value(SUPERSONIC_WIMAX_CPU_UARTz_SW, uart==2?1:0);
-	return uart?1:0; 
-}
-EXPORT_SYMBOL(supersonic_wimax_uart_switch);
-
-int supersonic_wimax_power(int on)
-{
-	printk("%s\n", __func__);
-
-	if (on) {
-		/*Power ON sequence*/
-		gpio_set_value(154, 1);
-		gpio_set_value(48, 1);
-                mdelay(5);
-		gpio_set_value(106, 0);
-                gpio_set_value(156, 1);
-                gpio_set_value(155, 1);
- 		mdelay(5);
-		gpio_set_value(106, 1);
- 		mdelay(1150);
-
-		config_gpio_table(wimax_on_gpio_table,
-				  ARRAY_SIZE(wimax_on_gpio_table));
-	} else {
-		/*Power OFF sequence*/
-		config_gpio_table(wimax_off_gpio_table,
-				  ARRAY_SIZE(wimax_off_gpio_table));
-		gpio_set_value(88, 0);	/*WiMax_SDIO_CLK_1 OL*/
-		gpio_set_value(159, 0);	/*WiMax_Host_2 OL*/
-
-		gpio_set_value(106, 1);
-		mdelay(5);
-		gpio_set_value(156, 0);
-		gpio_set_value(155, 0);
-                gpio_set_value(106, 0);
-		mdelay(5);
-		gpio_set_value(154, 0);
-		gpio_set_value(48, 0);
-		mdelay(5);
-	}
-	return 0;
-}
-EXPORT_SYMBOL(supersonic_wimax_power);
-
-int supersonic_wimax_set_status(int on)
-{
-	printk(KERN_INFO "%s on:%d\n", __func__, on);
-	supersonic_wimax_sdio_status = on;
-	return 0;
-}
-EXPORT_SYMBOL(supersonic_wimax_set_status);
-
-int supersonic_wimax_get_status()
-{
-	//printk(KERN_INFO "%s status:%d\n", __func__, supersonic_wimax_sdio_status);
-	return supersonic_wimax_sdio_status;
-}
-EXPORT_SYMBOL(supersonic_wimax_get_status);
-
-int __init supersonic_init_mmc(unsigned int sys_rev)
-{
-	uint32_t id;
-
-	wifi_status_cb = NULL;
-
-	printk(KERN_INFO "%s()+\n", __func__);
-
-	/* initial WIFI_SHUTDOWN# */
-	id = PCOM_GPIO_CFG(SUPERSONIC_GPIO_WIFI_SHUTDOWN_N, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-
-	msm_add_sdcc(1, &supersonic_wifi_data, 0, 0);
-
-        /* Initial WiMAX */
-	printk("config wimax power gpio table\n");
-	config_gpio_table(wimax_power_pin_gpio_table,
-			  ARRAY_SIZE(wimax_power_pin_gpio_table));
-
-	msm_add_sdcc(3, &supersonic_wimax_data,0,0);
-
-	if (opt_disable_sdcard) {
-		pr_info("%s: sdcard disabled on cmdline\n", __func__);
-		goto done;
-	}
-
-	sdslot_vreg_enabled = 0;
-
-	sdslot_vreg = vreg_get(0, "gp6");
-	if (IS_ERR(sdslot_vreg))
-		return PTR_ERR(sdslot_vreg);
-
-	if (system_rev == 0) { /* XA board */
-		set_irq_wake(MSM_GPIO_TO_INT(SUPERSONIC_GPIO_SDMC_CD_N), 1);
-
-		msm_add_sdcc(2, &supersonic_sdslot_data,
-			MSM_GPIO_TO_INT(SUPERSONIC_GPIO_SDMC_CD_N),
-			IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE);
-	} else
-		msm_add_sdcc(2, &supersonic_sdslot_data, 0, 0);
-
-done:
-	printk(KERN_INFO "%s()-\n", __func__);
-	return 0;
-}
diff --git a/arch/arm/mach-msm/board-supersonic-panel.c b/arch/arm/mach-msm/board-supersonic-panel.c
deleted file mode 100644
index 5543bd4..0000000
--- a/arch/arm/mach-msm/board-supersonic-panel.c
+++ /dev/null
@@ -1,488 +0,0 @@
-/* linux/arch/arm/mach-msm/board-supersonic-panel.c
- *
- * Copyright (C) 2008 HTC Corporation.
- * Author: Jay Tu <jay_tu@htc.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/i2c.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/gpio.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-#include <mach/msm_fb.h>
-#include <mach/msm_iomap.h>
-#include <mach/vreg.h>
-#include <mach/pmic.h>
-
-#include "board-supersonic.h"
-#include "devices.h"
-#include "proc_comm.h"
-
-#if 1
-#define B(s...) printk(s)
-#else
-#define B(s...) do {} while(0)
-#endif
-
-static struct cabc_t {
-	struct led_classdev lcd_backlight;
-	struct msm_mddi_client_data *client_data;
-	struct mutex lock;
-	unsigned long status;
-} cabc;
-
-enum {
-	GATE_ON = 1 << 0,
-};
-
-static void suc_set_brightness(struct led_classdev *led_cdev,
-				enum led_brightness val)
-{
-	struct msm_mddi_client_data *client = cabc.client_data;
-	unsigned int shrink_br = val;
-
-	printk(KERN_DEBUG "set brightness = %d\n", val);
-	if (test_bit(GATE_ON, &cabc.status) == 0)
-		return;
-
-	if (val < 30)
-		shrink_br = 5;
-	else if ((val >= 30) && (val <= 143))
-		shrink_br = 104 * (val - 30) / 113 + 5;
-	else
-		shrink_br = 145 * (val - 144) / 111 + 110;
-	mutex_lock(&cabc.lock);
-	client->remote_write(client, 0x00, 0x5500);
-	client->remote_write(client, shrink_br, 0x5100);
-	mutex_unlock(&cabc.lock);
-}
-
-static enum led_brightness
-suc_get_brightness(struct led_classdev *led_cdev)
-{
-	struct msm_mddi_client_data *client = cabc.client_data;
-
-	return client->remote_read(client, 0x5100);
-}
-
-#define DEFAULT_BRIGHTNESS 100
-static void suc_backlight_switch(int on)
-{
-	enum led_brightness val;
-
-	if (on) {
-		printk(KERN_DEBUG "turn on backlight\n");
-		set_bit(GATE_ON, &cabc.status);
-		val = cabc.lcd_backlight.brightness;
-
-		/* LED core uses get_brightness for default value
-		 * If the physical layer is not ready, we should
-		 * not count on it */
-		if (val == 0)
-			val = DEFAULT_BRIGHTNESS;
-		suc_set_brightness(&cabc.lcd_backlight, val);
-	} else {
-		clear_bit(GATE_ON, &cabc.status);
-		suc_set_brightness(&cabc.lcd_backlight, 0);
-	}
-}
-
-static int suc_backlight_probe(struct platform_device *pdev)
-{
-	int err = -EIO;
-
-	mutex_init(&cabc.lock);
-	cabc.client_data = pdev->dev.platform_data;
-	cabc.lcd_backlight.name = "lcd-backlight";
-	cabc.lcd_backlight.brightness_set = suc_set_brightness;
-	cabc.lcd_backlight.brightness_get = suc_get_brightness;
-	err = led_classdev_register(&pdev->dev, &cabc.lcd_backlight);
-	if (err)
-		goto err_register_lcd_bl;
-	return 0;
-
-err_register_lcd_bl:
-	led_classdev_unregister(&cabc.lcd_backlight);
-	return err;
-}
-
-/* ------------------------------------------------------------------- */
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct vreg *vreg_lcd_2v8;
-static struct vreg *vreg_lcd_1v8;
-
-#define REG_WAIT (0xffff)
-
-struct nov_regs {
-	unsigned reg;
-	unsigned val;
-} nov_init_seq[] = {
-	{0xc000, 0x86},
-	{0xc001, 0x00},
-	{0xc002, 0x86},
-	{0xc003, 0x00},
-	{0xc100, 0x40},
-	{0xc200, 0x02},
-	{0xc202, 0x32},
-	{0xe000, 0x0e},
-	{0xe001, 0x2a},
-	{0xe002, 0x33},
-	{0xe003, 0x38},
-	{0xe004, 0x1e},
-	{0xe005, 0x30},
-	{0xe006, 0x64},
-	{0xe007, 0x3f},
-	{0xe008, 0x21},
-	{0xe009, 0x27},
-	{0xe00a, 0x88},
-	{0xe00b, 0x14},
-	{0xe00c, 0x35},
-	{0xe00d, 0x56},
-	{0xe00e, 0x79},
-	{0xe00f, 0x88},
-	{0xe010, 0x55},
-	{0xe011, 0x57},
-	{0xe100, 0x0e},
-	{0xe101, 0x2a},
-	{0xe102, 0x33},
-	{0xe103, 0x3b},
-	{0xe104, 0x1e},
-	{0xe105, 0x30},
-	{0xe106, 0x64},
-	{0xe107, 0x3f},
-	{0xe108, 0x21},
-	{0xe109, 0x27},
-	{0xe10a, 0x88},
-	{0xe10b, 0x14},
-	{0xe10c, 0x35},
-	{0xe10d, 0x56},
-	{0xe10e, 0x79},
-	{0xe10f, 0x88},
-	{0xe110, 0x55},
-	{0xe111, 0x57},
-
-	{0xe200, 0x0E},
-	{0xe201, 0x2A},
-	{0xe202, 0x33},
-	{0xe203, 0x3B},
-	{0xe204, 0x1e},
-	{0xe205, 0x30},
-	{0xe206, 0x64},
-	{0xe207, 0x3F},
-	{0xe208, 0x21},
-	{0xe209, 0x27},
-	{0xe20A, 0x88},
-	{0xe20B, 0x14},
-	{0xe20C, 0x35},
-	{0xe20D, 0x56},
-	{0xe20E, 0x79},
-	{0xe20F, 0xB8},
-	{0xe210, 0x55},
-	{0xe211, 0x57},
-
-	{0xe300, 0x0E},
-	{0xe301, 0x2A},
-	{0xe302, 0x33},
-	{0xe303, 0x3B},
-	{0xe304, 0x1E},
-	{0xe305, 0x30},
-	{0xe306, 0x64},
-	{0xe307, 0x3F},
-	{0xe308, 0x21},
-	{0xe309, 0x27},
-	{0xe30A, 0x88},
-	{0xe30B, 0x14},
-	{0xe30C, 0x35},
-	{0xe30D, 0x56},
-	{0xe30E, 0x79},
-	{0xe30F, 0xB8},
-	{0xe310, 0x55},
-	{0xe311, 0x57},
-	{0xe400, 0x0E},
-	{0xe401, 0x2A},
-	{0xe402, 0x33},
-	{0xe403, 0x3B},
-	{0xe404, 0x1E},
-	{0xe405, 0x30},
-	{0xe406, 0x64},
-	{0xe407, 0x3F},
-	{0xe408, 0x21},
-	{0xe409, 0x27},
-	{0xe40A, 0x88},
-	{0xe40B, 0x14},
-	{0xe40C, 0x35},
-	{0xe40D, 0x56},
-	{0xe40E, 0x79},
-	{0xe40F, 0xB8},
-	{0xe410, 0x55},
-	{0xe411, 0x57},
-	{0xe500, 0x0E},
-	{0xe501, 0x2A},
-	{0xe502, 0x33},
-	{0xe503, 0x3B},
-	{0xe504, 0x1E},
-	{0xe505, 0x30},
-	{0xe506, 0x64},
-	{0xe507, 0x3F},
-	{0xe508, 0x21},
-	{0xe509, 0x27},
-	{0xe50A, 0x88},
-	{0xe50B, 0x14},
-	{0xe50C, 0x35},
-	{0xe50D, 0x56},
-	{0xe50E, 0x79},
-	{0xe50F, 0xB8},
-	{0xe510, 0x55},
-	{0xe511, 0x57},
-
-	{0x3a00, 0x05},
-
-	/* cabc */
-	{0x4e00, 0x00},
-	{0x5e00, 0x00},
-	{0x6a01, 0x00},
-	{0x6a02, 0x03},
-	{0x5100, 0xff},
-	{0x5301, 0x10},
-	{0x6A18, 0xff},
-	{0x6A17, 0x01},
-	{0xF402, 0x14},
-
-	{0x3500, 0x00},
-	{0x1100, 0x0},
-	{REG_WAIT, 120},
-};
-
-static int
-supersonic_mddi_init(struct msm_mddi_bridge_platform_data *bridge_data,
-		     struct msm_mddi_client_data *client_data)
-{
-	int i = 0;
-	unsigned reg, val;
-
-	client_data->auto_hibernate(client_data, 0);
-
-	for (i = 0; i < ARRAY_SIZE(nov_init_seq); i++) {
-		reg = cpu_to_le32(nov_init_seq[i].reg);
-		val = cpu_to_le32(nov_init_seq[i].val);
-		if (reg == REG_WAIT)
-			msleep(val);
-		else
-			client_data->remote_write(client_data, val, reg);
-	}
-
-	client_data->auto_hibernate(client_data, 1);
-	return 0;
-}
-
-static int
-supersonic_mddi_uninit(struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *client_data)
-{
-	client_data->remote_write(client_data, 0, 0x2800);
-	return 0;
-}
-
-/* FIXME: remove after XA03 */
-static int backlight_control(int on)
-{
-	struct i2c_adapter *adap = i2c_get_adapter(0);
-	struct i2c_msg msg;
-	u8 buf[] = {0x90, 0x00, 0x00, 0x08};
-	int ret = -EIO, max_retry = 3;
-
-	msg.addr = 0xcc >> 1;
-	msg.flags = 0;
-	msg.len = sizeof(buf);
-	msg.buf = buf;
-
-	if (on == 0)
-		buf[0] = 0x91;
-
-	while (max_retry--) {
-		ret = i2c_transfer(adap, &msg, 1);
-		if (ret != 1)
-			msleep(1);
-		else {
-			ret = 0;
-			break;
-		}
-		ret = -EIO;
-	}
-
-	if (ret)
-		printk(KERN_ERR "backlight control fail\n");
-	return 0;
-}
-
-static int
-supersonic_panel_blank(struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s\n", __func__);
-	suc_backlight_switch(LED_OFF);
-	backlight_control(0);
-	return 0;
-}
-
-static int
-supersonic_panel_unblank(struct msm_mddi_bridge_platform_data *bridge_data,
-			struct msm_mddi_client_data *client_data)
-{
-	B(KERN_DEBUG "%s\n", __func__);
-	suc_backlight_switch(LED_FULL);
-	client_data->remote_write(client_data, 0x00, 0x2900);
-	msleep(100);
-	client_data->remote_write(client_data, 0x24, 0x5300);
-	backlight_control(1);
-	return 0;
-}
-
-static struct msm_mddi_bridge_platform_data novatec_client_data = {
-	.init = supersonic_mddi_init,
-	.uninit = supersonic_mddi_uninit,
-	.blank = supersonic_panel_blank,
-	.unblank = supersonic_panel_unblank,
-	.fb_data = {
-		.xres = 480,
-		.yres = 800,
-		.width = 48,
-		.height = 80,
-		.output_format = 0,
-	},
-	.panel_conf = {
-		.caps = MSMFB_CAP_CABC,
-	},
-};
-
-static void
-mddi_novatec_power(struct msm_mddi_client_data *client_data, int on)
-{
-	unsigned id, on_off = 1;
-
-	B(KERN_DEBUG "%s: power %s.\n", __func__, on ? "on" : "off");
-
-	if (on) {
-		on_off = 1;
-		/* 2V8 */
-		id = PM_VREG_PDOWN_SYNT_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcd_2v8);
-
-		/* 1V8 */
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcd_1v8);
-		mdelay(15);
-
-		gpio_set_value(SUPERSONIC_LCD_RST, 1);
-		mdelay(1);
-		gpio_set_value(SUPERSONIC_LCD_RST, 0);
-		mdelay(5);
-		gpio_set_value(SUPERSONIC_LCD_RST, 1);
-		msleep(50);
-	} else {
-		on_off = 0;
-		gpio_set_value(SUPERSONIC_LCD_RST, 0);
-		mdelay(120);
-
-		/* 1V8 */
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_disable(vreg_lcd_1v8);
-
-		/* 2V8 */
-		id = PM_VREG_PDOWN_SYNT_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_disable(vreg_lcd_2v8);
-	}
-}
-
-static struct msm_mddi_platform_data mddi_pdata = {
-	.clk_rate = 384000000,
-	.power_client = mddi_novatec_power,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 1,
-	.client_platform_data = {
-		{
-			.product_id = (0xb9f6 << 16 | 0x5582),
-			.name = "mddi_c_b9f6_5582",
-			.id = 0,
-			.client_data = &novatec_client_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-static struct platform_driver suc_backlight_driver = {
-	.probe = suc_backlight_probe,
-	.driver = {
-		.name = "nov_cabc",
-		.owner = THIS_MODULE,
-	},
-};
-
-static struct msm_mdp_platform_data mdp_pdata = {
-	.dma_channel = MDP_DMA_S,
-};
-
-int __init supersonic_init_panel(void)
-{
-	int rc;
-
-	if (!machine_is_supersonic())
-		return -1;
-
-	B(KERN_INFO "%s: enter.\n", __func__);
-
-	vreg_lcd_1v8 = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_lcd_1v8))
-		return PTR_ERR(vreg_lcd_1v8);
-
-	vreg_lcd_2v8 = vreg_get(0, "synt");
-	if (IS_ERR(vreg_lcd_2v8))
-		return PTR_ERR(vreg_lcd_2v8);
-
-	msm_device_mdp.dev.platform_data = &mdp_pdata;
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-
-	msm_device_mddi0.dev.platform_data = &mddi_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-
-	rc = platform_driver_register(&suc_backlight_driver);
-	if (rc)
-		return rc;
-
-	return 0;
-}
-
-device_initcall(supersonic_init_panel);
diff --git a/arch/arm/mach-msm/board-supersonic-rfkill.c b/arch/arm/mach-msm/board-supersonic-rfkill.c
deleted file mode 100644
index e568368..0000000
--- a/arch/arm/mach-msm/board-supersonic-rfkill.c
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for supersonic platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include "proc_comm.h"
-#include "board-supersonic.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "bcm4329";
-
-static int supersonic_bt_status;
-
-static uint32_t supersonic_bt_init_table[] = {
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_RTS, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_RTS */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_CTS, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* BT_CTS */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_RX, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* BT_RX */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_TX, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* BT_TX */
-
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_RESET_N, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),	/* BT_RESET_N */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_SHUTDOWN_N, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),	/* BT_SHUTDOWN_N */
-
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_HOST_WAKE, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA),	/* BT_HOST_WAKE */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_CHIP_WAKE, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),	/* BT_CHIP_WAKE */
-};
-
-static uint32_t supersonic_bt_on_table[] = {
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_RTS, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),	/* BT_RTS */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_CTS, 2, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* BT_CTS */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_RX, 2, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* BT_RX */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_TX, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),	/* BT_TX */
-
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_HOST_WAKE, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),	/* BT_HOST_WAKE */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_CHIP_WAKE, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),	/* BT_CHIP_WAKE */
-
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_RESET_N, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),	/* BT_RESET_N */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_SHUTDOWN_N, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),	/* BT_SHUTDOWN_N */
-};
-
-/* BT off and system is sleep/suspend */
-static uint32_t supersonic_bt_disable_sleep_table[] = {
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_RTS, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* OLNP */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_CTS, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* OLNP */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_RX, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_8MA),	/* OLNP */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_UART1_TX, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA),	/* OLNP */
-
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_HOST_WAKE, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_4MA),	/* BT_HOST_W, OLNP */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_BT_CHIP_WAKE, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),	/* BT_CHIP_WAKE, OLNP */
-};
-
-static void config_bt_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for(n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void supersonic_config_bt_init(void)
-{
-	supersonic_bt_status = 0;
-	config_bt_table(supersonic_bt_init_table, ARRAY_SIZE(supersonic_bt_init_table));
-	mdelay(5);
-	gpio_configure(SUPERSONIC_GPIO_BT_RESET_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	gpio_configure(SUPERSONIC_GPIO_BT_SHUTDOWN_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-
-	gpio_configure(SUPERSONIC_GPIO_BT_UART1_RTS, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);	/* OLNP */
-	gpio_configure(SUPERSONIC_GPIO_BT_UART1_TX, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);	/* OLNP */
-
-	gpio_configure(SUPERSONIC_GPIO_BT_CHIP_WAKE, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);	/* OLNP */
-}
-
-static void supersonic_config_bt_on(void)
-{
-	config_bt_table(supersonic_bt_on_table, ARRAY_SIZE(supersonic_bt_on_table));
-	mdelay(5);
-	gpio_configure(SUPERSONIC_GPIO_BT_RESET_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	gpio_configure(SUPERSONIC_GPIO_BT_SHUTDOWN_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-
-	gpio_configure(SUPERSONIC_GPIO_BT_CHIP_WAKE, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-	supersonic_bt_status = 1;
-}
-
-void supersonic_config_bt_disable_sleep(void)
-{
-	config_bt_table(supersonic_bt_disable_sleep_table, ARRAY_SIZE(supersonic_bt_disable_sleep_table));
-	mdelay(5);
-	gpio_configure(SUPERSONIC_GPIO_BT_UART1_RTS, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);	/* OLNP */
-	gpio_configure(SUPERSONIC_GPIO_BT_UART1_TX, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);	/* OLNP */
-
-	gpio_configure(SUPERSONIC_GPIO_BT_CHIP_WAKE, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);	/* OLNP */
-}
-
-static void supersonic_config_bt_off(void)
-{
-	gpio_configure(SUPERSONIC_GPIO_BT_SHUTDOWN_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	gpio_configure(SUPERSONIC_GPIO_BT_RESET_N, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-	supersonic_config_bt_disable_sleep();
-	supersonic_bt_status = 0;
-}
-
-void supersonic_config_bt_disable_active(void)
-{
-	supersonic_config_bt_disable_sleep();
-}
-
-int supersonic_is_bluetooth_off(void)
-{
-	return !supersonic_bt_status;	//ON:1, OFF:0
-}
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-		case RFKILL_STATE_UNBLOCKED:
-			supersonic_config_bt_on();
-			break;
-		case RFKILL_STATE_SOFT_BLOCKED:
-			supersonic_config_bt_off();
-			break;
-		default:
-			pr_err("%s: bad rfkill state %d\n", __func__, state);
-	}
-
-	return 0;
-}
-
-static int supersonic_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;
-
-	supersonic_config_bt_init();	/* bt gpio initial config */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-	if (rc)
-		goto err_rfkill_reg;
-
-	return 0;
-
-err_rfkill_reg:
-	rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int supersonic_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver supersonic_rfkill_driver = {
-	.probe = supersonic_rfkill_probe,
-	.remove = supersonic_rfkill_remove,
-	.driver = {
-		.name = "supersonic_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init supersonic_rfkill_init(void)
-{
-	if (!machine_is_supersonic())
-		return 0;
-
-	return platform_driver_register(&supersonic_rfkill_driver);
-}
-
-static void __exit supersonic_rfkill_exit(void)
-{
-	platform_driver_unregister(&supersonic_rfkill_driver);
-}
-
-module_init(supersonic_rfkill_init);
-module_exit(supersonic_rfkill_exit);
-MODULE_DESCRIPTION("supersonic rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-supersonic-wifi.c b/arch/arm/mach-msm/board-supersonic-wifi.c
deleted file mode 100644
index 4a1062f..0000000
--- a/arch/arm/mach-msm/board-supersonic-wifi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* linux/arch/arm/mach-msm/board-supersonic-wifi.c
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <asm/mach-types.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <linux/skbuff.h>
-#include <linux/wifi_tiwlan.h>
-
-#include "board-supersonic.h"
-
-int supersonic_wifi_power(int on);
-int supersonic_wifi_reset(int on);
-int supersonic_wifi_set_carddetect(int on);
-
-#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
-#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
-#define PREALLOC_WLAN_SECTION_HEADER		24
-
-#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
-#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
-#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
-
-#define WLAN_SKB_BUF_NUM	16
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
-
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
-	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
-};
-
-static void *supersonic_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
-		return wlan_static_skb;
-	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
-		return NULL;
-	if (wifi_mem_array[section].size < size)
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init supersonic_init_wifi_mem(void)
-{
-	int i;
-
-	for(i=0;( i < WLAN_SKB_BUF_NUM );i++) {
-		if (i < (WLAN_SKB_BUF_NUM/2))
-			wlan_static_skb[i] = dev_alloc_skb(4096);
-		else
-			wlan_static_skb[i] = dev_alloc_skb(8192);
-	}
-	for(i=0;( i < PREALLOC_WLAN_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
-							GFP_KERNEL);
-		if (wifi_mem_array[i].mem_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct resource supersonic_wifi_resources[] = {
-	[0] = {
-		.name		= "bcm4329_wlan_irq",
-		.start		= MSM_GPIO_TO_INT(SUPERSONIC_GPIO_WIFI_IRQ),
-		.end		= MSM_GPIO_TO_INT(SUPERSONIC_GPIO_WIFI_IRQ),
-		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct wifi_platform_data supersonic_wifi_control = {
-	.set_power      = supersonic_wifi_power,
-	.set_reset      = supersonic_wifi_reset,
-	.set_carddetect = supersonic_wifi_set_carddetect,
-	.mem_prealloc   = supersonic_wifi_mem_prealloc,
-};
-
-static struct platform_device supersonic_wifi_device = {
-        .name           = "bcm4329_wlan",
-        .id             = 1,
-        .num_resources  = ARRAY_SIZE(supersonic_wifi_resources),
-        .resource       = supersonic_wifi_resources,
-        .dev            = {
-                .platform_data = &supersonic_wifi_control,
-        },
-};
-
-extern unsigned char *get_wifi_nvs_ram(void);
-
-static unsigned supersonic_wifi_update_nvs(char *str)
-{
-#define NVS_LEN_OFFSET		0x0C
-#define NVS_DATA_OFFSET		0x40
-	unsigned char *ptr;
-	unsigned len;
-
-	if (!str)
-		return -EINVAL;
-	ptr = get_wifi_nvs_ram();
-	/* Size in format LE assumed */
-	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
-
-	/* the last bye in NVRAM is 0, trim it */
-	if (ptr[NVS_DATA_OFFSET + len -1] == 0)
-		len -= 1;
-
-	strcpy(ptr + NVS_DATA_OFFSET + len, str);
-	len += strlen(str);
-	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
-	return 0;
-}
-
-static int __init supersonic_wifi_init(void)
-{
-	int ret;
-
-	if (!machine_is_supersonic())
-		return 0;
-
-	printk("%s: start\n", __func__);
-	supersonic_wifi_update_nvs("sd_oobonly=1\n");
-	supersonic_init_wifi_mem();
-	ret = platform_device_register(&supersonic_wifi_device);
-        return ret;
-}
-
-device_initcall(supersonic_wifi_init);
diff --git a/arch/arm/mach-msm/board-supersonic.c b/arch/arm/mach-msm/board-supersonic.c
deleted file mode 100644
index 6a00966..0000000
--- a/arch/arm/mach-msm/board-supersonic.c
+++ /dev/null
@@ -1,1540 +0,0 @@
-/* linux/arch/arm/mach-msm/board-supersonic.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/cy8c_tmg_ts.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/i2c-msm.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/android_pmem.h>
-#include <linux/synaptics_t1007.h>
-#include <linux/input.h>
-#include <mach/htc_headset_common.h>
-#include <mach/audio_jack.h>
-#include <linux/akm8973.h>
-#include <mach/tpa2018d1.h>
-#include <linux/bma150.h>
-#include <linux/capella_cm3602.h>
-#include <linux/regulator/machine.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/setup.h>
-
-#include <mach/board.h>
-#include <mach/board_htc.h>
-#include <mach/hardware.h>
-#include <mach/camera.h>
-#include <mach/msm_iomap.h>
-#include <mach/htc_battery.h>
-#include <mach/perflock.h>
-#include <mach/msm_serial_debugger.h>
-#include <mach/system.h>
-#include <linux/spi/spi.h>
-
-#include "board-supersonic.h"
-#include "devices.h"
-#include "proc_comm.h"
-#include "smd_private.h"
-#include <mach/msm_serial_hs.h>
-#include <mach/tpa6130.h>
-#include <mach/msm_flashlight.h>
-#include <linux/atmel_qt602240.h>
-#include <mach/vreg.h>
-#ifdef CONFIG_MICROP_COMMON
-#include <mach/atmega_microp.h>
-#endif
-
-#include <mach/msm_hdmi.h>
-#include <mach/msm_hsusb.h>
-
-#define SMEM_SPINLOCK_I2C      6
-
-#ifdef CONFIG_ARCH_QSD8X50
-extern unsigned char *get_bt_bd_ram(void);
-#endif
-
-static unsigned skuid;
-
-static uint opt_usb_h2w_sw;
-module_param_named(usb_h2w_sw, opt_usb_h2w_sw, uint, 0);
-
-void msm_init_pmic_vibrator(void);
-extern void __init supersonic_audio_init(void);
-#ifdef CONFIG_MICROP_COMMON
-void __init supersonic_microp_init(void);
-#endif
-static struct htc_battery_platform_data htc_battery_pdev_data = {
-	.gpio_mbat_in = SUPERSONIC_GPIO_MBAT_IN,
-	.gpio_mchg_en_n = SUPERSONIC_GPIO_MCHG_EN_N,
-	.gpio_iset = SUPERSONIC_GPIO_ISET,
-	.guage_driver = GUAGE_MODEM,
-	.m2a_cable_detect = 1,
-	.charger = SWITCH_CHARGER,
-};
-
-static struct platform_device htc_battery_pdev = {
-	.name = "htc_battery",
-	.id = -1,
-	.dev	= {
-		.platform_data = &htc_battery_pdev_data,
-	},
-};
-
-#ifdef CONFIG_MICROP_COMMON
-static int capella_cm3602_power(int pwr_device, uint8_t enable);
-static struct microp_function_config microp_functions[] = {
-	{
-		.name = "light_sensor",
-		.category = MICROP_FUNCTION_LSENSOR,
-		.levels = { 3, 7, 11, 80, 199, 279, 479, 539, 541, 0x3FF },
-		.channel = 3,
-		.int_pin = 1 << 9,
-		.golden_adc = 0x118,
-		.ls_power = capella_cm3602_power,
-	},
-	{
-		.name   = "remote-key",
-		.category = MICROP_FUNCTION_REMOTEKEY,
-		.levels = {0, 33, 50, 110, 160, 220},
-		.channel = 1,
-		.int_pin = 1 << 7,
-	},
-	{
-		.name   = "reset-int",
-		.category = MICROP_FUNCTION_RESET_INT,
-		.int_pin = 1 << 8,
-	},
-};
-
-static struct lightsensor_platform_data lightsensor_data = {
-	.config = &microp_functions[0],
-	.irq = MSM_uP_TO_INT(9),
-};
-
-static struct microp_led_config led_config[] = {
-	{
-		.name = "amber",
-		.type = LED_RGB,
-	},
-	{
-		.name = "green",
-		.type = LED_RGB,
-	},
-	{
-		.name = "wimax",
-		.type = LED_WIMAX,
-	},
-};
-
-static struct microp_led_platform_data microp_leds_data = {
-	.num_leds	= ARRAY_SIZE(led_config),
-	.led_config	= led_config,
-};
-
-static struct bma150_platform_data supersonic_g_sensor_pdata = {
-	.microp_new_cmd = 1,
-};
-
-/* Proximity Sensor (Capella_CM3602)*/
-static int __capella_cm3602_power(int on)
-{
-	int ret;
-	struct vreg *vreg = vreg_get(0, "gp1");;
-	if (!vreg) {
-		printk(KERN_ERR "%s: vreg error\n", __func__);
-		return -EIO;
-	}
-	ret = vreg_set_level(vreg, 2800);
-
-	printk(KERN_DEBUG "%s: Turn the capella_cm3602 power %s\n",
-		__func__, (on) ? "on" : "off");
-	if (on) {
-		gpio_direction_output(SUPERSONIC_GPIO_PROXIMITY_EN_N, 1);
-		ret = vreg_enable(vreg);
-		if (ret < 0)
-			printk(KERN_ERR "%s: vreg enable failed\n", __func__);
-	} else {
-		ret = vreg_disable(vreg);
-		if (ret < 0)
-			printk(KERN_ERR "%s: vreg disable failed\n", __func__);
-		gpio_direction_output(SUPERSONIC_GPIO_PROXIMITY_EN_N, 0);
-	}
-
-	return ret;
-}
-
-static DEFINE_MUTEX(capella_cm3602_lock);
-static unsigned int als_power_control;
-
-static int capella_cm3602_power(int pwr_device, uint8_t enable)
-{
-	unsigned int old_status = 0;
-	int ret = 0, on = 0;
-	mutex_lock(&capella_cm3602_lock);
-
-	old_status = als_power_control;
-	if (enable)
-		als_power_control |= pwr_device;
-	else
-		als_power_control &= ~pwr_device;
-
-	on = als_power_control ? 1 : 0;
-	if (old_status == 0 && on)
-		ret = __capella_cm3602_power(1);
-	else if (!on)
-		ret = __capella_cm3602_power(0);
-
-	mutex_unlock(&capella_cm3602_lock);
-	return ret;
-}
-
-static struct capella_cm3602_platform_data capella_cm3602_pdata = {
-	.power = capella_cm3602_power,
-	.p_en = SUPERSONIC_GPIO_PROXIMITY_EN_N,
-	.p_out = MSM_uP_TO_INT(4),
-};
-/* End Proximity Sensor (Capella_CM3602)*/
-
-
-static struct platform_device microp_devices[] = {
-	{
-		.name = "lightsensor_microp",
-		.dev = {
-			.platform_data = &lightsensor_data,
-		},
-	},
-	{
-		.name = "leds-microp",
-		.id = -1,
-		.dev = {
-			.platform_data = &microp_leds_data,
-		},
-	},
-	{
-		.name = BMA150_G_SENSOR_NAME,
-		.dev = {
-			.platform_data = &supersonic_g_sensor_pdata,
-		},
-	},
-	{
-		.name = "supersonic_proximity",
-		.id = -1,
-		.dev = {
-			.platform_data = &capella_cm3602_pdata,
-		},
-	},
-};
-
-static struct microp_i2c_platform_data microp_data = {
-	.num_functions   = ARRAY_SIZE(microp_functions),
-	.microp_function = microp_functions,
-	.num_devices = ARRAY_SIZE(microp_devices),
-	.microp_devices = microp_devices,
-	.gpio_reset = SUPERSONIC_GPIO_UP_RESET_N,
-	.microp_ls_on = LS_PWR_ON | PS_PWR_ON,
-	.spi_devices = SPI_GSENSOR,
-};
-#endif
-
-static struct gpio_led supersonic_led_list[] = {
-	{
-		.name = "button-backlight",
-		.gpio = SUPERSONIC_AP_KEY_LED_EN,
-		.active_low = 0,
-	},
-};
-
-static struct gpio_led_platform_data supersonic_leds_data = {
-	.num_leds	= ARRAY_SIZE(supersonic_led_list),
-	.leds		= supersonic_led_list,
-};
-
-static struct platform_device supersonic_leds = {
-	.name		= "leds-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &supersonic_leds_data,
-	},
-};
-
-extern void msm_hsusb_8x50_phy_reset(void);
-static int supersonic_phy_init_seq[] = { 0xC, 0x31, 0x30, 0x32, 0x1D, 0x0D, 0x1D, 0x10, -1 };
-static struct msm_hsusb_product supersonic_usb_products[] = {
-	{
-		.product_id	= 0x0ff9,
-		.functions	= 0x00000001, /* usb_mass_storage */
-	},
-	{
-		.product_id	= 0x0c8d,
-		.functions	= 0x00000003, /* usb_mass_storage + adb */
-	},
-	{
-		.product_id	= 0x0c03,
-		.functions	= 0x00000101, /* modem + mass_storage */
-	},
-	{
-		.product_id	= 0x0c04,
-		.functions	= 0x00000103, /* modem + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c05,
-		.functions	= 0x00000021, /* Projector + mass_storage */
-	},
-	{
-		.product_id	= 0x0c06,
-		.functions	= 0x00000023, /* Projector + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c07,
-		.functions	= 0x0000000B, /* diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c08,
-		.functions	= 0x00000009, /* diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c88,
-		.functions	= 0x0000010B, /* adb + mass_storage + diag + modem */
-	},
-	{
-		.product_id	= 0x0c89,
-		.functions	= 0x00000019, /* serial + diag + mass_storage */
-	},
-	{
-		.product_id	= 0x0c8a,
-		.functions	= 0x0000001B, /* serial + diag + adb + mass_storage */
-	},
-	{
-		.product_id	= 0x0c93,
-		.functions	= 0x00000080, /* mtp */
-	},
-	{
-		.product_id	= 0x0FFE,
-		.functions	= 0x00000004, /* internet sharing */
-	},
-};
-
-/* 2 : wimax UART, 1 : CPU uart, 0 : usb
-CPU_WIMAX_SW -> GPIO160
-USB_UART#_SW -> GPIO33
-
-XA : GPIO33 = 0 -> USB
-    GPIO33 = 1 -> CPU UART
-
-XB : GPIO33 = 0 -> USB
-    GPIO33 = 1 , GPIO160 = 0 -> CPU UART     // SUPERSONIC_WIMAX_CPU_UARTz_SW (GPIO160)
-    GPIO33 = 1 , GPIO160 = 1 -> Wimax UART   // SUPERSONIC_USB_UARTz_SW (GPIO33)
-*/
-
-
-// USB cable out: supersonic_uart_usb_switch(1)
-// USB cable in: supersonic_uart_usb_switch(0)
-static int supersonic_uart_usb_switch(int uart)
-{
-	printk(KERN_INFO "%s:uart:%d\n", __func__, uart); 
-	gpio_set_value(SUPERSONIC_USB_UARTz_SW, uart?1:0); // XA and for USB cable in to reset wimax UART
-
-	if(system_rev && uart) // XB
-	{		
-		if (gpio_get_value(SUPERSONIC_WIMAX_CPU_UARTz_SW))  // Wimax UART
-	    {
-			printk(KERN_INFO "%s:Wimax UART\n", __func__);
-			gpio_set_value(SUPERSONIC_USB_UARTz_SW,1);
-			gpio_set_value(SUPERSONIC_WIMAX_CPU_UARTz_SW,1);
-		}		
-		else // USB, CPU UART
-		{
-			printk(KERN_INFO "%s:Non wimax UART\n", __func__);
-			gpio_set_value(SUPERSONIC_WIMAX_CPU_UARTz_SW, uart==2?1:0);
-		}
-	}
-	return uart?1:0;
-}
-
-static struct platform_device supersonic_rfkill = {
-	.name = "supersonic_rfkill",
-	.id = -1,
-};
-
-static struct resource qsd_spi_resources[] = {
-	{
-		.name   = "spi_irq_in",
-		.start  = INT_SPI_INPUT,
-		.end    = INT_SPI_INPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_out",
-		.start  = INT_SPI_OUTPUT,
-		.end    = INT_SPI_OUTPUT,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_err",
-		.start  = INT_SPI_ERROR,
-		.end    = INT_SPI_ERROR,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_base",
-		.start  = 0xA1200000,
-		.end    = 0xA1200000 + SZ_4K - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.name   = "spi_clk",
-		.start  = 17,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_mosi",
-		.start  = 18,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_miso",
-		.start  = 19,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_cs0",
-		.start  = 20,
-		.end    = 1,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_pwr",
-		.start  = 21,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.name   = "spi_irq_cs0",
-		.start  = 22,
-		.end    = 0,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device qsd_device_spi = {
-	.name           = "spi_qsd",
-	.id             = 0,
-	.num_resources  = ARRAY_SIZE(qsd_spi_resources),
-	.resource       = qsd_spi_resources,
-};
-
-static struct resource msm_kgsl_resources[] = {
-	{
-		.name	= "kgsl_reg_memory",
-		.start	= MSM_GPU_REG_PHYS,
-		.end	= MSM_GPU_REG_PHYS + MSM_GPU_REG_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "kgsl_phys_memory",
-		.start	= MSM_GPU_MEM_BASE,
-		.end	= MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_GRAPHICS,
-		.end	= INT_GRAPHICS,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-#define PWR_RAIL_GRP_CLK		8
-static int supersonic_kgsl_power_rail_mode(int follow_clk)
-{
-	int mode = follow_clk ? 0 : 1;
-	int rail_id = PWR_RAIL_GRP_CLK;
-
-	return msm_proc_comm(PCOM_CLKCTL_RPC_RAIL_CONTROL, &rail_id, &mode);
-}
-
-static int supersonic_kgsl_power(bool on)
-{
-	int cmd;
-	int rail_id = PWR_RAIL_GRP_CLK;
-
-	cmd = on ? PCOM_CLKCTL_RPC_RAIL_ENABLE : PCOM_CLKCTL_RPC_RAIL_DISABLE;
-	return msm_proc_comm(cmd, &rail_id, NULL);
-}
-
-static struct platform_device msm_kgsl_device = {
-	.name		= "kgsl",
-	.id		= -1,
-	.resource	= msm_kgsl_resources,
-	.num_resources	= ARRAY_SIZE(msm_kgsl_resources),
-};
-
-static struct android_pmem_platform_data mdp_pmem_pdata = {
-	.name		= "pmem",
-	.start		= MSM_PMEM_MDP_BASE,
-	.size		= MSM_PMEM_MDP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-static struct android_pmem_platform_data android_pmem_adsp_pdata = {
-	.name		= "pmem_adsp",
-	.start		= MSM_PMEM_ADSP_BASE,
-	.size		= MSM_PMEM_ADSP_SIZE,
-	.no_allocator	= 0,
-	.cached		= 1,
-};
-
-static struct android_pmem_platform_data android_pmem_camera_pdata = {
-	.name		= "pmem_camera",
-	.start		= MSM_PMEM_CAMERA_BASE,
-	.size		= MSM_PMEM_CAMERA_SIZE,
-	.no_allocator	= 1,
-	.cached		= 1,
-};
-
-#ifdef CONFIG_BUILD_CIQ
-static struct android_pmem_platform_data android_pmem_ciq_pdata = {
-	.name = "pmem_ciq",
-	.start = MSM_PMEM_CIQ_BASE,
-	.size = MSM_PMEM_CIQ_SIZE,
-	.no_allocator = 0,
-	.cached = 0,
-};
-
-static struct android_pmem_platform_data android_pmem_ciq1_pdata = {
-	.name = "pmem_ciq1",
-	.start = MSM_PMEM_CIQ1_BASE,
-	.size = MSM_PMEM_CIQ1_SIZE,
-	.no_allocator = 0,
-	.cached = 0,
-};
-
-static struct android_pmem_platform_data android_pmem_ciq2_pdata = {
-	.name = "pmem_ciq2",
-	.start = MSM_PMEM_CIQ2_BASE,
-	.size = MSM_PMEM_CIQ2_SIZE,
-	.no_allocator = 0,
-	.cached = 0,
-};
-
-static struct android_pmem_platform_data android_pmem_ciq3_pdata = {
-	.name = "pmem_ciq3",
-	.start = MSM_PMEM_CIQ3_BASE,
-	.size = MSM_PMEM_CIQ3_SIZE,
-	.no_allocator = 0,
-	.cached = 0,
-};
-#endif
-
-static struct platform_device android_pmem_mdp_device = {
-	.name		= "android_pmem",
-	.id		= 0,
-	.dev		= {
-		.platform_data = &mdp_pmem_pdata
-	},
-};
-
-static struct platform_device android_pmem_adsp_device = {
-	.name		= "android_pmem",
-	.id		= 4,
-	.dev		= {
-		.platform_data = &android_pmem_adsp_pdata,
-	},
-};
-
-static struct platform_device android_pmem_camera_device = {
-	.name		= "android_pmem",
-	.id		= 5,
-	.dev		= {
-		.platform_data = &android_pmem_camera_pdata,
-	},
-};
-
-#ifdef CONFIG_BUILD_CIQ
-static struct platform_device android_pmem_ciq_device = {
-	.name = "android_pmem",
-	.id = 5,
-	.dev = { .platform_data = &android_pmem_ciq_pdata },
-};
-
-static struct platform_device android_pmem_ciq1_device = {
-	.name = "android_pmem",
-	.id = 6,
-	.dev = { .platform_data = &android_pmem_ciq1_pdata },
-};
-
-static struct platform_device android_pmem_ciq2_device = {
-	.name = "android_pmem",
-	.id = 7,
-	.dev = { .platform_data = &android_pmem_ciq2_pdata },
-};
-
-static struct platform_device android_pmem_ciq3_device = {
-	.name = "android_pmem",
-	.id = 8,
-	.dev = { .platform_data = &android_pmem_ciq3_pdata },
-};
-#endif
-
-static struct resource ram_console_resources[] = {
-	{
-		.start	= MSM_RAM_CONSOLE_BASE,
-		.end	= MSM_RAM_CONSOLE_BASE + MSM_RAM_CONSOLE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device ram_console_device = {
-	.name		= "ram_console",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(ram_console_resources),
-	.resource	= ram_console_resources,
-};
-
-static int supersonic_atmel_ts_power(int on)
-{
-	printk(KERN_INFO "supersonic_atmel_ts_power(%d)\n", on);
-	if (on) {
-		gpio_set_value(SUPERSONIC_GPIO_TP_RST, 0);
-		msleep(5);
-		gpio_set_value(SUPERSONIC_GPIO_TP_EN, 1);
-		msleep(5);
-		gpio_set_value(SUPERSONIC_GPIO_TP_RST, 1);
-		msleep(40);
-	} else {
-		gpio_set_value(SUPERSONIC_GPIO_TP_EN, 0);
-		msleep(2);
-	}
-	return 0;
-}
-
-struct atmel_i2c_platform_data supersonic_atmel_ts_data[] = {
-	{
-		.version = 0x016,
-		.abs_x_min = 34,
-		.abs_x_max = 990,
-		.abs_y_min = 15,
-		.abs_y_max = 950,
-		.abs_pressure_min = 0,
-		.abs_pressure_max = 255,
-		.abs_width_min = 0,
-		.abs_width_max = 20,
-		.gpio_irq = SUPERSONIC_GPIO_TP_INT_N,
-		.power = supersonic_atmel_ts_power,
-		.config_T6 = {0, 0, 0, 0, 0, 0},
-		.config_T7 = {50, 15, 50},
-		.config_T8 = {10, 0, 20, 10, 0, 0, 5, 0},
-		.config_T9 = {139, 0, 0, 18, 12, 0, 16, 40, 2, 5, 0, 5, 2, 14, 2, 10, 25, 10, 0, 0, 0, 0, 0, 0, 0, 0, 143, 47, 138, 67},
-		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T20 = {23, 0, 0, 0, 0, 0, 0, 25, 20, 4, 15, 0},
-		.config_T22 = {7, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 10, 15, 20, 30, 40, 0},
-		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T25 = {3, 0, 200, 50, 64, 31, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-		.config_T28 = {0, 0, 2, 4, 8, 60},
-		.object_crc = {0xE0, 0x77, 0xDF},
-		.filter_level = {46, 100, 923, 978},
-	},
-	{
-		.version = 0x015,
-		.abs_x_min = 10,
-		.abs_x_max = 1012,
-		.abs_y_min = 15,
-		.abs_y_max = 960,
-		.abs_pressure_min = 0,
-		.abs_pressure_max = 255,
-		.abs_width_min = 0,
-		.abs_width_max = 20,
-		.gpio_irq = SUPERSONIC_GPIO_TP_INT_N,
-		.power = supersonic_atmel_ts_power,
-		.config_T6 = {0, 0, 0, 0, 0, 0},
-		.config_T7 = {100, 10, 50},
-		.config_T8 = {8, 0, 50, 50, 0, 0, 50, 0},
-		.config_T9 = {3, 0, 0, 18, 12, 0, 32, 40, 2, 5, 0, 0, 0, 0, 2, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 143, 47, 145, 81},
-		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T20 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T22 = {7, 0, 0, 25, 0, -25, 255, 4, 50, 0, 1, 10, 15, 20, 25, 30, 4},
-		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T25 = {3, 0, 200, 50, 64, 31, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-		.config_T28 = {0, 0, 2, 4, 8, 60},
-		.object_crc = {0x87, 0xAD, 0xF5},
-	},
-	{
-		.version = 0x014,
-		.abs_x_min = 10,
-		.abs_x_max = 1012,
-		.abs_y_min = 15,
-		.abs_y_max = 960,
-		.abs_pressure_min = 0,
-		.abs_pressure_max = 255,
-		.abs_width_min = 0,
-		.abs_width_max = 20,
-		.gpio_irq = SUPERSONIC_GPIO_TP_INT_N,
-		.power = supersonic_atmel_ts_power,
-		.config_T6 = {0, 0, 0, 0, 0, 0},
-		.config_T7 = {100, 10, 50},
-		.config_T8 = {8, 0, 50, 50, 0, 0, 50, 0},
-		.config_T9 = {3, 0, 0, 18, 12, 0, 64, 45, 3, 5, 0, 0, 0, 0, 2, 10, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 47, 143, 81},
-		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T19 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T20 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T22 = {7, 0, 0, 25, 0, -25, 255, 4, 50, 0, 1, 10, 15, 20, 25, 30, 4},
-		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T25 = {3, 0, 200, 50, 64, 31, 0, 0, 0, 0, 0, 0, 0, 0},
-		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
-		.config_T28 = {0, 0, 2, 4, 8},
-	}
-};
-
-static struct regulator_consumer_supply tps65023_dcdc1_supplies[] = {
-	{
-		.supply = "acpu_vcore",
-	},
-};
-
-static struct regulator_init_data tps65023_data[5] = {
-	{
-		.constraints = {
-			.name = "dcdc1", /* VREG_MSMC2_1V29 */
-			.min_uV = 1000000,
-			.max_uV = 1300000,
-			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
-		},
-		.consumer_supplies = tps65023_dcdc1_supplies,
-		.num_consumer_supplies = ARRAY_SIZE(tps65023_dcdc1_supplies),
-	},
-	/* dummy values for unused regulators to not crash driver: */
-	{
-		.constraints = {
-			.name = "dcdc2", /* VREG_MSMC1_1V26 */
-			.min_uV = 1260000,
-			.max_uV = 1260000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "dcdc3", /* unused */
-			.min_uV = 800000,
-			.max_uV = 3300000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo1", /* unused */
-			.min_uV = 1000000,
-			.max_uV = 3150000,
-		},
-	},
-	{
-		.constraints = {
-			.name = "ldo2", /* V_USBPHY_3V3 */
-			.min_uV = 3300000,
-			.max_uV = 3300000,
-		},
-	},
-};
-
-static struct h2w_platform_data supersonic_h2w_data = {
-};
-
-static struct platform_device supersonic_h2w = {
-	.name		= "htc_headset",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &supersonic_h2w_data,
-	},
-};
-
-static struct audio_jack_platform_data supersonic_jack_data = {
-	.gpio	= SUPERSONIC_GPIO_35MM_HEADSET_DET,
-};
-
-static struct platform_device supersonic_audio_jack = {
-	.name		= "audio-jack",
-	.id			= -1,
-	.dev		= {
-		.platform_data	= &supersonic_jack_data,
-	},
-};
-
-static struct akm8973_platform_data compass_platform_data = {
-	.layouts = SUPERSONIC_LAYOUTS,
-	.project_name = SUPERSONIC_PROJECT_NAME,
-	.reset = SUPERSONIC_GPIO_COMPASS_RST_N,
-	.intr = SUPERSONIC_GPIO_COMPASS_INT_N,
-};
-
-static struct tpa2018d1_platform_data tpa2018_data = {
-	.gpio_tpa2018_spk_en = SUPERSONIC_AUD_SPK_EN,
-};
-
-/*
- * HDMI platform data
- */
-
-#if 1
-#define HDMI_DBG(s...) printk("[hdmi]" s)
-#else
-#define HDMI_DBG(s...) do {} while (0)
-#endif
-
-static int hdmi_power(int on)
-{
-	HDMI_DBG("%s(%d)\n", __func__, on);
-
-	switch(on) {
-	/* Power on/off sequence for normal or D2 sleep mode */
-	case 0:
-		gpio_set_value(HDMI_RST, 0);
-		msleep(2);
-		gpio_set_value(V_HDMI_3V3_EN, 0);
-		gpio_set_value(V_VGA_5V_SIL9022A_EN, 0);
-		msleep(2);
-		gpio_set_value(V_HDMI_1V2_EN, 0);
-		break;
-	case 1:
-		gpio_set_value(V_HDMI_1V2_EN, 1);
-		msleep(2);
-		gpio_set_value(V_VGA_5V_SIL9022A_EN, 1);
-		gpio_set_value(V_HDMI_3V3_EN, 1);
-		msleep(2);
-		gpio_set_value(HDMI_RST, 1);
-		msleep(2);
-		break;
-
-	/* Power on/off sequence for D3 sleep mode */
-	case 2:
-		gpio_set_value(V_VGA_5V_SIL9022A_EN, 0);
-		gpio_set_value(V_HDMI_3V3_EN, 0);
-		break;
-	case 3:
-		gpio_set_value(HDMI_RST, 0);
-		msleep(2);
-		gpio_set_value(V_HDMI_3V3_EN, 1);
-		gpio_set_value(V_VGA_5V_SIL9022A_EN, 1);
-		msleep(50);
-		gpio_set_value(HDMI_RST, 1);
-		msleep(10);
-		break;
-
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static uint32_t hdmi_gpio_on_table[] = {
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_R0, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_R1, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_R2, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_R3, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_R4, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G0, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G1, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G2, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G3, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G4, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G5, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_B0, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_B1, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_B2, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_B3, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_B4, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_PCLK, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_VSYNC, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_HSYNC, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_DE, 1, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-};
-
-static uint32_t hdmi_gpio_off_table[] = {
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_R0, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_R1, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_R2, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_R3, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_R4, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G0, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G1, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G2, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G3, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G4, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_G5, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_B0, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_B1, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_B2, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_B3, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_B4, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_PCLK, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_VSYNC, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_HSYNC, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-	PCOM_GPIO_CFG(SUPERSONIC_LCD_DE, 0, GPIO_OUTPUT, GPIO_NO_PULL,
-			GPIO_2MA),
-};
-
-
-static void suc_hdmi_gpio_on(void)
-{
-	HDMI_DBG("%s\n", __func__);
-
-	config_gpio_table(hdmi_gpio_on_table, ARRAY_SIZE(hdmi_gpio_on_table));
-}
-
-static void suc_hdmi_gpio_off(void)
-{
-	int i = 0;
-
-	HDMI_DBG("%s\n", __func__);
-	config_gpio_table(hdmi_gpio_off_table, ARRAY_SIZE(hdmi_gpio_off_table));
-
-	for (i = SUPERSONIC_LCD_R0; i <= SUPERSONIC_LCD_R4; i++)
-		gpio_set_value(i, 0);
-	for (i = SUPERSONIC_LCD_G0; i <= SUPERSONIC_LCD_G5; i++)
-		gpio_set_value(i, 0);
-	for (i = SUPERSONIC_LCD_B0; i <= SUPERSONIC_LCD_DE; i++)
-		gpio_set_value(i, 0);
-}
-
-static struct hdmi_platform_data hdmi_device_data = {
-	.hdmi_res = {
-		.start = MSM_HDMI_FB_BASE,
-		.end = MSM_HDMI_FB_BASE + MSM_HDMI_FB_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	.power = hdmi_power,
-	.hdmi_gpio_on = suc_hdmi_gpio_on,
-	.hdmi_gpio_off = suc_hdmi_gpio_off,
-};
-
-static struct tpa6130_platform_data headset_amp_platform_data = {
-	.enable_rpc_server = 0,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(ATMEL_QT602240_NAME, 0x94 >> 1),
-		.platform_data = &supersonic_atmel_ts_data,
-		.irq = MSM_GPIO_TO_INT(SUPERSONIC_GPIO_TP_INT_N)
-	},
-#ifdef CONFIG_MICROP_COMMON
-	{
-		I2C_BOARD_INFO(MICROP_I2C_NAME, 0xCC >> 1),
-		.platform_data = &microp_data,
-		.irq = MSM_GPIO_TO_INT(SUPERSONIC_GPIO_UP_INT_N)
-	},
-#endif
-	{
-		I2C_BOARD_INFO("ds2482", 0x30 >> 1),
-		/*.platform_data = &microp_data,*/
-		/*.irq = MSM_GPIO_TO_INT(PASSION_GPIO_UP_INT_N)*/
-	},
-	{
-		I2C_BOARD_INFO("smb329", 0x6E >> 1),
-	},
-	{
-		I2C_BOARD_INFO("tps65200", 0xD4 >> 1),
-	},
-	{
-		I2C_BOARD_INFO("akm8973", 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = MSM_GPIO_TO_INT(SUPERSONIC_GPIO_COMPASS_INT_N),
-	},
-
-	{
-		I2C_BOARD_INFO("ov8810", 0x6C >> 1),
-	},
-	{
-		I2C_BOARD_INFO("ov9665", 0x60 >> 1),
-	},
-	{
-		I2C_BOARD_INFO(TPA6130_I2C_NAME, 0xC0 >> 1),
-		.platform_data = &headset_amp_platform_data,
-	},
-	{
-		I2C_BOARD_INFO("tps65023", 0x48),
-		.platform_data = tps65023_data,
-	},
-	{
-		I2C_BOARD_INFO("tpa2018d1", 0x58),
-		.platform_data = &tpa2018_data,
-	},
-	{
-		I2C_BOARD_INFO("SiL902x-hdmi", 0x76 >> 1),
-		.platform_data = &hdmi_device_data,
-		.irq = MSM_uP_TO_INT(1),
-	},
-};
-
-#ifdef CONFIG_ARCH_QSD8X50
-static char bdaddress[20];
-
-static void bt_export_bd_address(void)
- {
-	unsigned char cTemp[6];
-
-	memcpy(cTemp, get_bt_bd_ram(), 6);
-	sprintf(bdaddress, "%02x:%02x:%02x:%02x:%02x:%02x", cTemp[0], cTemp[1], cTemp[2], cTemp[3], cTemp[4], cTemp[5]);
-	printk(KERN_INFO "YoYo--BD_ADDRESS=%s\n", bdaddress);
-}
-
-module_param_string(bdaddress, bdaddress, sizeof(bdaddress), S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(bdaddress, "BT MAC ADDRESS");
-#endif
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA SUSPEND*/
-	PCOM_GPIO_CFG(0, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-	PCOM_GPIO_CFG(99, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA), /* CAM1_RST */
-	PCOM_GPIO_CFG(100, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA), /* CAM1_PWD */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(0, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT0 */
-	PCOM_GPIO_CFG(1, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT1 */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* HSYNC */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* VSYNC */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_16MA), /* MCLK */
-};
-
-static void config_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-static void config_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-
-static struct resource msm_camera_resources[] = {
-	{
-		.start	= MSM_VFE_PHYS,
-		.end	= MSM_VFE_PHYS + MSM_VFE_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= INT_VFE,
-		 INT_VFE,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_camera_on_gpios,
-	.camera_gpio_off = config_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-static void supersonic_ov8810_clk_switch(void){
-	int rc = 0;
-	pr_info("SuperSoinc: clk switch (supersonic)(ov8810)\n");
-	rc = gpio_request(SUPERSONIC_CLK_SWITCH, "ov8810");
-	if (rc < 0)
-		pr_err("GPIO (%d) request fail\n", SUPERSONIC_CLK_SWITCH);
-	else
-		gpio_direction_output(SUPERSONIC_CLK_SWITCH, 0);
-	gpio_free(SUPERSONIC_CLK_SWITCH);
-
-	return;
-}
-
-static void supersonic_ov9665_clk_switch(void){
-	int rc = 0;
-	pr_info("SuperSoinc: Doing clk switch (supersonic)(ov9665)\n");
-	rc = gpio_request(SUPERSONIC_CLK_SWITCH, "ov9665");
-	if (rc < 0)
-		pr_err("GPIO (%d) request fail\n", SUPERSONIC_CLK_SWITCH);
-	else
-		gpio_direction_output(SUPERSONIC_CLK_SWITCH, 1);
-	gpio_free(SUPERSONIC_CLK_SWITCH);
-
-	return;
-}
-
-static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
-	.camera_flash		= flashlight_control,
-	.num_flash_levels	= FLASHLIGHT_NUM,
-	.low_temp_limit		= 10,
-	.low_cap_limit		= 15,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_ov8810_data = {
-	.sensor_name    = "ov8810",
-	.sensor_reset   = SUPERSONIC_MAINCAM_RST, /* CAM1_RST */
-	.sensor_pwd     = SUPERSONIC_MAINCAM_PWD,  /* CAM1_PWDN, enabled in a9 */
-	.camera_clk_switch	= supersonic_ov8810_clk_switch,
-	.pdata = &msm_camera_device_data,
-	.resource = msm_camera_resources,
-	.num_resources = ARRAY_SIZE(msm_camera_resources),
-	.waked_up = 0,
-	.need_suspend = 0,
-	.flash_cfg	= &msm_camera_sensor_flash_cfg,
-};
-
-static struct platform_device msm_camera_sensor_ov8810 = {
-    .name           = "msm_camera_ov8810",
-    .dev            = {
-    .platform_data = &msm_camera_sensor_ov8810_data,
-    },
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_ov9665_data = {
-	.sensor_name	= "ov9665",
-	.sensor_reset	= SUPERSONIC_MAINCAM_RST,
-	.sensor_pwd	= SUPERSONIC_2NDCAM_PWD,
-	.camera_clk_switch	= supersonic_ov9665_clk_switch,
-	.pdata		= &msm_camera_device_data,
-	.resource = msm_camera_resources,
-	.num_resources = ARRAY_SIZE(msm_camera_resources),
-	.waked_up = 0,
-	.need_suspend = 0,
-};
-
-static struct platform_device msm_camera_sensor_ov9665 = {
-	.name	   = "msm_camera_ov9665",
-	.dev	    = {
-		.platform_data = &msm_camera_sensor_ov9665_data,
-	},
-};
-
-static void config_supersonic_flashlight_gpios(void)
-{
-	static uint32_t flashlight_gpio_table[] = {
-		PCOM_GPIO_CFG(SUPERSONIC_GPIO_FLASHLIGHT_TORCH, 0,
-					GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-		PCOM_GPIO_CFG(SUPERSONIC_GPIO_FLASHLIGHT_FLASH, 0,
-					GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-		PCOM_GPIO_CFG(SUPERSONIC_GPIO_FLASHLIGHT_FLASH_ADJ, 0,
-					GPIO_OUTPUT, GPIO_NO_PULL, GPIO_2MA),
-	};
-	config_gpio_table(flashlight_gpio_table,
-		ARRAY_SIZE(flashlight_gpio_table));
-}
-
-static struct flashlight_platform_data supersonic_flashlight_data = {
-	.gpio_init  = config_supersonic_flashlight_gpios,
-	.torch = SUPERSONIC_GPIO_FLASHLIGHT_TORCH,
-	.flash = SUPERSONIC_GPIO_FLASHLIGHT_FLASH,
-	.flash_adj = SUPERSONIC_GPIO_FLASHLIGHT_FLASH_ADJ,
-	.flash_duration_ms = 600,
-	.led_count = 1,
-};
-
-static struct platform_device supersonic_flashlight_device = {
-	.name = FLASHLIGHT_NAME,
-	.dev		= {
-		.platform_data	= &supersonic_flashlight_data,
-	},
-};
-
-static struct platform_device *devices[] __initdata = {
-#ifndef CONFIG_MSM_SERIAL_DEBUGGER
-	&msm_device_uart1,
-#endif
-#ifdef CONFIG_SERIAL_MSM_HS
-	&msm_device_uart_dm1,
-#endif
-	&supersonic_h2w,
-	&htc_battery_pdev,
-	&supersonic_audio_jack,
-	&ram_console_device,
-	&supersonic_rfkill,
-	&msm_device_smd,
-	&msm_device_nand,
-	/*&msm_device_hsusb,*/
-	/*&usb_mass_storage_device,*/
-	&android_pmem_mdp_device,
-	&android_pmem_adsp_device,
-	/*&android_pmem_camera_device,*/
-#ifdef CONFIG_BUILD_CIQ
-	&android_pmem_ciq_device,
-	&android_pmem_ciq1_device,
-	&android_pmem_ciq2_device,
-	&android_pmem_ciq3_device,
-#endif
-	&msm_camera_sensor_ov8810,
-	&msm_kgsl_device,
-	&msm_device_i2c,
-	&msm_camera_sensor_ov9665,
-	&supersonic_flashlight_device,
-	&supersonic_leds,
-#if defined(CONFIG_SPI_QSD)
-	&qsd_device_spi,
-#endif
-};
-
-static uint32_t usb_phy_3v3_table[] = {
-	PCOM_GPIO_CFG(SUPERSONIC_USB_PHY_3V3_ENABLE, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA)
-};
-
-static uint32_t usb_ID_PIN_table[] = {
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_USB_ID_PIN, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),
-};
-
-/* UART1 debug port init. This is supposed to be init in bootloader */
-static uint32_t supersonic_serial_debug_table[] = {
-	/* for uart debugger. It should be removed when support usb to serial function */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_UART1_RX, 3, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA), /* RX */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_UART1_TX, 3, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* TX */
-};
-
-/* UART1 debug port init. This is supposed to be init in bootloader */
-static uint32_t supersonic_serial_debug_off_table[] = {
-	/* for uart debugger. It should be removed when support usb to serial function */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_UART1_RX, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA), /* RX */
-	PCOM_GPIO_CFG(SUPERSONIC_GPIO_UART1_TX, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* TX */
-};
-
-static void supersonic_config_serial_debug_gpios(int on)
-{
-	if (on){
-		config_gpio_table(supersonic_serial_debug_table, ARRAY_SIZE(supersonic_serial_debug_table));
-	}else{
-		config_gpio_table(supersonic_serial_debug_off_table, ARRAY_SIZE(supersonic_serial_debug_off_table));
-		/*gpio_set_value(SUPERSONIC_GPIO_UART1_RX, 0); *//* OL */
-		gpio_set_value(SUPERSONIC_GPIO_UART1_TX, 0); /* OL */
-	}
-	printk(KERN_INFO "supersonic_config_serial_debug_gpios %d  \n", on);
-}
-
-static struct msm_i2c_device_platform_data msm_i2c_pdata = {
-	.i2c_clock = 100000,
-	.clock_strength = GPIO_8MA,
-	.data_strength = GPIO_8MA,
-};
-
-static void __init msm_device_i2c_init(void)
-{
-	msm_device_i2c.dev.platform_data = &msm_i2c_pdata;
-}
-
-static struct msm_acpu_clock_platform_data supersonic_clock_data = {
-	.acpu_switch_time_us	= 20,
-	.max_speed_delta_khz	= 256000,
-	.vdd_switch_time_us	= 62,
-	.power_collapse_khz	= 245000,
-	.wait_for_irq_khz	= 245000,
-};
-
-static unsigned supersonic_perf_acpu_table[] = {
-	245000000,
-	576000000,
-	998400000,
-};
-
-static struct perflock_platform_data supersonic_perflock_data = {
-	.perf_acpu_table = supersonic_perf_acpu_table,
-	.table_size = ARRAY_SIZE(supersonic_perf_acpu_table),
-};
-
-int supersonic_init_mmc(int sysrev);
-
-#ifdef CONFIG_SERIAL_MSM_HS
-extern void supersonic_config_bt_disable_active(void);
-extern void supersonic_config_bt_disable_sleep(void);
-extern int supersonic_is_bluetooth_off(void);
-
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(SUPERSONIC_GPIO_BT_HOST_WAKE),	/*Chip to Device*/
-	.inject_rx_on_wakeup = 0,
-	.cpu_lock_supported = 0,
-
-	.config_as_uart = supersonic_config_bt_disable_active,
-	.config_as_gpio = supersonic_config_bt_disable_sleep,
-	.need_config = supersonic_is_bluetooth_off,
-
-	/* for bcm */
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = SUPERSONIC_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = SUPERSONIC_GPIO_BT_HOST_WAKE,
-};
-#endif
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-struct msm_serial_debug_platform_data msm_uart_debug_pdata = {
-	.config_gpio = supersonic_config_serial_debug_gpios,
-	.disable_uart = 1,
-};
-#endif
-
-static int OJ_BMA_power(void)
-{
-	int ret;
-	struct vreg *vreg = vreg_get(0, "synt");
-
-	if (!vreg) {
-		printk(KERN_ERR "%s: vreg error\n", __func__);
-		return -EIO;
-	}
-	ret = vreg_set_level(vreg, 2850);
-
-	ret = vreg_enable(vreg);
-	if (ret < 0)
-		printk(KERN_ERR "%s: vreg enable failed\n", __func__);
-
-	return 0;
-}
-
-unsigned supersonic_get_skuid(void)
-{
-	return skuid;
-}
-
-static ssize_t supersonic_virtual_keys_show(struct kobject *kobj,
-			struct kobj_attribute *attr, char *buf)
-{
-	/* center: x: home: 45, menu: 170, back: 305, search 430, y: 835*/
-	return sprintf(buf,
-			__stringify(EV_KEY) ":" __stringify(KEY_HOME)   ":45:835:90:50"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":170:835:110:50"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":305:835:110:50"
-			":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":430:835:100:50"
-			"\n");
-}
-
-static struct kobj_attribute supersonic_virtual_keys_attr = {
-	.attr = {
-		.name = "virtualkeys.atmel-touchscreen",
-		.mode = S_IRUGO,
-	},
-	.show = &supersonic_virtual_keys_show,
-};
-
-static struct attribute *supersonic_properties_attrs[] = {
-	&supersonic_virtual_keys_attr.attr,
-	NULL
-};
-
-static struct attribute_group supersonic_properties_attr_group = {
-	.attrs = supersonic_properties_attrs,
-};
-
-static void supersonic_reset(void)
-{
-        gpio_set_value(SUPERSONIC_GPIO_PS_HOLD, 0);
-}
-
-/* system_rev == higher 16bits of PCBID
-XA -> 0000FFFF -> 0x0000
-XB -> 0101FFFF -> 0x0101
-XC -> 0202FFFF -> 0x0202
-*/
-static void __init supersonic_init(void)
-{
-	int ret;
-	struct kobject *properties_kobj;
-
-	printk("supersonic_init() revision=%d\n", system_rev);
-
-	msm_hw_reset_hook = supersonic_reset;
-
-	OJ_BMA_power();
-
-	gpio_direction_output(SUPERSONIC_GPIO_PROXIMITY_EN_N, 0);
-
-	msm_acpu_clock_init(&supersonic_clock_data);
-
-	perflock_init(&supersonic_perflock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	msm_device_uart1.dev.platform_data = &msm_uart_debug_pdata;
-	msm_serial_debug_init(MSM_UART1_PHYS, INT_UART1,
-			      &msm_device_uart1.dev, 1, MSM_GPIO_TO_INT(SUPERSONIC_GPIO_UART1_RX));
-#endif
-
-#ifdef CONFIG_ARCH_QSD8X50
-	bt_export_bd_address();
-#endif
-
-	/* set the gpu power rail to manual mode so clk en/dis will not
-	 * turn off gpu power, and hang it on resume */
-	supersonic_kgsl_power_rail_mode(0);
-	supersonic_kgsl_power(true);
-
-	#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-	msm_device_uart_dm1.name = "msm_serial_hs_bcm";	/* for bcm */
-	#endif
-
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-	/*gpio_direction_output(SUPERSONIC_GPIO_TP_LS_EN, 0);*/
-	gpio_direction_output(SUPERSONIC_GPIO_TP_EN, 0);
-
-	supersonic_audio_init();
-#ifdef CONFIG_MICROP_COMMON
-	supersonic_microp_init();
-#endif
-	msm_device_i2c_init();
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-	if (!opt_usb_h2w_sw) {
-		msm_register_usb_phy_init_seq(supersonic_phy_init_seq);
-		msm_register_uart_usb_switch(supersonic_uart_usb_switch);
-		msm_add_usb_id_pin_gpio(SUPERSONIC_GPIO_USB_ID_PIN);
-		msm_hsusb_set_product(supersonic_usb_products,
-			ARRAY_SIZE(supersonic_usb_products));
-		msm_add_usb_devices(msm_hsusb_8x50_phy_reset, NULL);
-	}
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	ret = supersonic_init_mmc(system_rev);
-	if (ret != 0)
-		pr_crit("%s: Unable to initialize MMC\n", __func__);
-
-	properties_kobj = kobject_create_and_add("board_properties", NULL);
-	if (properties_kobj)
-		ret = sysfs_create_group(properties_kobj,
-				&supersonic_properties_attr_group);
-	if (!properties_kobj || ret)
-		pr_err("failed to create board_properties\n");
-
-	msm_init_pmic_vibrator();
-	config_gpio_table(usb_phy_3v3_table, ARRAY_SIZE(usb_phy_3v3_table));
-	config_gpio_table(usb_ID_PIN_table, ARRAY_SIZE(usb_ID_PIN_table));
-	gpio_set_value(SUPERSONIC_USB_PHY_3V3_ENABLE, 1);
-
-}
-
-static void __init supersonic_fixup(struct machine_desc *desc, struct tag *tags,
-				 char **cmdline, struct meminfo *mi)
-{
-	skuid = parse_tag_skuid((const struct tag *)tags);
-	printk(KERN_INFO "supersonic_fixup:skuid=0x%x\n", skuid);
-	/* First Bank 256MB */
-	mi->nr_banks = 1;
-	mi->bank[0].start = PHYS_OFFSET;
-	mi->bank[0].node = PHYS_TO_NID(PHYS_OFFSET);
-	mi->bank[0].size = MSM_EBI1_BANK0_SIZE;	/*(219*1024*1024);*/
-
-	/* Second Bank 128MB */
-	mi->nr_banks++;
-	mi->bank[1].start = MSM_EBI1_BANK1_BASE;
-	mi->bank[1].node = PHYS_TO_NID(MSM_EBI1_BANK1_BASE);
-	mi->bank[1].size = MSM_EBI1_BANK1_SIZE;
-}
-
-static void __init supersonic_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-extern struct sys_timer msm_timer;
-
-MACHINE_START(SUPERSONIC, "supersonic")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params	= 0x20000100,
-	.fixup		= supersonic_fixup,
-	.map_io		= supersonic_map_io,
-	.init_irq	= msm_init_irq,
-	.init_machine	= supersonic_init,
-	.timer		= &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-supersonic.h b/arch/arm/mach-msm/board-supersonic.h
deleted file mode 100644
index 15a483f..0000000
--- a/arch/arm/mach-msm/board-supersonic.h
+++ /dev/null
@@ -1,195 +0,0 @@
-/* arch/arm/mach-msm/board-supersonic.h
- *
- * Copyright (C) 2009 HTC Corporation.
-  *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_SUPERSONIC_H
-#define __ARCH_ARM_MACH_MSM_BOARD_SUPERSONIC_H
-
-#include <mach/board.h>
-
-#define MSM_SMI_BASE		0x02B00000
-#define MSM_SMI_SIZE		0x01500000
-
-#define MSM_HDMI_FB_BASE	0x02B00000
-#define MSM_HDMI_FB_SIZE	0x00400000
-
-#define MSM_GPU_MEM_BASE	0x03700000
-#define MSM_GPU_MEM_SIZE	0x00300000
-
-#define MSM_RAM_CONSOLE_BASE	0x03A00000
-#define MSM_RAM_CONSOLE_SIZE	0x00040000
-
-#ifdef CONFIG_BUILD_CIQ
-#define MSM_PMEM_CIQ_BASE		MSM_RAM_CONSOLE_BASE + MSM_RAM_CONSOLE_SIZE
-#define MSM_PMEM_CIQ_SIZE		SZ_64K
-#define MSM_PMEM_CIQ1_BASE	MSM_PMEM_CIQ_BASE
-#define MSM_PMEM_CIQ1_SIZE	MSM_PMEM_CIQ_SIZE
-#define MSM_PMEM_CIQ2_BASE	MSM_PMEM_CIQ_BASE
-#define MSM_PMEM_CIQ2_SIZE	MSM_PMEM_CIQ_SIZE
-#define MSM_PMEM_CIQ3_BASE	MSM_PMEM_CIQ_BASE
-#define MSM_PMEM_CIQ3_SIZE	MSM_PMEM_CIQ_SIZE
-#endif
-
-#define MSM_FB_BASE		0x03B00000
-#define MSM_FB_SIZE		0x00465000
-
-#define MSM_EBI1_BANK0_BASE	0x20000000
-//#define MSM_EBI1_BANK0_SIZE	0x0E000000	/* radio < 3210 */
-#define MSM_EBI1_BANK0_SIZE	0x0E800000 /*for radio >=3210 */
-
-/* 4Gb/512MB DRAM */
-#define MSM_EBI1_BANK1_BASE	0x30000000
-#define MSM_EBI1_BANK1_SIZE	0x0B300000
-
-#define MSM_PMEM_MDP_BASE	0x3B300000
-#define MSM_PMEM_MDP_SIZE	0x02000000
-
-#define MSM_PMEM_ADSP_BASE	0x3D300000
-#define MSM_PMEM_ADSP_SIZE	0x02900000
-
-#define MSM_PMEM_CAMERA_BASE    0x3FB00000
-#define MSM_PMEM_CAMERA_SIZE    0x00C00000
-
-#define SUPERSONIC_GPIO_UP_INT_N		35
-#define SUPERSONIC_GPIO_UP_RESET_N		108
-
-#define SUPERSONIC_GPIO_TP_RST		34
-#define SUPERSONIC_GPIO_TP_INT_N		38
-#define SUPERSONIC_GPIO_TP_EN			100	/* V_TP3V3_EN */
-
-//#define SUPERSONIC_GPIO_POWER_KEY		94
-#define SUPERSONIC_GPIO_SDMC_CD_N		28
-
-/* BT */
-#define SUPERSONIC_GPIO_BT_UART1_RTS	(43)
-#define SUPERSONIC_GPIO_BT_UART1_CTS	(44)
-#define SUPERSONIC_GPIO_BT_UART1_RX		(45)
-#define SUPERSONIC_GPIO_BT_UART1_TX		(46)
-#define SUPERSONIC_GPIO_BT_RESET_N		(27)
-#define SUPERSONIC_GPIO_BT_SHUTDOWN_N	(146)
-#define SUPERSONIC_GPIO_BT_HOST_WAKE	(86)
-#define SUPERSONIC_GPIO_BT_CHIP_WAKE	(87)
-
-#define SUPERSONIC_GPIO_COMPASS_RST_N	107
-#define SUPERSONIC_GPIO_COMPASS_INT_N	36
-#define SUPERSONIC_PROJECT_NAME        "supersonic"
-#define SUPERSONIC_LAYOUTS             { \
-		{ {  0,  1, 0}, { -1,  0, 0}, {0, 0, 1} }, \
-		{ {  0, -1, 0}, { -1,  0, 0}, {0, 0, 1} }, \
-		{ { -1,  0, 0}, {  0, -1, 0}, {0, 0, 1} }, \
-		{ {  1,  0, 0}, {  0,  0, 1}, {0, 1, 0} }  \
-					}
-
-/* Proximity */
-#define SUPERSONIC_GPIO_PROXIMITY_EN_N	109
-
-/* Battery */
-#define SUPERSONIC_GPIO_MBAT_IN		39
-#define SUPERSONIC_GPIO_MCHG_EN_N	22
-#define SUPERSONIC_GPIO_ISET		16
-
-/*Audio */
-#define SUPERSONIC_AUD_JACKHP_EN       157
-#define SUPERSONIC_AUD_2V5_EN          26
-#define SUPERSONIC_AUD_SPK_EN            129
-
-/* Bluetooth PCM */
-#define SUPERSONIC_BT_PCM_OUT          68
-#define SUPERSONIC_BT_PCM_IN           69
-#define SUPERSONIC_BT_PCM_SYNC         70
-#define SUPERSONIC_BT_PCM_CLK          71
-
-//#define SUPERSONIC_MENU_KEY   40
-#define SUPERSONIC_VOLUME_UP     41
-#define SUPERSONIC_VOLUME_DOWN   42
-#define SUPERSONIC_POWER_KEY     94
-
-/* flash light */
-#define SUPERSONIC_GPIO_FLASHLIGHT_FLASH (84)
-#define SUPERSONIC_GPIO_FLASHLIGHT_TORCH (85)
-#define SUPERSONIC_GPIO_FLASHLIGHT_FLASH_ADJ (31)
-
-/* AP Key Led turn on*/
-#define SUPERSONIC_AP_KEY_LED_EN                     (32)
-
-/* UART/USB switch : high -> UART, low -> HSUSB */
-#define SUPERSONIC_USB_UARTz_SW			33
-#define SUPERSONIC_WIMAX_CPU_UARTz_SW	160
-
-/* USB PHY 3V3 enable*/
-#define SUPERSONIC_USB_PHY_3V3_ENABLE   (104)
-#define SUPERSONIC_GPIO_USB_CABLE_IN_PIN          (82)
-#define SUPERSONIC_GPIO_USB_ID_PIN          (37)
-/* 35mm headset */
-#define SUPERSONIC_GPIO_35MM_HEADSET_DET (153)
-#if 0 /* TODO */
-//#define SUPERSONIC_GPIO_H2W_POWER (27)
-//#define SUPERSONIC_GPIO_CABLE_IN1 (38)
-#define SUPERSONIC_GPIO_CABLE_IN (37)
-//#define SUPERSONIC_GPIO_H2W_DATA (139)
-//#define SUPERSONIC_GPIO_H2W_CLK (140)
-#endif
-
-/* UART1*/
-#define SUPERSONIC_GPIO_UART1_RX (139)
-#define SUPERSONIC_GPIO_UART1_TX (140)
-
-/* Wifi */
-#define SUPERSONIC_GPIO_WIFI_SHUTDOWN_N	147
-#define SUPERSONIC_GPIO_WIFI_IRQ		152
-/*camera*/
-#define SUPERSONIC_MAINCAM_PWD	105
-#define SUPERSONIC_MAINCAM_RST	99
-#define SUPERSONIC_2NDCAM_PWD	120
-#define SUPERSONIC_CLK_SWITCH	102
-
-#define SUPERSONIC_LCD_RST	(113)
-unsigned supersonic_get_skuid(void);
-
-/* HDMI */
-#define HDMI_RST               (111)
-#define V_HDMI_1V2_EN          (119)
-#define V_VGA_5V_SIL9022A_EN   (127)
-#define V_HDMI_3V3_EN          (128)
-#define SUPERSONIC_I2S_CLK     (142)
-#define SUPERSONIC_I2S_WS      (143)
-#define SUPERSONIC_I2S_DOUT    (145)
-
-/* LCD RGB */
-#define SUPERSONIC_LCD_R0      (114)
-#define SUPERSONIC_LCD_R1      (115)
-#define SUPERSONIC_LCD_R2      (116)
-#define SUPERSONIC_LCD_R3      (117)
-#define SUPERSONIC_LCD_R4      (118)
-
-#define SUPERSONIC_LCD_G0      (121)
-#define SUPERSONIC_LCD_G1      (122)
-#define SUPERSONIC_LCD_G2      (123)
-#define SUPERSONIC_LCD_G3      (124)
-#define SUPERSONIC_LCD_G4      (125)
-#define SUPERSONIC_LCD_G5      (126)
-
-#define SUPERSONIC_LCD_B0      (130)
-#define SUPERSONIC_LCD_B1      (131)
-#define SUPERSONIC_LCD_B2      (132)
-#define SUPERSONIC_LCD_B3      (133)
-#define SUPERSONIC_LCD_B4      (134)
-
-#define SUPERSONIC_LCD_PCLK    (135)
-#define SUPERSONIC_LCD_VSYNC   (136)
-#define SUPERSONIC_LCD_HSYNC   (137)
-#define SUPERSONIC_LCD_DE      (138)
-
-#define SUPERSONIC_GPIO_PS_HOLD		(25)
-
-#endif /* __ARCH_ARM_MACH_MSM_BOARD_SUPERSONIC_H */
diff --git a/arch/arm/mach-msm/board-swordfish-keypad.c b/arch/arm/mach-msm/board-swordfish-keypad.c
deleted file mode 100644
index f2c2f39..0000000
--- a/arch/arm/mach-msm/board-swordfish-keypad.c
+++ /dev/null
@@ -1,177 +0,0 @@
-/* linux/arch/arm/mach-msm/board-swordfish-keypad.c
- *
- * Copyright (C) 2007 Google, Inc.
- * Author: Brian Swetland <swetland@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <asm/mach-types.h>
-#include <linux/platform_device.h>
-#include <linux/gpio_event.h>
-
-#undef MODULE_PARAM_PREFIX
-#define MODULE_PARAM_PREFIX "board_swordfish."
-static int swordfish_ffa;
-module_param_named(ffa, swordfish_ffa, int, S_IRUGO | S_IWUSR | S_IWGRP);
-
-#define SCAN_FUNCTION_KEYS 0 /* don't turn this on without updating the ffa support */
-
-static unsigned int swordfish_row_gpios[] = {
-	31, 32, 33, 34, 35, 41
-#if SCAN_FUNCTION_KEYS
-	, 42
-#endif
-};
-
-static unsigned int swordfish_col_gpios[] = { 36, 37, 38, 39, 40 };
-
-/* FFA:
- 36: KEYSENSE_N(0)
- 37: KEYSENSE_N(1)
- 38: KEYSENSE_N(2)
- 39: KEYSENSE_N(3)
- 40: KEYSENSE_N(4)
-
- 31: KYPD_17
- 32: KYPD_15
- 33: KYPD_13
- 34: KYPD_11
- 35: KYPD_9
- 41: KYPD_MEMO
-*/
-
-#define KEYMAP_INDEX(row, col) ((row)*ARRAY_SIZE(swordfish_col_gpios) + (col))
-
-static const unsigned short swordfish_keymap[ARRAY_SIZE(swordfish_col_gpios) * ARRAY_SIZE(swordfish_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_5,
-	[KEYMAP_INDEX(0, 1)] = KEY_9,
-	[KEYMAP_INDEX(0, 2)] = 229,            /* SOFT1 */
-	[KEYMAP_INDEX(0, 3)] = KEY_6,
-	[KEYMAP_INDEX(0, 4)] = KEY_LEFT,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_0,
-	[KEYMAP_INDEX(1, 1)] = KEY_RIGHT,
-	[KEYMAP_INDEX(1, 2)] = KEY_1,
-	[KEYMAP_INDEX(1, 3)] = 228,           /* KEY_SHARP */
-	[KEYMAP_INDEX(1, 4)] = KEY_SEND,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(2, 1)] = KEY_HOME,      /* FA   */
-	[KEYMAP_INDEX(2, 2)] = KEY_F8,        /* QCHT */
-	[KEYMAP_INDEX(2, 3)] = KEY_F6,        /* R+   */
-	[KEYMAP_INDEX(2, 4)] = KEY_F7,        /* R-   */
-
-	[KEYMAP_INDEX(3, 0)] = KEY_UP,
-	[KEYMAP_INDEX(3, 1)] = KEY_CLEAR,
-	[KEYMAP_INDEX(3, 2)] = KEY_4,
-	[KEYMAP_INDEX(3, 3)] = KEY_MUTE,      /* SPKR */
-	[KEYMAP_INDEX(3, 4)] = KEY_2,
-
-	[KEYMAP_INDEX(4, 0)] = 230,           /* SOFT2 */
-	[KEYMAP_INDEX(4, 1)] = 232,           /* KEY_CENTER */
-	[KEYMAP_INDEX(4, 2)] = KEY_DOWN,
-	[KEYMAP_INDEX(4, 3)] = KEY_BACK,      /* FB */
-	[KEYMAP_INDEX(4, 4)] = KEY_8,
-
-	[KEYMAP_INDEX(5, 0)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(5, 1)] = 227,           /* KEY_STAR */
-	[KEYMAP_INDEX(5, 2)] = KEY_MAIL,      /* MESG */
-	[KEYMAP_INDEX(5, 3)] = KEY_3,
-	[KEYMAP_INDEX(5, 4)] = KEY_7,
-
-#if SCAN_FUNCTION_KEYS
-	[KEYMAP_INDEX(6, 0)] = KEY_F5,
-	[KEYMAP_INDEX(6, 1)] = KEY_F4,
-	[KEYMAP_INDEX(6, 2)] = KEY_F3,
-	[KEYMAP_INDEX(6, 3)] = KEY_F2,
-	[KEYMAP_INDEX(6, 4)] = KEY_F1
-#endif
-};
-
-static const unsigned short swordfish_keymap_ffa[ARRAY_SIZE(swordfish_col_gpios) * ARRAY_SIZE(swordfish_row_gpios)] = {
-	/*[KEYMAP_INDEX(0, 0)] = ,*/
-	/*[KEYMAP_INDEX(0, 1)] = ,*/
-	[KEYMAP_INDEX(0, 2)] = KEY_1,
-	[KEYMAP_INDEX(0, 3)] = KEY_SEND,
-	[KEYMAP_INDEX(0, 4)] = KEY_LEFT,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_3,
-	[KEYMAP_INDEX(1, 1)] = KEY_RIGHT,
-	[KEYMAP_INDEX(1, 2)] = KEY_VOLUMEUP,
-	/*[KEYMAP_INDEX(1, 3)] = ,*/
-	[KEYMAP_INDEX(1, 4)] = KEY_6,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_HOME,      /* A */
-	[KEYMAP_INDEX(2, 1)] = KEY_BACK,      /* B */
-	[KEYMAP_INDEX(2, 2)] = KEY_0,
-	[KEYMAP_INDEX(2, 3)] = 228,           /* KEY_SHARP */
-	[KEYMAP_INDEX(2, 4)] = KEY_9,
-
-	[KEYMAP_INDEX(3, 0)] = KEY_UP,
-	[KEYMAP_INDEX(3, 1)] = 232, /* KEY_CENTER */ /* i */
-	[KEYMAP_INDEX(3, 2)] = KEY_4,
-	/*[KEYMAP_INDEX(3, 3)] = ,*/
-	[KEYMAP_INDEX(3, 4)] = KEY_2,
-
-	[KEYMAP_INDEX(4, 0)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(4, 1)] = KEY_SOUND,
-	[KEYMAP_INDEX(4, 2)] = KEY_DOWN,
-	[KEYMAP_INDEX(4, 3)] = KEY_8,
-	[KEYMAP_INDEX(4, 4)] = KEY_5,
-
-	/*[KEYMAP_INDEX(5, 0)] = ,*/
-	[KEYMAP_INDEX(5, 1)] = 227,           /* KEY_STAR */
-	[KEYMAP_INDEX(5, 2)] = 230, /*SOFT2*/ /* 2 */
-	[KEYMAP_INDEX(5, 3)] = KEY_MENU,      /* 1 */
-	[KEYMAP_INDEX(5, 4)] = KEY_7,
-};
-
-static struct gpio_event_matrix_info swordfish_matrix_info = {
-	.info.func	= gpio_event_matrix_func,
-	.keymap		= swordfish_keymap,
-	.output_gpios	= swordfish_row_gpios,
-	.input_gpios	= swordfish_col_gpios,
-	.noutputs	= ARRAY_SIZE(swordfish_row_gpios),
-	.ninputs	= ARRAY_SIZE(swordfish_col_gpios),
-	.settle_time.tv.nsec = 0,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.flags		= GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_DRIVE_INACTIVE | GPIOKPF_PRINT_UNMAPPED_KEYS /*| GPIOKPF_PRINT_MAPPED_KEYS*/
-};
-
-struct gpio_event_info *swordfish_keypad_info[] = {
-	&swordfish_matrix_info.info
-};
-
-static struct gpio_event_platform_data swordfish_keypad_data = {
-	.name		= "swordfish_keypad",
-	.info		= swordfish_keypad_info,
-	.info_count	= ARRAY_SIZE(swordfish_keypad_info)
-};
-
-static struct platform_device swordfish_keypad_device = {
-	.name	= GPIO_EVENT_DEV_NAME,
-	.id	= -1,
-	.dev	= {
-		.platform_data	= &swordfish_keypad_data,
-	},
-};
-
-static int __init swordfish_init_keypad(void)
-{
-	if (!machine_is_swordfish())
-		return 0;
-	if (swordfish_ffa)
-		swordfish_matrix_info.keymap = swordfish_keymap_ffa;
-	return platform_device_register(&swordfish_keypad_device);
-}
-
-device_initcall(swordfish_init_keypad);
diff --git a/arch/arm/mach-msm/board-swordfish-mmc.c b/arch/arm/mach-msm/board-swordfish-mmc.c
deleted file mode 100644
index fe19b27..0000000
--- a/arch/arm/mach-msm/board-swordfish-mmc.c
+++ /dev/null
@@ -1,265 +0,0 @@
-/* linux/arch/arm/mach-msm/board-swordfish-mmc.c
- *
- * Copyright (C) 2008 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- *
- */
-
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/platform_device.h>
-
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <asm/mach/mmc.h>
-
-#include <mach/vreg.h>
-
-#include "proc_comm.h"
-#include "devices.h"
-
-#define FPGA_BASE		0x70000000
-#define FPGA_SDIO_STATUS	0x280
-
-static void __iomem *fpga_base;
-
-#define DEBUG_SWORDFISH_MMC 1
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-static int config_gpio_table(unsigned *table, int len, int enable)
-{
-	int n;
-	int rc = 0;
-
-	for (n = 0; n < len; n++) {
-		unsigned dis = !enable;
-		unsigned id = table[n];
-
-		if (msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, &dis)) {
-			pr_err("%s: id=0x%08x dis=%d\n", __func__, table[n],
-			       dis);
-			rc = -1;
-		}
-	}
-
-	return rc;
-}
-
-static unsigned sdc1_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),
-};
-
-static unsigned sdc2_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),
-	PCOM_GPIO_CFG(63, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(64, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(65, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(66, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(67, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA),
-};
-
-static unsigned sdc3_gpio_table[] = {
-	PCOM_GPIO_CFG(88, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),
-	PCOM_GPIO_CFG(89, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(90, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(91, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(92, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(93, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-};
-
-static unsigned sdc4_gpio_table[] = {
-	PCOM_GPIO_CFG(142, 3, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),
-	PCOM_GPIO_CFG(143, 3, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(144, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(145, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(146, 3, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-	PCOM_GPIO_CFG(147, 3, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA),
-};
-
-struct sdc_info {
-	unsigned *table;
-	unsigned len;
-};
-
-static struct sdc_info sdcc_gpio_tables[] = {
-	[0] = {
-		.table	= sdc1_gpio_table,
-		.len	= ARRAY_SIZE(sdc1_gpio_table),
-	},
-	[1] = {
-		.table	= sdc2_gpio_table,
-		.len	= ARRAY_SIZE(sdc2_gpio_table),
-	},
-	[2] = {
-		.table	= sdc3_gpio_table,
-		.len	= ARRAY_SIZE(sdc3_gpio_table),
-	},
-	[3] = {
-		.table	= sdc4_gpio_table,
-		.len	= ARRAY_SIZE(sdc4_gpio_table),
-	},
-};
-
-static int swordfish_sdcc_setup_gpio(int dev_id, unsigned enable)
-{
-	struct sdc_info *info;
-
-	if (dev_id < 1 || dev_id > 4)
-		return -1;
-
-	info = &sdcc_gpio_tables[dev_id - 1];
-	return config_gpio_table(info->table, info->len, enable);
-}
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_165_195,	1800 },
-	{ MMC_VDD_20_21,	2050 },
-	{ MMC_VDD_21_22,	2150 },
-	{ MMC_VDD_22_23,	2250 },
-	{ MMC_VDD_23_24,	2350 },
-	{ MMC_VDD_24_25,	2450 },
-	{ MMC_VDD_25_26,	2550 },
-	{ MMC_VDD_26_27,	2650 },
-	{ MMC_VDD_27_28,	2750 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2950 },
-};
-
-static struct vreg *vreg_sdcc;
-static unsigned int vreg_sdcc_enabled;
-static unsigned int sdcc_vdd = 0xffffffff;
-
-static uint32_t sdcc_translate_vdd(struct device *dev, unsigned int vdd)
-{
-	int i;
-	int rc = 0;
-	struct platform_device *pdev;
-
-	pdev = container_of(dev, struct platform_device, dev);
-	BUG_ON(!vreg_sdcc);
-
-	if (vdd == sdcc_vdd)
-		return 0;
-
-	sdcc_vdd = vdd;
-
-	/* enable/disable the signals to the slot */
-	swordfish_sdcc_setup_gpio(pdev->id, !!vdd);
-
-	/* power down */
-	if (vdd == 0) {
-#if DEBUG_SWORDFISH_MMC
-		pr_info("%s: disable sdcc power\n", __func__);
-#endif
-		vreg_disable(vreg_sdcc);
-		vreg_sdcc_enabled = 0;
-		return 0;
-	}
-
-	if (!vreg_sdcc_enabled) {
-		mdelay(5);
-		rc = vreg_enable(vreg_sdcc);
-		if (rc)
-			pr_err("%s: Error enabling vreg (%d)\n", __func__, rc);
-		udelay(500);
-		vreg_sdcc_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask != (1 << vdd))
-			continue;
-#if DEBUG_SWORDFISH_MMC
-		pr_info("%s: Setting level to %u\n", __func__,
-			mmc_vdd_table[i].level);
-#endif
-		rc = vreg_set_level(vreg_sdcc, mmc_vdd_table[i].level);
-		if (rc)
-			pr_err("%s: Error setting vreg level (%d)\n", __func__, 				rc);
-		return 0;
-	}
-
-	pr_err("%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int swordfish_sdcc_slot_status (struct device *dev)
-{
-	struct platform_device *pdev;
-	uint32_t sdcc_stat;
-
-	pdev = container_of(dev, struct platform_device, dev);
-
-	sdcc_stat = readl(fpga_base + FPGA_SDIO_STATUS);
-
-	/* bit 0 - sdcc1 crd_det
-	 * bit 1 - sdcc1 wr_prt
-	 * bit 2 - sdcc2 crd_det
-	 * bit 3 - sdcc2 wr_prt
-	 * etc...
-	 */
-
-	/* crd_det is active low */
-	return !(sdcc_stat & (1 << ((pdev->id - 1) << 1)));
-}
-
-#define SWORDFISH_MMC_VDD (MMC_VDD_165_195 | MMC_VDD_20_21 | MMC_VDD_21_22 \
-			| MMC_VDD_22_23 | MMC_VDD_23_24 | MMC_VDD_24_25 \
-			| MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 \
-			| MMC_VDD_28_29 | MMC_VDD_29_30)
-
-static struct mmc_platform_data swordfish_sdcc_data = {
-	.ocr_mask	= SWORDFISH_MMC_VDD/*MMC_VDD_27_28 | MMC_VDD_28_29*/,
-	.status		= swordfish_sdcc_slot_status,
-	.translate_vdd	= sdcc_translate_vdd,
-};
-
-int __init swordfish_init_mmc(void)
-{
-	vreg_sdcc_enabled = 0;
-	vreg_sdcc = vreg_get(NULL, "gp5");
-	if (IS_ERR(vreg_sdcc)) {
-		pr_err("%s: vreg get failed (%ld)\n",
-		       __func__, PTR_ERR(vreg_sdcc));
-		return PTR_ERR(vreg_sdcc);
-	}
-
-	fpga_base = ioremap(FPGA_BASE, SZ_4K);
-	if (!fpga_base) {
-		pr_err("%s: Can't ioremap FPGA base address (0x%08x)\n",
-		       __func__, FPGA_BASE);
-		vreg_put(vreg_sdcc);
-		return -EIO;
-	}
-
-	msm_add_sdcc(1, &swordfish_sdcc_data, 0, 0);
-	msm_add_sdcc(4, &swordfish_sdcc_data, 0, 0);
-
-	return 0;
-}
-
diff --git a/arch/arm/mach-msm/board-swordfish-panel.c b/arch/arm/mach-msm/board-swordfish-panel.c
deleted file mode 100644
index cf5f3f6..0000000
--- a/arch/arm/mach-msm/board-swordfish-panel.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/* linux/arch/arm/mach-msm/board-swordfish-panel.c
- *
- * Copyright (c) 2009 Google Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * Author: Dima Zavin <dima@android.com>
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/err.h>
-
-#include <asm/io.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-
-#include "board-swordfish.h"
-#include "devices.h"
-
-#define CLK_NS_TO_RATE(ns)			(1000000000UL / (ns))
-
-int swordfish_panel_blank(struct msm_lcdc_panel_ops *ops)
-{
-	/* TODO: Turn backlight off? */
-	return 0;
-}
-
-int swordfish_panel_unblank(struct msm_lcdc_panel_ops *ops)
-{
-	/* TODO: Turn backlight on? */
-	return 0;
-}
-
-int swordfish_panel_init(struct msm_lcdc_panel_ops *ops)
-{
-	return 0;
-}
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct msm_lcdc_timing swordfish_lcdc_timing = {
-	.clk_rate		= CLK_NS_TO_RATE(26),
-	.hsync_pulse_width	= 60,
-	.hsync_back_porch	= 81,
-	.hsync_front_porch	= 81,
-	.hsync_skew		= 0,
-	.vsync_pulse_width	= 2,
-	.vsync_back_porch	= 20,
-	.vsync_front_porch	= 27,
-	.vsync_act_low		= 0,
-	.hsync_act_low		= 0,
-	.den_act_low		= 0,
-};
-
-static struct msm_fb_data swordfish_lcdc_fb_data = {
-	.xres		= 800,
-	.yres		= 480,
-	.width		= 94,
-	.height		= 57,
-	.output_format	= 0,
-};
-
-static struct msm_lcdc_panel_ops swordfish_lcdc_panel_ops = {
-	.init		= swordfish_panel_init,
-	.blank		= swordfish_panel_blank,
-	.unblank	= swordfish_panel_unblank,
-};
-
-static struct msm_lcdc_platform_data swordfish_lcdc_platform_data = {
-	.panel_ops	= &swordfish_lcdc_panel_ops,
-	.timing		= &swordfish_lcdc_timing,
-	.fb_id		= 0,
-	.fb_data	= &swordfish_lcdc_fb_data,
-	.fb_resource = &resources_msm_fb[0],
-};
-
-static struct platform_device swordfish_lcdc_device = {
-	.name	= "msm_mdp_lcdc",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &swordfish_lcdc_platform_data,
-	},
-};
-
-int __init swordfish_init_panel(void)
-{
-	int rc;
-	if (!machine_is_swordfish())
-		return 0;
-
-	if ((rc = platform_device_register(&msm_device_mdp)) != 0)
-		return rc;
-
-	if ((rc = platform_device_register(&swordfish_lcdc_device)) != 0)
-		return rc;
-
-	return 0;
-}
-
-device_initcall(swordfish_init_panel);
diff --git a/arch/arm/mach-msm/board-swordfish.c b/arch/arm/mach-msm/board-swordfish.c
deleted file mode 100644
index 25ea36c..0000000
--- a/arch/arm/mach-msm/board-swordfish.c
+++ /dev/null
@@ -1,337 +0,0 @@
-/* linux/arch/arm/mach-msm/board-swordfish.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Author: Brian Swetland <swetland@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/android_pmem.h>
-#include <linux/msm_kgsl.h>
-
-#include <mach/hardware.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/setup.h>
-
-#include <mach/board.h>
-#include <mach/irqs.h>
-#include <mach/msm_iomap.h>
-#include <mach/msm_hsusb.h>
-#include <mach/msm_ts.h>
-
-#ifdef CONFIG_USB_FUNCTION_MASS_STORAGE
-#include <linux/usb/mass_storage_function.h>
-#endif
-
-#ifdef CONFIG_USB_ANDROID
-#include <linux/usb/android.h>
-#endif
-
-#include "board-swordfish.h"
-#include "devices.h"
-
-extern int swordfish_init_mmc(void);
-
-static struct resource smc91x_resources[] = {
-	[0] = {
-		.start	= 0x70000300,
-		.end	= 0x70000400,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= MSM_GPIO_TO_INT(156),
-		.end	= MSM_GPIO_TO_INT(156),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smc91x_device = {
-	.name		= "smc91x",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(smc91x_resources),
-	.resource	= smc91x_resources,
-};
-
-#ifdef CONFIG_USB_FUNCTION
-static char *swordfish_usb_functions[] = {
-#if defined(CONFIG_USB_FUNCTION_MASS_STORAGE)
-	"usb_mass_storage",
-#endif
-#ifdef CONFIG_USB_FUNCTION_ADB
-	"adb",
-#endif
-};
-
-static struct msm_hsusb_product swordfish_usb_products[] = {
-	{
-		.product_id     = 0x0d01,
-		.functions      = 0x00000001, /* "usb_mass_storage" only */
-	},
-	{
-		.product_id     = 0x0d02,
-		.functions      = 0x00000003, /* "usb_mass_storage" and "adb" */
-	},
-};
-#endif
-
-static int swordfish_phy_init_seq[] = { 0x1D, 0x0D, 0x1D, 0x10, -1 };
-
-static struct msm_hsusb_platform_data msm_hsusb_pdata = {
-	.phy_init_seq		= swordfish_phy_init_seq,
-#ifdef CONFIG_USB_FUNCTION
-	.vendor_id		= 0x18d1,
-	.product_id		= 0x0d02,
-	.version		= 0x0100,
-	.product_name		= "Swordfish",
-	.serial_number		= "42",
-	.manufacturer_name	= "Qualcomm",
-
-	.functions		= swordfish_usb_functions,
-	.num_functions		= ARRAY_SIZE(swordfish_usb_functions),
-	.products		= swordfish_usb_products,
-	.num_products		= ARRAY_SIZE(swordfish_usb_products),
-#endif
-};
-
-#ifdef CONFIG_USB_FUNCTION_MASS_STORAGE
-static struct usb_mass_storage_platform_data mass_storage_pdata = {
-	.nluns		= 1,
-	.buf_size	= 16384,
-	.vendor		= "Qualcomm",
-	.product	= "Swordfish",
-	.release	= 0x0100,
-};
-
-static struct platform_device usb_mass_storage_device = {
-	.name	= "usb_mass_storage",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &mass_storage_pdata,
-	},
-};
-#endif
-
-static struct resource msm_kgsl_resources[] = {
-        {
-                .name   = "kgsl_reg_memory",
-                .start  = MSM_GPU_REG_PHYS,
-                .end    = MSM_GPU_REG_PHYS + MSM_GPU_REG_SIZE - 1,
-                .flags  = IORESOURCE_MEM,
-        },
-        {
-                .name   = "kgsl_phys_memory",
-                .start  = MSM_GPU_MEM_BASE,
-                .end    = MSM_GPU_MEM_BASE + MSM_GPU_MEM_SIZE - 1,
-                .flags  = IORESOURCE_MEM,
-        },
-        {
-                .start  = INT_GRAPHICS,
-                .end    = INT_GRAPHICS,
-                .flags  = IORESOURCE_IRQ,
-        },
-};
-
-static struct platform_device msm_kgsl_device = {
-        .name           = "kgsl",
-        .id             = -1,
-        .resource       = msm_kgsl_resources,
-        .num_resources  = ARRAY_SIZE(msm_kgsl_resources),
-};
-
-static struct android_pmem_platform_data mdp_pmem_pdata = {
-        .name           = "pmem",
-        .start          = MSM_PMEM_MDP_BASE,
-        .size           = MSM_PMEM_MDP_SIZE,
-        .no_allocator   = 0,
-        .cached         = 1,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu0_pdata = {
-        .name           = "pmem_gpu0",
-        .start          = MSM_PMEM_GPU0_BASE,
-        .size           = MSM_PMEM_GPU0_SIZE,
-        .no_allocator   = 0,
-        .cached         = 0,
-};
-
-static struct android_pmem_platform_data android_pmem_gpu1_pdata = {
-        .name           = "pmem_gpu1",
-        .start          = MSM_PMEM_GPU1_BASE,
-        .size           = MSM_PMEM_GPU1_SIZE,
-        .no_allocator   = 0,
-        .cached         = 0,
-};
-
-static struct android_pmem_platform_data android_pmem_adsp_pdata = {
-        .name           = "pmem_adsp",
-        .start          = MSM_PMEM_ADSP_BASE,
-        .size           = MSM_PMEM_ADSP_SIZE,
-        .no_allocator   = 0,
-        .cached         = 0,
-};
-
-static struct platform_device android_pmem_mdp_device = {
-        .name           = "android_pmem",
-        .id             = 0,
-        .dev            = {
-                .platform_data = &mdp_pmem_pdata
-        },
-};
-
-static struct platform_device android_pmem_adsp_device = {
-        .name           = "android_pmem",
-        .id             = 1,
-        .dev            = {
-                .platform_data = &android_pmem_adsp_pdata,
-        },
-};
-
-static struct platform_device android_pmem_gpu0_device = {
-        .name           = "android_pmem",
-        .id             = 2,
-        .dev            = {
-                .platform_data = &android_pmem_gpu0_pdata,
-        },
-};
-
-static struct platform_device android_pmem_gpu1_device = {
-        .name           = "android_pmem",
-        .id             = 3,
-        .dev            = {
-                .platform_data = &android_pmem_gpu1_pdata,
-        },
-};
-
-#ifdef CONFIG_USB_ANDROID
-static struct android_usb_platform_data android_usb_pdata = {
-	.vendor_id		= 0x18d1,
-	.product_id		= 0x0d01,
-	.adb_product_id		= 0x0d02,
-	.version		= 0x0100,
-	.serial_number		= "42",
-	.product_name		= "Swordfishdroid",
-	.manufacturer_name	= "Qualcomm",
-	.nluns			= 1,
-};
-
-static struct platform_device android_usb_device = {
-	.name	= "android_usb",
-	.id	= -1,
-	.dev	= {
-		.platform_data = &android_usb_pdata,
-	},
-};
-#endif
-
-static struct platform_device fish_battery_device = {
-	.name = "fish_battery",
-};
-
-static struct msm_ts_platform_data swordfish_ts_pdata = {
-	.min_x		= 296,
-	.max_x		= 3800,
-	.min_y		= 296,
-	.max_y		= 3800,
-	.min_press	= 0,
-	.max_press	= 256,
-	.inv_x		= 4096,
-	.inv_y		= 4096,
-};
-
-static struct platform_device *devices[] __initdata = {
-#if !defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	&msm_device_uart3,
-#endif
-	&msm_device_smd,
-	&msm_device_nand,
-	&msm_device_hsusb,
-#ifdef CONFIG_USB_FUNCTION_MASS_STORAGE
-	&usb_mass_storage_device,
-#endif
-#ifdef CONFIG_USB_ANDROID
-	&android_usb_device,
-#endif
-	&fish_battery_device,
-	&smc91x_device,
-	&msm_device_touchscreen,
-	&android_pmem_mdp_device,
-	&android_pmem_adsp_device,
-	&android_pmem_gpu0_device,
-	&android_pmem_gpu1_device,
-	&msm_kgsl_device,
-};
-
-extern struct sys_timer msm_timer;
-
-static struct msm_acpu_clock_platform_data swordfish_clock_data = {
-	.acpu_switch_time_us	= 20,
-	.max_speed_delta_khz	= 256000,
-	.vdd_switch_time_us	= 62,
-	.power_collapse_khz	= 128000000,
-	.wait_for_irq_khz	= 128000000,
-};
-
-void msm_serial_debug_init(unsigned int base, int irq,
-			   struct device *clk_device, int signal_irq);
-
-static void __init swordfish_init(void)
-{
-	int rc;
-
-	msm_acpu_clock_init(&swordfish_clock_data);
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-			      &msm_device_uart3.dev, 1);
-#endif
-	msm_device_hsusb.dev.platform_data = &msm_hsusb_pdata;
-	msm_device_touchscreen.dev.platform_data = &swordfish_ts_pdata;
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-	msm_hsusb_set_vbus_state(1);
-	rc = swordfish_init_mmc();
-	if (rc)
-		pr_crit("%s: MMC init failure (%d)\n", __func__, rc);
-}
-
-static void __init swordfish_fixup(struct machine_desc *desc, struct tag *tags,
-				 char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks = 1;
-	mi->bank[0].start = PHYS_OFFSET;
-	mi->bank[0].node = PHYS_TO_NID(PHYS_OFFSET);
-	mi->bank[0].size = (101*1024*1024);
-}
-
-static void __init swordfish_map_io(void)
-{
-	msm_map_common_io();
-	msm_clock_init();
-}
-
-MACHINE_START(SWORDFISH, "Swordfish Board (QCT SURF8250)")
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params	= 0x20000100,
-	.fixup		= swordfish_fixup,
-	.map_io		= swordfish_map_io,
-	.init_irq	= msm_init_irq,
-	.init_machine	= swordfish_init,
-	.timer		= &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-swordfish.h b/arch/arm/mach-msm/board-swordfish.h
deleted file mode 100644
index b9ea54f..0000000
--- a/arch/arm/mach-msm/board-swordfish.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/* arch/arm/mach-msm/board-swordfish.h
- *
- * Copyright (C) 2009 Google Inc.
- * Author: Dima Zavin <dima@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-*/
-
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_SWORDFISH_H
-#define __ARCH_ARM_MACH_MSM_BOARD_SWORDFISH_H
-
-#include <mach/board.h>
-
-#define MSM_SMI_BASE		0x02B00000
-#define MSM_SMI_SIZE		0x01500000
-
-#define MSM_PMEM_MDP_BASE	0x03000000
-#define MSM_PMEM_MDP_SIZE	0x01000000
-
-#define MSM_EBI1_BASE		0x20000000
-#define MSM_EBI1_SIZE		0x0E000000
-
-#define MSM_PMEM_ADSP_BASE      0x2A300000
-#define MSM_PMEM_ADSP_SIZE      0x02000000
-
-#define MSM_PMEM_GPU1_BASE	0x2C300000
-#define MSM_PMEM_GPU1_SIZE	0x01400000
-
-#define MSM_PMEM_GPU0_BASE	0x2D700000
-#define MSM_PMEM_GPU0_SIZE	0x00400000
-
-#define MSM_GPU_MEM_BASE	0x2DB00000
-#define MSM_GPU_MEM_SIZE	0x00200000
-
-#define MSM_RAM_CONSOLE_BASE	0x2DD00000
-#define MSM_RAM_CONSOLE_SIZE	0x00040000
-
-#define MSM_FB_BASE		0x2DE00000
-#define MSM_FB_SIZE		0x00200000
-
-#endif /* __ARCH_ARM_MACH_MSM_BOARD_SWORDFISH_H */
diff --git a/arch/arm/mach-msm/board-trout-gpio.c b/arch/arm/mach-msm/board-trout-gpio.c
deleted file mode 100644
index 527379e..0000000
--- a/arch/arm/mach-msm/board-trout-gpio.c
+++ /dev/null
@@ -1,305 +0,0 @@
-/* arch/arm/mach-msm/board-trout-gpio.c
- *
- * Copyright (C) 2008 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/irq.h>
-#include <linux/pm.h>
-#include <linux/sysdev.h>
-
-#include <asm/io.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include <mach/htc_pwrsink.h>
-
-#include "board-trout.h"
-#include "gpio_chip.h"
-
-#undef MODULE_PARAM_PREFIX
-#define MODULE_PARAM_PREFIX "board_trout."
-
-static uint cpld_usb_h2w_sw;
-module_param_named(usb_h2w_sw, cpld_usb_h2w_sw, uint, 0);
-
-static uint8_t trout_cpld_shadow[4] = {
-#if defined(CONFIG_MSM_DEBUG_UART1)
-	/* H2W pins <-> UART1 */
-        [0] = 0x40, // for serial debug, low current
-#else
-	/* H2W pins <-> UART3, Bluetooth <-> UART1 */
-        [0] = 0x80, // for serial debug, low current
-#endif
-        [1] = 0x04, // I2C_PULL
-        [3] = 0x04, // mmdi 32k en
-};
-static uint8_t trout_int_mask[2] = {
-        [0] = 0xff, /* mask all interrupts */
-        [1] = 0xff,
-};
-static uint8_t trout_sleep_int_mask[] = {
-        [0] = 0xff,
-        [1] = 0xff,
-};
-static int trout_suspended;
-
-static int trout_gpio_read(struct gpio_chip *chip, unsigned n)
-{
-	uint8_t b;
-	int reg;
-	if (n >= TROUT_GPIO_VIRTUAL_BASE)
-		n += TROUT_GPIO_VIRTUAL_TO_REAL_OFFSET;
-	b = 1U << (n & 7);
-	reg = (n & 0x78) >> 2; // assumes base is 128
-	return !!(readb(TROUT_CPLD_BASE + reg) & b);
-}
-
-static void update_pwrsink(unsigned gpio, unsigned on)
-{
-	switch(gpio) {
-	case TROUT_GPIO_UI_LED_EN:
-		htc_pwrsink_set(PWRSINK_LED_BUTTON, on ? 100 : 0);
-		break;
-	case TROUT_GPIO_QTKEY_LED_EN:
-		htc_pwrsink_set(PWRSINK_LED_KEYBOARD, on ? 100 : 0);
-		break;
-	}
-}
-
-static uint8_t trout_gpio_write_shadow(unsigned n, unsigned on)
-{
-	uint8_t b = 1U << (n & 7);
-	int reg = (n & 0x78) >> 2; // assumes base is 128
-
-	if(on)
-		return trout_cpld_shadow[reg >> 1] |= b;
-	else
-		return trout_cpld_shadow[reg >> 1] &= ~b;
-}
-
-static int trout_gpio_write(struct gpio_chip *chip, unsigned n, unsigned on)
-{
-	int reg = (n & 0x78) >> 2; // assumes base is 128
-	unsigned long flags;
-	uint8_t reg_val;
-
-	if ((reg >> 1) >= ARRAY_SIZE(trout_cpld_shadow)) {
-		printk(KERN_ERR "trout_gpio_write called on input %d\n", n);
-		return -ENOTSUPP;
-	}
-
-	local_irq_save(flags);
-	update_pwrsink(n, on);
-	reg_val = trout_gpio_write_shadow(n, on);
-	writeb(reg_val, TROUT_CPLD_BASE + reg);
-	local_irq_restore(flags);
-	return 0;
-}
-
-static int trout_gpio_configure(struct gpio_chip *chip, unsigned int gpio, unsigned long flags)
-{
-	if(flags & (GPIOF_OUTPUT_LOW | GPIOF_OUTPUT_HIGH))
-		trout_gpio_write(chip, gpio, flags & GPIOF_OUTPUT_HIGH);
-	return 0;
-}
-
-static int trout_gpio_get_irq_num(struct gpio_chip *chip, unsigned int gpio, unsigned int *irqp, unsigned long *irqnumflagsp)
-{
-	if ((gpio < TROUT_GPIO_BANK0_FIRST_INT_SOURCE ||
-	     gpio > TROUT_GPIO_BANK0_LAST_INT_SOURCE) &&
-	    (gpio < TROUT_GPIO_BANK1_FIRST_INT_SOURCE ||
-	     gpio > TROUT_GPIO_BANK1_LAST_INT_SOURCE))
-		return -ENOENT;
-	*irqp = TROUT_GPIO_TO_INT(gpio);
-	if(irqnumflagsp)
-		*irqnumflagsp = 0;
-	return 0;
-}
-
-static void trout_gpio_irq_ack(unsigned int irq)
-{
-	int bank = TROUT_INT_TO_BANK(irq);
-	uint8_t mask = TROUT_INT_TO_MASK(irq);
-	int reg = TROUT_BANK_TO_STAT_REG(bank);
-	/*printk(KERN_INFO "trout_gpio_irq_ack irq %d\n", irq);*/
-	writeb(mask, TROUT_CPLD_BASE + reg);
-}
-
-static void trout_gpio_irq_mask(unsigned int irq)
-{
-	unsigned long flags;
-	uint8_t reg_val;
-	int bank = TROUT_INT_TO_BANK(irq);
-	uint8_t mask = TROUT_INT_TO_MASK(irq);
-	int reg = TROUT_BANK_TO_MASK_REG(bank);
-
-	local_irq_save(flags);
-	reg_val = trout_int_mask[bank] |= mask;
-	/*printk(KERN_INFO "trout_gpio_irq_mask irq %d => %d:%02x\n",
-	       irq, bank, reg_val);*/
-	if (!trout_suspended)
-		writeb(reg_val, TROUT_CPLD_BASE + reg);
-	local_irq_restore(flags);
-}
-
-static void trout_gpio_irq_unmask(unsigned int irq)
-{
-	unsigned long flags;
-	uint8_t reg_val;
-	int bank = TROUT_INT_TO_BANK(irq);
-	uint8_t mask = TROUT_INT_TO_MASK(irq);
-	int reg = TROUT_BANK_TO_MASK_REG(bank);
-
-	local_irq_save(flags);
-	reg_val = trout_int_mask[bank] &= ~mask;
-	/*printk(KERN_INFO "trout_gpio_irq_unmask irq %d => %d:%02x\n",
-	       irq, bank, reg_val);*/
-	if (!trout_suspended)
-		writeb(reg_val, TROUT_CPLD_BASE + reg);
-	local_irq_restore(flags);
-}
-
-int trout_gpio_irq_set_wake(unsigned int irq, unsigned int on)
-{
-	unsigned long flags;
-	int bank = TROUT_INT_TO_BANK(irq);
-	uint8_t mask = TROUT_INT_TO_MASK(irq);
-
-	local_irq_save(flags);
-	if(on)
-		trout_sleep_int_mask[bank] &= ~mask;
-	else
-		trout_sleep_int_mask[bank] |= mask;
-	local_irq_restore(flags);
-	return 0;
-}
-
-static void trout_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
-{
-	int j, m;
-	unsigned v;
-	int bank;
-	int stat_reg;
-	int int_base = TROUT_INT_START;
-	uint8_t int_mask;
-
-	for (bank = 0; bank < 2; bank++) {
-		stat_reg = TROUT_BANK_TO_STAT_REG(bank);
-		v = readb(TROUT_CPLD_BASE + stat_reg);
-		int_mask = trout_int_mask[bank];
-		if (v & int_mask) {
-			writeb(v & int_mask, TROUT_CPLD_BASE + stat_reg);
-			printk(KERN_ERR "trout_gpio_irq_handler: got masked "
-			       "interrupt: %d:%02x\n", bank, v & int_mask);
-		}
-		v &= ~int_mask;
-		while (v) {
-			m = v & -v;
-			j = fls(m) - 1;
-			/*printk(KERN_INFO "msm_gpio_irq_handler %d:%02x %02x b"
-			       "it %d irq %d\n", bank, v, m, j, int_base + j);*/
-			v &= ~m;
-			generic_handle_irq(int_base + j);
-		}
-		int_base += TROUT_INT_BANK0_COUNT;
-	}
-	desc->chip->ack(irq);
-}
-
-static int trout_sysdev_suspend(struct sys_device *dev, pm_message_t state)
-{
-	trout_suspended = 1;
-	writeb(trout_sleep_int_mask[0],
-	       TROUT_CPLD_BASE + TROUT_GPIO_INT_MASK0_REG);
-	writeb(trout_sleep_int_mask[1],
-	       TROUT_CPLD_BASE + TROUT_GPIO_INT_MASK1_REG);
-	writeb(trout_sleep_int_mask[0],
-	       TROUT_CPLD_BASE + TROUT_GPIO_INT_STAT0_REG);
-	writeb(trout_sleep_int_mask[1],
-	       TROUT_CPLD_BASE + TROUT_GPIO_INT_STAT1_REG);
-	return 0;
-}
-
-int trout_sysdev_resume(struct sys_device *dev)
-{
-	writeb(trout_int_mask[0], TROUT_CPLD_BASE + TROUT_GPIO_INT_MASK0_REG);
-	writeb(trout_int_mask[1], TROUT_CPLD_BASE + TROUT_GPIO_INT_MASK1_REG);
-	trout_suspended = 0;
-	return 0;
-}
-
-static struct irq_chip trout_gpio_irq_chip = {
-	.name      = "troutgpio",
-	.ack       = trout_gpio_irq_ack,
-	.mask      = trout_gpio_irq_mask,
-	.unmask    = trout_gpio_irq_unmask,
-	.set_wake  = trout_gpio_irq_set_wake,
-	//.set_type  = trout_gpio_irq_set_type,
-};
-
-static struct gpio_chip trout_gpio_chip = {
-	.start = TROUT_GPIO_START,
-	.end = TROUT_GPIO_END,
-	.configure = trout_gpio_configure,
-	.get_irq_num = trout_gpio_get_irq_num,
-	.read = trout_gpio_read,
-	.write = trout_gpio_write,
-//	.read_detect_status = trout_gpio_read_detect_status,
-//	.clear_detect_status = trout_gpio_clear_detect_status
-};
-
-struct sysdev_class trout_sysdev_class = {
-	.name = "troutgpio_irq",
-	.suspend = trout_sysdev_suspend,
-	.resume = trout_sysdev_resume,
-};
-
-static struct sys_device trout_irq_device = {
-	.cls    = &trout_sysdev_class,
-};
-
-static int __init trout_init_gpio(void)
-{
-	int i;
-
-	if (!machine_is_trout())
-		return 0;
-
-	/* adjust GPIOs based on bootloader request */
-	pr_info("trout_init_gpio: cpld_usb_hw2_sw = %d\n", cpld_usb_h2w_sw);
-	trout_gpio_write_shadow(TROUT_GPIO_USB_H2W_SW, cpld_usb_h2w_sw);
-
-	for(i = 0; i < ARRAY_SIZE(trout_cpld_shadow); i++)
-		writeb(trout_cpld_shadow[i], TROUT_CPLD_BASE + i * 2);
-
-	for(i = TROUT_INT_START; i <= TROUT_INT_END; i++) {
-		set_irq_chip(i, &trout_gpio_irq_chip);
-		set_irq_handler(i, handle_edge_irq);
-		set_irq_flags(i, IRQF_VALID);
-	}
-
-	register_gpio_chip(&trout_gpio_chip);
-
-	set_irq_type(MSM_GPIO_TO_INT(17), IRQF_TRIGGER_HIGH);
-	set_irq_chained_handler(MSM_GPIO_TO_INT(17), trout_gpio_irq_handler);
-	set_irq_wake(MSM_GPIO_TO_INT(17), 1);
-
-	if(sysdev_class_register(&trout_sysdev_class) == 0)
-		sysdev_register(&trout_irq_device);
-
-	return 0;
-}
-
-postcore_initcall(trout_init_gpio);
diff --git a/arch/arm/mach-msm/board-trout-keypad.c b/arch/arm/mach-msm/board-trout-keypad.c
deleted file mode 100644
index 0299d06..0000000
--- a/arch/arm/mach-msm/board-trout-keypad.c
+++ /dev/null
@@ -1,345 +0,0 @@
-/* arch/arm/mach-msm/board-trout-keypad.c
- *
- * Copyright (C) 2008 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/gpio_event.h>
-#include <asm/mach-types.h>
-
-#include "board-trout.h"
-
-static char *keycaps = "--qwerty";
-#undef MODULE_PARAM_PREFIX
-#define MODULE_PARAM_PREFIX "board_trout."
-module_param_named(keycaps, keycaps, charp, 0);
-
-
-static unsigned int trout_col_gpios[] = { 35, 34, 33, 32, 31, 23, 30, 78 };
-static unsigned int trout_row_gpios[] = { 42, 41, 40, 39, 38, 37, 36 };
-
-#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(trout_row_gpios) + (row))
-
-static const unsigned short trout_keymap[ARRAY_SIZE(trout_col_gpios) * ARRAY_SIZE(trout_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_BACK,
-	[KEYMAP_INDEX(0, 1)] = KEY_HOME,
-//	[KEYMAP_INDEX(0, 2)] = KEY_,
-	[KEYMAP_INDEX(0, 3)] = KEY_BACKSPACE,
-	[KEYMAP_INDEX(0, 4)] = KEY_ENTER,
-	[KEYMAP_INDEX(0, 5)] = KEY_RIGHTALT,
-	[KEYMAP_INDEX(0, 6)] = KEY_P,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-//	[KEYMAP_INDEX(1, 0)] = 229, // SOFT1
-	[KEYMAP_INDEX(1, 1)] = KEY_SEND,
-	[KEYMAP_INDEX(1, 2)] = KEY_END,
-	[KEYMAP_INDEX(1, 3)] = KEY_LEFTALT,
-	[KEYMAP_INDEX(1, 4)] = KEY_A,
-	[KEYMAP_INDEX(1, 5)] = KEY_LEFTSHIFT,
-	[KEYMAP_INDEX(1, 6)] = KEY_Q,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_U,
-	[KEYMAP_INDEX(2, 1)] = KEY_7,
-	[KEYMAP_INDEX(2, 2)] = KEY_K,
-	[KEYMAP_INDEX(2, 3)] = KEY_J,
-	[KEYMAP_INDEX(2, 4)] = KEY_M,
-	[KEYMAP_INDEX(2, 5)] = KEY_SLASH,
-	[KEYMAP_INDEX(2, 6)] = KEY_8,
-
-	[KEYMAP_INDEX(3, 0)] = KEY_5,
-	[KEYMAP_INDEX(3, 1)] = KEY_6,
-	[KEYMAP_INDEX(3, 2)] = KEY_B,
-	[KEYMAP_INDEX(3, 3)] = KEY_H,
-	[KEYMAP_INDEX(3, 4)] = KEY_N,
-	[KEYMAP_INDEX(3, 5)] = KEY_SPACE,
-	[KEYMAP_INDEX(3, 6)] = KEY_Y,
-
-	[KEYMAP_INDEX(4, 0)] = KEY_4,
-	[KEYMAP_INDEX(4, 1)] = KEY_R,
-	[KEYMAP_INDEX(4, 2)] = KEY_V,
-	[KEYMAP_INDEX(4, 3)] = KEY_G,
-	[KEYMAP_INDEX(4, 4)] = KEY_C,
-	//[KEYMAP_INDEX(4, 5)] = KEY_,
-	[KEYMAP_INDEX(4, 6)] = KEY_T,
-
-	[KEYMAP_INDEX(5, 0)] = KEY_2,
-	[KEYMAP_INDEX(5, 1)] = KEY_W,
-	[KEYMAP_INDEX(5, 2)] = KEY_COMPOSE,
-	[KEYMAP_INDEX(5, 3)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(5, 4)] = KEY_S,
-	[KEYMAP_INDEX(5, 5)] = KEY_Z,
-	[KEYMAP_INDEX(5, 6)] = KEY_1,
-
-	[KEYMAP_INDEX(6, 0)] = KEY_I,
-	[KEYMAP_INDEX(6, 1)] = KEY_0,
-	[KEYMAP_INDEX(6, 2)] = KEY_O,
-	[KEYMAP_INDEX(6, 3)] = KEY_L,
-	[KEYMAP_INDEX(6, 4)] = KEY_DOT,
-	[KEYMAP_INDEX(6, 5)] = KEY_COMMA,
-	[KEYMAP_INDEX(6, 6)] = KEY_9,
-
-	[KEYMAP_INDEX(7, 0)] = KEY_3,
-	[KEYMAP_INDEX(7, 1)] = KEY_E,
-	[KEYMAP_INDEX(7, 2)] = KEY_EMAIL, // @
-	[KEYMAP_INDEX(7, 3)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(7, 4)] = KEY_X,
-	[KEYMAP_INDEX(7, 5)] = KEY_F,
-	[KEYMAP_INDEX(7, 6)] = KEY_D
-};
-
-static unsigned int trout_col_gpios_evt2[] = { 35, 34, 33, 32, 31, 23, 30, 109 };
-static unsigned int trout_row_gpios_evt2[] = { 42, 41, 40, 39, 38, 37, 36 };
-
-static const unsigned short trout_keymap_evt2_1[ARRAY_SIZE(trout_col_gpios) * ARRAY_SIZE(trout_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_BACK,
-	[KEYMAP_INDEX(0, 1)] = KEY_HOME,
-//	[KEYMAP_INDEX(0, 2)] = KEY_,
-	[KEYMAP_INDEX(0, 3)] = KEY_BACKSPACE,
-	[KEYMAP_INDEX(0, 4)] = KEY_ENTER,
-	[KEYMAP_INDEX(0, 5)] = KEY_RIGHTSHIFT,
-	[KEYMAP_INDEX(0, 6)] = KEY_P,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU,
-	[KEYMAP_INDEX(1, 1)] = KEY_SEND,
-//	[KEYMAP_INDEX(1, 2)] = KEY_,
-	[KEYMAP_INDEX(1, 3)] = KEY_LEFTSHIFT,
-	[KEYMAP_INDEX(1, 4)] = KEY_A,
-	[KEYMAP_INDEX(1, 5)] = KEY_COMPOSE,
-	[KEYMAP_INDEX(1, 6)] = KEY_Q,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_U,
-	[KEYMAP_INDEX(2, 1)] = KEY_7,
-	[KEYMAP_INDEX(2, 2)] = KEY_K,
-	[KEYMAP_INDEX(2, 3)] = KEY_J,
-	[KEYMAP_INDEX(2, 4)] = KEY_M,
-	[KEYMAP_INDEX(2, 5)] = KEY_SLASH,
-	[KEYMAP_INDEX(2, 6)] = KEY_8,
-
-	[KEYMAP_INDEX(3, 0)] = KEY_5,
-	[KEYMAP_INDEX(3, 1)] = KEY_6,
-	[KEYMAP_INDEX(3, 2)] = KEY_B,
-	[KEYMAP_INDEX(3, 3)] = KEY_H,
-	[KEYMAP_INDEX(3, 4)] = KEY_N,
-	[KEYMAP_INDEX(3, 5)] = KEY_SPACE,
-	[KEYMAP_INDEX(3, 6)] = KEY_Y,
-
-	[KEYMAP_INDEX(4, 0)] = KEY_4,
-	[KEYMAP_INDEX(4, 1)] = KEY_R,
-	[KEYMAP_INDEX(4, 2)] = KEY_V,
-	[KEYMAP_INDEX(4, 3)] = KEY_G,
-	[KEYMAP_INDEX(4, 4)] = KEY_C,
-//	[KEYMAP_INDEX(4, 5)] = KEY_,
-	[KEYMAP_INDEX(4, 6)] = KEY_T,
-
-	[KEYMAP_INDEX(5, 0)] = KEY_2,
-	[KEYMAP_INDEX(5, 1)] = KEY_W,
-	[KEYMAP_INDEX(5, 2)] = KEY_LEFTALT,
-	[KEYMAP_INDEX(5, 3)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(5, 4)] = KEY_S,
-	[KEYMAP_INDEX(5, 5)] = KEY_Z,
-	[KEYMAP_INDEX(5, 6)] = KEY_1,
-
-	[KEYMAP_INDEX(6, 0)] = KEY_I,
-	[KEYMAP_INDEX(6, 1)] = KEY_0,
-	[KEYMAP_INDEX(6, 2)] = KEY_O,
-	[KEYMAP_INDEX(6, 3)] = KEY_L,
-	[KEYMAP_INDEX(6, 4)] = KEY_COMMA,
-	[KEYMAP_INDEX(6, 5)] = KEY_DOT,
-	[KEYMAP_INDEX(6, 6)] = KEY_9,
-
-	[KEYMAP_INDEX(7, 0)] = KEY_3,
-	[KEYMAP_INDEX(7, 1)] = KEY_E,
-	[KEYMAP_INDEX(7, 2)] = KEY_EMAIL, // @
-	[KEYMAP_INDEX(7, 3)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(7, 4)] = KEY_X,
-	[KEYMAP_INDEX(7, 5)] = KEY_F,
-	[KEYMAP_INDEX(7, 6)] = KEY_D
-};
-
-static const unsigned short trout_keymap_evt2_2[ARRAY_SIZE(trout_col_gpios) * ARRAY_SIZE(trout_row_gpios)] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_BACK,
-	[KEYMAP_INDEX(0, 1)] = KEY_HOME,
-//	[KEYMAP_INDEX(0, 2)] = KEY_,
-	[KEYMAP_INDEX(0, 3)] = KEY_BACKSPACE,
-	[KEYMAP_INDEX(0, 4)] = KEY_ENTER,
-	[KEYMAP_INDEX(0, 5)] = KEY_RIGHTSHIFT,
-	[KEYMAP_INDEX(0, 6)] = KEY_P,
-
-	[KEYMAP_INDEX(1, 0)] = KEY_MENU, /* external menu key */
-	[KEYMAP_INDEX(1, 1)] = KEY_SEND,
-//	[KEYMAP_INDEX(1, 2)] = KEY_,
-	[KEYMAP_INDEX(1, 3)] = KEY_LEFTSHIFT,
-	[KEYMAP_INDEX(1, 4)] = KEY_A,
-	[KEYMAP_INDEX(1, 5)] = KEY_F1, /* qwerty menu key */
-	[KEYMAP_INDEX(1, 6)] = KEY_Q,
-
-	[KEYMAP_INDEX(2, 0)] = KEY_U,
-	[KEYMAP_INDEX(2, 1)] = KEY_7,
-	[KEYMAP_INDEX(2, 2)] = KEY_K,
-	[KEYMAP_INDEX(2, 3)] = KEY_J,
-	[KEYMAP_INDEX(2, 4)] = KEY_M,
-	[KEYMAP_INDEX(2, 5)] = KEY_DOT,
-	[KEYMAP_INDEX(2, 6)] = KEY_8,
-
-	[KEYMAP_INDEX(3, 0)] = KEY_5,
-	[KEYMAP_INDEX(3, 1)] = KEY_6,
-	[KEYMAP_INDEX(3, 2)] = KEY_B,
-	[KEYMAP_INDEX(3, 3)] = KEY_H,
-	[KEYMAP_INDEX(3, 4)] = KEY_N,
-	[KEYMAP_INDEX(3, 5)] = KEY_SPACE,
-	[KEYMAP_INDEX(3, 6)] = KEY_Y,
-
-	[KEYMAP_INDEX(4, 0)] = KEY_4,
-	[KEYMAP_INDEX(4, 1)] = KEY_R,
-	[KEYMAP_INDEX(4, 2)] = KEY_V,
-	[KEYMAP_INDEX(4, 3)] = KEY_G,
-	[KEYMAP_INDEX(4, 4)] = KEY_C,
-	[KEYMAP_INDEX(4, 5)] = KEY_EMAIL, // @
-	[KEYMAP_INDEX(4, 6)] = KEY_T,
-
-	[KEYMAP_INDEX(5, 0)] = KEY_2,
-	[KEYMAP_INDEX(5, 1)] = KEY_W,
-	[KEYMAP_INDEX(5, 2)] = KEY_LEFTALT,
-	[KEYMAP_INDEX(5, 3)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(5, 4)] = KEY_S,
-	[KEYMAP_INDEX(5, 5)] = KEY_Z,
-	[KEYMAP_INDEX(5, 6)] = KEY_1,
-
-	[KEYMAP_INDEX(6, 0)] = KEY_I,
-	[KEYMAP_INDEX(6, 1)] = KEY_0,
-	[KEYMAP_INDEX(6, 2)] = KEY_O,
-	[KEYMAP_INDEX(6, 3)] = KEY_L,
-	[KEYMAP_INDEX(6, 4)] = KEY_COMMA,
-	[KEYMAP_INDEX(6, 5)] = KEY_RIGHTALT,
-	[KEYMAP_INDEX(6, 6)] = KEY_9,
-
-	[KEYMAP_INDEX(7, 0)] = KEY_3,
-	[KEYMAP_INDEX(7, 1)] = KEY_E,
-	[KEYMAP_INDEX(7, 2)] = KEY_COMPOSE,
-	[KEYMAP_INDEX(7, 3)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(7, 4)] = KEY_X,
-	[KEYMAP_INDEX(7, 5)] = KEY_F,
-	[KEYMAP_INDEX(7, 6)] = KEY_D
-};
-
-static struct gpio_event_matrix_info trout_keypad_matrix_info = {
-	.info.func = gpio_event_matrix_func,
-	.keymap = trout_keymap,
-	.output_gpios = trout_col_gpios,
-	.input_gpios = trout_row_gpios,
-	.noutputs = ARRAY_SIZE(trout_col_gpios),
-	.ninputs = ARRAY_SIZE(trout_row_gpios),
-	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
-	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
-	.flags = GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_REMOVE_PHANTOM_KEYS |GPIOKPF_PRINT_UNMAPPED_KEYS /*| GPIOKPF_PRINT_MAPPED_KEYS*/
-};
-
-static struct gpio_event_direct_entry trout_keypad_nav_map[] = {
-	{ TROUT_POWER_KEY,              KEY_POWER    },
-	{ TROUT_GPIO_CAM_BTN_STEP1_N,   KEY_CAMERA-1 }, //steal KEY_HP
-	{ TROUT_GPIO_CAM_BTN_STEP2_N,   KEY_CAMERA   },
-};
-
-static struct gpio_event_direct_entry trout_keypad_nav_map_evt2[] = {
-	{ TROUT_POWER_KEY,              KEY_END      },
-	{ TROUT_GPIO_CAM_BTN_STEP1_N,   KEY_CAMERA-1 }, //steal KEY_HP
-	{ TROUT_GPIO_CAM_BTN_STEP2_N,   KEY_CAMERA   },
-};
-
-static struct gpio_event_input_info trout_keypad_nav_info = {
-	.info.func = gpio_event_input_func,
-	.flags = 0,
-	.type = EV_KEY,
-	.keymap = trout_keypad_nav_map,
-	.keymap_size = ARRAY_SIZE(trout_keypad_nav_map)
-};
-
-static struct gpio_event_direct_entry trout_keypad_switch_map[] = {
-	{ TROUT_GPIO_SLIDING_DET,       SW_LID       }
-};
-
-static struct gpio_event_input_info trout_keypad_switch_info = {
-	.info.func = gpio_event_input_func,
-	.flags = 0,
-	.type = EV_SW,
-	.keymap = trout_keypad_switch_map,
-	.keymap_size = ARRAY_SIZE(trout_keypad_switch_map)
-};
-
-static struct gpio_event_info *trout_keypad_info[] = {
-	&trout_keypad_matrix_info.info,
-	&trout_keypad_nav_info.info,
-	&trout_keypad_switch_info.info,
-};
-
-static struct gpio_event_platform_data trout_keypad_data = {
-	.name = "trout-keypad",
-	.info = trout_keypad_info,
-	.info_count = ARRAY_SIZE(trout_keypad_info)
-};
-
-static struct platform_device trout_keypad_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 0,
-	.dev		= {
-		.platform_data	= &trout_keypad_data,
-	},
-};
-
-static int __init trout_init_keypad(void)
-{
-	if (!machine_is_trout())
-		return 0;
-
-	switch (system_rev) {
-	case 0:
-		/* legacy default keylayout */
-		break;
-	case 1:
-		/* v1 has a new keyboard layout */
-		trout_keypad_matrix_info.keymap = trout_keymap_evt2_1;
-		trout_keypad_matrix_info.output_gpios = trout_col_gpios_evt2;
-		trout_keypad_matrix_info.input_gpios = trout_row_gpios_evt2;
-		
-		/* v1 has new direct keys */
-		trout_keypad_nav_info.keymap = trout_keypad_nav_map_evt2;
-		trout_keypad_nav_info.keymap_size = ARRAY_SIZE(trout_keypad_nav_map_evt2);
-
-		/* userspace needs to know about these changes as well */
-		trout_keypad_data.name = "trout-keypad-v2";
-		break;
-	default: /* 2, 3, 4 currently */
-		/* v2 has a new keyboard layout */
-		trout_keypad_matrix_info.keymap = trout_keymap_evt2_2;
-		trout_keypad_matrix_info.output_gpios = trout_col_gpios_evt2;
-		trout_keypad_matrix_info.input_gpios = trout_row_gpios_evt2;
-		
-		/* v2 has new direct keys */
-		trout_keypad_nav_info.keymap = trout_keypad_nav_map_evt2;
-		trout_keypad_nav_info.keymap_size = ARRAY_SIZE(trout_keypad_nav_map_evt2);
-
-		/* userspace needs to know about these changes as well */
-		if (!strcmp(keycaps, "qwertz")) {
-			trout_keypad_data.name = "trout-keypad-qwertz";
-		} else {
-			trout_keypad_data.name = "trout-keypad-v3";
-		}
-		break;
-	}
-	return platform_device_register(&trout_keypad_device);
-}
-
-device_initcall(trout_init_keypad);
-
diff --git a/arch/arm/mach-msm/board-trout-mmc.c b/arch/arm/mach-msm/board-trout-mmc.c
deleted file mode 100644
index f57bd3e..0000000
--- a/arch/arm/mach-msm/board-trout-mmc.c
+++ /dev/null
@@ -1,440 +0,0 @@
-/* linux/arch/arm/mach-msm/board-trout-mmc.c
-** Author: Brian Swetland <swetland@google.com>
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/err.h>
-#include <linux/debugfs.h>
-
-#include <asm/gpio.h>
-#include <asm/io.h>
-
-#include <mach/vreg.h>
-#include <mach/htc_pwrsink.h>
-
-#include <asm/mach/mmc.h>
-
-#include "devices.h"
-
-#include "board-trout.h"
-
-#include "proc_comm.h"
-
-#define DEBUG_SDSLOT_VDD 1
-
-extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,
-			unsigned int stat_irq, unsigned long stat_irq_flags);
-
-/* ---- COMMON ---- */
-static void config_gpio_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for(n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-/* ---- SDCARD ---- */
-
-static uint32_t sdcard_on_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 2, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(63, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(64, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-};
-
-static uint32_t sdcard_off_gpio_table[] = {
-	PCOM_GPIO_CFG(62, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(63, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(64, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(65, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(66, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(67, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-};
-
-static uint opt_disable_sdcard;
-
-static int __init trout_disablesdcard_setup(char *str)
-{
-	int cal = simple_strtol(str, NULL, 0);
-	
-	opt_disable_sdcard = cal;
-	return 1;
-}
-
-__setup("board_trout.disable_sdcard=", trout_disablesdcard_setup);
-
-static struct vreg *vreg_sdslot;	/* SD slot power */
-
-struct mmc_vdd_xlat {
-	int mask;
-	int level;
-};
-
-static struct mmc_vdd_xlat mmc_vdd_table[] = {
-	{ MMC_VDD_165_195,	1800 },
-	{ MMC_VDD_20_21,	2050 },
-	{ MMC_VDD_21_22,	2150 },
-	{ MMC_VDD_22_23,	2250 },
-	{ MMC_VDD_23_24,	2350 },
-	{ MMC_VDD_24_25,	2450 },
-	{ MMC_VDD_25_26,	2550 },
-	{ MMC_VDD_26_27,	2650 },
-	{ MMC_VDD_27_28,	2750 },
-	{ MMC_VDD_28_29,	2850 },
-	{ MMC_VDD_29_30,	2950 },
-};
-
-static unsigned int sdslot_vdd = 0xffffffff;
-static unsigned int sdslot_vreg_enabled;
-
-static uint32_t trout_sdslot_switchvdd(struct device *dev, unsigned int vdd)
-{
-	int i, rc;
-
-	BUG_ON(!vreg_sdslot);
-
-	if (vdd == sdslot_vdd)
-		return 0;
-
-	sdslot_vdd = vdd;
-
-	if (vdd == 0) {
-#if DEBUG_SDSLOT_VDD
-		printk("%s: Disabling SD slot power\n", __func__);
-#endif
-		config_gpio_table(sdcard_off_gpio_table,
-				  ARRAY_SIZE(sdcard_off_gpio_table));
-		vreg_disable(vreg_sdslot);
-		sdslot_vreg_enabled = 0;
-		return 0;
-	}
-
-	if (!sdslot_vreg_enabled) {
-		mdelay(5);
-		rc = vreg_enable(vreg_sdslot);
-		if (rc) {
-			printk(KERN_ERR "%s: Error enabling vreg (%d)\n",
-			       __func__, rc);
-		}
-		udelay(500);
-		config_gpio_table(sdcard_on_gpio_table,
-				  ARRAY_SIZE(sdcard_on_gpio_table));
-		sdslot_vreg_enabled = 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mmc_vdd_table); i++) {
-		if (mmc_vdd_table[i].mask == (1 << vdd)) {
-#if DEBUG_SDSLOT_VDD
-			printk("%s: Setting level to %u\n",
-			        __func__, mmc_vdd_table[i].level);
-#endif
-			rc = vreg_set_level(vreg_sdslot,
-					    mmc_vdd_table[i].level);
-			if (rc) {
-				printk(KERN_ERR
-				       "%s: Error setting vreg level (%d)\n",
-				       __func__, rc);
-			}
-			return 0;
-		}
-	}
-
-	printk(KERN_ERR "%s: Invalid VDD %d specified\n", __func__, vdd);
-	return 0;
-}
-
-static unsigned int trout_sdslot_status(struct device *dev)
-{
-	unsigned int status;
-
-	status = (unsigned int) gpio_get_value(TROUT_GPIO_SDMC_CD_N);
-	return (!status);
-}
-
-#define TROUT_MMC_VDD	MMC_VDD_165_195 | MMC_VDD_20_21 | MMC_VDD_21_22 \
-			| MMC_VDD_22_23 | MMC_VDD_23_24 | MMC_VDD_24_25 \
-			| MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 \
-			| MMC_VDD_28_29 | MMC_VDD_29_30
-
-static struct mmc_platform_data trout_sdslot_data = {
-	.ocr_mask	= TROUT_MMC_VDD,
-	.status		= trout_sdslot_status,
-	.translate_vdd	= trout_sdslot_switchvdd,
-};
-
-/* ---- WIFI ---- */
-
-static uint32_t wifi_on_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_8MA), /* CMD */
-	PCOM_GPIO_CFG(56, 1, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_8MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_INPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static uint32_t wifi_off_gpio_table[] = {
-	PCOM_GPIO_CFG(51, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(52, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(53, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT1 */
-	PCOM_GPIO_CFG(54, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT0 */
-	PCOM_GPIO_CFG(55, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CMD */
-	PCOM_GPIO_CFG(56, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* CLK */
-	PCOM_GPIO_CFG(29, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA),  /* WLAN IRQ */
-};
-
-static struct vreg *vreg_wifi_osc;	/* WIFI 32khz oscilator */
-static int trout_wifi_cd = 0;		/* WIFI virtual 'card detect' status */
-
-static struct sdio_embedded_func wifi_func = {
-	.f_class	= SDIO_CLASS_WLAN,
-	.f_maxblksize	= 512,
-};
-
-static struct embedded_sdio_data trout_wifi_emb_data = {
-	.cis	= {
-		.vendor		= 0x104c,
-		.device		= 0x9066,
-		.blksize	= 512,
-		/*.max_dtr	= 24000000,  Max of chip - no worky on Trout */
-		.max_dtr	= 20000000,
-	},
-	.cccr	= {
-		.multi_block	= 0,
-		.low_speed	= 0,
-		.wide_bus	= 1,
-		.high_power	= 0,
-		.high_speed	= 0,
-	},
-	.funcs	= &wifi_func,
-	.num_funcs = 1,
-};
-
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
-static int trout_wifi_status_register(void (*callback)(int card_present, void *dev_id), void *dev_id)
-{
-	if (wifi_status_cb)
-		return -EAGAIN;
-	wifi_status_cb = callback;
-	wifi_status_cb_devid = dev_id;
-	return 0;
-}
-
-static unsigned int trout_wifi_status(struct device *dev)
-{
-	return trout_wifi_cd;
-}
-
-int trout_wifi_set_carddetect(int val)
-{
-	printk("%s: %d\n", __func__, val);
-	trout_wifi_cd = val;
-	if (wifi_status_cb) {
-		wifi_status_cb(val, wifi_status_cb_devid);
-	} else
-		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
-	return 0;
-}
-#ifndef CONFIG_WIFI_CONTROL_FUNC
-EXPORT_SYMBOL(trout_wifi_set_carddetect);
-#endif
-
-static int trout_wifi_power_state;
-
-int trout_wifi_power(int on)
-{
-	int rc;
-
-	printk("%s: %d\n", __func__, on);
-
-	if (on) {
-		config_gpio_table(wifi_on_gpio_table,
-				  ARRAY_SIZE(wifi_on_gpio_table));
-		rc = vreg_enable(vreg_wifi_osc);
-		if (rc)
-			return rc;
-		htc_pwrsink_set(PWRSINK_WIFI, 70);
-	} else {
-		config_gpio_table(wifi_off_gpio_table,
-				  ARRAY_SIZE(wifi_off_gpio_table));
-		htc_pwrsink_set(PWRSINK_WIFI, 0);
-	}
-	gpio_set_value( TROUT_GPIO_MAC_32K_EN, on);
-	mdelay(100);
-	gpio_set_value( TROUT_GPIO_WIFI_EN, on);
-	mdelay(100);
-	if (!on) {
-		vreg_disable(vreg_wifi_osc);
-	}
-	trout_wifi_power_state = on;
-	return 0;
-}
-#ifndef CONFIG_WIFI_CONTROL_FUNC
-EXPORT_SYMBOL(trout_wifi_power);
-#endif
-
-static int trout_wifi_reset_state;
-int trout_wifi_reset(int on)
-{
-	printk("%s: %d\n", __func__, on);
-	gpio_set_value( TROUT_GPIO_WIFI_PA_RESETX, !on );
-	trout_wifi_reset_state = on;
-	mdelay(50);
-	return 0;
-}
-#ifndef CONFIG_WIFI_CONTROL_FUNC
-EXPORT_SYMBOL(trout_wifi_reset);
-#endif
-
-static struct mmc_platform_data trout_wifi_data = {
-	.ocr_mask		= MMC_VDD_28_29,
-	.status			= trout_wifi_status,
-	.register_status_notify	= trout_wifi_status_register,
-	.embedded_sdio		= &trout_wifi_emb_data,
-};
-
-int __init trout_init_mmc(unsigned int sys_rev)
-{
-	wifi_status_cb = NULL;
-
-	sdslot_vreg_enabled = 0;
-
-	vreg_sdslot = vreg_get(0, "gp6");
-	if (IS_ERR(vreg_sdslot))
-		return PTR_ERR(vreg_sdslot);
-	vreg_wifi_osc = vreg_get(0, "mmc");
-	if (IS_ERR(vreg_wifi_osc))
-		return PTR_ERR(vreg_wifi_osc);
-
-	set_irq_wake(TROUT_GPIO_TO_INT(TROUT_GPIO_SDMC_CD_N), 1);
-
-	msm_add_sdcc(1, &trout_wifi_data, 0, 0);
-
-	if (!opt_disable_sdcard)
-		msm_add_sdcc(2, &trout_sdslot_data,
-			     TROUT_GPIO_TO_INT(TROUT_GPIO_SDMC_CD_N), 0);
-	else
-		printk(KERN_INFO "trout: SD-Card interface disabled\n");
-	return 0;
-}
-
-#if defined(CONFIG_DEBUG_FS)
-static int troutmmc_dbg_wifi_reset_set(void *data, u64 val)
-{
-	trout_wifi_reset((int) val);
-	return 0;
-}
-
-static int troutmmc_dbg_wifi_reset_get(void *data, u64 *val)
-{
-	*val = trout_wifi_reset_state;
-	return 0;
-}
-
-static int troutmmc_dbg_wifi_cd_set(void *data, u64 val)
-{
-	trout_wifi_set_carddetect((int) val);
-	return 0;
-}
-
-static int troutmmc_dbg_wifi_cd_get(void *data, u64 *val)
-{
-	*val = trout_wifi_cd;
-	return 0;
-}
-
-static int troutmmc_dbg_wifi_pwr_set(void *data, u64 val)
-{
-	trout_wifi_power((int) val);
-	return 0;
-}
-
-static int troutmmc_dbg_wifi_pwr_get(void *data, u64 *val)
-{
-	
-	*val = trout_wifi_power_state;
-	return 0;
-}
-
-static int troutmmc_dbg_sd_pwr_set(void *data, u64 val)
-{
-	trout_sdslot_switchvdd(NULL, (unsigned int) val);
-	return 0;
-}
-
-static int troutmmc_dbg_sd_pwr_get(void *data, u64 *val)
-{
-	*val = sdslot_vdd;
-	return 0;
-}
-
-static int troutmmc_dbg_sd_cd_set(void *data, u64 val)
-{
-	return -ENOSYS;
-}
-
-static int troutmmc_dbg_sd_cd_get(void *data, u64 *val)
-{
-	*val = trout_sdslot_status(NULL);
-	return 0;
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(troutmmc_dbg_wifi_reset_fops,
-			troutmmc_dbg_wifi_reset_get,
-			troutmmc_dbg_wifi_reset_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(troutmmc_dbg_wifi_cd_fops,
-			troutmmc_dbg_wifi_cd_get,
-			troutmmc_dbg_wifi_cd_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(troutmmc_dbg_wifi_pwr_fops,
-			troutmmc_dbg_wifi_pwr_get,
-			troutmmc_dbg_wifi_pwr_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(troutmmc_dbg_sd_pwr_fops,
-			troutmmc_dbg_sd_pwr_get,
-			troutmmc_dbg_sd_pwr_set, "%llu\n");
-
-DEFINE_SIMPLE_ATTRIBUTE(troutmmc_dbg_sd_cd_fops,
-			troutmmc_dbg_sd_cd_get,
-			troutmmc_dbg_sd_cd_set, "%llu\n");
-
-static int __init troutmmc_dbg_init(void)
-{
-	struct dentry *dent;
-
-	dent = debugfs_create_dir("troutmmc_dbg", 0);
-	if (IS_ERR(dent))
-		return PTR_ERR(dent);
-
-	debugfs_create_file("wifi_reset", 0644, dent, NULL,
-			    &troutmmc_dbg_wifi_reset_fops);
-	debugfs_create_file("wifi_cd", 0644, dent, NULL,
-			    &troutmmc_dbg_wifi_cd_fops);
-	debugfs_create_file("wifi_pwr", 0644, dent, NULL,
-			    &troutmmc_dbg_wifi_pwr_fops);
-
-	debugfs_create_file("sd_pwr", 0644, dent, NULL,
-			    &troutmmc_dbg_sd_pwr_fops);
-	debugfs_create_file("sd_cd", 0644, dent, NULL,
-			    &troutmmc_dbg_sd_cd_fops);
-
-	return 0;
-}
-
-device_initcall(troutmmc_dbg_init);
-
-#endif
diff --git a/arch/arm/mach-msm/board-trout-panel.c b/arch/arm/mach-msm/board-trout-panel.c
deleted file mode 100644
index f4bc83a..0000000
--- a/arch/arm/mach-msm/board-trout-panel.c
+++ /dev/null
@@ -1,642 +0,0 @@
-/* linux/arch/arm/mach-msm/board-trout-mddi.c
-** Author: Brian Swetland <swetland@google.com>
-*/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-
-#include <asm/io.h>
-#include <asm/gpio.h>
-#include <asm/mach-types.h>
-
-#include <mach/msm_fb.h>
-#include <mach/vreg.h>
-#include <mach/htc_pwrsink.h>
-
-#include "board-trout.h"
-#include "proc_comm.h"
-#include "devices.h"
-
-#define TROUT_DEFAULT_BACKLIGHT_BRIGHTNESS 255
-
-static struct clk *gp_clk;
-static int trout_backlight_off;
-static int trout_backlight_brightness = TROUT_DEFAULT_BACKLIGHT_BRIGHTNESS;
-static int trout_new_backlight = 1;
-static uint8_t trout_backlight_last_level = 33;
-static DEFINE_MUTEX(trout_backlight_lock);
-
-static void trout_set_backlight_level(uint8_t level)
-{
-	unsigned percent = ((int)level * 100) / 255;
-
-	if (trout_new_backlight) {
-		unsigned long flags;
-		int i = 0;
-		level = (int)level * 34 / 256;
-
-		if (trout_backlight_last_level == level)
-			return;
-
-		if (level == 0) {
-			gpio_set_value(27, 0);
-			msleep(2);
-		} else {
-			local_irq_save(flags);
-			if (trout_backlight_last_level == 0) {
-				gpio_set_value(27, 1);
-				udelay(40);
-				trout_backlight_last_level = 33;
-			}
-			i = (trout_backlight_last_level - level + 33) % 33;
-			while (i-- > 0) {
-				gpio_set_value(27, 0);
-				udelay(1);
-				gpio_set_value(27, 1);
-				udelay(1);
-			}
-			local_irq_restore(flags);
-		}
-		trout_backlight_last_level = level;
-	}
-	else {
-		if(level) {
-			clk_enable(gp_clk);
-			writel((1U << 16) | (~level & 0xffff),
-			       MSM_CLK_CTL_BASE + 0x58);
-			/* Going directly to a 100% duty cycle does not
-			 *  seem to work */
-			if(level == 255) {
-				writel((~127 << 16) | 0xb20,
-				       MSM_CLK_CTL_BASE + 0x5c);
-				udelay(1);
-			}
-			writel((~127 << 16) | 0xb58, MSM_CLK_CTL_BASE + 0x5c);
-		}
-		else {
-			writel(0x0, MSM_CLK_CTL_BASE + 0x5c);
-			clk_disable(gp_clk);
-		}
-	}
-	htc_pwrsink_set(PWRSINK_BACKLIGHT, percent);
-}
-
-#define MDDI_CLIENT_CORE_BASE  0x108000
-#define LCD_CONTROL_BLOCK_BASE 0x110000
-#define SPI_BLOCK_BASE         0x120000
-#define I2C_BLOCK_BASE         0x130000
-#define PWM_BLOCK_BASE         0x140000
-#define GPIO_BLOCK_BASE        0x150000
-#define SYSTEM_BLOCK1_BASE     0x160000
-#define SYSTEM_BLOCK2_BASE     0x170000
-
-
-#define	DPSUS       (MDDI_CLIENT_CORE_BASE|0x24)
-#define	SYSCLKENA   (MDDI_CLIENT_CORE_BASE|0x2C)
-#define	PWM0OFF	      (PWM_BLOCK_BASE|0x1C)
-
-#define V_VDDE2E_VDD2_GPIO 0
-#define MDDI_RST_N 82
-
-#define	MDDICAP0    (MDDI_CLIENT_CORE_BASE|0x00)
-#define	MDDICAP1    (MDDI_CLIENT_CORE_BASE|0x04)
-#define	MDDICAP2    (MDDI_CLIENT_CORE_BASE|0x08)
-#define	MDDICAP3    (MDDI_CLIENT_CORE_BASE|0x0C)
-#define	MDCAPCHG    (MDDI_CLIENT_CORE_BASE|0x10)
-#define	MDCRCERC    (MDDI_CLIENT_CORE_BASE|0x14)
-#define	TTBUSSEL    (MDDI_CLIENT_CORE_BASE|0x18)
-#define	DPSET0      (MDDI_CLIENT_CORE_BASE|0x1C)
-#define	DPSET1      (MDDI_CLIENT_CORE_BASE|0x20)
-#define	DPSUS       (MDDI_CLIENT_CORE_BASE|0x24)
-#define	DPRUN       (MDDI_CLIENT_CORE_BASE|0x28)
-#define	SYSCKENA    (MDDI_CLIENT_CORE_BASE|0x2C)
-#define	TESTMODE    (MDDI_CLIENT_CORE_BASE|0x30)
-#define	FIFOMONI    (MDDI_CLIENT_CORE_BASE|0x34)
-#define	INTMONI     (MDDI_CLIENT_CORE_BASE|0x38)
-#define	MDIOBIST    (MDDI_CLIENT_CORE_BASE|0x3C)
-#define	MDIOPSET    (MDDI_CLIENT_CORE_BASE|0x40)
-#define	BITMAP0     (MDDI_CLIENT_CORE_BASE|0x44)
-#define	BITMAP1     (MDDI_CLIENT_CORE_BASE|0x48)
-#define	BITMAP2     (MDDI_CLIENT_CORE_BASE|0x4C)
-#define	BITMAP3     (MDDI_CLIENT_CORE_BASE|0x50)
-#define	BITMAP4     (MDDI_CLIENT_CORE_BASE|0x54)
-
-#define	SRST        (LCD_CONTROL_BLOCK_BASE|0x00)
-#define	PORT_ENB    (LCD_CONTROL_BLOCK_BASE|0x04)
-#define	START       (LCD_CONTROL_BLOCK_BASE|0x08)
-#define	PORT        (LCD_CONTROL_BLOCK_BASE|0x0C)
-#define	CMN         (LCD_CONTROL_BLOCK_BASE|0x10)
-#define	GAMMA       (LCD_CONTROL_BLOCK_BASE|0x14)
-#define	INTFLG      (LCD_CONTROL_BLOCK_BASE|0x18)
-#define	INTMSK      (LCD_CONTROL_BLOCK_BASE|0x1C)
-#define	MPLFBUF     (LCD_CONTROL_BLOCK_BASE|0x20)
-#define	HDE_LEFT    (LCD_CONTROL_BLOCK_BASE|0x24)
-#define	VDE_TOP     (LCD_CONTROL_BLOCK_BASE|0x28)
-#define	PXL         (LCD_CONTROL_BLOCK_BASE|0x30)
-#define	HCYCLE      (LCD_CONTROL_BLOCK_BASE|0x34)
-#define	HSW         (LCD_CONTROL_BLOCK_BASE|0x38)
-#define	HDE_START   (LCD_CONTROL_BLOCK_BASE|0x3C)
-#define	HDE_SIZE    (LCD_CONTROL_BLOCK_BASE|0x40)
-#define	VCYCLE      (LCD_CONTROL_BLOCK_BASE|0x44)
-#define	VSW         (LCD_CONTROL_BLOCK_BASE|0x48)
-#define	VDE_START   (LCD_CONTROL_BLOCK_BASE|0x4C)
-#define	VDE_SIZE    (LCD_CONTROL_BLOCK_BASE|0x50)
-#define	WAKEUP      (LCD_CONTROL_BLOCK_BASE|0x54)
-#define	WSYN_DLY    (LCD_CONTROL_BLOCK_BASE|0x58)
-#define	REGENB      (LCD_CONTROL_BLOCK_BASE|0x5C)
-#define	VSYNIF      (LCD_CONTROL_BLOCK_BASE|0x60)
-#define	WRSTB       (LCD_CONTROL_BLOCK_BASE|0x64)
-#define	RDSTB       (LCD_CONTROL_BLOCK_BASE|0x68)
-#define	ASY_DATA    (LCD_CONTROL_BLOCK_BASE|0x6C)
-#define	ASY_DATB    (LCD_CONTROL_BLOCK_BASE|0x70)
-#define	ASY_DATC    (LCD_CONTROL_BLOCK_BASE|0x74)
-#define	ASY_DATD    (LCD_CONTROL_BLOCK_BASE|0x78)
-#define	ASY_DATE    (LCD_CONTROL_BLOCK_BASE|0x7C)
-#define	ASY_DATF    (LCD_CONTROL_BLOCK_BASE|0x80)
-#define	ASY_DATG    (LCD_CONTROL_BLOCK_BASE|0x84)
-#define	ASY_DATH    (LCD_CONTROL_BLOCK_BASE|0x88)
-#define	ASY_CMDSET  (LCD_CONTROL_BLOCK_BASE|0x8C)
-
-#define	SSICTL      (SPI_BLOCK_BASE|0x00)
-#define	SSITIME     (SPI_BLOCK_BASE|0x04)
-#define	SSITX       (SPI_BLOCK_BASE|0x08)
-#define	SSIRX       (SPI_BLOCK_BASE|0x0C)
-#define	SSIINTC     (SPI_BLOCK_BASE|0x10)
-#define	SSIINTS     (SPI_BLOCK_BASE|0x14)
-#define	SSIDBG1     (SPI_BLOCK_BASE|0x18)
-#define	SSIDBG2     (SPI_BLOCK_BASE|0x1C)
-#define	SSIID       (SPI_BLOCK_BASE|0x20)
-
-#define	WKREQ       (SYSTEM_BLOCK1_BASE|0x00)
-#define	CLKENB      (SYSTEM_BLOCK1_BASE|0x04)
-#define	DRAMPWR     (SYSTEM_BLOCK1_BASE|0x08)
-#define	INTMASK     (SYSTEM_BLOCK1_BASE|0x0C)
-#define	GPIOSEL     (SYSTEM_BLOCK2_BASE|0x00)
-
-#define	GPIODATA    (GPIO_BLOCK_BASE|0x00)
-#define	GPIODIR     (GPIO_BLOCK_BASE|0x04)
-#define	GPIOIS      (GPIO_BLOCK_BASE|0x08)
-#define	GPIOIBE     (GPIO_BLOCK_BASE|0x0C)
-#define	GPIOIEV     (GPIO_BLOCK_BASE|0x10)
-#define	GPIOIE      (GPIO_BLOCK_BASE|0x14)
-#define	GPIORIS     (GPIO_BLOCK_BASE|0x18)
-#define	GPIOMIS     (GPIO_BLOCK_BASE|0x1C)
-#define	GPIOIC      (GPIO_BLOCK_BASE|0x20)
-#define	GPIOOMS     (GPIO_BLOCK_BASE|0x24)
-#define	GPIOPC      (GPIO_BLOCK_BASE|0x28)
-#define	GPIOID      (GPIO_BLOCK_BASE|0x30)
-
-#define SPI_WRITE(reg, val) \
-	{ SSITX,        0x00010000 | (((reg) & 0xff) << 8) | ((val) & 0xff) }, \
-	{ 0, 5 },
-
-#define SPI_WRITE1(reg) \
-	{ SSITX,        (reg) & 0xff }, \
-	{ 0, 5 },
-
-struct mddi_table {
-	uint32_t reg;
-	uint32_t value;
-};
-static struct mddi_table mddi_toshiba_init_table[] = {
-	{ DPSET0,       0x09e90046 },
-	{ DPSET1,       0x00000118 },
-	{ DPSUS,        0x00000000 },
-	{ DPRUN,        0x00000001 },
-	{ 1,            14         }, /* msleep 14 */
-	{ SYSCKENA,     0x00000001 },
-	//{ CLKENB,       0x000000EF },
-	{ CLKENB,       0x0000A1EF },  /*    # SYS.CLKENB  # Enable clocks for each module (without DCLK , i2cCLK) */
-	//{ CLKENB,       0x000025CB }, /* Clock enable register */
-
-	{ GPIODATA,     0x02000200 },  /*   # GPI .GPIODATA  # GPIO2(RESET_LCD_N) set to 0 , GPIO3(eDRAM_Power) set to 0 */
-	{ GPIODIR,      0x000030D  },  /* 24D   # GPI .GPIODIR  # Select direction of GPIO port (0,2,3,6,9 output) */
-	{ GPIOSEL,      0/*0x00000173*/},  /*   # SYS.GPIOSEL  # GPIO port multiplexing control */
-	{ GPIOPC,       0x03C300C0 },  /*   # GPI .GPIOPC  # GPIO2,3 PD cut */
-	{ WKREQ,        0x00000000 },  /*   # SYS.WKREQ  # Wake-up request event is VSYNC alignment */
-
-	{ GPIOIBE,      0x000003FF },
-	{ GPIOIS,       0x00000000 },
-	{ GPIOIC,       0x000003FF },
-	{ GPIOIE,       0x00000000 },
-
-	{ GPIODATA,     0x00040004 },  /*   # GPI .GPIODATA  # eDRAM VD supply */
-	{ 1,            1          }, /* msleep 1 */
-	{ GPIODATA,     0x02040004 },  /*   # GPI .GPIODATA  # eDRAM VD supply */
-	{ DRAMPWR,      0x00000001 }, /* eDRAM power */
-};
-
-static struct mddi_table mddi_toshiba_panel_init_table[] = {
-	{ SRST,         0x00000003 }, /* FIFO/LCDC not reset */
-	{ PORT_ENB,     0x00000001 }, /* Enable sync. Port */
-	{ START,        0x00000000 }, /* To stop operation */
-	//{ START,        0x00000001 }, /* To start operation */
-	{ PORT,         0x00000004 }, /* Polarity of VS/HS/DE. */
-	{ CMN,          0x00000000 },
-	{ GAMMA,        0x00000000 }, /* No Gamma correction */
-	{ INTFLG,       0x00000000 }, /* VSYNC interrupt flag clear/status */
-	{ INTMSK,       0x00000000 }, /* VSYNC interrupt mask is off. */
-	{ MPLFBUF,      0x00000000 }, /* Select frame buffer's base address. */
-	{ HDE_LEFT,     0x00000000 }, /* The value of HDE_LEFT. */
-	{ VDE_TOP,      0x00000000 }, /* The value of VDE_TPO. */
-	{ PXL,          0x00000001 }, /* 1. RGB666 */
-	                              /* 2. Data is valid from 1st frame of beginning. */
-	{ HDE_START,    0x00000006 }, /* HDE_START= 14 PCLK */
-	{ HDE_SIZE,     0x0000009F }, /* HDE_SIZE=320 PCLK */
-	{ HSW,          0x00000004 }, /* HSW= 10 PCLK */
-	{ VSW,          0x00000001 }, /* VSW=2 HCYCLE */
-	{ VDE_START,    0x00000003 }, /* VDE_START=4 HCYCLE */
-	{ VDE_SIZE,     0x000001DF }, /* VDE_SIZE=480 HCYCLE */
-	{ WAKEUP,       0x000001e2 }, /* Wakeup position in VSYNC mode. */
-	{ WSYN_DLY,     0x00000000 }, /* Wakeup position in VSIN mode. */
-	{ REGENB,       0x00000001 }, /* Set 1 to enable to change the value of registers. */
-	{ CLKENB,       0x000025CB }, /* Clock enable register */
-
-	{ SSICTL,       0x00000170 }, /* SSI control register */
-	{ SSITIME,      0x00000250 }, /* SSI timing control register */
-	{ SSICTL,       0x00000172 }, /* SSI control register */
-};
-
-
-static struct mddi_table mddi_sharp_init_table[] = {
-	{ VCYCLE,       0x000001eb },
-	{ HCYCLE,       0x000000ae },
-	{ REGENB,       0x00000001 }, /* Set 1 to enable to change the value of registers. */
-	{ GPIODATA,     0x00040000 }, /* GPIO2 low */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ 1,            1          }, /* msleep 1 */
-	{ GPIODATA,     0x00040004 }, /* GPIO2 high */
-	{ 1,            10         }, /* msleep 10 */
-	SPI_WRITE(0x5f, 0x01)
-	SPI_WRITE1(0x11)
-	{ 1,            200        }, /* msleep 200 */
-	SPI_WRITE1(0x29)
-	SPI_WRITE1(0xde)
-	{ START,        0x00000001 }, /* To start operation */
-};
-
-static struct mddi_table mddi_sharp_deinit_table[] = {
-	{ 1,            200        }, /* msleep 200 */
-	SPI_WRITE(0x10, 0x1)
-	{ 1,            100        }, /* msleep 100 */
-	{ GPIODATA,     0x00040004 }, /* GPIO2 high */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ GPIODATA,     0x00040000 }, /* GPIO2 low */
-	{ 1,            10         }, /* msleep 10 */
-};
-
-static struct mddi_table mddi_tpo_init_table[] = {
-	{ VCYCLE,       0x000001e5 },
-	{ HCYCLE,       0x000000ac },
-	{ REGENB,       0x00000001 }, /* Set 1 to enable to change the value of registers. */
-	{ 0,            20         }, /* udelay 20 */
-	{ GPIODATA,     0x00000004 }, /* GPIO2 high */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ 0,            20         }, /* udelay 20 */
-
-	SPI_WRITE(0x08, 0x01)
-	{ 0,            500        }, /* udelay 500 */
-	SPI_WRITE(0x08, 0x00)
-	SPI_WRITE(0x02, 0x00)
-	SPI_WRITE(0x03, 0x04)
-	SPI_WRITE(0x04, 0x0e)
-	SPI_WRITE(0x09, 0x02)
-	SPI_WRITE(0x0b, 0x08)
-	SPI_WRITE(0x0c, 0x53)
-	SPI_WRITE(0x0d, 0x01)
-	SPI_WRITE(0x0e, 0xe0)
-	SPI_WRITE(0x0f, 0x01)
-	SPI_WRITE(0x10, 0x58)
-	SPI_WRITE(0x20, 0x1e)
-	SPI_WRITE(0x21, 0x0a)
-	SPI_WRITE(0x22, 0x0a)
-	SPI_WRITE(0x23, 0x1e)
-	SPI_WRITE(0x25, 0x32)
-	SPI_WRITE(0x26, 0x00)
-	SPI_WRITE(0x27, 0xac)
-	SPI_WRITE(0x29, 0x06)
-	SPI_WRITE(0x2a, 0xa4)
-	SPI_WRITE(0x2b, 0x45)
-	SPI_WRITE(0x2c, 0x45)
-	SPI_WRITE(0x2d, 0x15)
-	SPI_WRITE(0x2e, 0x5a)
-	SPI_WRITE(0x2f, 0xff)
-	SPI_WRITE(0x30, 0x6b)
-	SPI_WRITE(0x31, 0x0d)
-	SPI_WRITE(0x32, 0x48)
-	SPI_WRITE(0x33, 0x82)
-	SPI_WRITE(0x34, 0xbd)
-	SPI_WRITE(0x35, 0xe7)
-	SPI_WRITE(0x36, 0x18)
-	SPI_WRITE(0x37, 0x94)
-	SPI_WRITE(0x38, 0x01)
-	SPI_WRITE(0x39, 0x5d)
-	SPI_WRITE(0x3a, 0xae)
-	SPI_WRITE(0x3b, 0xff)
-	SPI_WRITE(0x07, 0x09)
-	{ 0,            10         }, /* udelay 10 */
-	{ START,        0x00000001 }, /* To start operation */
-};
-
-static struct mddi_table mddi_tpo_deinit_table[] = {
-	SPI_WRITE(0x07, 0x19)
-	{ START,        0x00000000 }, /* To stop operation */
-	{ GPIODATA,     0x00040004 }, /* GPIO2 high */
-	{ GPIODIR,      0x00000004 }, /* GPIO2 out */
-	{ GPIODATA,     0x00040000 }, /* GPIO2 low */
-	{ 0,            5        }, /* usleep 5 */
-};
-
-
-#define GPIOSEL_VWAKEINT (1U << 0)
-#define INTMASK_VWAKEOUT (1U << 0)
-
-static void trout_process_mddi_table(struct msm_mddi_client_data *client_data,
-				     struct mddi_table *table, size_t count)
-{
-	int i;
-	for(i = 0; i < count; i++) {
-		uint32_t reg = table[i].reg;
-		uint32_t value = table[i].value;
-
-		if (reg == 0)
-			udelay(value);
-		else if (reg == 1)
-			msleep(value);
-		else
-			client_data->remote_write(client_data, value, reg);
-	}
-}
-
-static struct vreg *vreg_mddi_1v5;
-static struct vreg *vreg_lcm_2v85;
-
-static void trout_mddi_power_client(struct msm_mddi_client_data *client_data,
-				    int on)
-{
-    unsigned id, on_off;
-	if(on) {
-		on_off = 0;
-		id = PM_VREG_PDOWN_MDDI_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_mddi_1v5);
-		mdelay(5); // delay time >5ms and <10ms
-		gpio_set_value(V_VDDE2E_VDD2_GPIO, 1);
-		gpio_set_value(TROUT_GPIO_MDDI_32K_EN, 1);
-		msleep(3);
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		vreg_enable(vreg_lcm_2v85);
-		msleep(3);
-		gpio_set_value(MDDI_RST_N, 1);
-		msleep(10);
-	} else {
-		gpio_set_value(TROUT_GPIO_MDDI_32K_EN, 0);
-		gpio_set_value(MDDI_RST_N, 0);
-		msleep(10);
-		vreg_disable(vreg_lcm_2v85);
-		on_off = 1;
-		id = PM_VREG_PDOWN_AUX_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-		msleep(5);
-		gpio_set_value(V_VDDE2E_VDD2_GPIO, 0);
-		msleep(200);
-		vreg_disable(vreg_mddi_1v5);
-		id = PM_VREG_PDOWN_MDDI_ID;
-		msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);
-	}
-}
-
-static int trout_mddi_toshiba_client_init(
-	struct msm_mddi_bridge_platform_data *bridge_data,
-	struct msm_mddi_client_data *client_data)
-{
-	int panel_id;
-
-	client_data->auto_hibernate(client_data, 0);
-	trout_process_mddi_table(client_data, mddi_toshiba_init_table,
-				 ARRAY_SIZE(mddi_toshiba_init_table));
-	client_data->auto_hibernate(client_data, 1);
-	panel_id = (client_data->remote_read(client_data, GPIODATA) >> 4) & 3;
-	if (panel_id > 1) {
-		printk("unknown panel id at mddi_enable\n");
-		return -1;
-	}
-	return 0;
-}
-
-static int trout_mddi_toshiba_client_uninit(
-	struct msm_mddi_bridge_platform_data *bridge_data,
-	struct msm_mddi_client_data *client_data)
-{
-	return 0;
-}
-
-static int trout_mddi_panel_unblank(
-	struct msm_mddi_bridge_platform_data *bridge_data,
-	struct msm_mddi_client_data *client_data)
-{
-
-	int panel_id, ret = 0;
-	
-	trout_set_backlight_level(0);
-	client_data->auto_hibernate(client_data, 0);
-	trout_process_mddi_table(client_data, mddi_toshiba_panel_init_table,
-		ARRAY_SIZE(mddi_toshiba_panel_init_table));
-	panel_id = (client_data->remote_read(client_data, GPIODATA) >> 4) & 3;
-	switch(panel_id) {
-	 case 0:
-		printk("init sharp panel\n");
-		trout_process_mddi_table(client_data,
-					 mddi_sharp_init_table,
-					 ARRAY_SIZE(mddi_sharp_init_table));
-		break;
-	case 1:
-		printk("init tpo panel\n");
-		trout_process_mddi_table(client_data,
-					 mddi_tpo_init_table,
-					 ARRAY_SIZE(mddi_tpo_init_table));
-		break;
-	default:
-		printk("unknown panel_id: %d\n", panel_id);
-		ret = -1;
-	};
-	mutex_lock(&trout_backlight_lock);
-	trout_set_backlight_level(trout_backlight_brightness);
-	trout_backlight_off = 0;
-	mutex_unlock(&trout_backlight_lock);
-	client_data->auto_hibernate(client_data, 1);
-	client_data->remote_write(client_data, GPIOSEL_VWAKEINT, GPIOSEL);
-	client_data->remote_write(client_data, INTMASK_VWAKEOUT, INTMASK);
-	return ret;
-
-}
-
-static int trout_mddi_panel_blank(
-	struct msm_mddi_bridge_platform_data *bridge_data,
-	struct msm_mddi_client_data *client_data)
-{
-	int panel_id, ret = 0;
-
-	panel_id = (client_data->remote_read(client_data, GPIODATA) >> 4) & 3;
-	client_data->auto_hibernate(client_data, 0);
-	switch(panel_id) {
-	case 0:
-		printk("deinit sharp panel\n");
-		trout_process_mddi_table(client_data,
-					 mddi_sharp_deinit_table,
-					 ARRAY_SIZE(mddi_sharp_deinit_table));
-		break;
-	case 1:
-		printk("deinit tpo panel\n");
-		trout_process_mddi_table(client_data,
-					 mddi_tpo_deinit_table,
-					 ARRAY_SIZE(mddi_tpo_deinit_table));
-		break;
-	default:
-		printk("unknown panel_id: %d\n", panel_id);
-		ret = -1;
-	};
-	client_data->auto_hibernate(client_data, 1);
-	mutex_lock(&trout_backlight_lock);
-	trout_set_backlight_level(0);
-	trout_backlight_off = 1;
-	mutex_unlock(&trout_backlight_lock);
-	client_data->remote_write(client_data, 0, SYSCLKENA);
-	client_data->remote_write(client_data, 1, DPSUS);
-	return ret;
-}
-
-static void trout_brightness_set(struct led_classdev *led_cdev, enum led_brightness value)
-{
-	mutex_lock(&trout_backlight_lock);
-	trout_backlight_brightness = value;
-	if(!trout_backlight_off)
-		trout_set_backlight_level(trout_backlight_brightness);
-	mutex_unlock(&trout_backlight_lock);
-}
-
-static struct led_classdev trout_backlight_led = {
-	.name			= "lcd-backlight",
-	.brightness = TROUT_DEFAULT_BACKLIGHT_BRIGHTNESS,
-	.brightness_set = trout_brightness_set,
-};
-
-static int trout_backlight_probe(struct platform_device *pdev)
-{
-	led_classdev_register(&pdev->dev, &trout_backlight_led);
-	return 0;
-}
-
-static int trout_backlight_remove(struct platform_device *pdev)
-{
-	led_classdev_unregister(&trout_backlight_led);
-	return 0;
-}
-
-static struct platform_driver trout_backlight_driver = {
-	.probe		= trout_backlight_probe,
-	.remove		= trout_backlight_remove,
-	.driver		= {
-		.name		= "trout-backlight",
-		.owner		= THIS_MODULE,
-	},
-};
-
-static struct resource resources_msm_fb[] = {
-	{
-		.start = MSM_FB_BASE,
-		.end = MSM_FB_BASE + MSM_FB_SIZE,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-struct msm_mddi_bridge_platform_data toshiba_client_data = {
-	.init = trout_mddi_toshiba_client_init,
-	.uninit = trout_mddi_toshiba_client_uninit,
-	.blank = trout_mddi_panel_blank,
-	.unblank = trout_mddi_panel_unblank,
-	.fb_data = {
-		.xres = 320,
-		.yres = 480,
-		.width = 45,
-		.height = 67,
-		.output_format = 0,
-	},
-};
-
-static struct msm_mddi_platform_data mddi_pdata = {
-	.clk_rate = 122880000,
-	.power_client = trout_mddi_power_client,
-	.fb_resource = resources_msm_fb,
-	.num_clients = 1,
-	.client_platform_data = {
-		{
-			.product_id = (0xd263 << 16 | 0),
-			.name = "mddi_c_d263_0000",
-			//.name = "mddi_c_dummy",
-			.id = 0,
-			.client_data = &toshiba_client_data,
-			//.client_data = &toshiba_client_data.fb_data,
-			.clk_rate = 0,
-		},
-	},
-};
-
-static struct platform_device trout_backlight = {
-	.name = "trout-backlight",
-};
-
-int __init trout_init_panel(void)
-{
-	int rc;
-
-        if (!machine_is_trout())
-                return 0;
-	vreg_mddi_1v5 = vreg_get(0, "gp2");
-	if (IS_ERR(vreg_mddi_1v5))
-		return PTR_ERR(vreg_mddi_1v5);
-	vreg_lcm_2v85 = vreg_get(0, "gp4");
-	if (IS_ERR(vreg_lcm_2v85))
-		return PTR_ERR(vreg_lcm_2v85);
-
-	trout_new_backlight = system_rev >= 5;
-	if (trout_new_backlight) {
-		uint32_t config = PCOM_GPIO_CFG(27, 0, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_8MA);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &config, 0);
-	}
-	else {
-		uint32_t config = PCOM_GPIO_CFG(27, 1, GPIO_OUTPUT,
-						GPIO_NO_PULL, GPIO_8MA);
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &config, 0);
-
-		gp_clk = clk_get(NULL, "gp_clk");
-		if (IS_ERR(gp_clk)) {
-			printk(KERN_ERR "trout_init_panel: could not get gp"
-			       "clock\n");
-			gp_clk = NULL;
-		}
-		rc = clk_set_rate(gp_clk, 19200000);
-		if (rc)
-			printk(KERN_ERR "trout_init_panel: set clock rate "
-			       "failed\n");
-	}
-
-	rc = platform_device_register(&msm_device_mdp);
-	if (rc)
-		return rc;
-	msm_device_mddi0.dev.platform_data = &mddi_pdata;
-	rc = platform_device_register(&msm_device_mddi0);
-	if (rc)
-		return rc;
-	platform_device_register(&trout_backlight);
-	return platform_driver_register(&trout_backlight_driver);
-}
-
-device_initcall(trout_init_panel);
diff --git a/arch/arm/mach-msm/board-trout-rfkill.c b/arch/arm/mach-msm/board-trout-rfkill.c
deleted file mode 100644
index 2115b81..0000000
--- a/arch/arm/mach-msm/board-trout-rfkill.c
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2008 Google, Inc.
- * Author: Nick Pelly <npelly@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/* Control bluetooth power for trout platform */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/rfkill.h>
-#include <linux/delay.h>
-#include <asm/gpio.h>
-
-#include "board-trout.h"
-
-static struct rfkill *bt_rfk;
-static const char bt_name[] = "brf6300";
-
-static int bluetooth_set_power(void *data, enum rfkill_state state)
-{
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		gpio_set_value(TROUT_GPIO_BT_32K_EN, 1);
-		udelay(10);
-		gpio_configure(101, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_HIGH);
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		gpio_configure(101, GPIOF_DRIVE_OUTPUT | GPIOF_OUTPUT_LOW);
-		gpio_set_value(TROUT_GPIO_BT_32K_EN, 0);
-		break;
-	default:
-		printk(KERN_ERR "bad bluetooth rfkill state %d\n", state);
-	}
-	return 0;
-}
-
-static int trout_rfkill_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;  /* off */
-
-	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
-	bluetooth_set_power(NULL, default_state);
-
-	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
-	if (!bt_rfk)
-		return -ENOMEM;
-
-	bt_rfk->name = bt_name;
-	bt_rfk->state = default_state;
-	/* userspace cannot take exclusive control */
-	bt_rfk->user_claim_unsupported = 1;
-	bt_rfk->user_claim = 0;
-	bt_rfk->data = NULL;  // user data
-	bt_rfk->toggle_radio = bluetooth_set_power;
-
-	rc = rfkill_register(bt_rfk);
-
-	if (rc)
-		rfkill_free(bt_rfk);
-	return rc;
-}
-
-static int trout_rfkill_remove(struct platform_device *dev)
-{
-	rfkill_unregister(bt_rfk);
-	rfkill_free(bt_rfk);
-
-	return 0;
-}
-
-static struct platform_driver trout_rfkill_driver = {
-	.probe = trout_rfkill_probe,
-	.remove = trout_rfkill_remove,
-	.driver = {
-		.name = "trout_rfkill",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init trout_rfkill_init(void)
-{
-	return platform_driver_register(&trout_rfkill_driver);
-}
-
-static void __exit trout_rfkill_exit(void)
-{
-	platform_driver_unregister(&trout_rfkill_driver);
-}
-
-module_init(trout_rfkill_init);
-module_exit(trout_rfkill_exit);
-MODULE_DESCRIPTION("trout rfkill");
-MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-trout-wifi.c b/arch/arm/mach-msm/board-trout-wifi.c
deleted file mode 100644
index 51b26a4..0000000
--- a/arch/arm/mach-msm/board-trout-wifi.c
+++ /dev/null
@@ -1,74 +0,0 @@
-/* arch/arm/mach-msm/board-trout-wifi.c
- *
- * Copyright (C) 2008 Google, Inc.
- * Author: Dmitry Shmidt <dimitrysh@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/vmalloc.h>
-#include <linux/err.h>
-#include <linux/wifi_tiwlan.h>
-
-extern int trout_wifi_set_carddetect(int val);
-extern int trout_wifi_power(int on);
-extern int trout_wifi_reset(int on);
-
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-typedef struct wifi_mem_prealloc_struct {
-	void *mem_ptr;
-	unsigned long size;
-} wifi_mem_prealloc_t;
-
-static wifi_mem_prealloc_t wifi_mem_array[WMPA_NUMBER_OF_SECTIONS] = {
-	{ NULL, (WMPA_SECTION_SIZE_0 + WMPA_SECTION_HEADER) },
-	{ NULL, (WMPA_SECTION_SIZE_1 + WMPA_SECTION_HEADER) },
-	{ NULL, (WMPA_SECTION_SIZE_2 + WMPA_SECTION_HEADER) }
-};
-
-static void *trout_wifi_mem_prealloc(int section, unsigned long size)
-{
-	if( (section < 0) || (section >= WMPA_NUMBER_OF_SECTIONS) )
-		return NULL;
-	if( wifi_mem_array[section].size < size )
-		return NULL;
-	return wifi_mem_array[section].mem_ptr;
-}
-
-int __init trout_init_wifi_mem( void )
-{
-	int i;
-
-	for(i=0;( i < WMPA_NUMBER_OF_SECTIONS );i++) {
-		wifi_mem_array[i].mem_ptr = vmalloc(wifi_mem_array[i].size);
-		if( wifi_mem_array[i].mem_ptr == NULL )
-			return -ENOMEM;
-	}
-	return 0;
-}
-#endif
-
-struct wifi_platform_data trout_wifi_control = {
-	.set_power		= trout_wifi_power,
-	.set_reset		= trout_wifi_reset,
-	.set_carddetect		= trout_wifi_set_carddetect,
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-	.mem_prealloc		= trout_wifi_mem_prealloc,
-#else
-	.mem_prealloc		= NULL,
-#endif	
-};
-
-#endif
diff --git a/arch/arm/mach-msm/board-trout.c b/arch/arm/mach-msm/board-trout.c
deleted file mode 100644
index 5a53138..0000000
--- a/arch/arm/mach-msm/board-trout.c
+++ /dev/null
@@ -1,870 +0,0 @@
-/* arch/arm/mach-msm/board-trout.c
- *
- * Copyright (C) 2008 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/keyreset.h>
-#include <linux/leds.h>
-#include <linux/switch.h>
-#include <../../../drivers/staging/android/timed_gpio.h>
-#include <linux/synaptics_i2c_rmi.h>
-#include <linux/akm8976.h>
-#include <linux/sysdev.h>
-#include <linux/android_pmem.h>
-
-#include <linux/delay.h>
-
-#include <asm/gpio.h>
-#include <mach/hardware.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/system.h>
-#include <mach/system.h>
-#include <mach/vreg.h>
-
-#include <asm/io.h>
-#include <asm/delay.h>
-#include <asm/setup.h>
-
-#include <linux/gpio_event.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-
-#include <asm/mach/mmc.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/msm_audio.h>
-
-#include "board-trout.h"
-
-#include "gpio_chip.h"
-
-#include <mach/board.h>
-#include <mach/board_htc.h>
-#include <mach/msm_serial_hs.h>
-#include <mach/htc_pwrsink.h>
-#ifdef CONFIG_HTC_HEADSET
-#include <mach/htc_headset.h>
-#endif
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-#include <linux/wifi_tiwlan.h>
-#endif
-
-#include "proc_comm.h"
-#include "devices.h"
-
-void msm_init_irq(void);
-void msm_init_gpio(void);
-
-extern int trout_init_mmc(unsigned int);
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-extern int trout_init_wifi_mem(void);
-#endif
-extern struct wifi_platform_data trout_wifi_control;
-#endif
-
-struct trout_axis_info {
-	struct gpio_event_axis_info info;
-	uint16_t in_state;
-	uint16_t out_state;
-};
-static bool nav_just_on;
-static int nav_on_jiffies;
-
-uint16_t trout_axis_map(struct gpio_event_axis_info *info, uint16_t in)
-{
-	struct trout_axis_info *ai = container_of(info, struct trout_axis_info, info);
-	uint16_t out = ai->out_state;
-
-	if (nav_just_on) {
-		if (jiffies == nav_on_jiffies || jiffies == nav_on_jiffies + 1)
-			goto ignore;
-		nav_just_on = 0;
-	}
-	if((ai->in_state ^ in) & 1)
-		out--;
-	if((ai->in_state ^ in) & 2)
-		out++;
-	ai->out_state = out;
-ignore:
-	ai->in_state = in;
-	return out;
-}
-
-int trout_nav_power(const struct gpio_event_platform_data *pdata, bool on)
-{
-	gpio_set_value(TROUT_GPIO_JOG_EN, on);
-	if (on) {
-		nav_just_on = 1;
-		nav_on_jiffies = jiffies;
-	}
-	return 0;
-}
-
-static uint32_t trout_4_x_axis_gpios[] = {
-	TROUT_4_BALL_LEFT_0, TROUT_4_BALL_RIGHT_0
-};
-static uint32_t trout_5_x_axis_gpios[] = {
-	TROUT_5_BALL_LEFT_0, TROUT_5_BALL_RIGHT_0
-};
-
-static struct trout_axis_info trout_x_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(trout_5_x_axis_gpios),
-		.type = EV_REL,
-		.code = REL_X,
-		.decoded_size = 1U << ARRAY_SIZE(trout_5_x_axis_gpios),
-		.map = trout_axis_map,
-		.gpio = trout_5_x_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION /*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT */
-	}
-};
-
-static uint32_t trout_4_y_axis_gpios[] = {
-	TROUT_4_BALL_UP_0, TROUT_4_BALL_DOWN_0
-};
-static uint32_t trout_5_y_axis_gpios[] = {
-	TROUT_5_BALL_UP_0, TROUT_5_BALL_DOWN_0
-};
-
-static struct trout_axis_info trout_y_axis = {
-	.info = {
-		.info.func = gpio_event_axis_func,
-		.count = ARRAY_SIZE(trout_5_y_axis_gpios),
-		.type = EV_REL,
-		.code = REL_Y,
-		.decoded_size = 1U << ARRAY_SIZE(trout_5_y_axis_gpios),
-		.map = trout_axis_map,
-		.gpio = trout_5_y_axis_gpios,
-		.flags = GPIOEAF_PRINT_UNKNOWN_DIRECTION /*| GPIOEAF_PRINT_RAW | GPIOEAF_PRINT_EVENT */
-	}
-};
-
-static struct gpio_event_direct_entry trout_nav_buttons[] = {
-	{ TROUT_GPIO_NAVI_ACT_N, BTN_MOUSE }
-};
-
-static struct gpio_event_input_info trout_nav_button_info = {
-	.info.func = gpio_event_input_func,
-	.flags = 0,
-	.type = EV_KEY,
-	.keymap = trout_nav_buttons,
-	.keymap_size = ARRAY_SIZE(trout_nav_buttons)
-};
-
-static struct gpio_event_info *trout_nav_info[] = {
-	&trout_x_axis.info.info,
-	&trout_y_axis.info.info,
-	&trout_nav_button_info.info
-};
-
-static struct gpio_event_platform_data trout_nav_data = {
-	.name = "trout-nav",
-	.info = trout_nav_info,
-	.info_count = ARRAY_SIZE(trout_nav_info),
-	.power = trout_nav_power,
-};
-
-static struct platform_device trout_nav_device = {
-	.name = GPIO_EVENT_DEV_NAME,
-	.id = 2,
-	.dev = {
-		.platform_data = &trout_nav_data,
-	},
-};
-
-static int trout_reset_keys_up[] = {
-	BTN_MOUSE,
-	0
-};
-
-static struct keyreset_platform_data trout_reset_keys_pdata = {
-	.keys_up = trout_reset_keys_up,
-	.keys_down = {
-		KEY_SEND,
-		KEY_MENU,
-		KEY_END,
-		0
-	},
-};
-
-struct platform_device trout_reset_keys_device = {
-	.name = KEYRESET_NAME,
-	.dev.platform_data = &trout_reset_keys_pdata,
-};
-
-static int trout_ts_power(int on)
-{
-	int tp_ls_gpio = system_rev < 5 ? TROUT_4_TP_LS_EN : TROUT_5_TP_LS_EN;
-	if (on) {
-		gpio_set_value(TROUT_GPIO_TP_I2C_PULL, 1);
-		gpio_set_value(TROUT_GPIO_TP_EN, 1);
-		/* touchscreen must be powered before we enable i2c pullup */
-		msleep(2);
-		/* enable touch panel level shift */
-		gpio_set_value(tp_ls_gpio, 1);
-		msleep(2);
-	}
-	else {
-		gpio_set_value(tp_ls_gpio, 0);
-		udelay(50);
-		gpio_set_value(TROUT_GPIO_TP_EN, 0);
-		gpio_set_value(TROUT_GPIO_TP_I2C_PULL, 0);
-	}
-	return 0;
-}
-
-static struct synaptics_i2c_rmi_platform_data trout_ts_data[] = {
-	{
-		.version = 0x010c,
-		.power = trout_ts_power,
-		.flags = SYNAPTICS_FLIP_Y | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = -100 * 0x10000 / 4334,
-		.inactive_right = -100 * 0x10000 / 4334,
-		.inactive_top = -40 * 0x10000 / 6696,
-		.inactive_bottom = -40 * 0x10000 / 6696,
-		.snap_left_on = 300 * 0x10000 / 4334,
-		.snap_left_off = 310 * 0x10000 / 4334,
-		.snap_right_on = 300 * 0x10000 / 4334,
-		.snap_right_off = 310 * 0x10000 / 4334,
-		.snap_top_on = 100 * 0x10000 / 6696,
-		.snap_top_off = 110 * 0x10000 / 6696,
-		.snap_bottom_on = 100 * 0x10000 / 6696,
-		.snap_bottom_off = 110 * 0x10000 / 6696,
-	},
-	{
-		.flags = SYNAPTICS_FLIP_Y | SYNAPTICS_SNAP_TO_INACTIVE_EDGE,
-		.inactive_left = ((4674 - 4334) / 2 + 200) * 0x10000 / 4334,
-		.inactive_right = ((4674 - 4334) / 2 + 200) * 0x10000 / 4334,
-		.inactive_top = ((6946 - 6696) / 2) * 0x10000 / 6696,
-		.inactive_bottom = ((6946 - 6696) / 2) * 0x10000 / 6696,
-	}
-};
-
-static struct akm8976_platform_data compass_platform_data = {
-	.reset = TROUT_GPIO_COMPASS_RST_N,
-	.clk_on = TROUT_GPIO_COMPASS_32K_EN,
-	.intr = TROUT_GPIO_COMPASS_IRQ,
-};
-
-static struct i2c_board_info i2c_devices[] = {
-	{
-		I2C_BOARD_INFO(SYNAPTICS_I2C_RMI_NAME, 0x20),
-		.platform_data = trout_ts_data,
-		.irq = TROUT_GPIO_TO_INT(TROUT_GPIO_TP_ATT_N)
-	},
-	{
-		I2C_BOARD_INFO("elan-touch", 0x10),
-		.irq = TROUT_GPIO_TO_INT(TROUT_GPIO_TP_ATT_N),
-	},
-	{
-		I2C_BOARD_INFO("akm8976", 0x1C),
-		.platform_data = &compass_platform_data,
-		.irq = TROUT_GPIO_TO_INT(TROUT_GPIO_COMPASS_IRQ),
-	},
-	{
-		I2C_BOARD_INFO("pca963x", 0x62),
-	},
-#if defined(CONFIG_MSM_CAMERA) && defined(CONFIG_MT9T013)
-	{
-		I2C_BOARD_INFO("mt9t013", 0x6C),
-	},
-#endif
-#ifdef CONFIG_SENSORS_MT9T013
-	{
-		I2C_BOARD_INFO("mt9t013", 0x6C >> 1),
-	},
-#endif
-};
-
-static struct timed_gpio timed_gpios[] = {
-	{
-		.name = "vibrator",
-		.gpio = TROUT_GPIO_HAPTIC_PWM,
-		.max_timeout = 15000,
-	},
-	{
-		.name = "flash",
-		.gpio = TROUT_GPIO_FLASH_EN,
-		.max_timeout = 400,
-	},
-};
-
-static struct timed_gpio_platform_data timed_gpio_data = {
-	.num_gpios	= ARRAY_SIZE(timed_gpios),
-	.gpios		= timed_gpios,
-};
-
-static struct platform_device android_timed_gpios = {
-	.name		= "timed-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data = &timed_gpio_data,
-	},
-};
-
-static struct gpio_led android_led_list[] = {
-	{
-		.name = "spotlight",
-		.gpio = TROUT_GPIO_SPOTLIGHT_EN,
-	},
-	{
-		.name = "keyboard-backlight",
-		.gpio = TROUT_GPIO_QTKEY_LED_EN,
-	},
-	{
-		.name = "button-backlight",
-		.gpio = TROUT_GPIO_UI_LED_EN,
-	},
-};
-
-static struct gpio_led_platform_data android_leds_data = {
-	.num_leds	= ARRAY_SIZE(android_led_list),
-	.leds		= android_led_list,
-};
-
-static struct platform_device android_leds = {
-	.name		= "leds-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data = &android_leds_data,
-	},
-};
-
-static struct gpio_switch_platform_data sd_door_switch_data = {
-	.name		= "sd-door",
-	.gpio		= TROUT_GPIO_SD_DOOR_N,
-	.state_on	= "open",
-	.state_off	= "closed",
-};
-
-static struct platform_device sd_door_switch = {
-	.name		= "switch-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data = &sd_door_switch_data,
-	},
-};
-
-#ifdef CONFIG_HTC_HEADSET
-static void h2w_config_cpld(int route)
-{
-	switch (route) {
-	case H2W_UART3:
-		gpio_set_value(TROUT_GPIO_H2W_SEL0, 0);
-		gpio_set_value(TROUT_GPIO_H2W_SEL1, 1);
-		break;
-	case H2W_GPIO:
-		gpio_set_value(TROUT_GPIO_H2W_SEL0, 0);
-		gpio_set_value(TROUT_GPIO_H2W_SEL1, 0);
-		break;
-	}
-}
-
-static void h2w_init_cpld(void)
-{
-	h2w_config_cpld(H2W_UART3);
-	gpio_set_value(TROUT_GPIO_H2W_CLK_DIR, 0);
-	gpio_set_value(TROUT_GPIO_H2W_DAT_DIR, 0);
-}
-
-static struct h2w_platform_data trout_h2w_data = {
-	.cable_in1		= TROUT_GPIO_CABLE_IN1,
-	.cable_in2		= TROUT_GPIO_CABLE_IN2,
-	.h2w_clk		= TROUT_GPIO_H2W_CLK_GPI,
-	.h2w_data		= TROUT_GPIO_H2W_DAT_GPI,
-	.debug_uart 		= H2W_UART3,
-	.config_cpld 		= h2w_config_cpld,
-	.init_cpld 		= h2w_init_cpld,
-};
-
-static struct platform_device trout_h2w = {
-	.name		= "h2w",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &trout_h2w_data,
-	},
-};
-#endif
-
-static void trout_phy_reset(void)
-{
-	gpio_set_value(TROUT_GPIO_USB_PHY_RST_N, 0);
-	mdelay(10);
-	gpio_set_value(TROUT_GPIO_USB_PHY_RST_N, 1);
-	mdelay(10);
-}
-
-static void config_camera_on_gpios(void);
-static void config_camera_off_gpios(void);
-
-#ifdef CONFIG_MSM_CAMERA
-static struct msm_camera_device_platform_data msm_camera_device_data = {
-	.camera_gpio_on  = config_camera_on_gpios,
-	.camera_gpio_off = config_camera_off_gpios,
-	.ioext.mdcphy = MSM_MDC_PHYS,
-	.ioext.mdcsz  = MSM_MDC_SIZE,
-	.ioext.appphy = MSM_CLK_CTL_PHYS,
-	.ioext.appsz  = MSM_CLK_CTL_SIZE,
-};
-
-#ifdef CONFIG_MT9T013
-static struct msm_camera_sensor_info msm_camera_sensor_mt9t013_data = {
-	.sensor_name    = "mt9t013",
-	.sensor_reset   = 108,
-	.sensor_pwd     = 85,
-	.vcm_pwd        = TROUT_GPIO_VCM_PWDN,
-	.pdata          = &msm_camera_device_data,
-};
-
-static struct platform_device msm_camera_sensor_mt9t013 = {
-	.name           = "msm_camera_mt9t013",
-	.dev            = {
-		.platform_data = &msm_camera_sensor_mt9t013_data,
-	},
-};
-#endif
-#endif
-
-#ifdef CONFIG_SENSORS_MT9T013
-static struct msm_camera_legacy_device_platform_data msm_camera_device_mt9t013 = {
-	.sensor_reset	= 108,
-	.sensor_pwd	= 85,
-	.vcm_pwd	= TROUT_GPIO_VCM_PWDN,
-	.config_gpio_on = config_camera_on_gpios,
-	.config_gpio_off = config_camera_off_gpios,
-};
-
-static struct platform_device trout_camera = {
-	.name           = "camera",
-	.dev            = {
-		.platform_data = &msm_camera_device_mt9t013,
-	},
-};
-#endif
-
-static struct pwr_sink trout_pwrsink_table[] = {
-	{
-		.id	= PWRSINK_AUDIO,
-		.ua_max	= 90000,
-	},
-	{
-		.id	= PWRSINK_BACKLIGHT,
-		.ua_max	= 128000,
-	},
-	{
-		.id	= PWRSINK_LED_BUTTON,
-		.ua_max	= 17000,
-	},
-	{
-		.id	= PWRSINK_LED_KEYBOARD,
-		.ua_max	= 22000,
-	},
-	{
-		.id	= PWRSINK_GP_CLK,
-		.ua_max	= 30000,
-	},
-	{
-		.id	= PWRSINK_BLUETOOTH,
-		.ua_max	= 15000,
-	},
-	{
-		.id	= PWRSINK_CAMERA,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_SDCARD,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_VIDEO,
-		.ua_max	= 0,
-	},
-	{
-		.id	= PWRSINK_WIFI,
-		.ua_max = 200000,
-	},
-	{
-		.id	= PWRSINK_SYSTEM_LOAD,
-		.ua_max	= 100000,
-		.percent_util = 38,
-	},
-};
-
-static struct pwr_sink_platform_data trout_pwrsink_data = {
-	.num_sinks	= ARRAY_SIZE(trout_pwrsink_table),
-	.sinks		= trout_pwrsink_table,
-	.suspend_late	= NULL,
-	.resume_early	= NULL,
-	.suspend_early	= NULL,
-	.resume_late	= NULL,
-};
-
-static struct platform_device trout_pwr_sink = {
-	.name = "htc_pwrsink",
-	.id = -1,
-	.dev	= {
-		.platform_data = &trout_pwrsink_data,
-	},
-};
-
-static struct platform_device trout_rfkill = {
-	.name = "trout_rfkill",
-	.id = -1,
-};
-
-static struct msm_pmem_setting pmem_setting = {
-	.pmem_start = MSM_PMEM_MDP_BASE,
-	.pmem_size = MSM_PMEM_MDP_SIZE,
-	.pmem_adsp_start = MSM_PMEM_ADSP_BASE,
-	.pmem_adsp_size = MSM_PMEM_ADSP_SIZE,
-	.pmem_gpu0_start = MSM_PMEM_GPU0_BASE,
-	.pmem_gpu0_size = MSM_PMEM_GPU0_SIZE,
-	.pmem_gpu1_start = MSM_PMEM_GPU1_BASE,
-	.pmem_gpu1_size = MSM_PMEM_GPU1_SIZE,
-	.pmem_camera_start = MSM_PMEM_CAMERA_BASE,
-	.pmem_camera_size = MSM_PMEM_CAMERA_SIZE,
-	.ram_console_start = MSM_RAM_CONSOLE_BASE,
-	.ram_console_size = MSM_RAM_CONSOLE_SIZE,
-};
-
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-static struct platform_device trout_wifi = {
-	.name		= "msm_wifi",
-	.id		= 1,
-	.num_resources	= 0,
-	.resource	= NULL,
-	.dev		= {
-		.platform_data = &trout_wifi_control,
-	},
-};
-#endif
-
-#define SND(num, desc) { .name = desc, .id = num }
-static struct snd_endpoint snd_endpoints_list[] = {
-	SND(0, "HANDSET"),
-	SND(1, "SPEAKER"),
-	SND(2, "HEADSET"),
-	SND(3, "BT"),
-	SND(44, "BT_EC_OFF"),
-	SND(10, "HEADSET_AND_SPEAKER"),
-	SND(256, "CURRENT"),
-
-	/* Bluetooth accessories. */
-
-	SND(12, "HTC BH S100"),
-	SND(13, "HTC BH M100"),
-	SND(14, "Motorola H500"),
-	SND(15, "Nokia HS-36W"),
-	SND(16, "PLT 510v.D"),
-	SND(17, "M2500 by Plantronics"),
-	SND(18, "Nokia HDW-3"),
-	SND(19, "HBH-608"),
-	SND(20, "HBH-DS970"),
-	SND(21, "i.Tech BlueBAND"),
-	SND(22, "Nokia BH-800"),
-	SND(23, "Motorola H700"),
-	SND(24, "HTC BH M200"),
-	SND(25, "Jabra JX10"),
-	SND(26, "320Plantronics"),
-	SND(27, "640Plantronics"),
-	SND(28, "Jabra BT500"),
-	SND(29, "Motorola HT820"),
-	SND(30, "HBH-IV840"),
-	SND(31, "6XXPlantronics"),
-	SND(32, "3XXPlantronics"),
-	SND(33, "HBH-PV710"),
-	SND(34, "Motorola H670"),
-	SND(35, "HBM-300"),
-	SND(36, "Nokia BH-208"),
-	SND(37, "Samsung WEP410"),
-	SND(38, "Jabra BT8010"),
-	SND(39, "Motorola S9"),
-	SND(40, "Jabra BT620s"),
-	SND(41, "Nokia BH-902"),
-	SND(42, "HBH-DS220"),
-	SND(43, "HBH-DS980"),
-};
-#undef SND
-
-static struct msm_snd_endpoints trout_snd_endpoints = {
-	.endpoints = snd_endpoints_list,
-	.num = ARRAY_SIZE(snd_endpoints_list),
-};
-
-static struct platform_device trout_snd = {
-	.name = "msm_snd",
-	.id = -1,
-	.dev	= {
-		.platform_data = &trout_snd_endpoints,
-	},
-};
-
-static struct platform_device *devices[] __initdata = {
-	&msm_device_smd,
-	&msm_device_nand,
-	&msm_device_i2c,
-	&msm_device_uart1,
-#if !defined(CONFIG_MSM_SERIAL_DEBUGGER) && !defined(CONFIG_TROUT_H2W)
-	&msm_device_uart3,
-#endif
-#ifdef CONFIG_SERIAL_MSM_HS
-	&msm_device_uart_dm1,
-#endif
-	&trout_nav_device,
-	&trout_reset_keys_device,
-	&android_leds,
-	&sd_door_switch,
-	&android_timed_gpios,
-#ifdef CONFIG_MT9T013
-	&msm_camera_sensor_mt9t013,
-#endif
-#ifdef CONFIG_SENSORS_MT9T013
-	&trout_camera,
-#endif
-	&trout_rfkill,
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-	&trout_wifi,
-#endif
-#ifdef CONFIG_HTC_HEADSET
-	&trout_h2w,
-#endif
-#ifdef CONFIG_HTC_PWRSINK
-	&trout_pwr_sink,
-#endif
-	&trout_snd,
-};
-
-extern struct sys_timer msm_timer;
-
-static void __init trout_init_irq(void)
-{
-	printk("trout_init_irq()\n");
-	msm_init_irq();
-}
-
-static uint opt_disable_uart3;
-
-module_param_named(disable_uart3, opt_disable_uart3, uint, 0);
-
-static void trout_reset(void)
-{
-	gpio_set_value(TROUT_GPIO_PS_HOLD, 0);
-}
-
-static uint32_t gpio_table[] = {
-	/* BLUETOOTH */
-#ifdef CONFIG_SERIAL_MSM_HS
-	PCOM_GPIO_CFG(43, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* RTS */
-	PCOM_GPIO_CFG(44, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* CTS */
-	PCOM_GPIO_CFG(45, 2, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* RX */
-	PCOM_GPIO_CFG(46, 3, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* TX */
-#else
-	PCOM_GPIO_CFG(43, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* RTS */
-	PCOM_GPIO_CFG(44, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* CTS */
-	PCOM_GPIO_CFG(45, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* RX */
-	PCOM_GPIO_CFG(46, 1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_4MA), /* TX */
-#endif
-};
-
-
-static uint32_t camera_off_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 0, GPIO_OUTPUT, GPIO_NO_PULL, GPIO_4MA), /* MCLK */
-};
-
-static uint32_t camera_on_gpio_table[] = {
-	/* CAMERA */
-	PCOM_GPIO_CFG(2, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT2 */
-	PCOM_GPIO_CFG(3, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT3 */
-	PCOM_GPIO_CFG(4, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT4 */
-	PCOM_GPIO_CFG(5, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT5 */
-	PCOM_GPIO_CFG(6, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT6 */
-	PCOM_GPIO_CFG(7, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT7 */
-	PCOM_GPIO_CFG(8, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT8 */
-	PCOM_GPIO_CFG(9, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT9 */
-	PCOM_GPIO_CFG(10, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT10 */
-	PCOM_GPIO_CFG(11, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* DAT11 */
-	PCOM_GPIO_CFG(12, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_16MA), /* PCLK */
-	PCOM_GPIO_CFG(13, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* HSYNC_IN */
-	PCOM_GPIO_CFG(14, 1, GPIO_INPUT, GPIO_PULL_DOWN, GPIO_2MA), /* VSYNC_IN */
-	PCOM_GPIO_CFG(15, 1, GPIO_OUTPUT, GPIO_PULL_DOWN, GPIO_16MA), /* MCLK */
-};
-
-static void config_gpio_table(uint32_t *table, int len)
-{
-	int n;
-	unsigned id;
-	for(n = 0; n < len; n++) {
-		id = table[n];
-		msm_proc_comm(PCOM_RPC_GPIO_TLMM_CONFIG_EX, &id, 0);
-	}
-}
-
-static void config_camera_on_gpios(void)
-{
-	config_gpio_table(camera_on_gpio_table,
-		ARRAY_SIZE(camera_on_gpio_table));
-}
-
-static void config_camera_off_gpios(void)
-{
-	config_gpio_table(camera_off_gpio_table,
-		ARRAY_SIZE(camera_off_gpio_table));
-}
-
-static void __init config_gpios(void)
-{
-	config_gpio_table(gpio_table, ARRAY_SIZE(gpio_table));
-	config_camera_off_gpios();
-}
-
-void msm_serial_debug_init(unsigned int base, int irq,
-			   struct device *clk_device, int signal_irq);
-
-static struct msm_acpu_clock_platform_data trout_clock_data = {
-	.acpu_switch_time_us = 20,
-	.max_speed_delta_khz = 256000,
-	.vdd_switch_time_us = 62,
-	.power_collapse_khz = 19200000,
-	.wait_for_irq_khz = 128000000,
-};
-
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
-	.wakeup_irq = MSM_GPIO_TO_INT(45),
-	.inject_rx_on_wakeup = 1,
-	.rx_to_inject = 0x32,
-};
-#endif
-
-static void __init trout_init(void)
-{
-	int rc;
-
-	printk("trout_init() revision=%d\n", system_rev);
-
-	/*
-	 * Setup common MSM GPIOS
-	 */
-	config_gpios();
-
-	msm_hw_reset_hook = trout_reset;
-
-	gpio_direction_output(system_rev < 5 ?
-			TROUT_4_TP_LS_EN : TROUT_5_TP_LS_EN, 0);
-
-	msm_acpu_clock_init(&trout_clock_data);
-
-#if defined(CONFIG_MSM_SERIAL_DEBUGGER)
-	if (!opt_disable_uart3)
-		msm_serial_debug_init(MSM_UART3_PHYS, INT_UART3,
-				      &msm_device_uart3.dev, 1);
-#endif
-
-	/* gpio_configure(108, IRQF_TRIGGER_LOW); */
-
-	/* put the AF VCM in powerdown mode to avoid noise */
-	gpio_set_value(TROUT_GPIO_VCM_PWDN, 1);
-	mdelay(100);
-
-	if (system_rev < 5) {
-		trout_x_axis.info.gpio = trout_4_x_axis_gpios;
-		trout_y_axis.info.gpio = trout_4_y_axis_gpios;
-	}
-
-#ifdef CONFIG_SERIAL_MSM_HS
-	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
-#endif
-	msm_add_usb_devices(trout_phy_reset);
-
-	msm_add_mem_devices(&pmem_setting);
-
-	rc = trout_init_mmc(system_rev);
-	if (rc)
-		printk(KERN_CRIT "%s: MMC init failure (%d)\n", __func__, rc);
-
-#ifdef CONFIG_WIFI_MEM_PREALLOC
-	rc = trout_init_wifi_mem();
-	if (rc)
-		printk(KERN_CRIT "%s: WiFi Memory init failure (%d)\n", __func__, rc);
-#endif
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
-
-	/* SD card door should wake the device */
-	set_irq_wake(TROUT_GPIO_TO_INT(TROUT_GPIO_SD_DOOR_N), 1);
-}
-
-static struct map_desc trout_io_desc[] __initdata = {
-	{
-		.virtual = TROUT_CPLD_BASE,
-		.pfn     = __phys_to_pfn(TROUT_CPLD_START),
-		.length  = TROUT_CPLD_SIZE,
-		.type    = MT_DEVICE_NONSHARED
-	}
-};
-
-static void __init trout_fixup(struct machine_desc *desc, struct tag *tags,
-				char **cmdline, struct meminfo *mi)
-{
-	mi->nr_banks=1;
-	mi->bank[0].start = PHYS_OFFSET;
-	mi->bank[0].node = PHYS_TO_NID(PHYS_OFFSET);
-	mi->bank[0].size = (101*1024*1024);
-}
-
-static void __init trout_map_io(void)
-{
-	msm_map_common_io();
-	iotable_init(trout_io_desc, ARRAY_SIZE(trout_io_desc));
-	msm_clock_init();
-}
-
-MACHINE_START(TROUT, "trout")
-/* Maintainer: Brian Swetland <swetland@google.com> */
-#ifdef CONFIG_MSM_DEBUG_UART
-	.phys_io        = MSM_DEBUG_UART_PHYS,
-	.io_pg_offst    = ((MSM_DEBUG_UART_BASE) >> 18) & 0xfffc,
-#endif
-	.boot_params    = 0x10000100,
-	.fixup          = trout_fixup,
-	.map_io         = trout_map_io,
-	.init_irq       = trout_init_irq,
-	.init_machine   = trout_init,
-	.timer          = &msm_timer,
-MACHINE_END
diff --git a/arch/arm/mach-msm/board-trout.h b/arch/arm/mach-msm/board-trout.h
deleted file mode 100644
index 308c4df..0000000
--- a/arch/arm/mach-msm/board-trout.h
+++ /dev/null
@@ -1,162 +0,0 @@
-/* linux/arch/arm/mach-msm/board-trout.h
-** Author: Brian Swetland <swetland@google.com>
-*/
-#ifndef __ARCH_ARM_MACH_MSM_BOARD_TROUT_H
-#define __ARCH_ARM_MACH_MSM_BOARD_TROUT_H
-
-#include <mach/board.h>
-
-#define MSM_SMI_BASE		0x00000000
-#define MSM_SMI_SIZE		0x00800000
-
-#define MSM_EBI_BASE		0x10000000
-#define MSM_EBI_SIZE		0x06e00000
-
-#define MSM_PMEM_GPU0_BASE	0x00000000
-#define MSM_PMEM_GPU0_SIZE	0x00700000
-
-#define MSM_PMEM_MDP_BASE	0x02000000
-#define MSM_PMEM_MDP_SIZE	0x00800000
-
-#define MSM_PMEM_ADSP_BASE      0x02800000
-#define MSM_PMEM_ADSP_SIZE	0x00800000
-
-#define MSM_PMEM_CAMERA_BASE	0x03000000
-#define MSM_PMEM_CAMERA_SIZE	0x00800000
-
-#define MSM_FB_BASE		0x03800000
-#define MSM_FB_SIZE		0x00100000
-
-#define MSM_LINUX_BASE		MSM_EBI_BASE
-#define MSM_LINUX_SIZE		0x06500000
-
-#define MSM_PMEM_GPU1_SIZE	0x800000
-#define MSM_PMEM_GPU1_BASE	MSM_RAM_CONSOLE_BASE - MSM_PMEM_GPU1_SIZE
-
-#define MSM_RAM_CONSOLE_BASE	MSM_EBI_BASE + 0x6d00000
-#define MSM_RAM_CONSOLE_SIZE	128 * SZ_1K
-
-#if (MSM_FB_BASE + MSM_FB_SIZE) >= (MSM_PMEM_GPU1_BASE)
-#error invalid memory map
-#endif
-
-#define DECLARE_MSM_IOMAP
-#include <mach/msm_iomap.h>
-
-#define TROUT_4_BALL_UP_0     1
-#define TROUT_4_BALL_LEFT_0   18
-#define TROUT_4_BALL_DOWN_0   57
-#define TROUT_4_BALL_RIGHT_0  91
-
-#define TROUT_5_BALL_UP_0     94
-#define TROUT_5_BALL_LEFT_0   18
-#define TROUT_5_BALL_DOWN_0   90
-#define TROUT_5_BALL_RIGHT_0  19
-
-#define TROUT_POWER_KEY     20
-
-#define TROUT_4_TP_LS_EN    19
-#define TROUT_5_TP_LS_EN    1
-
-#define TROUT_CPLD_BASE   0xE8100000
-#define TROUT_CPLD_START  0x98000000
-#define TROUT_CPLD_SIZE   SZ_4K
-
-#define TROUT_GPIO_CABLE_IN1		(83)
-#define TROUT_GPIO_CABLE_IN2		(49)
-
-#define TROUT_GPIO_START (128)
-
-#define TROUT_GPIO_INT_MASK0_REG            (0x0c)
-#define TROUT_GPIO_INT_STAT0_REG            (0x0e)
-#define TROUT_GPIO_INT_MASK1_REG            (0x14)
-#define TROUT_GPIO_INT_STAT1_REG            (0x10)
-
-#define TROUT_GPIO_HAPTIC_PWM               (28)
-#define TROUT_GPIO_PS_HOLD                  (25)
-
-#define TROUT_GPIO_MISC2_BASE               (TROUT_GPIO_START + 0x00)
-#define TROUT_GPIO_MISC3_BASE               (TROUT_GPIO_START + 0x08)
-#define TROUT_GPIO_MISC4_BASE               (TROUT_GPIO_START + 0x10)
-#define TROUT_GPIO_MISC5_BASE               (TROUT_GPIO_START + 0x18)
-#define TROUT_GPIO_INT2_BASE                (TROUT_GPIO_START + 0x20)
-#define TROUT_GPIO_MISC1_BASE               (TROUT_GPIO_START + 0x28)
-#define TROUT_GPIO_VIRTUAL_BASE             (TROUT_GPIO_START + 0x30)
-#define TROUT_GPIO_INT5_BASE                (TROUT_GPIO_START + 0x48)
-
-#define TROUT_GPIO_CHARGER_EN               (TROUT_GPIO_MISC2_BASE + 0)
-#define TROUT_GPIO_ISET                     (TROUT_GPIO_MISC2_BASE + 1)
-#define TROUT_GPIO_H2W_DAT_DIR              (TROUT_GPIO_MISC2_BASE + 2)
-#define TROUT_GPIO_H2W_CLK_DIR              (TROUT_GPIO_MISC2_BASE + 3)
-#define TROUT_GPIO_H2W_DAT_GPO              (TROUT_GPIO_MISC2_BASE + 4)
-#define TROUT_GPIO_H2W_CLK_GPO              (TROUT_GPIO_MISC2_BASE + 5)
-#define TROUT_GPIO_H2W_SEL0                 (TROUT_GPIO_MISC2_BASE + 6)
-#define TROUT_GPIO_H2W_SEL1                 (TROUT_GPIO_MISC2_BASE + 7)
-
-#define TROUT_GPIO_SPOTLIGHT_EN             (TROUT_GPIO_MISC3_BASE + 0)
-#define TROUT_GPIO_FLASH_EN                 (TROUT_GPIO_MISC3_BASE + 1)
-#define TROUT_GPIO_I2C_PULL                 (TROUT_GPIO_MISC3_BASE + 2)
-#define TROUT_GPIO_TP_I2C_PULL              (TROUT_GPIO_MISC3_BASE + 3)
-#define TROUT_GPIO_TP_EN                    (TROUT_GPIO_MISC3_BASE + 4)
-#define TROUT_GPIO_JOG_EN                   (TROUT_GPIO_MISC3_BASE + 5)
-#define TROUT_GPIO_UI_LED_EN                (TROUT_GPIO_MISC3_BASE + 6)
-#define TROUT_GPIO_QTKEY_LED_EN             (TROUT_GPIO_MISC3_BASE + 7)
-
-#define TROUT_GPIO_VCM_PWDN                 (TROUT_GPIO_MISC4_BASE + 0)
-#define TROUT_GPIO_USB_H2W_SW               (TROUT_GPIO_MISC4_BASE + 1)
-#define TROUT_GPIO_COMPASS_RST_N            (TROUT_GPIO_MISC4_BASE + 2)
-#define TROUT_GPIO_HAPTIC_EN_UP             (TROUT_GPIO_MISC4_BASE + 3)
-#define TROUT_GPIO_HAPTIC_EN_MAIN           (TROUT_GPIO_MISC4_BASE + 4)
-#define TROUT_GPIO_USB_PHY_RST_N            (TROUT_GPIO_MISC4_BASE + 5)
-#define TROUT_GPIO_WIFI_PA_RESETX           (TROUT_GPIO_MISC4_BASE + 6)
-#define TROUT_GPIO_WIFI_EN                  (TROUT_GPIO_MISC4_BASE + 7)
-
-#define TROUT_GPIO_BT_32K_EN                (TROUT_GPIO_MISC5_BASE + 0)
-#define TROUT_GPIO_MAC_32K_EN               (TROUT_GPIO_MISC5_BASE + 1)
-#define TROUT_GPIO_MDDI_32K_EN              (TROUT_GPIO_MISC5_BASE + 2)
-#define TROUT_GPIO_COMPASS_32K_EN           (TROUT_GPIO_MISC5_BASE + 3)
-
-#define TROUT_GPIO_NAVI_ACT_N               (TROUT_GPIO_INT2_BASE + 0)
-#define TROUT_GPIO_COMPASS_IRQ              (TROUT_GPIO_INT2_BASE + 1)
-#define TROUT_GPIO_SLIDING_DET              (TROUT_GPIO_INT2_BASE + 2)
-#define TROUT_GPIO_AUD_HSMIC_DET_N          (TROUT_GPIO_INT2_BASE + 3)
-#define TROUT_GPIO_SD_DOOR_N                (TROUT_GPIO_INT2_BASE + 4)
-#define TROUT_GPIO_CAM_BTN_STEP1_N          (TROUT_GPIO_INT2_BASE + 5)
-#define TROUT_GPIO_CAM_BTN_STEP2_N          (TROUT_GPIO_INT2_BASE + 6)
-#define TROUT_GPIO_TP_ATT_N                 (TROUT_GPIO_INT2_BASE + 7)
-#define TROUT_GPIO_BANK0_FIRST_INT_SOURCE   (TROUT_GPIO_NAVI_ACT_N)
-#define TROUT_GPIO_BANK0_LAST_INT_SOURCE    (TROUT_GPIO_TP_ATT_N)
-
-#define TROUT_GPIO_H2W_DAT_GPI              (TROUT_GPIO_MISC1_BASE + 0)
-#define TROUT_GPIO_H2W_CLK_GPI              (TROUT_GPIO_MISC1_BASE + 1)
-#define TROUT_GPIO_CPLD128_VER_0            (TROUT_GPIO_MISC1_BASE + 4)
-#define TROUT_GPIO_CPLD128_VER_1            (TROUT_GPIO_MISC1_BASE + 5)
-#define TROUT_GPIO_CPLD128_VER_2            (TROUT_GPIO_MISC1_BASE + 6)
-#define TROUT_GPIO_CPLD128_VER_3            (TROUT_GPIO_MISC1_BASE + 7)
-
-#define TROUT_GPIO_SDMC_CD_N                (TROUT_GPIO_VIRTUAL_BASE + 0)
-#define TROUT_GPIO_END                      (TROUT_GPIO_SDMC_CD_N)
-#define TROUT_GPIO_BANK1_FIRST_INT_SOURCE   (TROUT_GPIO_SDMC_CD_N)
-#define TROUT_GPIO_BANK1_LAST_INT_SOURCE    (TROUT_GPIO_SDMC_CD_N)
-
-#define TROUT_GPIO_VIRTUAL_TO_REAL_OFFSET \
-	(TROUT_GPIO_INT5_BASE - TROUT_GPIO_VIRTUAL_BASE)
-
-#define TROUT_INT_START (NR_MSM_IRQS + NR_GPIO_IRQS)
-#define TROUT_INT_BANK0_COUNT (8)
-#define TROUT_INT_BANK1_START (TROUT_INT_START + TROUT_INT_BANK0_COUNT)
-#define TROUT_INT_BANK1_COUNT (1)
-#define TROUT_INT_END (TROUT_INT_START + TROUT_INT_BANK0_COUNT + \
-			TROUT_INT_BANK1_COUNT - 1)
-#define TROUT_GPIO_TO_INT(n) (((n) <= TROUT_GPIO_BANK0_LAST_INT_SOURCE) ? \
-	(TROUT_INT_START - TROUT_GPIO_BANK0_FIRST_INT_SOURCE + (n)) : \
-	(TROUT_INT_BANK1_START - TROUT_GPIO_BANK1_FIRST_INT_SOURCE + (n)))
-
-#define TROUT_INT_TO_BANK(n) ((n - TROUT_INT_START) / TROUT_INT_BANK0_COUNT)
-#define TROUT_INT_TO_MASK(n) (1U << ((n - TROUT_INT_START) & 7))
-#define TROUT_BANK_TO_MASK_REG(bank) \
-	(bank ? TROUT_GPIO_INT_MASK1_REG : TROUT_GPIO_INT_MASK0_REG)
-#define TROUT_BANK_TO_STAT_REG(bank) \
-	(bank ? TROUT_GPIO_INT_STAT1_REG : TROUT_GPIO_INT_STAT0_REG)
-
-#endif /* GUARD */
diff --git a/arch/arm/mach-msm/qdsp6/Makefile b/arch/arm/mach-msm/qdsp6/Makefile
deleted file mode 100644
index 361c9e6..0000000
--- a/arch/arm/mach-msm/qdsp6/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-obj-y += dal.o
-obj-y += q6audio.o
-obj-y += pcm_out.o
-obj-y += pcm_in.o
-obj-y += mp3.o
-obj-y += routing.o
-obj-y += audio_ctl.o
-obj-y += msm_q6vdec.o
-obj-y += msm_q6venc.o
-obj-y += aac_in.o
-obj-y += qcelp_in.o
diff --git a/arch/arm/mach-msm/qdsp6/aac_in.c b/arch/arm/mach-msm/qdsp6/aac_in.c
deleted file mode 100644
index 5c7042b..0000000
--- a/arch/arm/mach-msm/qdsp6/aac_in.c
+++ /dev/null
@@ -1,217 +0,0 @@
-/* arch/arm/mach-msm/qdsp6/aac_in.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
-*/
-
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/miscdevice.h>
-#include <linux/mutex.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/uaccess.h>
-#include <linux/msm_audio.h>
-#include <mach/msm_qdsp6_audio.h>
-
-#define BUFSZ (4096)
-#define DMASZ (BUFSZ * 2)
-
-#if 0
-#define TRACE(x...) pr_info("Q6: "x)
-#else
-#define TRACE(x...) do{}while(0)
-#endif
-
-static DEFINE_MUTEX(aac_in_lock);
-static int aac_in_opened = 0;
-static struct aac_format *af;
-
-void audio_client_dump(struct audio_client *ac);
-
-static long aac_in_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	int rc = 0;
-
-	switch (cmd) {
-	case AUDIO_SET_VOLUME:
-		break;
-	case AUDIO_GET_STATS: {
-		struct msm_audio_stats stats;
-		memset(&stats, 0, sizeof(stats));
-		if (copy_to_user((void*) arg, &stats, sizeof(stats)))
-			return -EFAULT;
-		return 0;
-	}
-	case AUDIO_START: {
-		uint32_t acdb_id;
-		rc = 0;
-
-		if (arg == 0) {
-			acdb_id = 0;
-		} else if (copy_from_user(&acdb_id,
-				(void*) arg, sizeof(acdb_id))) {
-			rc = -EFAULT;
-			break;
-		}
-
-		mutex_lock(&aac_in_lock);
-		if (file->private_data) {
-			rc = -EBUSY;
-		} else {
-			file->private_data = q6audio_open_aac(
-				BUFSZ, 48000, AUDIO_FLAG_READ, af, acdb_id);
-			if (!file->private_data)
-				rc = -ENOMEM;
-		}
-		mutex_unlock(&aac_in_lock);
-		break;
-	}
-	case AUDIO_STOP:
-		break;
-	case AUDIO_FLUSH:
-		break;
-	case AUDIO_SET_CONFIG: {
-		struct msm_audio_config config;
-		if (copy_from_user(&config, (void*) arg, sizeof(config))) {
-			rc = -EFAULT;
-			break;
-		}
-		if (config.sample_rate != 48000)
-			pr_info("only 48KHz AAC encode supported\n");
-		af->channel_config = config.channel_count;
-		break;
-	}
-	case AUDIO_GET_CONFIG: {
-		struct msm_audio_config config;
-		config.buffer_size = BUFSZ;
-		config.buffer_count = 2;
-		config.sample_rate = 48000;
-		config.channel_count = af->channel_config;
-		config.unused[0] = 0;
-		config.unused[1] = 0;
-		config.unused[2] = 0;
-		if (copy_to_user((void*) arg, &config, sizeof(config))) {
-			rc = -EFAULT;
-		}
-		break;
-	}
-	default:
-		rc = -EINVAL;
-	}
-	return rc;
-}
-
-static int aac_in_open(struct inode *inode, struct file *file)
-{
-	int rc;
-
-	pr_info("aac_in: open\n");
-	mutex_lock(&aac_in_lock);
-	if (aac_in_opened) {
-		pr_err("aac_in: busy\n");
-		rc = -EBUSY;
-	} else {
-		af = kzalloc(sizeof(*af), GFP_KERNEL);
-		memset(af, 0, sizeof(struct aac_format));
-		af->sample_rate = 3; /* 48000 */
-		af->channel_config = 1;
-		af->block_formats = AUDIO_AAC_FORMAT_ADTS;
-		af->audio_object_type = 2; /* CAD to ADSP format */
-		af->bit_rate = 192000;
-
-		aac_in_opened = 1;
-		rc = 0;
-	}
-	mutex_unlock(&aac_in_lock);
-	return rc;
-}
-
-static ssize_t aac_in_read(struct file *file, char __user *buf,
-			   size_t count, loff_t *pos)
-{
-	struct audio_client *ac;
-	struct audio_buffer *ab;
-	const char __user *start = buf;
-	int xfer, res = 0;
-
-	mutex_lock(&aac_in_lock);
-	ac = file->private_data;
-	if (!ac) {
-		res = -ENODEV;
-		goto fail;
-	}
-	while (count > 0) {
-		ab = ac->buf + ac->cpu_buf;
-
-		if (ab->used)
-			if (!wait_event_timeout(ac->wait, (ab->used == 0), 5*HZ)) {
-				audio_client_dump(ac);
-				pr_err("aac_read: timeout. dsp dead?\n");
-				BUG();
-			}
-
-		xfer = count;
-		if (xfer > ab->size)
-			xfer = ab->size;
-
-		if (copy_to_user(buf, ab->data, xfer)) {
-			res = -EFAULT;
-			goto fail;
-		}
-
-		buf += xfer;
-		count -= xfer;
-
-		ab->used = 1;
-		q6audio_read(ac, ab);
-		ac->cpu_buf ^= 1;
-	}
-fail:
-	res = buf - start;
-	mutex_unlock(&aac_in_lock);
-	return res;
-}
-
-static int aac_in_release(struct inode *inode, struct file *file)
-{
-	int rc = 0;
-	pr_info("aac_in: release\n");
-	mutex_lock(&aac_in_lock);
-	if (file->private_data)
-		rc = q6audio_close(file->private_data);
-	kfree(af);
-	aac_in_opened = 0;
-	mutex_unlock(&aac_in_lock);
-	return rc;
-}
-
-static struct file_operations aac_in_fops = {
-	.owner	= THIS_MODULE,
-	.open	= aac_in_open,
-	.read	= aac_in_read,
-	.release  = aac_in_release,
-	.unlocked_ioctl	= aac_in_ioctl,
-};
-
-struct miscdevice aac_in_misc = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "msm_aac_in",
-	.fops = &aac_in_fops,
-};
-
-static int __init aac_in_init(void) {
-	return misc_register(&aac_in_misc);
-}
-
-device_initcall(aac_in_init);
diff --git a/arch/arm/mach-msm/qdsp6/analog_audio.c b/arch/arm/mach-msm/qdsp6/analog_audio.c
deleted file mode 100644
index 3ec80d4..0000000
--- a/arch/arm/mach-msm/qdsp6/analog_audio.c
+++ /dev/null
@@ -1,67 +0,0 @@
-
-#include <linux/gpio.h>
-#include "../pmic.h"
-#include <mach/msm_qdsp6_audio.h>
-
-#define GPIO_HEADSET_AMP 157
-
-void analog_init(void)
-{
-	/* stereo pmic init */
-	pmic_spkr_set_gain(LEFT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_spkr_set_gain(RIGHT_SPKR, SPKR_GAIN_PLUS12DB);
-	pmic_mic_set_volt(MIC_VOLT_1_80V);
-
-	gpio_direction_output(GPIO_HEADSET_AMP, 1);
-	gpio_set_value(GPIO_HEADSET_AMP, 0);
-}
-
-void analog_headset_enable(int en)
-{
-	/* enable audio amp */
-	gpio_set_value(GPIO_HEADSET_AMP, !!en);
-}
-
-void analog_speaker_enable(int en)
-{
-	struct spkr_config_mode scm;
-	memset(&scm, 0, sizeof(scm));
-
-	if (en) {
-		scm.is_right_chan_en = 1;
-		scm.is_left_chan_en = 1;
-		scm.is_stereo_en = 1;
-		scm.is_hpf_en = 1;
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-		pmic_spkr_en_mute(RIGHT_SPKR, 0);
-		pmic_set_spkr_configuration(&scm);
-		pmic_spkr_en(LEFT_SPKR, 1);
-		pmic_spkr_en(RIGHT_SPKR, 1);
-		
-		/* unmute */
-		pmic_spkr_en_mute(LEFT_SPKR, 1);
-		pmic_spkr_en_mute(RIGHT_SPKR, 1);
-	} else {
-		pmic_spkr_en_mute(LEFT_SPKR, 0);
-		pmic_spkr_en_mute(RIGHT_SPKR, 0);
-
-		pmic_spkr_en(LEFT_SPKR, 0);
-		pmic_spkr_en(RIGHT_SPKR, 0);
-
-		pmic_set_spkr_configuration(&scm);
-	}
-}
-
-static struct q6audio_analog_ops ops = {
-	.init = analog_init,
-	.speaker_enable = analog_speaker_enable,
-	.headset_enable = analog_headset_enable,
-};
-
-static int __init init(void)
-{
-	q6audio_register_analog_ops(&ops);
-	return 0;
-}
-
-device_initcall(init);
diff --git a/arch/arm/mach-msm/qdsp6/audio_ctl.c b/arch/arm/mach-msm/qdsp6/audio_ctl.c
deleted file mode 100644
index 0c70f46..0000000
--- a/arch/arm/mach-msm/qdsp6/audio_ctl.c
+++ /dev/null
@@ -1,242 +0,0 @@
-/* arch/arm/mach-msm/qdsp6/audio_ctrl.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/miscdevice.h>
-#include <linux/uaccess.h>
-#include <linux/msm_audio.h>
-
-#include <mach/msm_qdsp6_audio.h>
-#include <mach/htc_acoustic_qsd.h>
-
-#define BUFSZ (0)
-
-#if 1
-#define AUDIO_INFO(x...) pr_info("Audio: "x)
-#else
-#define AUDIO_INFO(x...) do{}while(0)
-#endif
-
-static DEFINE_MUTEX(voice_lock);
-static DEFINE_MUTEX(fm_lock);
-static int voice_started;
-static int fm_started;
-
-static struct audio_client *voc_tx_clnt;
-static struct audio_client *voc_rx_clnt;
-static struct audio_client *fm_clnt;
-
-static int q6_voice_start(uint32_t rx_acdb_id, uint32_t tx_acdb_id)
-{
-	int rc = 0;
-
-	mutex_lock(&voice_lock);
-
-	if (voice_started) {
-		pr_err("voice: busy\n");
-		rc = -EBUSY;
-		goto done;
-	}
-
-	voc_rx_clnt = q6voice_open(AUDIO_FLAG_WRITE, rx_acdb_id);
-	if (!voc_rx_clnt) {
-		pr_err("voice: open voice rx failed.\n");
-		rc = -ENOMEM;
-		goto done;
-	}
-
-	voc_tx_clnt = q6voice_open(AUDIO_FLAG_READ, tx_acdb_id);
-	if (!voc_tx_clnt) {
-		pr_err("voice: open voice tx failed.\n");
-		q6voice_close(voc_rx_clnt);
-		rc = -ENOMEM;
-	}
-
-	voice_started = 1;
-done:
-	mutex_unlock(&voice_lock);
-	return rc;
-}
-
-static int q6_voice_stop(void)
-{
-	mutex_lock(&voice_lock);
-	if (voice_started) {
-		q6voice_close(voc_tx_clnt);
-		q6voice_close(voc_rx_clnt);
-		voice_started = 0;
-	}
-	mutex_unlock(&voice_lock);
-	return 0;
-}
-
-static int q6_fm_start(void)
-{
-	int rc = 0;
-
-	mutex_lock(&fm_lock);
-
-	if (fm_started) {
-		pr_err("fm: busy\n");
-		rc = -EBUSY;
-		goto done;
-	}
-
-	fm_clnt = q6fm_open();
-	if (!fm_clnt) {
-		pr_err("fm: open failed.\n");
-		rc = -ENOMEM;
-		goto done;
-	}
-
-	fm_started = 1;
-done:
-	mutex_unlock(&fm_lock);
-	return rc;
-}
-
-static int q6_fm_stop(void)
-{
-	mutex_lock(&fm_lock);
-	if (fm_started) {
-		q6fm_close(fm_clnt);
-		fm_started = 0;
-	}
-	mutex_unlock(&fm_lock);
-	return 0;
-}
-
-static int q6_open(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static int q6_ioctl(struct inode *inode, struct file *file,
-		    unsigned int cmd, unsigned long arg)
-{
-	int rc;
-	uint32_t n;
-	uint32_t id[2];
-	char filename[64];
-
-	switch (cmd) {
-	case AUDIO_SWITCH_DEVICE:
-		rc = copy_from_user(&id, (void *)arg, sizeof(id));
-		AUDIO_INFO("SWITCH DEVICE %d, acdb %d\n", id[0], id[1]);
-		if (!rc)
-			rc = q6audio_do_routing(id[0], id[1]);
-		break;
-	case AUDIO_SET_VOLUME:
-		rc = copy_from_user(&n, (void *)arg, sizeof(n));
-		if (!rc)
-			rc = q6audio_set_rx_volume(n);
-		break;
-	case AUDIO_SET_MUTE:
-		rc = copy_from_user(&n, (void *)arg, sizeof(n));
-		if (!rc)
-			rc = q6audio_set_tx_mute(n);
-		break;
-	case AUDIO_UPDATE_ACDB:
-		rc = copy_from_user(&id, (void *)arg, sizeof(id));
-		if (!rc)
-			rc = q6audio_update_acdb(id[0], id[1]);
-		break;
-	case AUDIO_START_VOICE:
-		if (arg == 0) {
-			id[0] = id[1] = 0;
-		} else if (copy_from_user(&id, (void*) arg, sizeof(id))) {
-			pr_info("voice: copy acdb_id from user failed\n");
-			rc = -EFAULT;
-			break;
-		}
-		AUDIO_INFO("voice: start\n");
-		rc = q6_voice_start(id[0], id[1]);
-		break;
-	case AUDIO_STOP_VOICE:
-		AUDIO_INFO("voice: stop\n");
-		rc = q6_voice_stop();
-		break;
-	case AUDIO_START_FM:
-		AUDIO_INFO("FM: start\n");
-		rc = q6_fm_start();
-		break;
-	case AUDIO_STOP_FM:
-		AUDIO_INFO("FM: stop\n");
-		rc = q6_fm_stop();
-		break;
-	case AUDIO_REINIT_ACDB:
-		rc = copy_from_user(&filename, (void *)arg, sizeof(filename));
-		if (!rc)
-			rc = q6audio_reinit_acdb(filename);
-		break;
-	case AUDIO_ENABLE_AUXPGA_LOOPBACK: {
-		uint32_t enable;
-		if (copy_from_user(&enable, (void*) arg, sizeof(enable))) {
-			rc = -EFAULT;
-			break;
-		}
-		AUDIO_INFO("audio_ctl: enable aux loopback %d\n", enable);
-		rc = enable_aux_loopback(enable);
-		break;
-	}
-	case AUDIO_SET_AUXPGA_GAIN: {
-		int level;
-		if (copy_from_user(&level, (void*) arg, sizeof(level))) {
-			rc = -EFAULT;
-			break;
-		}
-		AUDIO_INFO("audio_ctl: set aux gain %d\n", level);
-		rc = set_aux_gain(level);
-		break;
-	}
-	case AUDIO_SET_RX_MUTE:
-		rc = copy_from_user(&n, (void *)arg, sizeof(n));
-		if (!rc)
-			rc = q6audio_set_rx_mute(n);
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-
-static int q6_release(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static struct file_operations q6_dev_fops = {
-	.owner		= THIS_MODULE,
-	.open		= q6_open,
-	.ioctl		= q6_ioctl,
-	.release	= q6_release,
-};
-
-struct miscdevice q6_control_device = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_audio_ctl",
-	.fops	= &q6_dev_fops,
-};
-
-
-static int __init q6_audio_ctl_init(void) {
-	return misc_register(&q6_control_device);
-}
-
-device_initcall(q6_audio_ctl_init);
diff --git a/arch/arm/mach-msm/qdsp6/dal.c b/arch/arm/mach-msm/qdsp6/dal.c
deleted file mode 100644
index 2bf85ae..0000000
--- a/arch/arm/mach-msm/qdsp6/dal.c
+++ /dev/null
@@ -1,599 +0,0 @@
-/* arch/arm/mach-msm/qdsp6/dal.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Author: Brian Swetland <swetland@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/spinlock.h>
-#include <linux/mutex.h>
-#include <linux/list.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/errno.h>
-
-#include <linux/delay.h>
-
-#include <mach/msm_smd.h>
-
-#include "dal.h"
-
-#define DAL_TRACE 0
-
-struct dal_hdr {
-	uint32_t length:16;	/* message length (header inclusive) */
-	uint32_t version:8;	/* DAL protocol version */
-	uint32_t priority:7;
-	uint32_t async:1;
-	uint32_t ddi:16;	/* DDI method number */
-	uint32_t prototype:8;	/* DDI serialization format */
-	uint32_t msgid:8;	/* message id (DDI, ATTACH, DETACH, ...) */
-	void *from;
-	void *to;
-} __attribute__((packed));
-
-#define TRACE_DATA_MAX	128
-#define TRACE_LOG_MAX	32
-#define TRACE_LOG_MASK	(TRACE_LOG_MAX - 1)
-
-struct dal_trace {
-	unsigned timestamp;
-	struct dal_hdr hdr;
-	uint32_t data[TRACE_DATA_MAX];
-};
-
-#define DAL_HDR_SIZE		(sizeof(struct dal_hdr))
-#define DAL_DATA_MAX		512
-#define DAL_MSG_MAX		(DAL_HDR_SIZE + DAL_DATA_MAX)
-
-#define DAL_VERSION		0x11
-
-#define DAL_MSGID_DDI		0x00
-#define DAL_MSGID_ATTACH	0x01
-#define DAL_MSGID_DETACH	0x02
-#define DAL_MSGID_ASYNCH	0xC0
-#define DAL_MSGID_REPLY		0x80
-
-struct dal_channel {
-	struct list_head list;
-	struct list_head clients;
-
-	/* synchronization for changing channel state,
-	 * adding/removing clients, smd callbacks, etc
-	 */
-	spinlock_t lock;
-
-	struct smd_channel *sch;
-	char *name;
-
-	/* events are delivered at IRQ context immediately, so
-	 * we only need one assembly buffer for the entire channel
-	 */
-	struct dal_hdr hdr;
-	unsigned char data[DAL_DATA_MAX];
-
-	unsigned count;
-	void *ptr;
-
-	/* client which the current inbound message is for */
-	struct dal_client *active;
-};
-
-struct dal_client {
-	struct list_head list;
-	struct dal_channel *dch;
-	void *cookie;
-	dal_event_func_t event;
-
-	/* opaque handle for the far side */
-	void *remote;
-
-	/* dal rpc calls are fully synchronous -- only one call may be
-	 * active per client at a time
-	 */
-	struct mutex write_lock;
-	wait_queue_head_t wait;
-
-	unsigned char data[DAL_DATA_MAX];
-
-	void *reply;
-	int reply_max;
-	int status;
-	unsigned msgid; /* msgid of expected reply */
-
-	spinlock_t tr_lock;
-	unsigned tr_head;
-	unsigned tr_tail;
-	struct dal_trace *tr_log;
-};
-
-static unsigned now(void)
-{
-	struct timespec ts;
-	ktime_get_ts(&ts);
-	return (ts.tv_nsec / 1000000) + (ts.tv_sec * 1000);
-}
-
-void dal_trace(struct dal_client *c)
-{
-	if (c->tr_log)
-		return;
-	c->tr_log = kzalloc(sizeof(struct dal_trace) * TRACE_LOG_MAX,
-			    GFP_KERNEL);
-}
-
-void dal_trace_print(struct dal_hdr *hdr, unsigned *data, int len, unsigned when)
-{
-	int i;
-	printk("DAL %08x -> %08x L=%03x A=%d D=%04x P=%02x M=%02x T=%d",
-	       (unsigned) hdr->from, (unsigned) hdr->to,
-	       hdr->length, hdr->async,
-	       hdr->ddi, hdr->prototype, hdr->msgid,
-	       when);
-	len /= 4;
-	for (i = 0; i < len; i++) {
-		if (!(i & 7))
-			printk("\n%03x", i * 4);
-		printk(" %08x", data[i]);
-	}
-	printk("\n");
-}
-
-void dal_trace_dump(struct dal_client *c)
-{
-	struct dal_trace *dt;
-	unsigned n, len;
-
-	if (!c->tr_log)
-		return;
-
-	for (n = c->tr_tail; n != c->tr_head; n = (n + 1) & TRACE_LOG_MASK) {
-		dt = c->tr_log + n;
-		len = dt->hdr.length;
-		if (len > TRACE_DATA_MAX)
-			len = TRACE_DATA_MAX;
-		dal_trace_print(&dt->hdr, dt->data, len, dt->timestamp);
-	}
-}
-
-static void dal_trace_log(struct dal_client *c,
-			  struct dal_hdr *hdr, void *data, unsigned len)
-{
-	unsigned long flags;
-	unsigned t, n;
-	struct dal_trace *dt;
-
-	t = now();
-	if (len > TRACE_DATA_MAX)
-		len = TRACE_DATA_MAX;
-
-	spin_lock_irqsave(&c->tr_lock, flags);
-	n = (c->tr_head + 1) & TRACE_LOG_MASK;
-	if (c->tr_tail == n)
-		c->tr_tail = (c->tr_tail + 1) & TRACE_LOG_MASK;
-	dt = c->tr_log + n;
-	dt->timestamp = t;
-	memcpy(&dt->hdr, hdr, sizeof(struct dal_hdr));
-	memcpy(dt->data, data, len);
-	c->tr_head = n;
-
-	spin_unlock_irqrestore(&c->tr_lock, flags);
-}
-
-
-static void dal_channel_notify(void *priv, unsigned event)
-{
-	struct dal_channel *dch = priv;
-	struct dal_hdr *hdr = &dch->hdr;
-	struct dal_client *client;
-	unsigned long flags;
-	int len;
-	int r;
-
-	spin_lock_irqsave(&dch->lock, flags);
-
-again:
-	if (dch->count == 0) {
-		if (smd_read_avail(dch->sch) < DAL_HDR_SIZE)
-			goto done;
-
-		smd_read(dch->sch, hdr, DAL_HDR_SIZE);
-
-		if (hdr->length < DAL_HDR_SIZE)
-			goto done;
-
-		if (hdr->length > DAL_MSG_MAX)
-			panic("oversize message");
-
-		dch->count = hdr->length - DAL_HDR_SIZE;
-
-		/* locate the client this message is targeted to */
-		list_for_each_entry(client, &dch->clients, list) {
-			if (dch->hdr.to == client) {
-				dch->active = client;
-				dch->ptr = client->data;
-				goto check_data;
-			}
-		}
-		pr_err("$$$ receiving unknown message len = %d $$$\n",
-		       dch->count);
-		dch->active = 0;
-		dch->ptr = dch->data;
-	}
-
-check_data:
-	len = dch->count;
-	if (len > 0) {
-		if (smd_read_avail(dch->sch) < len)
-			goto done;
-
-		r = smd_read(dch->sch, dch->ptr, len);
-		if (r != len)
-			panic("invalid read");
-
-#if DAL_TRACE
-		pr_info("dal recv %p <- %p %02x:%04x:%02x %d\n",
-			hdr->to, hdr->from, hdr->msgid, hdr->ddi,
-			hdr->prototype, hdr->length - sizeof(*hdr));
-		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, dch->ptr, len);
-#endif
-		dch->count = 0;
-
-		client = dch->active;
-		if (!client) {
-			pr_err("dal: message to %p discarded\n", dch->hdr.to);
-			goto again;
-		}
-
-		if (client->tr_log)
-			dal_trace_log(client, hdr, dch->ptr, len);
-
-		if (hdr->msgid == DAL_MSGID_ASYNCH) {
-			if (client->event)
-				client->event(dch->ptr, len, client->cookie);
-			else
-				pr_err("dal: client %p has no event handler\n",
-				       client);
-			goto again;
-		}
-
-		if (hdr->msgid == client->msgid) {
-			if (!client->remote)
-				client->remote = hdr->from;
-			if (len > client->reply_max)
-				len = client->reply_max;
-			memcpy(client->reply, client->data, len);
-			client->status = len;
-			wake_up(&client->wait);
-			goto again;
-		}
-
-		pr_err("dal: cannot find client %p\n", dch->hdr.to);
-		goto again;
-	}
-
-done:
-	spin_unlock_irqrestore(&dch->lock, flags);
-}
-
-static LIST_HEAD(dal_channel_list);
-static DEFINE_MUTEX(dal_channel_list_lock);
-
-static struct dal_channel *dal_open_channel(const char *name)
-{
-	struct dal_channel *dch;
-
-	/* quick sanity check to avoid trying to talk to
-	 * some non-DAL channel...
-	 */
-	if (strncmp(name, "DSP_DAL", 7) && strncmp(name, "SMD_DAL", 7))
-		return 0;
-
-	mutex_lock(&dal_channel_list_lock);
-
-	list_for_each_entry(dch, &dal_channel_list, list) {
-		if (!strcmp(dch->name, name))
-			goto found_it;
-	}
-
-	dch = kzalloc(sizeof(*dch) + strlen(name) + 1, GFP_KERNEL);
-	if (!dch)
-		goto fail;
-
-	dch->name = (char *) (dch + 1);
-	strcpy(dch->name, name);
-	spin_lock_init(&dch->lock);
-	INIT_LIST_HEAD(&dch->clients);
-
-	list_add(&dch->list, &dal_channel_list);
-
-found_it:
-	if (!dch->sch) {
-		if (smd_open(name, &dch->sch, dch, dal_channel_notify))
-			dch = NULL;
-		/* FIXME: wait for channel to open before returning */
-		msleep(100);
-	}
-
-fail:
-	mutex_unlock(&dal_channel_list_lock);
-
-	return dch;
-}
-
-int dal_call_raw(struct dal_client *client,
-		 struct dal_hdr *hdr,
-		 void *data, int data_len,
-		 void *reply, int reply_max)
-{
-	struct dal_channel *dch = client->dch;
-	unsigned long flags;
-
-	client->reply = reply;
-	client->reply_max = reply_max;
-	client->msgid = hdr->msgid | DAL_MSGID_REPLY;
-	client->status = -EBUSY;
-
-#if DAL_TRACE
-	pr_info("dal send %p -> %p %02x:%04x:%02x %d\n",
-		hdr->from, hdr->to, hdr->msgid, hdr->ddi,
-		hdr->prototype, hdr->length - sizeof(*hdr));
-	print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, data, data_len);
-#endif
-
-	if (client->tr_log)
-		dal_trace_log(client, hdr, data, data_len);
-
-	spin_lock_irqsave(&dch->lock, flags);
-	/* FIXME: ensure entire message is written or none. */
-	smd_write(dch->sch, hdr, sizeof(*hdr));
-	smd_write(dch->sch, data, data_len);
-	spin_unlock_irqrestore(&dch->lock, flags);
-
-	if (!wait_event_timeout(client->wait, (client->status != -EBUSY), 5*HZ)) {
-		dal_trace_dump(client);
-		pr_err("dal: call timed out. dsp is probably dead.\n");
-		dal_trace_print(hdr, data, data_len, 0);
-		BUG();
-	}
-
-	return client->status;
-}
-
-int dal_call(struct dal_client *client,
-	     unsigned ddi, unsigned prototype,
-	     void *data, int data_len,
-	     void *reply, int reply_max)
-{
-	struct dal_hdr hdr;
-	int r;
-
-	memset(&hdr, 0, sizeof(hdr));
-
-	hdr.length = data_len + sizeof(hdr);
-	hdr.version = DAL_VERSION;
-	hdr.msgid = DAL_MSGID_DDI;
-	hdr.ddi = ddi;
-	hdr.prototype = prototype;
-	hdr.from = client;
-	hdr.to = client->remote;
-
-	if (hdr.length > DAL_MSG_MAX)
-		return -EINVAL;
-
-	mutex_lock(&client->write_lock);
-	r = dal_call_raw(client, &hdr, data, data_len, reply, reply_max);
-	mutex_unlock(&client->write_lock);
-#if 0
-	if ((r > 3) && (((uint32_t*) reply)[0] == 0)) {
-		pr_info("dal call OK\n");
-	} else {
-		pr_info("dal call ERROR\n");
-	}
-#endif
-	return r;
-}
-
-struct dal_msg_attach {
-	uint32_t device_id;
-	char attach[64];
-	char service_name[32];
-} __attribute__((packed));
-
-struct dal_reply_attach {
-	uint32_t status;
-	char name[64];
-};
-
-struct dal_client *dal_attach(uint32_t device_id, const char *name,
-			      dal_event_func_t func, void *cookie)
-{
-	struct dal_hdr hdr;
-	struct dal_msg_attach msg;
-	struct dal_reply_attach reply;
-	struct dal_channel *dch;
-	struct dal_client *client;
-	unsigned long flags;
-	int r;
-
-	dch = dal_open_channel(name);
-	if (!dch)
-		return 0;
-
-	client = kzalloc(sizeof(*client), GFP_KERNEL);
-	if (!client)
-		return 0;
-
-	client->dch = dch;
-	client->event = func;
-	client->cookie = cookie;
-	mutex_init(&client->write_lock);
-	spin_lock_init(&client->tr_lock);
-	init_waitqueue_head(&client->wait);
-
-	spin_lock_irqsave(&dch->lock, flags);
-	list_add(&client->list, &dch->clients);
-	spin_unlock_irqrestore(&dch->lock, flags);
-
-	memset(&hdr, 0, sizeof(hdr));
-	memset(&msg, 0, sizeof(msg));
-
-	hdr.length = sizeof(hdr) + sizeof(msg);
-	hdr.version = DAL_VERSION;
-	hdr.msgid = DAL_MSGID_ATTACH;
-	hdr.from = client;
-	msg.device_id = device_id;
-
-	r = dal_call_raw(client, &hdr, &msg, sizeof(msg),
-			 &reply, sizeof(reply));
-
-	if ((r == sizeof(reply)) && (reply.status == 0)) {
-		reply.name[63] = 0;
-		pr_info("dal_attach: status = %d, name = '%s'\n",
-			reply.status, reply.name);
-		return client;
-	}
-
-	pr_err("dal_attach: failure\n");
-
-	dal_detach(client);
-	return 0;
-}
-
-int dal_detach(struct dal_client *client)
-{
-	struct dal_channel *dch;
-	unsigned long flags;
-
-	mutex_lock(&client->write_lock);
-	if (client->remote) {
-		struct dal_hdr hdr;
-		uint32_t data;
-
-		memset(&hdr, 0, sizeof(hdr));
-		hdr.length = sizeof(hdr) + sizeof(data);
-		hdr.version = DAL_VERSION;
-		hdr.msgid = DAL_MSGID_DETACH;
-		hdr.from = client;
-		hdr.to = client->remote;
-		data = (uint32_t) client;
-
-		dal_call_raw(client, &hdr, &data, sizeof(data),
-			     &data, sizeof(data));
-	}
-
-	dch = client->dch;
-	spin_lock_irqsave(&dch->lock, flags);
-	if (dch->active == client) {
-		/* We have received a message header for this client
-		 * but not the body of the message.  Ensure that when
-		 * the body arrives we don't write it into the now-closed
-		 * client.  In *theory* this should never happen.
-		 */
-		dch->active = 0;
-		dch->ptr = dch->data;
-	}
-	list_del(&client->list);
-	spin_unlock_irqrestore(&dch->lock, flags);
-
-	mutex_unlock(&client->write_lock);
-
-	kfree(client);
-	return 0;
-}
-
-void *dal_get_remote_handle(struct dal_client *client)
-{
-	return client->remote;
-}
-
-/* convenience wrappers */
-
-int dal_call_f0(struct dal_client *client, uint32_t ddi, uint32_t arg1)
-{
-	uint32_t tmp = arg1;
-	int res;
-	res = dal_call(client, ddi, 0, &tmp, sizeof(tmp), &tmp, sizeof(tmp));
-	if (res >= 4)
-		return (int) tmp;
-	return res;
-}
-
-int dal_call_f1(struct dal_client *client, uint32_t ddi, uint32_t arg1, uint32_t arg2)
-{
-	uint32_t tmp[2];
-	int res;
-	tmp[0] = arg1;
-	tmp[1] = arg2;
-	res = dal_call(client, ddi, 1, tmp, sizeof(tmp), tmp, sizeof(uint32_t));
-	if (res >= 4)
-		return (int) tmp[0];
-	return res;
-}
-
-int dal_call_f5(struct dal_client *client, uint32_t ddi, void *ibuf, uint32_t ilen)
-{
-	uint32_t tmp[128];
-	int res;
-	int param_idx = 0;
-
-	if (ilen + 4 > DAL_DATA_MAX)
-		return -EINVAL;
-
-	tmp[param_idx] = ilen;
-	param_idx++;
-
-	memcpy(&tmp[param_idx], ibuf, ilen);
-	param_idx += DIV_ROUND_UP(ilen, 4);
-
-	res = dal_call(client, ddi, 5, tmp, param_idx * 4, tmp, sizeof(tmp));
-
-	if (res >= 4)
-		return (int) tmp[0];
-	return res;
-}
-
-int dal_call_f13(struct dal_client *client, uint32_t ddi, void *ibuf1,
-		 uint32_t ilen1, void *ibuf2, uint32_t ilen2, void *obuf,
-		 uint32_t olen)
-{
-	uint32_t tmp[128];
-	int res;
-	int param_idx = 0;
-
-	if (ilen1 + ilen2 + 8 > DAL_DATA_MAX)
-		return -EINVAL;
-
-	tmp[param_idx] = ilen1;
-	param_idx++;
-
-	memcpy(&tmp[param_idx], ibuf1, ilen1);
-	param_idx += DIV_ROUND_UP(ilen1, 4);
-
-	tmp[param_idx++] = ilen2;
-	memcpy(&tmp[param_idx], ibuf2, ilen2);
-	param_idx += DIV_ROUND_UP(ilen2, 4);
-
-	tmp[param_idx++] = olen;
-	res = dal_call(client, ddi, 13, tmp, param_idx * 4, tmp, sizeof(tmp));
-
-	if (res >= 4)
-		res = (int)tmp[0];
-
-	if (!res) {
-		if (tmp[1] > olen)
-			return -EIO;
-		memcpy(obuf, &tmp[2], tmp[1]);
-	}
-	return res;
-}
diff --git a/arch/arm/mach-msm/qdsp6/dal.h b/arch/arm/mach-msm/qdsp6/dal.h
deleted file mode 100644
index c02f5c7..0000000
--- a/arch/arm/mach-msm/qdsp6/dal.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* arch/arm/mach-msm/qdsp6/dal.h
- *
- * Copyright (C) 2009 Google, Inc.
- * Author: Brian Swetland <swetland@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef _MACH_MSM_DAL_
-#define _MACH_MSM_DAL_
-
-struct dal_client;
-
-typedef void (*dal_event_func_t)(void *data, int len, void *cookie);
-
-struct dal_client *dal_attach(uint32_t device_id, const char *name,
-			      dal_event_func_t func, void *cookie);
-
-int dal_detach(struct dal_client *client);
-
-int dal_call(struct dal_client *client,
-	     unsigned ddi, unsigned prototype,
-	     void *data, int data_len,
-	     void *reply, int reply_max);
-
-void dal_trace(struct dal_client *client);
-void dal_trace_dump(struct dal_client *client);
-
-/* function to call before panic on stalled dal calls */
-void dal_set_oops(struct dal_client *client, void (*oops)(void));
-
-/* convenience wrappers */
-int dal_call_f0(struct dal_client *client, uint32_t ddi,
-		uint32_t arg1);
-int dal_call_f1(struct dal_client *client, uint32_t ddi,
-		uint32_t arg1, uint32_t arg2);
-int dal_call_f5(struct dal_client *client, uint32_t ddi,
-		void *ibuf, uint32_t ilen);
-int dal_call_f13(struct dal_client *client, uint32_t ddi, void *ibuf1,
-		 uint32_t ilen1, void *ibuf2, uint32_t ilen2, void *obuf,
-		 uint32_t olen);
-
-/* common DAL operations */
-enum {
-	DAL_OP_ATTACH = 0,
-	DAL_OP_DETACH,
-	DAL_OP_INIT,
-	DAL_OP_DEINIT,
-	DAL_OP_OPEN,
-	DAL_OP_CLOSE,
-	DAL_OP_INFO,
-	DAL_OP_POWEREVENT,
-	DAL_OP_SYSREQUEST,
-	DAL_OP_FIRST_DEVICE_API,
-};
-
-#endif
diff --git a/arch/arm/mach-msm/qdsp6/dal_acdb.h b/arch/arm/mach-msm/qdsp6/dal_acdb.h
deleted file mode 100644
index 0e95b3b..0000000
--- a/arch/arm/mach-msm/qdsp6/dal_acdb.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#define ACDB_DAL_DEVICE		0x02000069
-#define ACDB_DAL_PORT		"SMD_DAL_AM_AUD"
-
-#define ACDB_OP_IOCTL		DAL_OP_FIRST_DEVICE_API
-
-/* ioctls */
-#define ACDB_GET_DEVICE		0x0108bb92
-#define ACDB_SET_DEVICE		0x0108bb93
-#define ACDB_GET_STREAM		0x0108bb95
-#define ACDB_SET_STREAM		0x0108bb96
-#define ACDB_GET_DEVICE_TABLE	0x0108bb97
-#define ACDB_GET_STREAM_TABLE	0x0108bb98
-
-#define ACDB_RES_SUCCESS	0
-#define ACDB_RES_FAILURE	-1
-#define ACDB_RES_BADPARM	-2
-#define ACDB_RES_BADSTATE	-3
-
-struct acdb_cmd_device {
-	uint32_t size;
-
-	uint32_t command_id;
-	uint32_t device_id;
-	uint32_t network_id;
-	uint32_t sample_rate_id;
-	uint32_t interface_id;
-	uint32_t algorithm_block_id;
-
-	/* physical page aligned buffer */
-	uint32_t total_bytes;
-	uint32_t unmapped_buf;
-} __attribute__((packed));
-
-struct acdb_cmd_device_table {
-	uint32_t size;
-
-	uint32_t command_id;
-	uint32_t device_id;
-	uint32_t network_id;
-	uint32_t sample_rate_id;
-
-	/* physical page aligned buffer */
-	uint32_t total_bytes;
-	uint32_t unmapped_buf;
-
-	uint32_t res_size;
-} __attribute__((packed));
-
-struct acdb_result {
-	uint32_t dal_status;
-	uint32_t size;
-
-	uint32_t unmapped_buf;
-	uint32_t used_bytes;
-	uint32_t result;
-} __attribute__((packed));
diff --git a/arch/arm/mach-msm/qdsp6/dal_adie.h b/arch/arm/mach-msm/qdsp6/dal_adie.h
deleted file mode 100644
index b7f5845..0000000
--- a/arch/arm/mach-msm/qdsp6/dal_adie.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef _MACH_MSM_QDSP6_ADIE_
-#define _MACH_MSM_QDSP6_ADIE_
-
-#include "dal.h"
-
-#define ADIE_DAL_DEVICE		0x02000029
-#define ADIE_DAL_PORT		"SMD_DAL_AM_AUD"
-
-enum {
-	ADIE_OP_GET_NUM_PATHS = DAL_OP_FIRST_DEVICE_API,
-	ADIE_OP_GET_ALL_PATH_IDS,
-	ADIE_OP_SET_PATH,
-	ADIE_OP_GET_NUM_PATH_FREQUENCY_PLANS,
-	ADIE_OP_GET_PATH_FREQUENCY_PLANS,
-	ADIE_OP_SET_PATH_FREQUENCY_PLAN,
-	ADIE_OP_PROCEED_TO_STAGE,
-	ADIE_OP_MUTE_PATH
-};
-
-/* Path IDs for normal operation. */
-#define ADIE_PATH_HANDSET_TX			0x010740f6
-#define ADIE_PATH_HANDSET_RX			0x010740f7
-#define ADIE_PATH_HEADSET_MONO_TX		0x010740f8
-#define ADIE_PATH_HEADSET_STEREO_TX		0x010740f9
-#define ADIE_PATH_HEADSET_MONO_RX		0x010740fa
-#define ADIE_PATH_HEADSET_STEREO_RX		0x010740fb
-#define ADIE_PATH_SPEAKER_TX			0x010740fc
-#define ADIE_PATH_SPEAKER_RX			0x010740fd
-#define ADIE_PATH_SPEAKER_STEREO_RX		0x01074101
-
-/* Path IDs used for TTY */
-#define ADIE_PATH_TTY_HEADSET_TX		0x010740fe
-#define ADIE_PATH_TTY_HEADSET_RX		0x010740ff
-
-/* Path IDs used by Factory Test Mode. */
-#define ADIE_PATH_FTM_MIC1_TX			0x01074108
-#define ADIE_PATH_FTM_MIC2_TX			0x01074107
-#define ADIE_PATH_FTM_HPH_L_RX			0x01074106
-#define ADIE_PATH_FTM_HPH_R_RX			0x01074104
-#define ADIE_PATH_FTM_EAR_RX			0x01074103
-#define ADIE_PATH_FTM_SPKR_RX			0x01074102
-
-/* Path IDs for Loopback */
-/* Path IDs used for Line in -> AuxPGA -> Line Out Stereo Mode*/
-#define ADIE_PATH_AUXPGA_LINEOUT_STEREO_LB	0x01074100
-/* Line in -> AuxPGA -> LineOut Mono */
-#define ADIE_PATH_AUXPGA_LINEOUT_MONO_LB	0x01073d82
-/* Line in -> AuxPGA -> Stereo Headphone */
-#define ADIE_PATH_AUXPGA_HDPH_STEREO_LB		0x01074109
-/* Line in -> AuxPGA -> Mono Headphone */
-#define ADIE_PATH_AUXPGA_HDPH_MONO_LB		0x01073d85
-/* Line in -> AuxPGA -> Earpiece */
-#define ADIE_PATH_AUXPGA_EAP_LB			0x01073d81
-/* Line in -> AuxPGA -> AuxOut */
-#define ADIE_PATH_AUXPGA_AUXOUT_LB		0x01073d86
-
-/* Concurrency Profiles */
-#define ADIE_PATH_SPKR_STEREO_HDPH_MONO_RX	0x01073d83
-#define ADIE_PATH_SPKR_MONO_HDPH_MONO_RX	0x01073d84
-#define ADIE_PATH_SPKR_MONO_HDPH_STEREO_RX	0x01073d88
-#define ADIE_PATH_SPKR_STEREO_HDPH_STEREO_RX	0x01073d89
-
-/* stages */
-#define ADIE_STAGE_PATH_OFF			0x0050
-#define ADIE_STAGE_DIGITAL_READY		0x0100
-#define ADIE_STAGE_DIGITAL_ANALOG_READY		0x1000
-#define ADIE_STAGE_ANALOG_OFF			0x0750
-#define ADIE_STAGE_DIGITAL_OFF			0x0600
-
-/* path types */
-#define ADIE_PATH_RX		0
-#define ADIE_PATH_TX		1
-#define ADIE_PATH_LOOPBACK	2
-
-/* mute states */
-#define ADIE_MUTE_OFF		0
-#define ADIE_MUTE_ON		1
-
-
-#endif
diff --git a/arch/arm/mach-msm/qdsp6/dal_audio.h b/arch/arm/mach-msm/qdsp6/dal_audio.h
deleted file mode 100644
index b185ed1..0000000
--- a/arch/arm/mach-msm/qdsp6/dal_audio.h
+++ /dev/null
@@ -1,606 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef __DAL_AUDIO_H__
-#define __DAL_AUDIO_H__
-
-#include "dal_audio_format.h"
-#include "dal.h"
-#include <mach/msm_qdsp6_audio.h>
-
-#define AUDIO_DAL_DEVICE 0x02000028
-#define AUDIO_DAL_PORT "DSP_DAL_AQ_AUD"
-
-enum {
-	AUDIO_OP_CONTROL = DAL_OP_FIRST_DEVICE_API,
-	AUDIO_OP_DATA,
-	AUDIO_OP_INIT,
-};	
-
-/* ---- common audio structures ---- */
-
-/* This flag, if set, indicates that the beginning of the data in the*/
-/* buffer is a synchronization point or key frame, meaning no data */
-/* before it in the stream is required in order to render the stream */
-/* from this point onward. */
-#define ADSP_AUDIO_BUFFER_FLAG_SYNC_POINT        0x01
-
-/* This flag, if set, indicates that the buffer object is using valid */
-/* physical address used to store the media data */
-#define ADSP_AUDIO_BUFFER_FLAG_PHYS_ADDR         0x04
-
-/* This flag, if set, indicates that a media start timestamp has been */
-/* set for a buffer. */
-#define ADSP_AUDIO_BUFFER_FLAG_START_SET         0x08
-
-/* This flag, if set, indicates that a media stop timestamp has been set */
-/* for a buffer. */
-#define ADSP_AUDIO_BUFFER_FLAG_STOP_SET          0x10
-
-/* This flag, if set, indicates that a preroll timestamp has been set */
-/* for a buffer. */
-#define ADSP_AUDIO_BUFFER_FLAG_PREROLL_SET       0x20
-
-/* This flag, if set, indicates that the data in the buffer is a fragment of */
-/* a larger block of data, and will be continued by the data in the next */
-/* buffer to be delivered. */
-#define ADSP_AUDIO_BUFFER_FLAG_CONTINUATION      0x40
-
-struct adsp_audio_buffer {
-	u32 addr;		/* Physical Address of buffer */
-	u32 max_size;		/* Maximum size of buffer */
-	u32 actual_size;	/* Actual size of valid data in the buffer */
-	u32 offset;		/* Offset to the first valid byte */
-	u32 flags;		/* ADSP_AUDIO_BUFFER_FLAGs that has been set */
-	s64 start;		/* Start timestamp, if any */
-	s64 stop;		/* Stop timestamp, if any */
-	s64 preroll;		/* Preroll timestamp, if any */
-} __attribute__ ((packed));
-
-
-
-/* ---- audio commands ---- */
-
-/* Command/event response types */
-#define ADSP_AUDIO_RESPONSE_COMMAND   0
-#define ADSP_AUDIO_RESPONSE_ASYNC     1
-
-struct adsp_command_hdr {
-	u32 size;		/* sizeof(cmd) - sizeof(u32) */
-
-	u32 dst;
-	u32 src;
-
-	u32 opcode;
-	u32 response_type;
-	u32 seq_number;
-
-	u32 context;		/* opaque to DSP */
-	u32 data;
-
-	u32 padding;
-} __attribute__ ((packed));
-
-
-#define AUDIO_DOMAIN_APP	0
-#define AUDIO_DOMAIN_MODEM	1
-#define AUDIO_DOMAIN_DSP	2
-
-#define AUDIO_SERVICE_AUDIO	0
-#define AUDIO_SERVICE_VIDEO	1 /* really? */
-
-/* adsp audio addresses are (byte order) domain, service, major, minor */
-//#define AUDIO_ADDR(maj,min) ( (((maj) & 0xff) << 16) | (((min) & 0xff) << 24) | (1) )
-
-#define AUDIO_ADDR(maj,min,dom) ( (((min) & 0xff) << 24) | (((maj) & 0xff) << 16) | ((AUDIO_SERVICE_AUDIO) << 8) | (dom) )
-
-
-/* AAC Encoder modes */
-#define ADSP_AUDIO_ENC_AAC_LC_ONLY_MODE		0
-#define ADSP_AUDIO_ENC_AAC_PLUS_MODE		1
-#define ADSP_AUDIO_ENC_ENHANCED_AAC_PLUS_MODE	2
-
-struct adsp_audio_aac_enc_cfg {
-	u32 bit_rate;		/* bits per second */
-	u32 encoder_mode;	/* ADSP_AUDIO_ENC_* */
-} __attribute__ ((packed));
-
-#define ADSP_AUDIO_ENC_SBC_ALLOCATION_METHOD_LOUNDNESS     0
-#define ADSP_AUDIO_ENC_SBC_ALLOCATION_METHOD_SNR           1
-
-#define ADSP_AUDIO_ENC_SBC_CHANNEL_MODE_MONO                1
-#define ADSP_AUDIO_ENC_SBC_CHANNEL_MODE_STEREO              2
-#define ADSP_AUDIO_ENC_SBC_CHANNEL_MODE_DUAL                8
-#define ADSP_AUDIO_ENC_SBC_CHANNEL_MODE_JOINT_STEREO        9
-
-struct adsp_audio_sbc_encoder_cfg {
-	u32 num_subbands;
-	u32 block_len;
-	u32 channel_mode;
-	u32 allocation_method;
-	u32 bit_rate;
-} __attribute__ ((packed));
-
-/* AMR NB encoder modes */
-#define ADSP_AUDIO_AMR_MR475	0
-#define ADSP_AUDIO_AMR_MR515	1
-#define ADSP_AUDIO_AMR_MMR59	2
-#define ADSP_AUDIO_AMR_MMR67	3
-#define ADSP_AUDIO_AMR_MMR74	4
-#define ADSP_AUDIO_AMR_MMR795	5
-#define ADSP_AUDIO_AMR_MMR102	6
-#define ADSP_AUDIO_AMR_MMR122	7
-
-/* The following are valid AMR NB DTX modes */
-#define ADSP_AUDIO_AMR_DTX_MODE_OFF		0
-#define ADSP_AUDIO_AMR_DTX_MODE_ON_VAD1		1
-#define ADSP_AUDIO_AMR_DTX_MODE_ON_VAD2		2
-#define ADSP_AUDIO_AMR_DTX_MODE_ON_AUTO		3
-
-/* AMR Encoder configuration */
-struct adsp_audio_amr_enc_cfg {
-	u32	mode;		/* ADSP_AUDIO_AMR_MR* */
-	u32	dtx_mode;	/* ADSP_AUDIO_AMR_DTX_MODE* */
-	u32	enable;		/* 1 = enable, 0 = disable */
-} __attribute__ ((packed));
-
-struct adsp_audio_qcelp13k_enc_cfg {
-	u16	min_rate;
-	u16	max_rate;
-} __attribute__ ((packed));
-
-struct adsp_audio_evrc_enc_cfg {
-	u16	min_rate;
-	u16	max_rate;
-} __attribute__ ((packed));
-
-union adsp_audio_codec_config {
-	struct adsp_audio_amr_enc_cfg amr;
-	struct adsp_audio_aac_enc_cfg aac;
-	struct adsp_audio_qcelp13k_enc_cfg qcelp13k;
-	struct adsp_audio_evrc_enc_cfg evrc;
-	struct adsp_audio_sbc_encoder_cfg sbc;
-} __attribute__ ((packed));
-
-
-/* This is the default value. */
-#define ADSP_AUDIO_OPEN_STREAM_MODE_NONE		0x0000
-
-/* This bit, if set, indicates that the AVSync mode is activated. */
-#define ADSP_AUDIO_OPEN_STREAM_MODE_AVSYNC		0x0001
-
-/* This bit, if set, indicates that the Sample Rate/Channel Mode */
-/* Change Notification mode is activated. */
-#define ADSP_AUDIO_OPEN_STREAM_MODE_SR_CM_NOTIFY	0x0002
-
-/* This bit, if set, indicates that the sync clock is enabled */
-#define  ADSP_AUDIO_OPEN_STREAM_MODE_ENABLE_SYNC_CLOCK	0x0004
-
-struct adsp_open_command {
-	struct adsp_command_hdr hdr;
-
-	u32 device;
-	u32 endpoint; /* address */
-
-	u32 stream_context;
-	u32 mode;
-
-	u32 buf_max_size;
-
-	union adsp_audio_format format;
-	union adsp_audio_codec_config config;
-} __attribute__ ((packed));
-
-
-/* --- audio control and stream session ioctls ---- */
-
-/* Opcode to open a device stream session to capture audio */
-#define ADSP_AUDIO_IOCTL_CMD_OPEN_READ			0x0108dd79
-
-/* Opcode to open a device stream session to render audio */
-#define ADSP_AUDIO_IOCTL_CMD_OPEN_WRITE			0x0108dd7a
-
-/* Opcode to open a device session, must open a device */
-#define ADSP_AUDIO_IOCTL_CMD_OPEN_DEVICE		0x0108dd7b
-
-/* Close an existing stream or device */
-#define ADSP_AUDIO_IOCTL_CMD_CLOSE			0x0108d8bc
-
-
-
-/* A device switch requires three IOCTL */
-/* commands in the following sequence: PREPARE, STANDBY, COMMIT */
-
-/* adsp_audio_device_switch_command structure is needed for */
-/* DEVICE_SWITCH_PREPARE */
-
-/* Device switch protocol step #1. Pause old device and */
-/* generate silence for the old device. */
-#define ADSP_AUDIO_IOCTL_CMD_DEVICE_SWITCH_PREPARE	0x010815c4
-
-/* Device switch protocol step #2. Release old device, */
-/* create new device and generate silence for the new device. */
-
-/* When client receives ack for this IOCTL, the client can */
-/* start sending IOCTL commands to configure, calibrate and */
-/* change filter settings on the new device. */
-#define ADSP_AUDIO_IOCTL_CMD_DEVICE_SWITCH_STANDBY	0x010815c5
-
-/* Device switch protocol step #3. Start normal operations on new device */
-#define ADSP_AUDIO_IOCTL_CMD_DEVICE_SWITCH_COMMIT	0x01075ee7
-
-struct adsp_device_switch_command {
-	struct adsp_command_hdr hdr;
-	u32 old_device;
-	u32 new_device;
-	u8 device_class; /* 0 = i.rx, 1 = i.tx, 2 = e.rx, 3 = e.tx */
-	u8 device_type; /* 0 = rx, 1 = tx, 2 = both */
-} __attribute__ ((packed));
-
-
-
-/* --- audio control session ioctls ---- */
-
-#define ADSP_PATH_RX	0
-#define ADSP_PATH_TX	1
-#define ADSP_PATH_BOTH	2
-
-/* These commands will affect a logical device and all its associated */
-/* streams. */
-
-
-/* Set device volume. */
-#define ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_VOL		0x0107605c
-
-struct adsp_set_dev_volume_command {
-	struct adsp_command_hdr hdr;
-	u32 device_id;
-	u32 path; /* 0 = rx, 1 = tx, 2 = both */
-	s32 volume;
-} __attribute__ ((packed));
-
-/* Set Device stereo volume. This command has data payload, */
-/* struct adsp_audio_set_dev_stereo_volume_command. */
-#define ADSP_AUDIO_IOCTL_SET_DEVICE_STEREO_VOL		0x0108df3e
-
-/* Set L, R cross channel gain for a Device. This command has */
-/* data payload, struct adsp_audio_set_dev_x_chan_gain_command. */
-#define ADSP_AUDIO_IOCTL_SET_DEVICE_XCHAN_GAIN		0x0108df40
-
-/* Set device mute state. */
-#define ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_MUTE		0x0107605f
-
-struct adsp_set_dev_mute_command {
-	struct adsp_command_hdr hdr;
-	u32 device_id;
-	u32 path; /* 0 = rx, 1 = tx, 2 = both */
-	u32 mute; /* 1 = mute */
-} __attribute__ ((packed));
-
-/* Configure Equalizer for a device. */
-/* This command has payload struct adsp_audio_set_dev_equalizer_command. */
-#define ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_EQ_CONFIG	0x0108b10e
-
-/* Set configuration data for an algorithm aspect of a device. */
-/* This command has payload struct adsp_audio_set_dev_cfg_command. */
-#define ADSP_AUDIO_IOCTL_SET_DEVICE_CONFIG		0x0108b6cb
-
-struct adsp_set_dev_cfg_command {
-	struct adsp_command_hdr hdr;
-	u32 device_id;
-	u32 block_id;
-	u32 interface_id;
-	u32 phys_addr;
-	u32 phys_size;
-	u32 phys_used;
-} __attribute__ ((packed));
-
-/* Set configuration data for all interfaces of a device. */
-#define ADSP_AUDIO_IOCTL_SET_DEVICE_CONFIG_TABLE	0x0108b6bf
-
-struct adsp_set_dev_cfg_table_command {
-	struct adsp_command_hdr hdr;
-	u32 device_id;
-	u32 phys_addr;
-	u32 phys_size;
-	u32 phys_used;
-} __attribute__ ((packed));
-
-/* ---- audio stream data commands ---- */
-
-#define ADSP_AUDIO_IOCTL_CMD_DATA_TX			0x0108dd7f
-#define ADSP_AUDIO_IOCTL_CMD_DATA_RX			0x0108dd80
-
-struct adsp_buffer_command {
-	struct adsp_command_hdr hdr;
-	struct adsp_audio_buffer buffer;
-} __attribute__ ((packed));
-
-
-
-/* ---- audio stream ioctls (only affect a single stream in a session) ---- */
-
-/* Stop stream for audio device. */
-#define ADSP_AUDIO_IOCTL_CMD_STREAM_STOP		0x01075c54
-
-/* End of stream reached. Client will not send any more data. */
-#define ADSP_AUDIO_IOCTL_CMD_STREAM_EOS			0x0108b150
-
-/* Do sample slipping/stuffing on AAC outputs. The payload of */
-/* this command is struct adsp_audio_slip_sample_command. */
-#define ADSP_AUDIO_IOCTL_CMD_STREAM_SLIPSAMPLE		0x0108d40e
-
-/* Set stream volume. */
-/* This command has data payload, struct adsp_audio_set_volume_command. */
-#define ADSP_AUDIO_IOCTL_CMD_SET_STREAM_VOL		0x0108c0de
-
-/* Set stream stereo volume. This command has data payload, */
-/* struct adsp_audio_set_stereo_volume_command. */
-#define ADSP_AUDIO_IOCTL_SET_STREAM_STEREO_VOL		0x0108dd7c
-
-/* Set L, R cross channel gain for a Stream. This command has */
-/* data payload, struct adsp_audio_set_x_chan_gain_command. */
-#define ADSP_AUDIO_IOCTL_SET_STREAM_XCHAN_GAIN		0x0108dd7d
-
-/* Set stream mute state. */
-/* This command has data payload, struct adsp_audio_set_stream_mute. */
-#define ADSP_AUDIO_IOCTL_CMD_SET_STREAM_MUTE		0x0108c0df
-
-/* Reconfigure bit rate information. This command has data */
-/* payload, struct adsp_audio_set_bit_rate_command */
-#define ADSP_AUDIO_IOCTL_SET_STREAM_BITRATE		0x0108ccf1
-
-/* Set Channel Mapping. This command has data payload, struct */
-/* This command has data payload struct adsp_audio_set_channel_map_command. */
-#define ADSP_AUDIO_IOCTL_SET_STREAM_CHANNELMAP		0x0108d32a
-
-/* Enable/disable AACPlus SBR. */
-/* This command has data payload struct adsp_audio_set_sbr_command */
-#define ADSP_AUDIO_IOCTL_SET_STREAM_SBR			0x0108d416
-
-/* Enable/disable WMA Pro Chex and Fex. This command has data payload */
-/* struct adsp_audio_stream_set_wma_command. */
-#define ADSP_AUDIO_IOCTL_SET_STREAM_WMAPRO		0x0108d417
-
-
-/* ---- audio session ioctls (affect all streams in a session) --- */
-
-/* Start stream for audio device. */
-#define ADSP_AUDIO_IOCTL_CMD_SESSION_START		0x010815c6
-
-/* Stop all stream(s) for audio session as indicated by major id. */
-#define ADSP_AUDIO_IOCTL_CMD_SESSION_STOP		0x0108dd7e
-
-/* Pause the data flow for a session as indicated by major id. */
-#define ADSP_AUDIO_IOCTL_CMD_SESSION_PAUSE		0x01075ee8
-
-/* Resume the data flow for a session as indicated by major id. */
-#define ADSP_AUDIO_IOCTL_CMD_SESSION_RESUME		0x01075ee9
-
-/* Drop any unprocessed data buffers for a session as indicated by major id. */
-#define ADSP_AUDIO_IOCTL_CMD_SESSION_FLUSH		0x01075eea
-
-/* Start Stream DTMF tone */
-#define ADSP_AUDIO_IOCTL_CMD_SESSION_DTMF_START		0x0108c0dd
-
-/* Stop Stream DTMF tone */
-#define ADSP_AUDIO_IOCTL_CMD_SESSION_DTMF_STOP		0x01087554
-
-/* Set Session volume. */
-/* This command has data payload, struct adsp_audio_set_volume_command. */
-#define ADSP_AUDIO_IOCTL_SET_SESSION_VOL		0x0108d8bd
-
-/* Set session stereo volume. This command has data payload, */
-/* struct adsp_audio_set_stereo_volume_command. */
-#define ADSP_AUDIO_IOCTL_SET_SESSION_STEREO_VOL		0x0108df3d
-
-/* Set L, R cross channel gain for a session. This command has */
-/* data payload, struct adsp_audio_set_x_chan_gain_command. */
-#define ADSP_AUDIO_IOCTL_SET_SESSION_XCHAN_GAIN		0x0108df3f
-
-/* Set Session mute state. */
-/* This command has data payload, struct adsp_audio_set_mute_command. */
-#define ADSP_AUDIO_IOCTL_SET_SESSION_MUTE		0x0108d8be
-
-/* Configure Equalizer for a stream. */
-/* This command has payload struct adsp_audio_set_equalizer_command. */
-#define ADSP_AUDIO_IOCTL_SET_SESSION_EQ_CONFIG		0x0108c0e0
-
-#define ADSP_AUDIO_MAX_EQ_BANDS		12
-
-/* Definition for any one band of Equalizer. */
-struct adsp_audio_eq_band {
-	u16	band_idx;
-	u32	filter_type;
-	u32	center_freq_hz;
-	s32	filter_gain;
-	s32	q_factor;
-} __attribute__ ((packed));
-
-struct adsp_audio_set_equalizer_command {
-	struct adsp_command_hdr hdr;
-	u32	enable;
-	u32	num_bands;
-	struct adsp_audio_eq_band eq_bands[ADSP_AUDIO_MAX_EQ_BANDS];
-} __attribute__ ((packed));
-
-
-/* Set Audio Video sync information. */
-/* This command has data payload, struct adsp_audio_set_av_sync_command. */
-#define ADSP_AUDIO_IOCTL_SET_SESSION_AVSYNC		0x0108d1e2
-
-/* Get Audio Media Session time. */
-/* This command returns the audioTime in adsp_audio_unsigned64_event */
-#define ADSP_AUDIO_IOCTL_CMD_GET_AUDIO_TIME		0x0108c26c
-
-
-/* these command structures are used for both STREAM and SESSION ioctls */
-
-struct adsp_set_volume_command {
-	struct adsp_command_hdr hdr;
-	s32 volume;
-} __attribute__ ((packed));
-	
-struct adsp_set_mute_command {
-	struct adsp_command_hdr hdr;
-	u32 mute; /* 1 == mute */
-} __attribute__ ((packed));
-
-
-
-/* ---- audio events ---- */
-
-/* All IOCTL commands generate an event with the IOCTL opcode as the */
-/* event id after the IOCTL command has been executed. */
-
-/* This event is generated after a media stream session is opened. */
-#define ADSP_AUDIO_EVT_STATUS_OPEN				0x0108c0d6
-
-/* This event is generated after a media stream  session is closed. */
-#define ADSP_AUDIO_EVT_STATUS_CLOSE				0x0108c0d7
-
-/* Asyncronous buffer consumption. This event is generated after a */
-/* recived  buffer is consumed during rendering or filled during */
-/* capture opeartion. */
-#define ADSP_AUDIO_EVT_STATUS_BUF_DONE				0x0108c0d8
-
-/* This event is generated when rendering operation is starving for */
-/* data. In order to avoid audio loss at the end of a plauback, the */
-/* client should wait for this event before issuing the close command. */
-#define ADSP_AUDIO_EVT_STATUS_BUF_UNDERRUN			0x0108c0d9
-
-/* This event is generated during capture operation when there are no */
-/* buffers available to copy the captured audio data */
-#define ADSP_AUDIO_EVT_STATUS_BUF_OVERFLOW			0x0108c0da
-
-/* This asynchronous event is generated as a result of an input */
-/* sample rate change and/or channel mode change detected by the */
-/* decoder. The event payload data is an array of 2 uint32 */
-/* values containing the sample rate in Hz and channel mode. */
-#define ADSP_AUDIO_EVT_SR_CM_CHANGE				0x0108d329
-
-struct adsp_event_hdr {
-	u32 evt_handle;		/* DAL common header */
-	u32 evt_cookie;
-	u32 evt_length;
-
-	u32 src;		/* "source" audio address */
-	u32 dst;		/* "destination" audio address */
-
-	u32 event_id;
-	u32 response_type;
-	u32 seq_number;
-
-	u32 context;		/* opaque to DSP */
-	u32 data;
-
-	u32 status;
-} __attribute__ ((packed));
-
-struct adsp_buffer_event {
-	struct adsp_event_hdr hdr;
-	struct adsp_audio_buffer buffer;
-} __attribute__ ((packed));
-
-
-/* ---- audio device IDs ---- */
-
-/* Device direction Rx/Tx flag */
-#define ADSP_AUDIO_RX_DEVICE		0x00
-#define ADSP_AUDIO_TX_DEVICE		0x01
-
-/* Default RX or TX device */
-#define ADSP_AUDIO_DEVICE_ID_DEFAULT		0x1081679
-
-/* Source (TX) devices */
-#define ADSP_AUDIO_DEVICE_ID_HANDSET_MIC	0x107ac8d
-#define ADSP_AUDIO_DEVICE_ID_HEADSET_MIC	0x1081510
-#define ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MIC	0x1081512
-#define ADSP_AUDIO_DEVICE_ID_BT_SCO_MIC		0x1081518
-#define ADSP_AUDIO_DEVICE_ID_TTY_HEADSET_MIC	0x108151b
-#define ADSP_AUDIO_DEVICE_ID_I2S_MIC		0x1089bf3
-
-/* Special loopback pseudo device to be paired with an RX device */
-/* with usage ADSP_AUDIO_DEVICE_USAGE_MIXED_PCM_LOOPBACK */
-#define ADSP_AUDIO_DEVICE_ID_MIXED_PCM_LOOPBACK_TX	0x1089bf2
-
-/* Sink (RX) devices */
-#define ADSP_AUDIO_DEVICE_ID_HANDSET_SPKR			0x107ac88
-#define ADSP_AUDIO_DEVICE_ID_HEADSET_SPKR_MONO			0x1081511
-#define ADSP_AUDIO_DEVICE_ID_HEADSET_SPKR_STEREO		0x107ac8a
-#define ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO			0x1081513
-#define ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO_W_MONO_HEADSET     0x108c508
-#define ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO_W_STEREO_HEADSET   0x108c894
-#define ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO			0x1081514
-#define ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO_W_MONO_HEADSET   0x108c895
-#define ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO_W_STEREO_HEADSET	0x108c509
-#define ADSP_AUDIO_DEVICE_ID_BT_SCO_SPKR			0x1081519
-#define ADSP_AUDIO_DEVICE_ID_TTY_HEADSET_SPKR			0x108151c
-#define ADSP_AUDIO_DEVICE_ID_I2S_SPKR				0x1089bf4
-#define ADSP_AUDIO_DEVICE_ID_NULL_SINK				0x108e512
-
-/* BT A2DP playback device. */
-/* This device must be paired with */
-/* ADSP_AUDIO_DEVICE_ID_MIXED_PCM_LOOPBACK_TX using  */
-/* ADSP_AUDIO_DEVICE_USAGE_MIXED_PCM_LOOPBACK mode */
-#define ADSP_AUDIO_DEVICE_ID_BT_A2DP_SPKR	0x108151a
-
-/* Voice Destination identifier - specifically used for */
-/* controlling Voice module from the Device Control Session */
-#define ADSP_AUDIO_DEVICE_ID_VOICE		0x0108df3c
-
-/*  Audio device usage types. */
-/*  This is a bit mask to determine which topology to use in the */
-/* device session */
-#define ADSP_AUDIO_DEVICE_CONTEXT_VOICE			0x01
-#define ADSP_AUDIO_DEVICE_CONTEXT_PLAYBACK		0x02
-#define ADSP_AUDIO_DEVICE_CONTEXT_MIXED_RECORD		0x10
-#define ADSP_AUDIO_DEVICE_CONTEXT_RECORD		0x20
-#define ADSP_AUDIO_DEVICE_CONTEXT_PCM_LOOPBACK		0x40
-
-/* for EQ */
-#define CAD_EQ_INVALID_DATA        0xFFFFFFFF
-
-/* Equalizer filter band types */
-#define ADSP_AUDIO_EQUALIZER_TYPE_NONE		0
-#define ADSP_AUDIO_EQUALIZER_BASS_BOOST		1
-#define ADSP_AUDIO_EQUALIZER_BASS_CUT		2
-#define ADSP_AUDIO_EQUALIZER_TREBLE_BOOST	3
-#define ADSP_AUDIO_EQUALIZER_TREBLE_CUT		4
-#define ADSP_AUDIO_EQUALIZER_BAND_BOOST		5
-#define ADSP_AUDIO_EQUALIZER_BAND_CUT		6
-
-struct cad_audio_eq_cfg {
-	u32 enable;
-	u32 num_bands;
-	struct adsp_audio_eq_band eq_bands[ADSP_AUDIO_MAX_EQ_BANDS];
-} __attribute__ ((packed));
-
-int q6audio_set_stream_eq(struct audio_client *ac, struct cad_audio_eq_cfg *eq_cfg);
-
-#endif
diff --git a/arch/arm/mach-msm/qdsp6/dal_audio_format.h b/arch/arm/mach-msm/qdsp6/dal_audio_format.h
deleted file mode 100644
index cdb2e1a..0000000
--- a/arch/arm/mach-msm/qdsp6/dal_audio_format.h
+++ /dev/null
@@ -1,285 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef __ADSP_AUDIO_MEDIA_FORMAT_H
-#define __ADSP_AUDIO_MEDIA_FORMAT_H
-
-
-
-/* Supported audio media formats */
-
-/* format block in shmem */
-#define ADSP_AUDIO_FORMAT_SHAREDMEMORY	0x01091a78
-/* adsp_audio_format_raw_pcm type */
-#define ADSP_AUDIO_FORMAT_PCM		0x0103d2fd
-/* adsp_audio_format_raw_pcm type */
-#define ADSP_AUDIO_FORMAT_DTMF		0x01087725
-/* adsp_audio_format_adpcm type */
-#define ADSP_AUDIO_FORMAT_ADPCM		0x0103d2ff
-/* Yamaha PCM format */
-#define ADSP_AUDIO_FORMAT_YADPCM	0x0108dc07
-/* ISO/IEC 11172 */
-#define ADSP_AUDIO_FORMAT_MP3		0x0103d308
-/* ISO/IEC 14496 */
-#define ADSP_AUDIO_FORMAT_MPEG4_AAC	0x010422f1
-/* AMR-NB audio in FS format */
-#define ADSP_AUDIO_FORMAT_AMRNB_FS	0x0105c16c
-/* AMR-WB audio in FS format */
-#define ADSP_AUDIO_FORMAT_AMRWB_FS	0x0105c16e
-/* QCELP 13k, IS733 */
-#define ADSP_AUDIO_FORMAT_V13K_FS	0x01080b8a
-/* EVRC   8k, IS127 */
-#define ADSP_AUDIO_FORMAT_EVRC_FS	0x01080b89
-/* EVRC-B   8k, 4GV */
-#define ADSP_AUDIO_FORMAT_EVRCB_FS	0x0108f2a3
-/* MIDI command stream */
-#define ADSP_AUDIO_FORMAT_MIDI		0x0103d300
-/* A2DP SBC stream */
-#define ADSP_AUDIO_FORMAT_SBC		0x0108c4d8
-/* Version 10 Professional */
-#define ADSP_AUDIO_FORMAT_WMA_V10PRO	0x0108aa92
-/* Version 9 Starndard */
-#define ADSP_AUDIO_FORMAT_WMA_V9	0x0108d430
-/* AMR WideBand Plus */
-#define ADSP_AUDIO_FORMAT_AMR_WB_PLUS	0x0108f3da
-/* AC3 Decoder */
-#define ADSP_AUDIO_FORMAT_AC3_DECODER	0x0108d5f9
-
-
-/* Not yet supported audio media formats */
-
-
-
-/* ISO/IEC 13818 */
-#define ADSP_AUDIO_FORMAT_MPEG2_AAC	0x0103d309
-/* 3GPP TS 26.101 Sec 4.0 */
-#define ADSP_AUDIO_FORMAT_AMRNB_IF1	0x0103d305
-/* 3GPP TS 26.101 Annex A */
-#define ADSP_AUDIO_FORMAT_AMRNB_IF2	0x01057b31
-/* 3GPP TS 26.201 */
-#define ADSP_AUDIO_FORMAT_AMRWB_IF1	0x0103d306
-/* 3GPP TS 26.201 */
-#define ADSP_AUDIO_FORMAT_AMRWB_IF2	0x0105c16d
-/* G.711 */
-#define ADSP_AUDIO_FORMAT_G711		0x0106201d
-/* QCELP  8k, IS96A */
-#define ADSP_AUDIO_FORMAT_V8K_FS	0x01081d29
-/* Version 1 codec */
-#define ADSP_AUDIO_FORMAT_WMA_V1	0x01055b2b
-/* Version 2, 7 & 8 codec */
-#define ADSP_AUDIO_FORMAT_WMA_V8	0x01055b2c
-/* Version 9 Professional codec */
-#define ADSP_AUDIO_FORMAT_WMA_V9PRO	0x01055b2d
-/* Version 9 Voice codec */
-#define ADSP_AUDIO_FORMAT_WMA_SP1	0x01055b2e
-/* Version 9 Lossless codec */
-#define ADSP_AUDIO_FORMAT_WMA_LOSSLESS	0x01055b2f
-/* Real Media content, low-bitrate */
-#define ADSP_AUDIO_FORMAT_RA_SIPR	0x01042a0f
-/* Real Media content */
-#define ADSP_AUDIO_FORMAT_RA_COOK	0x01042a0e
-
-
-/* For all of the audio formats, unless specified otherwise, */
-/* the following apply: */
-/* Format block bits are arranged in bytes and words in little-endian */
-/* order, i.e., least-significant bit first and least-significant */
-/* byte first. */
-
-
-
-/* AAC Format Block. */
-
-/* AAC format block consist of a format identifier followed by */
-/* AudioSpecificConfig formatted according to ISO/IEC 14496-3 */
-
-/* The following AAC format identifiers are supported */
-#define ADSP_AUDIO_AAC_ADTS		0x010619cf
-#define ADSP_AUDIO_AAC_MPEG4_ADTS	0x010619d0
-#define ADSP_AUDIO_AAC_LOAS		0x010619d1
-#define ADSP_AUDIO_AAC_ADIF		0x010619d2
-#define ADSP_AUDIO_AAC_RAW		0x010619d3
-#define ADSP_AUDIO_AAC_FRAMED_RAW	0x0108c1fb
-
-
-#define ADSP_AUDIO_COMPANDING_ALAW	0x10619cd
-#define ADSP_AUDIO_COMPANDING_MLAW	0x10619ce
-
-/* Maxmum number of bytes allowed in a format block */
-#define ADSP_AUDIO_FORMAT_DATA_MAX 16
-
-
-struct adsp_audio_no_payload_format {
-	/* Media Format Code (must always be first element) */
-	u32		format;
-
-	/* no payload for this format type */
-} __attribute__ ((packed));
-
-
-/* For convenience, to be used as a standard format block */
-/* for various media types that don't need a unique format block */
-/* ie. PCM, DTMF, etc. */
-struct adsp_audio_standard_format {
-	/* Media Format Code (must always be first element) */
-	u32		format;
-
-	/* payload */
-	u16		channels;
-	u16		bits_per_sample;
-	u32		sampling_rate;
-	u8		is_signed;
-	u8		is_interleaved;
-} __attribute__ ((packed));
-
-
-
-/* ADPCM format block */
-struct adsp_audio_adpcm_format {
-	/* Media Format Code (must always be first element) */
-	u32		format;
-
-	/* payload */
-	u16		channels;
-	u16		bits_per_sample;
-	u32		sampling_rate;
-	u8		is_signed;
-	u8		is_interleaved;
-	u32		block_size;
-} __attribute__ ((packed));
-
-
-/* MIDI format block */
-struct adsp_audio_midi_format {
-	/* Media Format Code (must always be first element) */
-	u32		format;
-
-	/* payload */
-	u32		sampling_rate;
-	u16		channels;
-	u16		mode;
-} __attribute__ ((packed));
-
-
-/* G711 format block */
-struct adsp_audio_g711_format {
-	/* Media Format Code (must always be first element) */
-	u32		format;
-
-	/* payload */
-	u32		companding;
-} __attribute__ ((packed));
-
-
-struct adsp_audio_wma_pro_format {
-	/* Media Format Code (must always be first element) */
-	u32		format;
-
-	/* payload */
-	u16		format_tag;
-	u16		channels;
-	u32		samples_per_sec;
-	u32		avg_bytes_per_sec;
-	u16		block_align;
-	u16		valid_bits_per_sample;
-	u32		channel_mask;
-	u16		encode_opt;
-	u16		advanced_encode_opt;
-	u32		advanced_encode_opt2;
-	u32		drc_peak_reference;
-	u32		drc_peak_target;
-	u32		drc_average_reference;
-	u32		drc_average_target;
-} __attribute__ ((packed));
-
-
-struct adsp_audio_amrwb_plus_format {
-	/* Media Format Code (must always be first element) */
-	u32		format;
-
-	/* payload */
-	u32		size;
-	u32		version;
-	u32		channels;
-	u32		amr_band_mode;
-	u32		amr_dtx_mode;
-	u32		amr_frame_format;
-	u32		amr_isf_index;
-} __attribute__ ((packed));
-
-
-/* Binary Byte Stream Format */
-/* Binary format type that defines a byte stream, */
-/* can be used to specify any format (ie. AAC) */
-struct adsp_audio_binary_format {
-	/* Media Format Code (must always be first element) */
-	u32		format;
-
-	/* payload */
-	/* number of bytes set in byte stream */
-	u32		num_bytes;
-	/* Byte stream binary data */
-	u8		data[ADSP_AUDIO_FORMAT_DATA_MAX];
-} __attribute__ ((packed));
-
-
-struct adsp_audio_shared_memory_format {
-	/* Media Format Code (must always be first element) */
-	u32		format;
-
-	/* Number of bytes in shared memory */
-	u32		len;
-	/* Phyisical address to data in shared memory */
-	u32		address;
-} __attribute__ ((packed));
-
-
-/* Union of all format types */
-union adsp_audio_format {
-	/* Basic format block with no payload */
-	struct adsp_audio_no_payload_format	no_payload;
-	/* Generic format block PCM, DTMF */
-	struct adsp_audio_standard_format	standard;
-	/* ADPCM format block */
-	struct adsp_audio_adpcm_format		adpcm;
-	/* MIDI format block */
-	struct adsp_audio_midi_format		midi;
-	/* G711 format block */
-	struct adsp_audio_g711_format		g711;
-	/* WmaPro format block */
-	struct adsp_audio_wma_pro_format	wma_pro;
-	/* WmaPro format block */
-	struct adsp_audio_amrwb_plus_format	amrwb_plus;
-	/* binary (byte stream) format block, used for AAC */
-	struct adsp_audio_binary_format		binary;
-	/* format block in shared memory */
-	struct adsp_audio_shared_memory_format	shared_mem;
-};
-
-#endif
-
diff --git a/arch/arm/mach-msm/qdsp6/mp3.c b/arch/arm/mach-msm/qdsp6/mp3.c
deleted file mode 100644
index 92e8f0f..0000000
--- a/arch/arm/mach-msm/qdsp6/mp3.c
+++ /dev/null
@@ -1,229 +0,0 @@
-/* arch/arm/mach-msm/qdsp6/mp3.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/miscdevice.h>
-#include <linux/mutex.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/uaccess.h>
-
-#include <linux/msm_audio.h>
-
-#include <mach/msm_qdsp6_audio.h>
-#include "dal_audio.h"
-
-#define BUFSZ (8192)
-#define DMASZ (BUFSZ * 2)
-
-struct mp3 {
-	struct mutex lock;
-	struct audio_client *ac;
-	uint32_t sample_rate;
-	uint32_t channel_count;
-};
-
-static long mp3_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct mp3 *mp3 = file->private_data;
-	struct cad_audio_eq_cfg eq_cfg;
-	int rc = 0;
-
-	if (cmd == AUDIO_GET_STATS) {
-		struct msm_audio_stats stats;
-		memset(&stats, 0, sizeof(stats));
-		if (copy_to_user((void*) arg, &stats, sizeof(stats)))
-			return -EFAULT;
-		return 0;
-	}
-
-	mutex_lock(&mp3->lock);
-	switch (cmd) {
-	case AUDIO_SET_VOLUME: {
-		int vol;
-		if (copy_from_user(&vol, (void*) arg, sizeof(vol))) {
-			rc = -EFAULT;
-			break;
-		}
-		rc = q6audio_set_stream_volume(mp3->ac, vol);
-		break;
-	}
-	case AUDIO_SET_EQ: {
-		if (copy_from_user(&eq_cfg, (void *)arg, sizeof(struct cad_audio_eq_cfg))) {
-			rc = -EFAULT;
-			break;
-		}
-		rc = q6audio_set_stream_eq(mp3->ac, &eq_cfg);
-		break;
-	}
-	case AUDIO_START: {
-		uint32_t acdb_id;
-		if (arg == 0) {
-			acdb_id = 0;
-		} else if (copy_from_user(&acdb_id, (void*) arg, sizeof(acdb_id))) {
-			pr_info("pcm_out: copy acdb_id from user failed\n");
-			rc = -EFAULT;
-			break;
-		}
-		if (mp3->ac) {
-			rc = -EBUSY;
-		} else {
-			mp3->ac = q6audio_open_mp3(BUFSZ,
-				mp3->sample_rate, mp3->channel_count, acdb_id);
-			if (!mp3->ac)
-				rc = -ENOMEM;
-		}
-		break;
-	}
-	case AUDIO_STOP:
-		break;
-	case AUDIO_FLUSH:
-		break;
-	case AUDIO_SET_CONFIG: {
-		struct msm_audio_config config;
-		if (mp3->ac) {
-			rc = -EBUSY;
-			break;
-		}
-		if (copy_from_user(&config, (void*) arg, sizeof(config))) {
-			rc = -EFAULT;
-			break;
-		}
-		if (config.channel_count < 1 || config.channel_count > 2) {
-			rc = -EINVAL;
-			break;
-		}
-		mp3->sample_rate = config.sample_rate;
-		mp3->channel_count = config.channel_count;
-		break;
-	}
-	case AUDIO_GET_CONFIG: {
-		struct msm_audio_config config;
-		config.buffer_size = BUFSZ;
-		config.buffer_count = 2;
-		config.sample_rate = mp3->sample_rate;
-		config.channel_count = mp3->channel_count;
-		config.unused[0] = 0;
-		config.unused[1] = 0;
-		config.unused[2] = 0;
-		if (copy_to_user((void*) arg, &config, sizeof(config))) {
-			rc = -EFAULT;
-		}
-		break;
-	}
-	default:
-		rc = -EINVAL;
-	}
-	mutex_unlock(&mp3->lock);
-	return rc;
-}
-
-static int mp3_open(struct inode *inode, struct file *file)
-{
-	int rc = 0;
-
-	struct mp3 *mp3;
-	mp3 = kzalloc(sizeof(struct mp3), GFP_KERNEL);
-
-	if (!mp3)
-		return -ENOMEM;
-
-	mutex_init(&mp3->lock);
-	mp3->channel_count = 2;
-	mp3->sample_rate = 44100;
-
-	file->private_data = mp3;
-	return rc;
-}
-
-static ssize_t mp3_write(struct file *file, const char __user *buf,
-			   size_t count, loff_t *pos)
-{
-	struct mp3 *mp3 = file->private_data;
-	struct audio_client *ac;
-	struct audio_buffer *ab;
-	const char __user *start = buf;
-	int xfer;
-
-	if (!mp3->ac)
-		mp3_ioctl(file, AUDIO_START, 0);
-
-	ac = mp3->ac;
-	if (!ac)
-		return -ENODEV;
-
-	while (count > 0) {
-		ab = ac->buf + ac->cpu_buf;
-
-		if (ab->used)
-			wait_event(ac->wait, (ab->used == 0));
-
-		xfer = count;
-		if (xfer > ab->size)
-			xfer = ab->size;
-
-		if (copy_from_user(ab->data, buf, xfer))
-			return -EFAULT;
-
-		buf += xfer;
-		count -= xfer;
-
-		ab->used = xfer;
-		q6audio_write(ac, ab);
-		ac->cpu_buf ^= 1;
-	}
-
-	return buf - start;
-}
-
-static int mp3_fsync(struct file *f, struct dentry *dentry, int datasync)
-{
-	struct mp3 *mp3 = f->private_data;
-	if (mp3->ac)
-		return q6audio_async(mp3->ac);
-	return -ENODEV;
-}
-
-static int mp3_release(struct inode *inode, struct file *file)
-{
-	struct mp3 *mp3 = file->private_data;
-	if (mp3->ac)
-		q6audio_mp3_close(mp3->ac);
-	kfree(mp3);
-	return 0;
-}
-
-static struct file_operations mp3_fops = {
-	.owner		= THIS_MODULE,
-	.open		= mp3_open,
-	.write		= mp3_write,
-	.fsync		= mp3_fsync,
-	.release	= mp3_release,
-	.unlocked_ioctl	= mp3_ioctl,
-};
-
-struct miscdevice mp3_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_mp3",
-	.fops	= &mp3_fops,
-};
-
-static int __init mp3_init(void) {
-	return misc_register(&mp3_misc);
-}
-
-device_initcall(mp3_init);
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_aac.c b/arch/arm/mach-msm/qdsp6/msm8k_aac.c
deleted file mode 100644
index 46e2c7e..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_aac.c
+++ /dev/null
@@ -1,579 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/uaccess.h>
-#include <linux/wakelock.h>
-#include <linux/msm_audio.h>
-#include <linux/sched.h>
-
-#include <asm/ioctls.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_ard.h>
-#include <mach/qdsp6/msm8k_cad_write_aac_format.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_cad_volume.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_aac: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MSM8K_AAC_PROC_NAME "msm8k_aac"
-
-#define AUDIO_MAGIC 'a'
-
-struct aac {
-	u32 cad_w_handle;
-	u32 volume;
-	struct msm_audio_config cfg;
-	struct msm_audio_aac_config aac_cfg;
-	struct mutex write_lock;
-	wait_queue_head_t eos_wait;
-	u16 eos_ack;
-	u16 flush_rcvd;
-};
-
-static struct wake_lock g_aac_wakelock;
-static atomic_t g_aac_open_count = ATOMIC_INIT(0);
-
-static void audio_prevent_sleep(void)
-{
-	if (atomic_add_return(1, &g_aac_open_count) == 1)
-		wake_lock(&g_aac_wakelock);
-}
-
-static void audio_allow_sleep(void)
-{
-	if (atomic_sub_and_test(1, &g_aac_open_count))
-		wake_unlock(&g_aac_wakelock);
-}
-
-static int msm8k_aac_open(struct inode *inode, struct file *f)
-{
-	struct aac *aac;
-	struct cad_open_struct_type  cos;
-	D("%s\n", __func__);
-
-	aac = kmalloc(sizeof(struct aac), GFP_KERNEL);
-	if (aac == NULL) {
-		pr_err("Could not allocate memory for aac driver\n");
-		return CAD_RES_FAILURE;
-	}
-	f->private_data = aac;
-
-	memset(aac, 0, sizeof(struct aac));
-	aac->cfg.buffer_size = 4096;
-	aac->cfg.buffer_count = 2;
-	aac->cfg.channel_count = 1;
-	/* This sample rate will be converted to the CAD value upon start. */
-	aac->cfg.sample_rate = 48000;
-
-	aac->aac_cfg.format = CAD_BLK_FMT_ADTS;
-	aac->aac_cfg.audio_object = CAD_AUDIO_OBJ_TYPE_AAC_LC;
-	aac->aac_cfg.ep_config = CAD_ERR_PROT_SCHEME_0;
-	aac->aac_cfg.channel_configuration = CAD_CHANNEL_CFG_MONO;
-
-	aac->eos_ack = 0;
-	aac->flush_rcvd = 0;
-
-	mutex_init(&aac->write_lock);
-	init_waitqueue_head(&aac->eos_wait);
-
-	audio_prevent_sleep();
-	cos.format = CAD_FORMAT_AAC;
-	cos.op_code = CAD_OPEN_OP_WRITE;
-	aac->cad_w_handle = cad_open(&cos);
-
-	if (aac->cad_w_handle == 0) {
-		kfree(aac);
-		audio_allow_sleep();
-		return CAD_RES_FAILURE;
-	} else
-		return CAD_RES_SUCCESS;
-}
-
-static int msm8k_aac_fsync(struct file *f, struct dentry *dentry, int datasync)
-{
-	int ret = CAD_RES_SUCCESS;
-	struct aac *aac = f->private_data;
-
-	mutex_lock(&aac->write_lock);
-	ret = cad_ioctl(aac->cad_w_handle,
-			CAD_IOCTL_CMD_STREAM_END_OF_STREAM, NULL, 0);
-	mutex_unlock(&aac->write_lock);
-
-	ret = wait_event_interruptible(aac->eos_wait, aac->eos_ack
-					|| aac->flush_rcvd);
-
-	aac->eos_ack = 0;
-	aac->flush_rcvd = 0;
-
-	return ret;
-
-}
-static int msm8k_aac_release(struct inode *inode, struct file *f)
-{
-	struct aac *aac = f->private_data;
-	D("%s %d\n", __func__, aac->cad_w_handle);
-
-	cad_close(aac->cad_w_handle);
-	kfree(aac);
-	audio_allow_sleep();
-
-	return CAD_RES_SUCCESS;
-}
-
-static ssize_t msm8k_aac_read(struct file *f, char __user *buf, size_t cnt,
-		loff_t *pos)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-void msm8k_aac_eos_event_cb(u32 event, void *evt_packet,
-				u32 evt_packet_len, void *client_data)
-{
-	struct aac *aac = client_data;
-
-	if (event == CAD_EVT_STATUS_EOS) {
-
-		aac->eos_ack = 1;
-		wake_up(&aac->eos_wait);
-	}
-}
-
-static ssize_t msm8k_aac_write(struct file *f, const char __user *buf,
-		size_t cnt, loff_t *pos)
-{
-	struct cad_buf_struct_type cbs;
-	struct aac *aac = f->private_data;
-
-	D("%s %d\n", __func__, aac->cad_w_handle);
-
-	memset(&cbs, 0, sizeof(struct cad_buf_struct_type));
-	cbs.buffer = (void *)buf;
-	cbs.phys_addr = 0;
-	cbs.max_size = cnt;
-
-	mutex_lock(&aac->write_lock);
-	cad_write(aac->cad_w_handle, &cbs);
-	mutex_unlock(&aac->write_lock);
-
-	return cnt;
-}
-
-static int msm8k_aac_ioctl(struct inode *inode, struct file *f,
-		unsigned int cmd, unsigned long arg)
-{
-	int rc;
-	struct aac *p = f->private_data;
-	u32 stream_device[1];
-	struct cad_device_struct_type cad_dev;
-	struct cad_stream_device_struct_type cad_stream_dev;
-	struct cad_stream_info_struct_type cad_stream_info;
-	struct cad_write_aac_format_struct_type cad_write_aac_fmt;
-	struct cad_flt_cfg_strm_vol cad_strm_volume;
-	struct cad_filter_struct flt;
-	struct cad_filter_struct cfs;
-	struct msm_audio_aac_config ncfg;
-	struct cad_event_struct_type eos_event;
-
-	D("%s %d\n", __func__, p->cad_w_handle);
-	memset(&cad_dev, 0, sizeof(struct cad_device_struct_type));
-	memset(&cad_stream_dev, 0,
-			sizeof(struct cad_stream_device_struct_type));
-	memset(&cad_stream_info, 0, sizeof(struct cad_stream_info_struct_type));
-	memset(&cad_write_aac_fmt, 0,
-			sizeof(struct cad_write_aac_format_struct_type));
-	memset(&flt, 0, sizeof(struct cad_filter_struct));
-	memset(&cfs, 0, sizeof(struct cad_filter_struct));
-
-	switch (cmd) {
-	case AUDIO_START:
-
-		cad_stream_info.app_type = CAD_STREAM_APP_PLAYBACK;
-		cad_stream_info.priority = 0;
-		cad_stream_info.buf_mem_type = CAD_STREAM_BUF_MEM_HEAP;
-		cad_stream_info.ses_buf_max_size = 1024 * 10;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_INFO,
-			&cad_stream_info,
-			sizeof(struct cad_stream_info_struct_type));
-		if (rc) {
-			pr_err("aac: cad_ioctl() SET_STREAM_INFO failed\n");
-			break;
-		}
-
-		stream_device[0] = CAD_HW_DEVICE_ID_DEFAULT_RX;
-		cad_stream_dev.device = (u32 *)&stream_device[0];
-		cad_stream_dev.device_len = 1;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_DEVICE,
-			&cad_stream_dev,
-			sizeof(struct cad_stream_device_struct_type));
-		if (rc) {
-			pr_err("aac: cad_ioctl() SET_STREAM_DEVICE failed\n");
-			break;
-		}
-
-		cad_write_aac_fmt.ver_id = CAD_WRITE_AAC_VERSION_10;
-		switch (p->cfg.sample_rate) {
-		case 96:
-		case 96000:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_96000;
-			break;
-		case 88:
-		case 88200:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_88200;
-			break;
-		case 64:
-		case 64000:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_64000;
-			break;
-		case 48:
-		case 48000:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_48000;
-			break;
-		case 44:
-		case 44100:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_44100;
-			break;
-		case 32:
-		case 32000:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_32000;
-			break;
-		case 24:
-		case 24000:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_24000;
-			break;
-		case 22:
-		case 22050:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_22050;
-			break;
-		case 16:
-		case 16000:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_16000;
-			break;
-		case 12:
-		case 12000:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_12000;
-			break;
-		case 11:
-		case 11025:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_11025;
-			break;
-		case 8:
-		case 8000:
-			cad_write_aac_fmt.aac.sample_rate
-						= CAD_SAMPLE_RATE_08000;
-			break;
-		default:
-			return -EINVAL;
-		}
-		cad_write_aac_fmt.aac.channel_config =
-			p->aac_cfg.channel_configuration;
-		cad_write_aac_fmt.aac.block_formats = p->aac_cfg.format;
-		cad_write_aac_fmt.aac.audio_object_type
-			= p->aac_cfg.audio_object;
-		cad_write_aac_fmt.aac.ep_config =
-			p->aac_cfg.ep_config;
-		cad_write_aac_fmt.aac.aac_section_data_resilience_flag =
-			p->aac_cfg.aac_section_data_resilience_flag;
-		cad_write_aac_fmt.aac.aac_scalefactor_data_resilience_flag =
-			p->aac_cfg.aac_scalefactor_data_resilience_flag;
-		cad_write_aac_fmt.aac.aac_spectral_data_resilience_flag =
-			p->aac_cfg.aac_spectral_data_resilience_flag;
-#ifndef CONFIG_AUDIO_AAC_PLUS
-		cad_write_aac_fmt.aac.sbr_on_flag = AUDIO_AAC_SBR_ON_FLAG_OFF;
-#else
-		cad_write_aac_fmt.aac.sbr_on_flag = p->aac_cfg.sbr_on_flag;
-#endif
-#ifndef CONFIG_AUDIO_ENHANCED_AAC_PLUS
-		cad_write_aac_fmt.aac.sbr_ps_on_flag =
-			AUDIO_AAC_SBR_PS_ON_FLAG_OFF;
-#else
-		cad_write_aac_fmt.aac.sbr_ps_on_flag =
-			p->aac_cfg.sbr_ps_on_flag;
-#endif
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_CONFIG,
-			&cad_write_aac_fmt,
-			sizeof(struct cad_write_aac_format_struct_type));
-		if (rc) {
-			pr_err("aac: cad_ioctl() SET_STREAM_CONFIG failed\n");
-			break;
-		}
-
-		eos_event.callback = &msm8k_aac_eos_event_cb;
-		eos_event.client_data = p;
-
-		rc = cad_ioctl(p->cad_w_handle,
-			CAD_IOCTL_CMD_SET_STREAM_EVENT_LSTR,
-			&eos_event, sizeof(struct cad_event_struct_type));
-
-		if (rc) {
-			pr_err("aac: cad_ioctl() "
-			       "SET_STREAM_EVENT_LSTR failed\n");
-			break;
-		}
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_START,
-			NULL, 0);
-		if (rc) {
-			pr_err("aac: cad_ioctl() STREAM_START failed\n");
-			break;
-		}
-		break;
-	case AUDIO_STOP:
-	case AUDIO_ADSP_PAUSE:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_PAUSE,
-			NULL, 0);
-		break;
-	case AUDIO_ADSP_RESUME:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_RESUME,
-			NULL, 0);
-		break;
-	case AUDIO_FLUSH:
-		p->flush_rcvd = 1;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_FLUSH,
-				NULL, 0);
-		wake_up(&p->eos_wait);
-		break;
-	case AUDIO_GET_PCM_CONFIG:
-		D("AUDIO_GET_PCM_CONFIG\n");
-		rc = CAD_RES_SUCCESS;
-		break;
-	case AUDIO_SET_PCM_CONFIG:
-		D("AUDIO_SET_PCM_CONFIG\n");
-		rc = CAD_RES_SUCCESS;
-		break;
-	case AUDIO_GET_CONFIG:
-		if (copy_to_user((void *)arg, &p->cfg,
-				sizeof(struct msm_audio_config)))
-			return -EFAULT;
-		rc = CAD_RES_SUCCESS;
-		break;
-	case AUDIO_SET_CONFIG:
-		rc = copy_from_user(&p->cfg, (void *)arg,
-				sizeof(struct msm_audio_config));
-		if (rc)
-			pr_err("aac: cad_ioctl() SET_STREAM_CONFIG failed\n");
-		break;
-	case AUDIO_GET_AAC_CONFIG:
-#ifndef CONFIG_AUDIO_AAC_PLUS
-		p->aac_cfg.sbr_on_flag = AUDIO_AAC_SBR_ON_FLAG_OFF;
-#else
-		p->aac_cfg.sbr_on_flag = AUDIO_AAC_SBR_ON_FLAG_ON;
-#endif
-#ifndef CONFIG_AUDIO_ENHANCED_AAC_PLUS
-		p->aac_cfg.sbr_ps_on_flag = AUDIO_AAC_SBR_PS_ON_FLAG_OFF;
-#else
-		p->aac_cfg.sbr_ps_on_flag = AUDIO_AAC_SBR_PS_ON_FLAG_ON;
-#endif
-		if (copy_to_user((void *)arg, &p->aac_cfg,
-				sizeof(struct msm_audio_aac_config)))
-			return -EFAULT;
-		rc = CAD_RES_SUCCESS;
-		break;
-	case AUDIO_SET_AAC_CONFIG:
-		if (copy_from_user(&ncfg, (void *)arg,
-				sizeof(struct msm_audio_aac_config)))
-			return -EFAULT;
-		p->aac_cfg.channel_configuration = ncfg.channel_configuration;
-		p->aac_cfg.format = ncfg.format;
-		p->aac_cfg.ep_config = ncfg.ep_config;
-		p->aac_cfg.aac_section_data_resilience_flag =
-				ncfg.aac_section_data_resilience_flag;
-		p->aac_cfg.aac_scalefactor_data_resilience_flag =
-				ncfg.aac_scalefactor_data_resilience_flag;
-		p->aac_cfg.aac_spectral_data_resilience_flag =
-				ncfg.aac_spectral_data_resilience_flag;
-#ifndef CONFIG_AUDIO_AAC_PLUS
-		p->aac_cfg.sbr_on_flag = AUDIO_AAC_SBR_ON_FLAG_OFF;
-#else
-		p->aac_cfg.sbr_on_flag = ncfg.sbr_on_flag;
-#endif
-#ifndef CONFIG_AUDIO_ENHANCED_AAC_PLUS
-		p->aac_cfg.sbr_ps_on_flag = AUDIO_AAC_SBR_PS_ON_FLAG_OFF;
-#else
-		p->aac_cfg.sbr_ps_on_flag = ncfg.sbr_ps_on_flag;
-#endif
-		if ((ncfg.audio_object == CAD_AUDIO_OBJ_TYPE_AAC_LC)
-			|| (ncfg.audio_object == CAD_AUDIO_OBJ_TYPE_AAC_LTP)
-			|| (ncfg.audio_object == CAD_AUDIO_OBJ_TYPE_ER_AAC_LC)
-			|| (ncfg.audio_object == CAD_AUDIO_OBJ_TYPE_AAC_BSAC))
-			p->aac_cfg.audio_object = ncfg.audio_object;
-
-		rc = CAD_RES_SUCCESS;
-		break;
-	case AUDIO_SET_VOLUME:
-		rc = copy_from_user(&p->volume, (void *)arg, sizeof(u32));
-
-		memset(&cad_strm_volume, 0,
-				sizeof(struct cad_flt_cfg_strm_vol));
-		cad_strm_volume.volume = p->volume;
-		flt.filter_type = CAD_DEVICE_FILTER_TYPE_VOL;
-		flt.format_block = &cad_strm_volume;
-		flt.cmd = CAD_FILTER_CONFIG_STREAM_VOLUME;
-		flt.format_block_len =
-			sizeof(struct cad_flt_cfg_strm_vol);
-
-		rc = cad_ioctl(p->cad_w_handle,
-			CAD_IOCTL_CMD_SET_STREAM_FILTER_CONFIG,
-			&flt,
-			sizeof(struct cad_filter_struct));
-		if (rc) {
-			pr_err("aac: cad_ioctl() set volume failed\n");
-			break;
-		}
-		break;
-	case AUDIO_SET_EQ:
-		rc = copy_from_user(&cfs, (void *)arg,
-				sizeof(struct cad_filter_struct));
-		rc = cad_ioctl(p->cad_w_handle,
-			CAD_IOCTL_CMD_SET_STREAM_FILTER_CONFIG,
-			&cfs,
-			sizeof(struct cad_filter_struct));
-		if (rc)
-			pr_err("aac: cad_ioctl() set equalizer failed\n");
-		break;
-	default:
-		D("unknown ioctl: 0x%08X\n", cmd);
-		rc = CAD_RES_SUCCESS;
-	}
-
-	return rc;
-}
-
-#ifdef CONFIG_PROC_FS
-int msm8k_aac_read_proc(char *pbuf, char **start, off_t offset,
-			int count, int *eof, void *data)
-{
-	int len = 0;
-	len += snprintf(pbuf, 16, "aac\n");
-
-	*eof = 1;
-	return len;
-}
-#endif
-
-static const struct file_operations msm8k_aac_fops = {
-	.owner = THIS_MODULE,
-	.open = msm8k_aac_open,
-	.release = msm8k_aac_release,
-	.read = msm8k_aac_read,
-	.write = msm8k_aac_write,
-	.ioctl = msm8k_aac_ioctl,
-	.llseek = no_llseek,
-	.fsync = msm8k_aac_fsync,
-};
-
-
-struct miscdevice msm8k_aac_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_aac",
-	.fops	= &msm8k_aac_fops,
-};
-
-static int __init msm8k_aac_init(void)
-{
-	int rc;
-	D("%s\n", __func__);
-
-	rc = misc_register(&msm8k_aac_misc);
-	wake_lock_init(&g_aac_wakelock, WAKE_LOCK_SUSPEND, "audio_aac");
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(MSM8K_AAC_PROC_NAME,
-			0, NULL, msm8k_aac_read_proc, NULL);
-#endif
-
-	return rc;
-}
-
-static void __exit msm8k_aac_exit(void)
-{
-	D("%s\n", __func__);
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(MSM8K_AAC_PROC_NAME, NULL);
-#endif
-}
-
-
-module_init(msm8k_aac_init);
-module_exit(msm8k_aac_exit);
-
-MODULE_DESCRIPTION("MSM AAC driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_aac_in.c b/arch/arm/mach-msm/qdsp6/msm8k_aac_in.c
deleted file mode 100644
index 2ab33b9..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_aac_in.c
+++ /dev/null
@@ -1,306 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/uaccess.h>
-#include <linux/msm_audio.h>
-
-#include <asm/ioctls.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_ard.h>
-#include <mach/qdsp6/msm8k_cad_write_aac_format.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_aac_in: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MSM8K_AAC_IN_PROC_NAME "msm8k_aac_in"
-
-#define AUDIO_MAGIC 'a'
-
-struct aac {
-	u32 cad_w_handle;
-	struct msm_audio_config cfg;
-};
-
-static int msm8k_aac_in_open(struct inode *inode, struct file *f)
-{
-	struct aac *aac;
-	struct cad_open_struct_type  cos;
-	D("%s\n", __func__);
-
-	aac = kmalloc(sizeof(struct aac), GFP_KERNEL);
-
-	if (aac == NULL) {
-		pr_err("Could not allocate memory for aac recording driver\n");
-		return CAD_RES_FAILURE;
-	}
-
-	f->private_data = aac;
-	memset(aac, 0, sizeof(struct aac));
-
-	aac->cfg.buffer_size = 4096;
-	aac->cfg.buffer_count = 2;
-	aac->cfg.channel_count = 1;
-	aac->cfg.sample_rate = 48000;
-
-	cos.format = CAD_FORMAT_AAC;
-	cos.op_code = CAD_OPEN_OP_READ;
-	aac->cad_w_handle = cad_open(&cos);
-
-	if (aac->cad_w_handle == 0)
-		return CAD_RES_FAILURE;
-	else
-		return CAD_RES_SUCCESS;
-}
-
-static int msm8k_aac_in_release(struct inode *inode, struct file *f)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct aac *aac = f->private_data;
-	D("%s\n", __func__);
-
-	cad_close(aac->cad_w_handle);
-	kfree(aac);
-	return rc;
-}
-
-static ssize_t msm8k_aac_in_read(struct file *f, char __user *buf, size_t cnt,
-		loff_t *pos)
-{
-	struct aac			*aac = f->private_data;
-	struct cad_buf_struct_type	cbs;
-
-	D("%s\n", __func__);
-
-	memset(&cbs, 0, sizeof(struct cad_buf_struct_type));
-	cbs.buffer = (void *)buf;
-	cbs.max_size = cnt;
-	cbs.actual_size = cnt;
-
-
-	cnt = cad_read(aac->cad_w_handle, &cbs);
-	return cnt;
-}
-
-static ssize_t msm8k_aac_in_write(struct file *f, const char __user *buf,
-		size_t cnt, loff_t *pos)
-{
-	D("%s\n", __func__);
-
-	return cnt;
-}
-
-static int msm8k_aac_in_ioctl(struct inode *inode, struct file *f,
-		unsigned int cmd, unsigned long arg)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct aac *p = f->private_data;
-	u32 stream_device[1];
-	struct cad_device_struct_type cad_dev;
-	struct cad_stream_device_struct_type cad_stream_dev;
-	struct cad_stream_info_struct_type cad_stream_info;
-	struct cad_write_aac_format_struct_type cad_write_aac_fmt;
-	D("%s\n", __func__);
-
-	memset(&cad_dev, 0, sizeof(struct cad_device_struct_type));
-	memset(&cad_stream_dev, 0,
-			sizeof(struct cad_stream_device_struct_type));
-	memset(&cad_stream_info, 0, sizeof(struct cad_stream_info_struct_type));
-	memset(&cad_write_aac_fmt, 0,
-			sizeof(struct cad_write_aac_format_struct_type));
-
-	switch (cmd) {
-	case AUDIO_START:
-
-		cad_stream_info.app_type = CAD_STREAM_APP_RECORD;
-		cad_stream_info.priority = 0;
-		cad_stream_info.buf_mem_type = CAD_STREAM_BUF_MEM_HEAP;
-		cad_stream_info.ses_buf_max_size = p->cfg.buffer_size;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_INFO,
-			&cad_stream_info,
-			sizeof(struct cad_stream_info_struct_type));
-		if (rc) {
-			pr_err("cad_ioctl() SET_STREAM_INFO failed\n");
-			break;
-		}
-
-		stream_device[0] = CAD_HW_DEVICE_ID_DEFAULT_TX;
-		cad_stream_dev.device = (u32 *)&stream_device[0];
-		cad_stream_dev.device_len = 1;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_DEVICE,
-			&cad_stream_dev,
-			sizeof(struct cad_stream_device_struct_type));
-		if (rc) {
-			pr_err("cad_ioctl() SET_STREAM_DEVICE failed\n");
-			break;
-		}
-		cad_write_aac_fmt.ver_id = CAD_WRITE_AAC_VERSION_10;
-
-		if (p->cfg.sample_rate != 48000)
-			D("Switching to 48KHz, only 48KHz supported!\n");
-
-		cad_write_aac_fmt.aac.sample_rate = CAD_SAMPLE_RATE_48000;
-		cad_write_aac_fmt.aac.channel_config = 1;
-		cad_write_aac_fmt.aac.block_formats = 0xffff;
-		cad_write_aac_fmt.aac.audio_object_type = 2;
-		cad_write_aac_fmt.aac.bit_rate = 192000;
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_CONFIG,
-			&cad_write_aac_fmt,
-			sizeof(struct cad_write_aac_format_struct_type));
-		if (rc) {
-			pr_err("cad_ioctl() SET_STREAM_CONFIG failed\n");
-			break;
-		}
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_START,
-			NULL, 0);
-		if (rc) {
-			pr_err("cad_ioctl() STREAM_START failed\n");
-			break;
-		}
-		break;
-	case AUDIO_STOP:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_PAUSE,
-			NULL, 0);
-		break;
-	case AUDIO_FLUSH:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_FLUSH,
-			NULL, 0);
-		break;
-	case AUDIO_GET_CONFIG:
-		if (copy_to_user((void *)arg, &p->cfg,
-				sizeof(struct msm_audio_config)))
-			return -EFAULT;
-	case AUDIO_SET_CONFIG:
-		rc = copy_from_user(&p->cfg, (void *)arg,
-				sizeof(struct msm_audio_config));
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-#ifdef CONFIG_PROC_FS
-int msm8k_aac_in_read_proc(char *pbuf, char **start, off_t offset,
-			int count, int *eof, void *data)
-{
-	int len = 0;
-	len += snprintf(pbuf, 16, "aac_in\n");
-
-	*eof = 1;
-	return len;
-}
-#endif
-
-static const struct file_operations msm8k_aac_in_fops = {
-	.owner = THIS_MODULE,
-	.open = msm8k_aac_in_open,
-	.release = msm8k_aac_in_release,
-	.read = msm8k_aac_in_read,
-	.write = msm8k_aac_in_write,
-	.ioctl = msm8k_aac_in_ioctl,
-	.llseek = no_llseek,
-};
-
-
-struct miscdevice msm8k_aac_in_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_aac_in",
-	.fops	= &msm8k_aac_in_fops,
-};
-
-static int __init msm8k_aac_in_init(void)
-{
-	int rc;
-	D("%s\n", __func__);
-
-	rc = misc_register(&msm8k_aac_in_misc);
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(MSM8K_AAC_IN_PROC_NAME,
-			0, NULL, msm8k_aac_in_read_proc, NULL);
-#endif
-
-	return rc;
-}
-
-static void __exit msm8k_aac_in_exit(void)
-{
-	D("%s\n", __func__);
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(MSM8K_AAC_IN_PROC_NAME, NULL);
-#endif
-}
-
-
-module_init(msm8k_aac_in_init);
-module_exit(msm8k_aac_in_exit);
-
-MODULE_DESCRIPTION("MSM AAC recording driver");
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_amrnb.c b/arch/arm/mach-msm/qdsp6/msm8k_amrnb.c
deleted file mode 100644
index 173626d..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_amrnb.c
+++ /dev/null
@@ -1,326 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/uaccess.h>
-#include <linux/msm_audio.h>
-
-#include <asm/ioctls.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_ard.h>
-#include <mach/qdsp6/msm8k_cad_write_amr_format.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_cad_volume.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_amr: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MSM8K_AMR_PROC_NAME "msm8k_amr"
-
-#define AUDIO_MAGIC 'a'
-
-struct amr {
-	u32 cad_w_handle;
-	struct msm_audio_config cfg;
-	u32 volume;
-};
-
-static int msm8k_amr_open(struct inode *inode, struct file *f)
-{
-	struct amr *amr;
-	struct cad_open_struct_type  cos;
-	D("%s\n", __func__);
-
-	amr = kmalloc(sizeof(struct amr), GFP_KERNEL);
-	if (amr == NULL) {
-		pr_err("Could not allocate memory for amr driver\n");
-		return CAD_RES_FAILURE;
-	}
-
-	f->private_data = amr;
-
-	memset(amr, 0, sizeof(struct amr));
-
-	cos.format = CAD_FORMAT_AMRNB;
-	cos.op_code = CAD_OPEN_OP_WRITE;
-	amr->cad_w_handle = cad_open(&cos);
-
-	if (amr->cad_w_handle == 0)
-		return CAD_RES_FAILURE;
-	else
-		return CAD_RES_SUCCESS;
-}
-
-static int msm8k_amr_release(struct inode *inode, struct file *f)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct amr *amr = f->private_data;
-	D("%s\n", __func__);
-
-	cad_close(amr->cad_w_handle);
-	kfree(amr);
-
-	return rc;
-}
-
-static ssize_t msm8k_amr_read(struct file *f, char __user *buf, size_t cnt,
-		loff_t *pos)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-static ssize_t msm8k_amr_write(struct file *f, const char __user *buf,
-		size_t cnt, loff_t *pos)
-{
-	struct cad_buf_struct_type cbs;
-	struct amr *amr = f->private_data;
-
-	D("%s\n", __func__);
-
-	memset(&cbs, 0, sizeof(struct cad_buf_struct_type));
-	cbs.buffer = (void *)buf;
-	cbs.phys_addr = 0;
-	cbs.max_size = cnt;
-	cbs.actual_size = cnt;
-
-	cad_write(amr->cad_w_handle, &cbs);
-
-	return cnt;
-}
-
-static int msm8k_amr_ioctl(struct inode *inode, struct file *f,
-		unsigned int cmd, unsigned long arg)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct amr *p = f->private_data;
-	void *cad_arg = (void *)arg;
-	u32 stream_device[1];
-	struct cad_device_struct_type cad_dev;
-	struct cad_stream_device_struct_type cad_stream_dev;
-	struct cad_stream_info_struct_type cad_stream_info;
-	struct cad_write_amr_format_struct_type cad_write_amr_fmt;
-	struct cad_flt_cfg_strm_vol cad_strm_volume;
-	struct cad_filter_struct flt;
-
-	D("%s\n", __func__);
-
-	memset(&cad_dev, 0, sizeof(struct cad_device_struct_type));
-	memset(&cad_stream_dev, 0,
-			sizeof(struct cad_stream_device_struct_type));
-	memset(&cad_stream_info, 0, sizeof(struct cad_stream_info_struct_type));
-	memset(&cad_write_amr_fmt, 0,
-			sizeof(struct cad_write_amr_format_struct_type));
-	memset(&flt, 0, sizeof(struct cad_filter_struct));
-
-	switch (cmd) {
-	case AUDIO_START:
-
-		cad_stream_info.app_type = CAD_STREAM_APP_PLAYBACK;
-		cad_stream_info.priority = 0;
-		cad_stream_info.buf_mem_type = CAD_STREAM_BUF_MEM_HEAP;
-		cad_stream_info.ses_buf_max_size = 1024 * 10;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_INFO,
-			&cad_stream_info,
-			sizeof(struct cad_stream_info_struct_type));
-		if (rc) {
-			pr_err("cad_ioctl() SET_STREAM_INFO failed\n");
-			break;
-		}
-
-		stream_device[0] = CAD_HW_DEVICE_ID_DEFAULT_RX;
-		cad_stream_dev.device = (u32 *)&stream_device[0];
-		cad_stream_dev.device_len = 1;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_DEVICE,
-			&cad_stream_dev,
-			sizeof(struct cad_stream_device_struct_type));
-		if (rc) {
-			pr_err("cad_ioctl() SET_STREAM_DEVICE failed\n");
-			break;
-		}
-
-		cad_write_amr_fmt.ver_id = CAD_WRITE_AMR_VERSION_10;
-		cad_write_amr_fmt.amr.sample_rate = 48000;
-		cad_write_amr_fmt.amr.stereo_config = 1;
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_CONFIG,
-			&cad_write_amr_fmt,
-			sizeof(struct cad_write_amr_format_struct_type));
-		if (rc) {
-			pr_err("cad_ioctl() SET_STREAM_CONFIG failed\n");
-			break;
-		}
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_START,
-			NULL, 0);
-		if (rc) {
-			pr_err("cad_ioctl() STREAM_START failed\n");
-			break;
-		}
-		break;
-	case AUDIO_STOP:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_PAUSE,
-			cad_arg, sizeof(u32));
-		break;
-	case AUDIO_FLUSH:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_FLUSH,
-			cad_arg, sizeof(u32));
-		break;
-	case AUDIO_GET_CONFIG:
-		if (copy_to_user((void *)arg, &p->cfg,
-				sizeof(struct msm_audio_config)))
-			return -EFAULT;
-		break;
-	case AUDIO_SET_CONFIG:
-		rc = copy_from_user(&p->cfg, (void *)arg,
-				sizeof(struct msm_audio_config));
-		break;
-	case AUDIO_SET_VOLUME:
-		rc = copy_from_user(&p->volume, (void *)arg, sizeof(u32));
-
-		memset(&cad_strm_volume, 0,
-				sizeof(struct cad_flt_cfg_strm_vol));
-		cad_strm_volume.volume = p->volume;
-		flt.filter_type = CAD_DEVICE_FILTER_TYPE_VOL;
-		flt.format_block = &cad_strm_volume;
-		flt.cmd = CAD_FILTER_CONFIG_STREAM_VOLUME;
-		flt.format_block_len =
-			sizeof(struct cad_flt_cfg_strm_vol);
-
-		rc = cad_ioctl(p->cad_w_handle,
-			CAD_IOCTL_CMD_SET_STREAM_FILTER_CONFIG,
-			&flt,
-			sizeof(struct cad_stream_filter_struct_type));
-		if (rc) {
-			pr_err("cad_ioctl() set volume failed\n");
-			break;
-		}
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-#ifdef CONFIG_PROC_FS
-int msm8k_amr_read_proc(char *pbuf, char **start, off_t offset,
-			int count, int *eof, void *data)
-{
-	int len = 0;
-	len += snprintf(pbuf, 16, "amr\n");
-
-	*eof = 1;
-	return len;
-}
-#endif
-
-static const struct file_operations msm8k_amr_fops = {
-	.owner = THIS_MODULE,
-	.open = msm8k_amr_open,
-	.release = msm8k_amr_release,
-	.read = msm8k_amr_read,
-	.write = msm8k_amr_write,
-	.ioctl = msm8k_amr_ioctl,
-	.llseek = no_llseek,
-};
-
-
-struct miscdevice msm8k_amr_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_amr",
-	.fops	= &msm8k_amr_fops,
-};
-
-static int __init msm8k_amr_init(void)
-{
-	int rc;
-	D("%s\n", __func__);
-
-	rc = misc_register(&msm8k_amr_misc);
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(MSM8K_AMR_PROC_NAME,
-			0, NULL, msm8k_amr_read_proc, NULL);
-#endif
-
-	return rc;
-}
-
-static void __exit msm8k_amr_exit(void)
-{
-	D("%s\n", __func__);
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(MSM8K_AMR_PROC_NAME, NULL);
-#endif
-}
-
-
-module_init(msm8k_amr_init);
-module_exit(msm8k_amr_exit);
-
-MODULE_DESCRIPTION("MSM AMR driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_amrnb_in.c b/arch/arm/mach-msm/qdsp6/msm8k_amrnb_in.c
deleted file mode 100644
index e62613c..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_amrnb_in.c
+++ /dev/null
@@ -1,299 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/uaccess.h>
-#include <linux/msm_audio.h>
-
-#include <asm/ioctls.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_ard.h>
-#include <mach/qdsp6/msm8k_cad_write_amr_format.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_amr_in: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MSM8K_AMR_IN_PROC_NAME "msm8k_amr_in"
-
-#define AUDIO_MAGIC 'a'
-
-struct amr {
-	u32 cad_w_handle;
-	struct msm_audio_config cfg;
-};
-
-
-static int msm8k_amr_in_open(struct inode *inode, struct file *f)
-{
-	struct amr *amr;
-	struct cad_open_struct_type  cos;
-	D("%s\n", __func__);
-
-	amr = kmalloc(sizeof(struct amr), GFP_KERNEL);
-	if (amr == NULL) {
-		pr_err("Could not allocate memory for amr_in driver\n");
-		return CAD_RES_FAILURE;
-	}
-
-	f->private_data = amr;
-
-	memset(amr, 0, sizeof(struct amr));
-
-	cos.format = CAD_FORMAT_AMRNB;
-	cos.op_code = CAD_OPEN_OP_READ;
-	amr->cad_w_handle = cad_open(&cos);
-
-	if (amr->cad_w_handle == 0)
-		return CAD_RES_FAILURE;
-	else
-		return CAD_RES_SUCCESS;
-}
-
-static int msm8k_amr_in_release(struct inode *inode, struct file *f)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct amr *amr = f->private_data;
-	D("%s\n", __func__);
-
-	cad_close(amr->cad_w_handle);
-	kfree(amr);
-
-	return rc;
-}
-
-static ssize_t msm8k_amr_in_read(struct file *f, char __user *buf, size_t cnt,
-		loff_t *pos)
-{
-	struct amr			*amr = f->private_data;
-	struct cad_buf_struct_type	cbs;
-
-	D("%s\n", __func__);
-
-	memset(&cbs, 0, sizeof(struct cad_buf_struct_type));
-	cbs.buffer = (void *)buf;
-	cbs.max_size = cnt;
-	cbs.actual_size = cnt;
-
-
-	cnt = cad_read(amr->cad_w_handle, &cbs);
-	return cnt;
-}
-
-static ssize_t msm8k_amr_in_write(struct file *f, const char __user *buf,
-		size_t cnt, loff_t *pos)
-{
-	D("%s\n", __func__);
-
-	return cnt;
-}
-
-static int msm8k_amr_in_ioctl(struct inode *inode, struct file *f,
-		unsigned int cmd, unsigned long arg)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct amr *p = f->private_data;
-	void *cad_arg = (void *)arg;
-	u32 stream_device[1];
-	struct cad_device_struct_type cad_dev;
-	struct cad_stream_device_struct_type cad_stream_dev;
-	struct cad_stream_info_struct_type cad_stream_info;
-	struct cad_write_amr_format_struct_type cad_write_amr_fmt;
-	D("%s\n", __func__);
-
-	memset(&cad_dev, 0, sizeof(struct cad_device_struct_type));
-	memset(&cad_stream_dev, 0,
-			sizeof(struct cad_stream_device_struct_type));
-	memset(&cad_stream_info, 0, sizeof(struct cad_stream_info_struct_type));
-	memset(&cad_write_amr_fmt, 0,
-			sizeof(struct cad_write_amr_format_struct_type));
-
-	switch (cmd) {
-	case AUDIO_START:
-
-		cad_stream_info.app_type = CAD_STREAM_APP_RECORD;
-		cad_stream_info.priority = 0;
-		cad_stream_info.buf_mem_type = CAD_STREAM_BUF_MEM_HEAP;
-		cad_stream_info.ses_buf_max_size = 1024 * 10;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_INFO,
-			&cad_stream_info,
-			sizeof(struct cad_stream_info_struct_type));
-		if (rc) {
-			pr_err("cad_ioctl() SET_STREAM_INFO failed\n");
-			break;
-		}
-
-		stream_device[0] = CAD_HW_DEVICE_ID_DEFAULT_TX;
-		cad_stream_dev.device = (u32 *)&stream_device[0];
-		cad_stream_dev.device_len = 1;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_DEVICE,
-			&cad_stream_dev,
-			sizeof(struct cad_stream_device_struct_type));
-		if (rc) {
-			pr_err("cad_ioctl() SET_STREAM_DEVICE failed\n");
-			break;
-		}
-
-		cad_write_amr_fmt.ver_id = CAD_WRITE_AMR_VERSION_10;
-		cad_write_amr_fmt.amr.stereo_config = 0;
-		cad_write_amr_fmt.amr.sample_rate = 8000;
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_CONFIG,
-			&cad_write_amr_fmt,
-			sizeof(struct cad_write_amr_format_struct_type));
-		if (rc) {
-			pr_err("cad_ioctl() SET_STREAM_CONFIG failed\n");
-			break;
-		}
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_START,
-			NULL, 0);
-		if (rc) {
-			pr_err("cad_ioctl() STREAM_START failed\n");
-			break;
-		}
-		break;
-	case AUDIO_STOP:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_PAUSE,
-			cad_arg, sizeof(u32));
-		break;
-	case AUDIO_FLUSH:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_FLUSH,
-			cad_arg, sizeof(u32));
-		break;
-	case AUDIO_GET_CONFIG:
-		if (copy_to_user((void *)arg, &p->cfg,
-				sizeof(struct msm_audio_config)))
-			return -EFAULT;
-	case AUDIO_SET_CONFIG:
-		rc = copy_from_user(&p->cfg, (void *)arg,
-				sizeof(struct msm_audio_config));
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-#ifdef CONFIG_PROC_FS
-int msm8k_amr_in_read_proc(char *pbuf, char **start, off_t offset,
-			int count, int *eof, void *data)
-{
-	int len = 0;
-	len += snprintf(pbuf, 16, "amr_in\n");
-
-	*eof = 1;
-	return len;
-}
-#endif
-
-static const struct file_operations msm8k_amr_in_fops = {
-	.owner = THIS_MODULE,
-	.open = msm8k_amr_in_open,
-	.release = msm8k_amr_in_release,
-	.read = msm8k_amr_in_read,
-	.write = msm8k_amr_in_write,
-	.ioctl = msm8k_amr_in_ioctl,
-	.llseek = no_llseek,
-};
-
-
-struct miscdevice msm8k_amr_in_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_amr_in",
-	.fops	= &msm8k_amr_in_fops,
-};
-
-static int __init msm8k_amr_in_init(void)
-{
-	int rc;
-	D("%s\n", __func__);
-
-	rc = misc_register(&msm8k_amr_in_misc);
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(MSM8K_AMR_IN_PROC_NAME,
-			0, NULL, msm8k_amr_in_read_proc, NULL);
-#endif
-
-	return rc;
-}
-
-static void __exit msm8k_amr_in_exit(void)
-{
-	D("%s\n", __func__);
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(MSM8K_AMR_IN_PROC_NAME, NULL);
-#endif
-}
-
-
-module_init(msm8k_amr_in_init);
-module_exit(msm8k_amr_in_exit);
-
-MODULE_DESCRIPTION("MSM AMR IN driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_ard.c b/arch/arm/mach-msm/qdsp6/msm8k_ard.c
deleted file mode 100644
index 08b4370..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_ard.c
+++ /dev/null
@@ -1,1505 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/mutex.h>
-#include <linux/dma-mapping.h>
-
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_ard_clk.h>
-#include <mach/qdsp6/msm8k_ard_adie.h>
-#include <mach/qdsp6/msm8k_cad_rpc_type.h>
-#include <mach/qdsp6/msm8k_cad_rpc.h>
-#include <mach/qdsp6/msm8k_ard_q6.h>
-#include <mach/qdsp6/msm8k_ard_helper.h>
-#include <mach/qdsp6/msm8k_ard_acdb.h>
-#include <mach/qdsp6/msm8k_cad_q6dec_drvi.h>
-#include <mach/qdsp6/msm8k_cad_q6enc_drvi.h>
-#include <mach/qdsp6/msm8k_cad_write_pcm_format.h>
-#include <mach/qdsp6/msm8k_cad_write_aac_format.h>
-
-static struct ard_session_info_struct_type	ard_session
-							[ARD_AUDIO_MAX_CLIENT];
-struct ard_session_info_struct_type		*ardsession[CAD_MAX_SESSION];
-struct ard_state_struct_type			ard_state;
-struct clk_info 				g_clk_info = {8000, 0};
-u32						device_control_session;
-
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "ARD: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-s32 cad_ard_init(struct cad_func_tbl_type **func_ptr_tbl)
-{
-	s32				rc, dal_rc, i;
-	struct ard_state_struct_type	*local_ard_state = NULL;
-
-	static struct cad_func_tbl_type ard_func = {
-		ard_open, ard_close, ard_write, ard_read, ard_ioctl
-	};
-
-	rc = dal_rc = CAD_RES_SUCCESS;
-
-	*func_ptr_tbl = &ard_func;
-	local_ard_state = &ard_state;
-
-	/* Initialize the sessions. */
-	for (i = 0; i < ARD_AUDIO_MAX_CLIENT; i++)
-		memset(&ard_session[i], 0,
-			sizeof(struct ard_session_info_struct_type));
-
-	for (i = 0; i < MAX_NUM_DEVICES; i++) {
-		mutex_init(&local_ard_state->ard_device[i].device_mutex);
-
-		local_ard_state->ard_device[i].state = ARD_STATE_RESET;
-		local_ard_state->ard_device[i].afe_enabled = ARD_FALSE;
-		local_ard_state->ard_device[i].device_configured = ARD_FALSE;
-		local_ard_state->ard_device[i].device_config_request
-			= ARD_FALSE;
-		local_ard_state->ard_device[i].device_change_request
-			= ARD_FALSE;
-		local_ard_state->ard_device[i].device_inuse = 0;
-		local_ard_state->ard_device[i].device_type = CAD_RX_DEVICE;
-		local_ard_state->ard_device[i].clk_configured = ARD_FALSE;
-		local_ard_state->ard_device[i].stream_count = 0;
-	}
-
-	/* Set the default TX and RX devices to */
-
-	/* Device 0 is RX Internal Codec */
-	local_ard_state->ard_device[0].device_type = CAD_RX_DEVICE;
-
-	/* Device 1 is TX Internal Codec */
-	local_ard_state->ard_device[1].device_type = CAD_TX_DEVICE;
-
-	local_ard_state->ard_device[2].device_type = CAD_RX_DEVICE;
-
-	local_ard_state->ard_device[3].device_type = CAD_TX_DEVICE;
-
-	local_ard_state->def_tx_device = CAD_HW_DEVICE_ID_HANDSET_MIC;
-	local_ard_state->def_rx_device = CAD_HW_DEVICE_ID_HANDSET_SPKR;
-
-	/* Create the session mutexes */
-	for (i = 0; i < ARD_AUDIO_MAX_CLIENT; i++)
-		mutex_init(&ard_session[i].session_mutex);
-
-	/* Create a mutex for the state machine */
-	mutex_init(&local_ard_state->ard_state_machine_mutex);
-
-	/* Initialize the ADIE */
-	dal_rc = adie_init();
-	if (dal_rc != CAD_RES_SUCCESS) {
-		pr_err("ARD ard_init failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	dal_rc = ard_acdb_init();
-	if (dal_rc != CAD_RES_SUCCESS) {
-		pr_err("ARD ard_acdb_init failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	dal_rc = cad_rpc_init(CAD_RPC_ARM11);
-	if (dal_rc != CAD_RES_SUCCESS) {
-		pr_err("ARD RPC Interface Attach Init failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	/* Register ARD Callback function */
-	dal_rc = cad_rpc_reg_callback(0, ard_callback_func, NULL);
-	if (dal_rc != CAD_RES_SUCCESS) {
-		pr_err("ARD RPC Register Callback failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-done:
-	return rc;
-}
-
-s32 cad_ard_dinit(void)
-{
-	s32				rc, dal_rc, i;
-	struct ard_state_struct_type	*local_ard_state = NULL;
-
-	rc = dal_rc = CAD_RES_SUCCESS;
-
-
-	local_ard_state = &ard_state;
-
-	mutex_destroy(&local_ard_state->ard_state_machine_mutex);
-
-	for (i = 0; i < ARD_AUDIO_MAX_CLIENT; i++)
-		mutex_unlock(&ard_session[i].session_mutex);
-
-	for (i = 0; i < MAX_NUM_DEVICES; i++) {
-		mutex_unlock(&local_ard_state->ard_device[i].device_mutex);
-		mutex_destroy(&local_ard_state->ard_device[i].device_mutex);
-		local_ard_state->ard_device[i].state = ARD_STATE_RESET;
-		local_ard_state->ard_device[i].afe_enabled = ARD_FALSE;
-		local_ard_state->ard_device[i].device_configured = ARD_FALSE;
-		local_ard_state->ard_device[i].device_config_request
-			= ARD_FALSE;
-		local_ard_state->ard_device[i].device_change_request
-			= ARD_FALSE;
-		local_ard_state->ard_device[i].device_inuse =
-			CAD_HW_DEVICE_ID_DEFAULT_RX;
-		local_ard_state->ard_device[i].device_type = CAD_RX_DEVICE;
-		local_ard_state->ard_device[i].clk_configured = ARD_FALSE;
-		local_ard_state->ard_device[i].stream_count = 0;
-	}
-
-	/* DeInit the ADIE */
-	dal_rc = adie_dinit();
-	if (dal_rc != CAD_RES_SUCCESS) {
-		pr_err("ARD Adie Interface DeAttach Init failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	dal_rc = cad_rpc_deinit();
-	if (dal_rc != CAD_RES_SUCCESS) {
-		pr_err("ARD RPC Interface DeAttach Init failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	dal_rc = cad_rpc_dereg_callback(0, ard_callback_func);
-	if (dal_rc != CAD_RES_SUCCESS) {
-		pr_err("ARD RPC DeRegister Callback failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-done:
-	ard_acdb_dinit();
-	return rc;
-}
-
-s32 ard_open(s32 session_id, struct cad_open_struct_type *open_param)
-{
-	s32				i, rc, dal_rc;
-	u32				open_parm_len;
-	struct cadi_open_struct_type	*op = NULL;
-
-	rc = dal_rc = CAD_RES_SUCCESS;
-	open_parm_len = 0;
-
-	D("ARD ard_open()\n");
-
-	for (i = 0; i < ARD_AUDIO_MAX_CLIENT; i++) {
-		if (ard_session[i].available == ARD_FALSE)
-			break;
-	}
-
-	if (i == ARD_AUDIO_MAX_CLIENT) {
-		pr_err("ARD session not available %d\n", session_id);
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	if (open_param == NULL) {
-		pr_err("ARD NULL open_param sent.. ses: %d\n", session_id);
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	/* Parse the open parameters and check if this is a device control */
-	/* session or a stream based session */
-	if (open_param->op_code == CAD_OPEN_OP_DEVICE_CTRL)
-		ard_session[i].session_type = DEVICE_CTRL_TYPE;
-	else if ((open_param->op_code == CAD_OPEN_OP_WRITE) ||
-		(open_param->op_code == CAD_OPEN_OP_READ))
-		ard_session[i].session_type = STREAM_TYPE;
-	else {
-		pr_err("ARD unknown session type %d\n", session_id);
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	ard_session[i].sess_open_info =
-		kmalloc(sizeof(struct cadi_open_struct_type),
-			GFP_KERNEL);
-
-	if (ard_session[i].sess_open_info == NULL) {
-		pr_err("ARD open kmalloc failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	op = (struct cadi_open_struct_type *)
-			ard_session[i].sess_open_info;
-
-	memset(op, 0, sizeof(struct cadi_open_struct_type));
-
-	open_parm_len = sizeof(struct cad_open_struct_type);
-
-	memcpy(&op->cad_open, open_param, open_parm_len);
-
-	open_param->group_id = session_id;
-
-	ard_session[i].group_id = open_param->group_id;
-
-	/* Init the qdsp6_opened flag */
-	ard_session[i].qdsp6_opened = ARD_FALSE;
-	ard_session[i].qdsp6_started = ARD_FALSE;
-
-	/* Init the local format block ptr */
-	ard_session[i].local_format_block = NULL;
-
-	ardsession[session_id] = &ard_session[i];
-
-	mutex_lock(&ardsession[session_id]->session_mutex);
-
-	/* Commit session */
-	ard_session[i].enabled = ARD_TRUE;
-	ard_session[i].available = ARD_TRUE;
-
-	mutex_unlock(&ardsession[session_id]->session_mutex);
-
-	D("ARD Opened session_id %d, sess_opn_info(cadr) = %p\n",
-		session_id, op);
-
-	print_data(session_id);
-
-done:
-
-	return rc;
-}
-
-
-s32 ard_close(s32 session_id)
-{
-	s32					rc, dal_rc;
-	u32					dev_id, i, cad_device;
-	struct cad_stream_device_struct_type	*cadr_strm_device = NULL;
-	struct cad_stream_info_struct_type	*cadr_stream = NULL;
-	struct cadi_open_struct_type		*cadr = NULL;
-	struct cad_stream_config_struct_type	*cadr_config = NULL;
-	struct cad_stream_device_struct_type	*strm_dev = NULL;
-	struct ard_state_struct_type            *local_ard_state = NULL;
-
-	rc = dal_rc = CAD_RES_SUCCESS;
-	if (ardsession[session_id]->enabled == ARD_FALSE)
-		return rc;
-
-	/*PCM recording specific change*/
-	if (ardsession[session_id]->sess_open_info->cad_open.op_code ==
-		CAD_OPEN_OP_READ && (
-		ardsession[session_id]->sess_open_info->cad_open.format ==
-		CAD_FORMAT_PCM ||
-		ardsession[session_id]->sess_open_info->cad_open.format ==
-		CAD_FORMAT_AAC)) {
-
-		g_clk_info.open_rec_sessions -= 1;
-		g_clk_info.tx_clk_freq = 8000;
-	}
-
-	local_ard_state = &ard_state;
-	cadr = ardsession[session_id]->sess_open_info;
-	strm_dev = &cadr->cad_device;
-
-	D("ARD close ses_id %d, sess_opn_info(cadr) = %p, strm_dev = %p\n",
-		session_id, cadr, strm_dev);
-
-	print_data(session_id);
-
-	/* Disable the session */
-	ardsession[session_id]->enabled = ARD_FALSE;
-
-
-	if (ardsession[session_id]->session_type != DEVICE_CTRL_TYPE
-		&& ardsession[session_id]->active == ARD_TRUE) {
-
-		mutex_lock(&local_ard_state->ard_state_machine_mutex);
-
-		for (i = 0; i < strm_dev->device_len; i++) {
-			if (strm_dev->device[i] == CAD_HW_DEVICE_ID_DEFAULT_TX)
-				cad_device = local_ard_state->def_tx_device;
-			else if (strm_dev->device[i] ==
-					CAD_HW_DEVICE_ID_DEFAULT_RX)
-				cad_device = local_ard_state->def_rx_device;
-			else
-				/* not asking for default devices */
-				cad_device = strm_dev->device[i];
-
-			dev_id = get_device_id(cad_device);
-			if (dev_id == CAD_HW_DEVICE_ID_INVALID) {
-				pr_err("%s: unsupported device\n", __func__);
-				return CAD_RES_FAILURE;
-			}
-
-
-			/* Lock the device data*/
-			mutex_lock(&local_ard_state->ard_device[dev_id].
-				device_mutex);
-
-			/* Decrement the number of streams on this device */
-			local_ard_state->ard_device[dev_id].stream_count--;
-
-			if (local_ard_state->ard_device[dev_id].stream_count
-				== 0) {
-
-
-				/* No more streams, so teardown device */
-				local_ard_state->ard_device[dev_id].
-					device_configured = ARD_FALSE;
-
-				/* invoke the state m/c */
-				rc = ard_state_control(session_id, dev_id);
-
-			} else
-				D("Ses Closed no teardown, ses %d, dev %d,"
-						 "%d\n", session_id, dev_id,
-					local_ard_state->ard_device[dev_id].
-					stream_count);
-
-			/* Release the device data*/
-			mutex_unlock(&local_ard_state->ard_device[dev_id].
-				device_mutex);
-		}
-
-		mutex_unlock(&local_ard_state->ard_state_machine_mutex);
-
-		/* If device was torn down, session would've been removed */
-		if (ardsession[session_id]->qdsp6_opened == ARD_TRUE) {
-			/* No Device teardown, so close the QDSP6 session */
-			rc = qdsp6_close(session_id);
-			if (rc != CAD_RES_SUCCESS)
-				pr_err("ARD DAL RPC CLOSE FAILED %d\n",
-				session_id);
-		}
-	} else if (ardsession[session_id]->session_type == DEVICE_CTRL_TYPE) {
-		rc = qdsp6_close(session_id);
-		if (rc != CAD_RES_SUCCESS)
-			pr_err("ARD DAL RPC OPEN FAILED %d\n", session_id);
-	}
-
-	ardsession[session_id]->active = ARD_FALSE;
-
-	/* Start Freeing up allocated session resources */
-	/* Free the session open buffer and internal buffers */
-	cadr_strm_device = &cadr->cad_device;
-	cadr_config = &cadr->cad_config;
-	cadr_stream = &cadr->cad_stream;
-
-	cadr_strm_device->device = NULL;
-
-	D("ARD Session %d, App Type = %d, Strm Ptr = %p\n",
-		session_id, cadr_stream->app_type, cadr_stream);
-
-	if (cadr_stream->app_type != CAD_STREAM_APP_VOICE) {
-		if (ardsession[session_id]->local_format_block) {
-			D("ARD Freeing PMEM Session %d, Ptr = %p\n",
-				session_id,
-				ardsession[session_id]->local_format_block);
-			kfree(ardsession[session_id]->local_format_block);
-		}
-		ardsession[session_id]->local_format_block = NULL;
-	}
-
-	kfree(ardsession[session_id]->sess_open_info);
-	ardsession[session_id]->sess_open_info = NULL;
-
-	mutex_lock(&ardsession[session_id]->session_mutex);
-	ardsession[session_id]->available = ARD_FALSE;
-	mutex_unlock(&ardsession[session_id]->session_mutex);
-
-	return rc;
-}
-
-s32 ard_ioctl(s32 session_id, u32 cmd_code, void *cmd_buf, u32 cmd_len)
-{
-	s32					rc, dal_rc;
-	u32					dev_id, i, old_dev_stream_count;
-	u32					cad_device;
-	u32					old_device, new_device;
-	u16					sample_rate;
-	u32					clk_freq;
-	struct cad_stream_device_struct_type	*cadr_strm_device = NULL;
-	struct cad_stream_info_struct_type	*cadr_stream = NULL;
-	struct cad_stream_config_struct_type	*cadr_config = NULL;
-	struct cadi_open_struct_type		*cadr = NULL;
-	struct cad_device_struct_type		*def_device = NULL;
-	struct cad_stream_device_struct_type	*strm_dev = NULL;
-	struct ard_state_struct_type            *local_ard_state = NULL;
-	struct cad_write_pcm_format_struct_type *pcm_format_struct;
-	struct cad_write_aac_format_struct_type *aac_format_struct;
-
-	rc = dal_rc = CAD_RES_SUCCESS;
-
-	D("ARD ard_IOCTL ses %d, cmd 0X%x\n", session_id, cmd_code);
-
-	local_ard_state = &ard_state;
-
-	switch (cmd_code) {
-	case CAD_IOCTL_CMD_DEVICE_SET_GLOBAL_DEFAULT:
-		/* Command sent to change global default TX or RX device */
-		if (ardsession[session_id]->session_type != DEVICE_CTRL_TYPE) {
-			/* Log Error and do nothing */
-			pr_err("ARD IOCTL SET DEF DEV not supported Stm"
-				" ses %d\n", session_id);
-			break;
-		}
-
-		def_device = (struct cad_device_struct_type *)cmd_buf;
-
-		/* Only one device can be setup at a given time */
-		mutex_lock(&local_ard_state->ard_state_machine_mutex);
-
-		/* Set the device requeste */
-		if (def_device->reserved == CAD_RX_DEVICE) {
-			dev_id = get_device_id
-				(local_ard_state->def_rx_device);
-			local_ard_state->new_rx_device
-				= def_device->device;
-		} else {
-			dev_id = get_device_id
-				(local_ard_state->def_tx_device);
-			local_ard_state->new_tx_device
-				= def_device->device;
-		}
-
-		if (dev_id == CAD_HW_DEVICE_ID_INVALID) {
-			pr_err("%s: unsupported device\n", __func__);
-			mutex_unlock(&local_ard_state->
-				ard_state_machine_mutex);
-			return CAD_RES_FAILURE;
-		}
-
-		if ((local_ard_state->ard_device[dev_id].device_inuse
-			== def_device->device &&
-			!def_device->force_update) ||
-			(CAD_HW_DEVICE_ID_DEFAULT_TX ==
-			def_device->device) ||
-			(CAD_HW_DEVICE_ID_DEFAULT_RX ==
-			def_device->device)) {
-
-			/* Do nothing */
-			D("ARD Device Change not required\n");
-			mutex_unlock(&local_ard_state->
-				ard_state_machine_mutex);
-			break;
-		}
-
-		/* Grab Mutex and set Device In Use */
-		mutex_lock(&local_ard_state->ard_device[dev_id].
-			device_mutex);
-
-		old_dev_stream_count = local_ard_state->
-			ard_device[dev_id].stream_count;
-
-		if (old_dev_stream_count != 0) {
-			/* Teardown the current default device */
-			local_ard_state->ard_device[dev_id].
-				device_change_request = ARD_TRUE;
-			local_ard_state->ard_device[dev_id].
-				device_config_request = ARD_TRUE;
-
-			/* Check if device needs setup/teardown */
-			rc = ard_state_control(session_id, dev_id);
-
-			/* Device Torn Down, clear stream count */
-			local_ard_state->ard_device[dev_id].
-				stream_count = 0;
-		}
-
-		/* Release mutex */
-		mutex_unlock(&local_ard_state->
-			ard_device[dev_id].device_mutex);
-
-
-		/* Set device to the default device and */
-		/* get new dev_id */
-		if (def_device->reserved == CAD_RX_DEVICE) {
-			local_ard_state->def_rx_device =
-				def_device->device;
-			dev_id = get_device_id(
-				local_ard_state->
-				def_rx_device);
-			if (dev_id == CAD_HW_DEVICE_ID_INVALID) {
-				pr_err("%s: unsupported device\n", __func__);
-				return CAD_RES_FAILURE;
-			}
-
-			/* Grab the Device Mutex and set */
-			/* Device In Use */
-			mutex_lock(&local_ard_state->ard_device
-				[dev_id].device_mutex);
-
-			local_ard_state->ard_device[dev_id].device_type
-				= CAD_RX_DEVICE;
-			/* set the stream device to the */
-			/* requested device */
-			local_ard_state->ard_device[dev_id].
-				device_inuse =
-				local_ard_state->new_rx_device;
-
-			old_device = local_ard_state->def_rx_device;
-		} else {
-			local_ard_state->def_tx_device =
-				def_device->device;
-			dev_id = get_device_id(
-				local_ard_state->
-				def_tx_device);
-			if (dev_id == CAD_HW_DEVICE_ID_INVALID) {
-				pr_err("%s: unsupported device\n", __func__);
-				return CAD_RES_FAILURE;
-			}
-
-			/* Grab the Device Mutex and set */
-			/* Device In Use */
-			mutex_lock(&local_ard_state->ard_device
-				[dev_id].device_mutex);
-
-			local_ard_state->ard_device[dev_id].device_type
-				= CAD_TX_DEVICE;
-			/* set the stream device to the */
-			/* requested device */
-			local_ard_state->ard_device[dev_id].
-				device_inuse =
-				local_ard_state->new_tx_device;
-
-			old_device = local_ard_state->def_tx_device;
-		}
-		new_device = def_device->device;
-
-		ard_acdb_send_cal(session_id, new_device, old_device);
-
-		/* Begin new device setup */
-		if ((device_needs_setup(local_ard_state->
-			ard_device[dev_id].device_inuse)
-			== ARD_TRUE) &&
-			(valid_session_present(dev_id) == ARD_TRUE)) {
-			/* Setup for the new device */
-			rc = ard_state_control(session_id,
-				dev_id);
-			local_ard_state->ard_device[dev_id].
-				stream_count =
-				old_dev_stream_count;
-		} else {
-			/* Either the Device is setup and */
-			/* being used by stream(s) [OR] */
-			/* there are no Streams present */
-			/* at this time, so simply */
-			/* communicate device change to QDSP6 */
-			local_ard_state->ard_device[dev_id].
-				stream_count +=
-				old_dev_stream_count;
-
-			D("Dev setup or no strms, dev %d\n",
-				local_ard_state->ard_device[dev_id].
-				device_inuse);
-
-			/* Go ahead and open a Q6 Dev_Ctrl */
-			/* Session & send the Q6 dev chg */
-			/* notification Open QDSP6 session */
-			rc = qdsp6_open(session_id);
-			if (rc != CAD_RES_SUCCESS) {
-				/* Log Error and do nothing */
-				pr_err("Q6 OPEN FAILED %d\n",
-					session_id);
-				goto done;
-			}
-
-			rc = qdsp6_devchg_notify(session_id,
-				dev_id);
-			if (rc != CAD_RES_SUCCESS) {
-				/* Log Error and do nothing */
-				pr_err("Q6 DEV_CHG FAILED %d\n",
-					session_id);
-				qdsp6_close(session_id);
-				goto done;
-			}
-
-			rc = qdsp6_standby(session_id);
-			if (rc != CAD_RES_SUCCESS) {
-				/* Log Error and do nothing */
-				pr_err("Q6 STANDBY FAILED %d\n",
-					session_id);
-				qdsp6_close(session_id);
-				goto done;
-			}
-
-			rc = qdsp6_start(session_id);
-			if (rc != CAD_RES_SUCCESS) {
-				/* Log Error and do nothing */
-				pr_err("Q6 START FAILED %d\n",
-					session_id);
-				qdsp6_close(session_id);
-				goto done;
-			}
-		}
-
-		/* New devices setup, so update def device. */
-		if (def_device->reserved == CAD_RX_DEVICE)
-			local_ard_state->def_rx_device =
-					local_ard_state->new_rx_device;
-		else
-			local_ard_state->def_tx_device =
-					local_ard_state->new_tx_device;
-
-
-
-		/* Release mutex */
-		mutex_unlock(&local_ard_state->
-			ard_device[dev_id].device_mutex);
-
-		/* Release mutex */
-		mutex_unlock(&local_ard_state->
-			ard_state_machine_mutex);
-
-		print_data(session_id);
-
-		break;
-
-	case CAD_IOCTL_CMD_STREAM_START:
-		if (ardsession[session_id]->session_type != STREAM_TYPE) {
-			/* Log Error and do nothing */
-			D("STREAM_START called for device session"
-				" ses: %d\n", session_id);
-			rc = qdsp6_open(session_id);
-			if (rc != CAD_RES_SUCCESS)
-				pr_err("ARD DAL RPC OPEN FAILED %d\n",
-					session_id);
-			else
-				device_control_session = session_id;
-
-			break;
-		}
-
-		/* Check if this stream session has any device setup */
-		/* needs. Such as: Sampling Rate change, Devices */
-		/* Requested if not, don't call the device setup */
-		/* state m/c */
-		cadr = ardsession[session_id]->sess_open_info;
-		strm_dev = &(cadr->cad_device);
-
-		D("ard_ioctl START cadr %p, strm_dev %p\n", cadr, strm_dev);
-
-		D("ARD STREAM START IOCTL, sess %d, num devices = %d\n",
-			session_id, strm_dev->device_len);
-
-		mutex_lock(&local_ard_state->ard_state_machine_mutex);
-
-		for (i = 0; i < strm_dev->device_len; i++) {
-			if (strm_dev->device[i] == CAD_HW_DEVICE_ID_DEFAULT_TX)
-				cad_device = local_ard_state->def_tx_device;
-
-			else if (strm_dev->device[i]
-					== CAD_HW_DEVICE_ID_DEFAULT_RX)
-				cad_device = local_ard_state->def_rx_device;
-			else
-				/* not asking for default devices */
-				cad_device = strm_dev->device[i];
-
-			dev_id = get_device_id(cad_device);
-			if (dev_id == CAD_HW_DEVICE_ID_INVALID) {
-				pr_err("%s: unsupported device\n", __func__);
-				mutex_unlock(&local_ard_state->
-					ard_state_machine_mutex);
-				return CAD_RES_FAILURE;
-			}
-
-			/* Grab the Device mutex so that no updates */
-			/* are allowed to the device data */
-			mutex_lock(&local_ard_state->ard_device[dev_id].
-				device_mutex);
-
-			if ((check_sampling_rate() == ARD_TRUE) ||
-				(device_needs_setup(cad_device) == ARD_TRUE)) {
-				/* Session has a new sampling rate */
-				/* requirement or has new device(s) */
-				/* that need to be setup, so go */
-				/* ahead and grab the Device Mutex */
-				/* and setup Device requested */
-
-				/* set the stream device to the */
-				/* requested device */
-				local_ard_state->ard_device[dev_id].
-					device_inuse = cad_device;
-
-				rc = ard_state_control(session_id,
-					dev_id);
-
-			}
-
-			/* Release the device mutex */
-			mutex_unlock(&local_ard_state->ard_device[dev_id].
-				device_mutex);
-
-		}
-
-		/* Release mutex */
-		mutex_unlock(&local_ard_state->ard_state_machine_mutex);
-
-		/* If Device needed setup, the Q6 would've been */
-		/* Opened for this session if not, then go  */
-		/* ahead and open & send the Q6 info */
-		if (ardsession[session_id]->qdsp6_opened != ARD_TRUE) {
-			/* Open QDSP6 session */
-			rc = qdsp6_open(session_id);
-
-			if (rc != CAD_RES_SUCCESS) {
-				/* Log Error and do nothing */
-				pr_err("ARD DAL RPC OPEN FAILED %d\n",
-					session_id);
-				goto done;
-			}
-
-			rc = qdsp6_standby(session_id);
-			if (rc != CAD_RES_SUCCESS) {
-				/* Log Error and do nothing */
-				pr_err("ARD IOCTL STANDBY FAILED %d\n",
-					session_id);
-				qdsp6_close(session_id);
-				goto done;
-			}
-
-			rc = qdsp6_start(session_id);
-			if (rc != CAD_RES_SUCCESS) {
-				/* Log Error and do nothing */
-				pr_err("ARD IOCTL START FAILED %d\n",
-					session_id);
-				qdsp6_close(session_id);
-				goto done;
-			}
-		}
-
-		/* We don't know which of the devices are default device.
-		   Also, the stream can request more than one device */
-		for (i = 0; i < strm_dev->device_len; i++) {
-			if (strm_dev->device[i] == CAD_HW_DEVICE_ID_DEFAULT_TX)
-				cad_device = local_ard_state->def_tx_device;
-			else if (strm_dev->device[i] ==
-					CAD_HW_DEVICE_ID_DEFAULT_RX)
-				cad_device = local_ard_state->def_rx_device;
-			else
-				/* not asking for default devices */
-				cad_device = strm_dev->device[i];
-
-			dev_id = get_device_id(cad_device);
-			if (dev_id == CAD_HW_DEVICE_ID_INVALID) {
-				pr_err("%s: unsupported device\n", __func__);
-				return CAD_RES_FAILURE;
-			}
-
-			/* Grab the route mutex so that no updates are allowed
-			   to the route data. */
-			mutex_lock(&local_ard_state->ard_device[dev_id].
-				device_mutex);
-
-			ardsession[session_id]->active = ARD_TRUE;
-			local_ard_state->ard_device[dev_id].stream_count++;
-
-			mutex_unlock(&local_ard_state->ard_device[dev_id].
-				device_mutex);
-		}
-
-
-		D("ard_ioctl STARTED ses %d, cadr = %p, strm_dev = %p\n",
-			session_id, cadr, strm_dev);
-
-		print_data(session_id);
-
-		break;
-
-	case CAD_IOCTL_CMD_SET_STREAM_DEVICE:
-
-		/* At this point Cache/Store the stream Device ID info to
-			send later to Q6 */
-		if (ardsession[session_id]->session_type == DEVICE_CTRL_TYPE) {
-			pr_err("ARD: recieved strm start for dev ctrl ses\n");
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		cadr = ardsession[session_id]->sess_open_info;
-		cadr_strm_device = &(cadr->cad_device);
-
-		if (cmd_buf == NULL) {
-			pr_err("ARD bad value passed as stream device\n");
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		strm_dev = (struct cad_stream_device_struct_type *)cmd_buf;
-
-		cadr_strm_device->device =
-			kmalloc((sizeof(u32) * strm_dev->device_len),
-			GFP_KERNEL);
-
-		if (cadr_strm_device->device == NULL) {
-			/* Log Error and do nothing */
-			pr_err("ARD IOCTL CMD STREAM DEVICE Memory is"
-				" NULL %d\n", session_id);
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		/* Save the cmdbuff passed in */
-		memcpy(cadr_strm_device->device, strm_dev->device,
-			(sizeof(u32) * strm_dev->device_len));
-		cadr_strm_device->device_len = strm_dev->device_len;
-
-
-		D("ard_ioctl STRM DEV SET ses %d, cadr = %p, strm_dev = %p\n",
-			session_id, cadr, cadr_strm_device);
-
-		if (strm_dev->device[0] == CAD_HW_DEVICE_ID_DEFAULT_TX)
-			dev_id = ard_state.def_tx_device;
-		else if (strm_dev->device[0] == CAD_HW_DEVICE_ID_DEFAULT_RX)
-			dev_id = ard_state.def_rx_device;
-		else
-			dev_id = strm_dev->device[0];
-
-		ard_acdb_send_cal(session_id, dev_id, 0);
-		print_data(session_id);
-		break;
-
-	case CAD_IOCTL_CMD_SET_STREAM_INFO:
-		/* Cache/Store the stream Device ID info to send later to Q6 */
-		cadr = ardsession[session_id]->sess_open_info;
-		cadr_stream = &(cadr->cad_stream);
-
-		/* Save the cmdbuff passed in */
-		if (cmd_buf == NULL) {
-			/* Log Error and do nothing */
-			pr_err("ARD IOCTL CMD STREAM INFO cmdBuff is NULL %d\n",
-				session_id);
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		memcpy(cadr_stream, cmd_buf, cmd_len);
-
-		if (cadr_stream->app_type == CAD_STREAM_APP_VOICE &&
-			ardsession[session_id]->sess_open_info->cad_open.op_code
-			== CAD_OPEN_OP_READ) {
-
-			if (g_clk_info.tx_clk_freq != 8000)
-				for (i = 0; i < ARD_AUDIO_MAX_CLIENT; i++)
-					if (ardsession[i] &&
-						ardsession[i]->sess_open_info
-						->cad_open.op_code
-						== CAD_OPEN_OP_READ
-						&& i != session_id)
-						ard_close(i);
-
-			g_clk_info.open_rec_sessions += 1;
-
-		}
-
-		D("ard_ioctl STRM INFO SET ses %d, sess_opn_info(cadr) = %p\n",
-			session_id, cadr);
-
-		print_data(session_id);
-		break;
-
-	case CAD_IOCTL_CMD_SET_STREAM_CONFIG:
-		cadr = ardsession[session_id]->sess_open_info;
-		cadr_config = &(cadr->cad_config);
-
-		if (cmd_buf == NULL) {
-			pr_err("ARD bad value passed as format block\n");
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		cadr_config->format_block = kmalloc(cmd_len, GFP_KERNEL);
-
-		if (cadr_config->format_block == NULL) {
-			pr_err("ARD format block allocation failed\n");
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		memcpy(cadr_config->format_block, cmd_buf, cmd_len);
-		cadr_config->format_block_len = cmd_len;
-
-		D("ard_ioctl STRM CFG SET ses %d, sess_opn_info(cadr) = %p\n",
-			session_id, cadr);
-
-		if ((ardsession[session_id]->sess_open_info->cad_open.format ==
-			CAD_FORMAT_PCM ||
-			ardsession[session_id]->sess_open_info->cad_open.format
-			== CAD_FORMAT_AAC) &&
-			ardsession[session_id]->sess_open_info->cad_open.op_code
-			== CAD_OPEN_OP_READ) {
-
-			if (ardsession[session_id]->sess_open_info->
-				cad_open.format == CAD_FORMAT_PCM) {
-
-				pcm_format_struct = cmd_buf;
-				sample_rate = pcm_format_struct->
-							pcm.us_sample_rate;
-			} else {
-
-				aac_format_struct = cmd_buf;
-				sample_rate = aac_format_struct->
-							aac.sample_rate;
-			}
-
-			switch (sample_rate) {
-
-			case 0:
-				clk_freq = 96000;
-				break;
-			case 1:
-				clk_freq = 88200;
-				break;
-			case 2:
-				clk_freq = 64000;
-				break;
-			case 3:
-				clk_freq = 48000;
-				break;
-			case 4:
-				clk_freq = 44100;
-				break;
-			case 5:
-				clk_freq = 32000;
-				break;
-			case 6:
-				clk_freq = 24000;
-				break;
-			case 7:
-				clk_freq = 22050;
-				break;
-			case 8:
-				clk_freq = 16000;
-				break;
-			case 9:
-				clk_freq = 12000;
-				break;
-			case 10:
-				clk_freq = 11025;
-				break;
-			case 11:
-			default:
-				clk_freq = 8000;
-				break;
-			}
-
-			if (g_clk_info.open_rec_sessions > 0 &&
-					g_clk_info.tx_clk_freq != clk_freq) {
-
-				rc = CAD_RES_FAILURE;
-				pr_err("clk mismatch with current recording\n");
-				break;
-			} else
-				g_clk_info.tx_clk_freq = clk_freq;
-
-			g_clk_info.open_rec_sessions += 1;
-
-		}
-		print_data(session_id);
-		break;
-
-	default:
-		/* Just silently succeed unrecognized IOCTLs. */
-		break;
-	}
-
-done:
-	return rc;
-}
-
-
-s32 ard_read(s32 session_id, struct cad_buf_struct_type *buf)
-{
-	return CAD_RES_SUCCESS;
-}
-
-s32 ard_write(s32 session_id, struct cad_buf_struct_type *buf)
-{
-	return CAD_RES_SUCCESS;
-}
-
-void ard_callback_func(union adsp_audio_event *ev_data, void *client_data)
-{
-}
-
-
-
-enum ard_state_ret_enum_type ard_state_control(s32 session_id, u32 dev_id)
-{
-	enum ard_state_ret_enum_type	rc;
-	struct ard_state_struct_type	*local_ard_state = NULL;
-
-	rc = ARD_STATE_RC_SUCCESS;
-
-
-	local_ard_state = &ard_state;
-
-	do {
-		D("ARD SM session_id %d, ard state %d\n",
-			session_id, local_ard_state->ard_device[dev_id].state);
-
-		switch (local_ard_state->ard_device[dev_id].state) {
-		case ARD_STATE_RESET:
-			rc = ard_state_reset(session_id, dev_id);
-			break;
-		case ARD_STATE_CLK_ACTIVE:
-			rc = ard_state_clk_active(session_id, dev_id);
-			break;
-		case ARD_STATE_AFE_ACTIVE:
-			rc = ard_state_afe_active(session_id, dev_id);
-			break;
-		case ARD_STATE_ACTIVE:
-			rc = ard_state_active(session_id, dev_id);
-			break;
-		default:
-			break;
-		}
-	} while (rc == ARD_STATE_RC_CONTINUE);
-
-	return rc;
-}
-
-
-
-enum ard_state_ret_enum_type ard_state_reset(s32 session_id, u32 dev_id)
-{
-	enum ard_state_ret_enum_type	rc;
-	struct ard_state_struct_type	*local_ard_state = NULL;
-
-	rc = ARD_STATE_RC_SUCCESS;
-
-	local_ard_state = &ard_state;
-
-	if (valid_session_present(dev_id)) {
-		local_ard_state->ard_device[dev_id].state
-			= ARD_STATE_CLK_ACTIVE;
-
-		if (local_ard_state->ard_device[dev_id].clk_configured
-			!= ARD_TRUE) {
-
-			ard_clk_enable(dev_id);
-			local_ard_state->ard_device[dev_id].clk_configured =
-				ARD_TRUE;
-
-			D("ARD - Setup: Enabled clocks dev_id %d\n", dev_id);
-		} else
-			D("ARD - Setup: CLKs Already Enabled, dev_id %d\n",
-				dev_id);
-
-
-		rc = ARD_STATE_RC_CONTINUE;
-	}
-	return rc;
-}
-
-enum ard_state_ret_enum_type ard_state_clk_active(s32 session_id, u32 dev_id)
-{
-	s32				res;
-	enum ard_state_ret_enum_type	rc;
-	enum codec_enum_type		codec_type;
-	struct ard_state_struct_type	*local_ard_state = NULL;
-
-	rc = ARD_STATE_RC_SUCCESS;
-	codec_type = CODEC_INT;
-	res = CAD_RES_SUCCESS;
-
-
-	local_ard_state = &ard_state;
-
-	codec_type = get_codec_type((u32)local_ard_state->ard_device[dev_id].
-		device_inuse);
-
-	if ((!valid_session_present(dev_id)) ||
-		(local_ard_state->ard_device[dev_id].clk_configured
-		!= ARD_TRUE)) {
-
-		D("ARD - Teardown: Disabling clocks, ses %d\n", session_id);
-		ard_clk_disable(dev_id);
-		local_ard_state->ard_device[dev_id].clk_configured = ARD_FALSE;
-		local_ard_state->ard_device[dev_id].state = ARD_STATE_RESET;
-		rc = ARD_STATE_RC_SUCCESS;
-		goto done;
-	}
-
-	/* Ready to Open and Start Q6(enable AFE). It is */
-	/* assumed that this will 0 fill PCM buffers */
-	res = qdsp6_open(session_id);
-	if (res == CAD_RES_FAILURE) {
-		pr_err("ARD - Unable to Open QDSP6 in session %d\n",
-			session_id);
-
-		ard_clk_disable(dev_id);
-		local_ard_state->ard_device[dev_id].clk_configured = ARD_FALSE;
-		local_ard_state->ard_device[dev_id].state = ARD_STATE_RESET;
-		rc = ARD_STATE_RC_SUCCESS;
-		goto done;
-	}
-
-	res = qdsp6_standby(session_id);
-	if (res == CAD_RES_FAILURE) {
-		pr_err("ARD - Unable to STANDBY QDSP6 in session %d\n",
-			session_id);
-		qdsp6_close(session_id);
-		ard_clk_disable(dev_id);
-		local_ard_state->ard_device[dev_id].clk_configured = ARD_FALSE;
-		local_ard_state->ard_device[dev_id].state = ARD_STATE_RESET;
-		rc = ARD_STATE_RC_SUCCESS;
-		goto done;
-	}
-
-	D("ARD - Setup: Standby Q6, ses %d\n", session_id);
-	local_ard_state->ard_device[dev_id].afe_enabled = ARD_TRUE;
-	local_ard_state->ard_device[dev_id].state = ARD_STATE_AFE_ACTIVE;
-	rc = ARD_STATE_RC_CONTINUE;
-
-done:
-	return rc;
-}
-
-enum ard_state_ret_enum_type ard_state_afe_active(s32 session_id, u32 dev_id)
-{
-	s32				res;
-	enum ard_state_ret_enum_type	rc;
-	enum codec_enum_type		codec_type;
-	struct ard_state_struct_type	*local_ard_state = NULL;
-
-	rc = ARD_STATE_RC_SUCCESS;
-	res = CAD_RES_SUCCESS;
-
-	local_ard_state = &ard_state;
-
-	if ((!valid_session_present(dev_id)) || (local_ard_state->
-		ard_device[dev_id].afe_enabled != ARD_TRUE)) {
-
-		D("ARD - Teardown: Disabling Q6\n");
-		qdsp6_close(session_id);
-		local_ard_state->ard_device[dev_id].clk_configured = ARD_FALSE;
-		local_ard_state->ard_device[dev_id].state
-			= ARD_STATE_CLK_ACTIVE;
-		rc = ARD_STATE_RC_CONTINUE;
-		goto done;
-	}
-
-	codec_type = get_codec_type(local_ard_state->
-		ard_device[dev_id].device_inuse);
-
-	res = codec_enable(codec_type,
-		(u32)local_ard_state->ard_device[dev_id].device_type,
-		local_ard_state->ard_device[dev_id].device_inuse);
-
-	if (res == CAD_RES_FAILURE) {
-		/* Failed to setup Codec. Go back to previous state */
-		pr_err("ARD Codec setup failed, state %d\n",
-			local_ard_state->ard_device[dev_id].state);
-		/* Disable QDSP6/AFE */
-		qdsp6_close(session_id);
-		local_ard_state->ard_device[dev_id].clk_configured = ARD_FALSE;
-		/* Goto previous state */
-		local_ard_state->ard_device[dev_id].state
-			= ARD_STATE_CLK_ACTIVE;
-		rc = ARD_STATE_RC_CONTINUE;
-		goto done;
-	}
-
-	D("ARD - Setup: Enabled ADIE\n");
-	local_ard_state->ard_device[dev_id].device_configured = ARD_TRUE;
-	local_ard_state->ard_device[dev_id].state = ARD_STATE_ACTIVE;
-	local_ard_state->ard_device[dev_id].device_config_request = ARD_FALSE;
-	rc = ARD_STATE_RC_CONTINUE;
-
-done:
-	return rc;
-}
-
-enum ard_state_ret_enum_type ard_state_active(s32 session_id, u32 dev_id)
-{
-	s32				res;
-	enum ard_state_ret_enum_type	rc;
-	enum codec_enum_type		codec_type;
-	struct ard_state_struct_type	*local_ard_state = NULL;
-
-	rc = ARD_STATE_RC_SUCCESS;
-	res = CAD_RES_SUCCESS;
-
-	local_ard_state = &ard_state;
-	codec_type = get_codec_type(local_ard_state->ard_device[dev_id].
-		device_inuse);
-
-	if ((!valid_session_present(dev_id)) ||
-		(local_ard_state->ard_device[dev_id].device_configured
-		!= ARD_TRUE)) {
-
-		D("ARD - Teardown: Disabling CODEC, ses %d\n", session_id);
-		res = codec_disable(codec_type,
-			(u32)local_ard_state->ard_device[dev_id].device_type,
-			local_ard_state->ard_device[dev_id].device_inuse);
-
-		local_ard_state->ard_device[dev_id].afe_enabled = ARD_FALSE;
-		local_ard_state->ard_device[dev_id].state
-			= ARD_STATE_AFE_ACTIVE;
-		rc = ARD_STATE_RC_CONTINUE;
-		goto done;
-	}
-
-	if (local_ard_state->ard_device[dev_id].device_config_request
-		== ARD_TRUE) {
-
-		/* see if ADIE needs to be torn down, w/o closing Q6 sessions */
-		if (local_ard_state->ard_device[dev_id].device_change_request
-			== ARD_TRUE) {
-			D("Reconfig: Notify Q6, Disable ADIE & Clocks,"
-				" ses %d\n", session_id);
-
-			/* Notify Q6 of impending device change, payload */
-			/* can contain new Device ID. Q6 will play out */
-			/* buffers and perhaps 0 fill AFE*/
-			qdsp6_devchg_notify(session_id, dev_id);
-
-			/* Tear down codec for the current device in use */
-			res = codec_disable(codec_type,
-				local_ard_state->ard_device[dev_id].device_type,
-				local_ard_state->ard_device[dev_id].
-				device_inuse);
-
-			local_ard_state->ard_device[dev_id].dsp_started
-				= ARD_FALSE;
-
-			/* Clocks need reconfig, so simply disable clocks */
-			/* and goto reset state to start from beginning */
-			ard_clk_disable(dev_id);
-			local_ard_state->ard_device[dev_id].state
-				= ARD_STATE_RESET;
-			local_ard_state->ard_device[dev_id].
-				device_change_request = ARD_FALSE;
-			local_ard_state->ard_device[dev_id].device_configured
-				= ARD_FALSE;
-			local_ard_state->ard_device[dev_id].
-				device_config_request = ARD_FALSE;
-			local_ard_state->ard_device[dev_id].clk_configured
-				= ARD_FALSE;
-			local_ard_state->ard_device[dev_id].
-				afe_enabled = ARD_FALSE;
-			rc = ARD_STATE_RC_SUCCESS;
-		} else {
-			/* Do Nothing as Devices are not different */
-			D("Device Config Request w new & old device"
-				" for ses %d\n", session_id);
-			local_ard_state->ard_device[dev_id].
-				device_config_request = ARD_FALSE;
-			rc = ARD_STATE_RC_SUCCESS;
-		}
-	} else {
-		/* No reconfig request */
-		D("ARD - No Device (re)config for this session %d\n",
-			session_id);
-
-		/* Start the Q6 */
-		if (ardsession[session_id]->qdsp6_started != ARD_TRUE) {
-			res = qdsp6_start(session_id);
-			if (res != CAD_RES_FAILURE) {
-				D("ARD-Setup: Started Q6, ses %d\n",
-					session_id);
-				if (ardsession[session_id]->session_type
-					== STREAM_TYPE)
-
-					ardsession[session_id]->qdsp6_started
-					= ARD_TRUE;
-
-				rc = ARD_STATE_RC_SUCCESS;
-			} else {
-				qdsp6_close(session_id);
-				res = codec_disable(codec_type,
-					local_ard_state->ard_device[dev_id].
-					device_type,
-					local_ard_state->ard_device[dev_id].
-					device_inuse);
-				local_ard_state->ard_device[dev_id].afe_enabled
-					= ARD_FALSE;
-				local_ard_state->ard_device[dev_id].state
-					= ARD_STATE_AFE_ACTIVE;
-				rc = ARD_STATE_RC_CONTINUE;
-			}
-		}
-	}
-
-done:
-	return rc;
-}
-
-enum ard_ret_enum_type valid_session_present(u32 dev_id)
-{
-	u8 i = 0;
-	enum ard_ret_enum_type rc;
-
-	rc = ARD_FALSE;
-
-	/* Check if there are any valid stream sessions. */
-	switch (dev_id) {
-	case 0:
-	case 2:
-	case 4:	/* A2DP */
-	case 6:	/* I2S */
-		for (i = 0; i < ARD_AUDIO_MAX_CLIENT; i++) {
-			if ((ard_session[i].enabled == ARD_TRUE)
-				&& (ard_session[i].sess_open_info->
-					cad_open.op_code
-						== CAD_OPEN_OP_WRITE)) {
-				/* Valid RX stream exists. */
-				rc = ARD_TRUE;
-				break;
-			}
-		}
-		break;
-	case 1:
-	case 3:
-	case 5:	/* A2DP */
-	case 7:	/* I2S */
-		for (i = 0; i < ARD_AUDIO_MAX_CLIENT; i++) {
-			if ((ard_session[i].enabled == ARD_TRUE)
-				&& (ard_session[i].sess_open_info->
-					cad_open.op_code
-						== CAD_OPEN_OP_READ)) {
-				/* Valid TX stream exists. */
-				rc = ARD_TRUE;
-				break;
-			}
-		}
-		break;
-	default:
-		pr_err("valid_session_present(): bad device_id %d\n", dev_id);
-	}
-
-	if (i == ARD_AUDIO_MAX_CLIENT) {
-		rc = ARD_FALSE;
-		D("ARD No Stream sessions\n");
-	}
-
-	return rc;
-}
-
-enum ard_ret_enum_type check_sampling_rate(void)
-{
-	return ARD_FALSE;
-}
-
-enum ard_ret_enum_type device_needs_setup(u32 cad_device)
-{
-	u32				dev_id;
-	enum ard_ret_enum_type		rc;
-	struct ard_state_struct_type	*local_ard_state = NULL;
-
-	rc = ARD_TRUE;
-
-	local_ard_state = &ard_state;
-
-	for (dev_id = 0; dev_id < MAX_NUM_DEVICES; dev_id++) {
-		if ((local_ard_state->ard_device[dev_id].device_configured) &&
-			(local_ard_state->ard_device[dev_id].device_inuse ==
-			cad_device)) {
-
-			/* Device Is In Use and has been configured*/
-			rc = ARD_FALSE;
-			break;
-		}
-	}
-
-	return rc;
-}
-
-
-void print_data(u32 session_id)
-{
-	struct cadi_open_struct_type            *cadr = NULL;
-	struct cad_stream_info_struct_type      *cadr_stream = NULL;
-	struct cad_stream_config_struct_type    *cadr_config = NULL;
-	struct cad_stream_device_struct_type    *strm_dev = NULL;
-	struct cad_open_struct_type             *cad_open = NULL;
-
-	cadr = ardsession[session_id]->sess_open_info;
-
-	cad_open = &(cadr->cad_open);
-	D("ARD session_id %d cad_open->op_code %d\n", session_id,
-		cad_open->op_code);
-	D("ARD session_id %d cad_open->format %d\n", session_id,
-		cad_open->format);
-
-	cadr_config = &(cadr->cad_config);
-	D("ARD session_id %d cadr_config %p\n", session_id, cadr_config);
-
-	cadr_stream = &(cadr->cad_stream);
-	D("ARD session_id %d cadr_stream->app_type %d\n",
-		session_id, cadr_stream->app_type);
-	D("ARD session_id %d cadr_stream->ses_buf_max_size %d\n",
-		session_id, cadr_stream->ses_buf_max_size);
-	D("ARD session_id %d cadr_stream->buf_mem_type %d\n",
-		session_id, cadr_stream->buf_mem_type);
-	D("ARD session_id %d cadr_stream->priority %d\n",
-		session_id, cadr_stream->priority);
-
-	strm_dev = &(cadr->cad_device);
-	D("ARD session_id %d strm_dev->device %p\n", session_id,
-		strm_dev->device);
-	D("ARD session_id %d strm_dev->device_len %d\n", session_id,
-		strm_dev->device_len);
-
-}
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_ard_acdb.c b/arch/arm/mach-msm/qdsp6/msm8k_ard_acdb.c
deleted file mode 100644
index 63667fa..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_ard_acdb.c
+++ /dev/null
@@ -1,342 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/slab.h>
-
-#include <mach/dal.h>
-#include <mach/qdsp6/msm8k_ard_acdb.h>
-#include <mach/qdsp6/msm8k_ard_acdbi.h>
-#include <mach/qdsp6/msm8k_ardi.h>
-#include <mach/qdsp6/msm8k_ard_helper.h>
-#include <mach/qdsp6/msm8k_adsp_audio_cfg_ioctl.h>
-#include <mach/qdsp6/msm8k_adsp_audio_error.h>
-#include <mach/qdsp6/msm8k_q6_api_flip_utils.h>
-
-
-/* this is the ACDB device ID */
-#define DALDEVICEID_ACDB		0x02000069
-#define ACDB_PORT_NAME			"SMD_DAL_AM_AUD"
-#define ACDB_CPU			0 /* SMD_TYPE_APPS_MODEM */
-
-/* rpc table index */
-enum {
-	ACDB_DalACDB_ioctl = DALDEVICE_FIRST_DEVICE_API_IDX
-};
-
-
-/* this is the default acdb data buffer size */
-#define ARD_ACDB_DEFAULT_BUF_SIZE	4096
-#define ARD_ACDB_BUF_OFFSET		0x190000
-
-/* this defines the sampel rate */
-enum ard_acdb_sample_rate {
-	ARD_ACDB_SR_INVALID	= 0,
-	ARD_ACDB_SR_8K_HZ	= 8000,
-	ARD_ACDB_SR_16k_HZ	= 16000,
-	ARD_ACDB_SR_24K_HZ	= 24000,
-	ARD_ACDB_SR_48K_HZ	= 48000,
-	ARD_ACDB_SR_96K_HZ	= 96000
-};
-
-
-static void		*acdb_handle;
-static void		*ard_acdb_buffer;
-
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_cad: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-
-
-/* this function calcuate the sample rate for TX session*/
-enum ard_acdb_sample_rate	ard_acdb_calculate_sample_rate(u32 session_id)
-{
-	enum ard_acdb_sample_rate	sample_rate = ARD_ACDB_SR_INVALID;
-	u32				voice_exist = 0;
-	u32				i;
-
-
-	for (i = 0; i < ARD_AUDIO_MAX_CLIENT; ++i) {
-		if (ardsession[i] == NULL  ||
-			ardsession[i]->enabled != ARD_TRUE)
-
-			continue;
-
-		if ((ardsession[i]->sess_open_info)->cad_open.op_code !=
-			CAD_OPEN_OP_DEVICE_CTRL) {
-
-			if (ardsession[i]->sess_open_info->cad_stream.app_type
-				 == CAD_STREAM_APP_VOICE) {
-
-				voice_exist = 1;
-				sample_rate = ARD_ACDB_SR_8K_HZ;
-				break;
-			}
-		}
-	}
-
-	if (voice_exist != 1) {
-		if (ardsession[session_id]->sess_open_info->cad_open.format ==
-			CAD_FORMAT_PCM)
-
-			sample_rate = ARD_ACDB_SR_16k_HZ;
-
-		else if (ardsession[session_id]->sess_open_info->
-			cad_open.format == CAD_FORMAT_AAC)
-
-			sample_rate = ARD_ACDB_SR_48K_HZ;
-
-		else
-			sample_rate = ARD_ACDB_SR_8K_HZ;
-	}
-	return sample_rate;
-}
-
-
-/* this is the current sample rate selection for cad device */
-/* It will be revisited once we finalize the cad device definition*/
-u32 ard_acdb_get_sample_rate(u32 session_id, u32 route_id)
-{
-	u32	sample_rate = ARD_ACDB_SR_INVALID;
-
-	switch (route_id) {
-	case 0:
-	case 2:
-	case 4: /* A2DP */
-	case 5: /* A2DP */
-	case 6: /* I2S RX */
-		sample_rate = ARD_ACDB_SR_48K_HZ;
-		break;
-	case 1:
-		sample_rate = ard_acdb_calculate_sample_rate(session_id);
-		break;
-	case 3:
-		sample_rate = ARD_ACDB_SR_8K_HZ;
-		break;
-	/* I2S TX */
-	case 7:
-		sample_rate = ARD_ACDB_SR_16k_HZ;
-		break;
-	default:
-		pr_err("CAD:ACDB==> Unsupported route_id %d\n", route_id);
-		break;
-	}
-	D("CAD:ACDB=> device sampel rate is %d\n", sample_rate);
-	return sample_rate;
-}
-
-
-/* this function is called in once to initialize the acdb interface */
-s32 ard_acdb_init(void)
-{
-	s32 err = CAD_RES_SUCCESS;
-
-	err = daldevice_attach(DALDEVICEID_ACDB, ACDB_PORT_NAME,
-			ACDB_CPU, &acdb_handle);
-
-	if (err) {
-		pr_err("CAD:ACDB=> Device Attach failed\n");
-		goto err_1;
-	}
-
-	/*initialize local cache */
-	ard_acdb_buffer = g_audio_mem + ARD_ACDB_BUF_OFFSET;
-
-	if (ard_acdb_buffer == NULL) {
-		pr_err("CAD:ACDB=> Can not create buffers\n");
-		goto err_2;
-	}
-
-	memset(ard_acdb_buffer, 0, sizeof(ard_acdb_buffer));
-	return CAD_RES_SUCCESS;
-
-err_2:
-	daldevice_detach(acdb_handle);
-	acdb_handle = NULL;
-err_1:
-	return CAD_RES_FAILURE;
-}
-
-
-void ard_acdb_dinit(void)
-{
-	/* release memory */
-	if (ard_acdb_buffer)
-		ard_acdb_buffer = NULL;
-
-	/* dettach handle */
-	if (acdb_handle) {
-		daldevice_detach(acdb_handle);
-		acdb_handle = NULL;
-	}
-}
-
-/* this function sends the device id list to q6 */
-/* we can not get the default tx/rx device id, */
-/* the caller should do the translation */
-s32   ard_acdb_send_cal(u32 session_id, u32 new_device, u32 old_device)
-{
-	struct acbd_cmd_device_table_struct	acdb_cmd;
-	struct acdb_result_struct		acdb_cmd_result;
-	struct adsp_audio_set_dev_cfg_table_command	q6_cmd;
-	union adsp_audio_event				q6_cmd_result;
-	u32					route_id;
-	s32					err = CAD_RES_SUCCESS;
-
-	if (acdb_handle == NULL) {
-		pr_err("CAD:ACDB=> Device has not been initialized\n");
-		return CAD_RES_FAILURE;
-	}
-
-	if (device_control_session == 0) {
-		pr_err("CAD:ACDB=> Device control session does not exist\n");
-		return CAD_RES_FAILURE;
-	}
-
-	if (new_device == CAD_HW_DEVICE_ID_DEFAULT_TX ||
-		new_device == CAD_HW_DEVICE_ID_DEFAULT_RX ||
-		old_device == CAD_HW_DEVICE_ID_DEFAULT_TX ||
-		old_device == CAD_HW_DEVICE_ID_DEFAULT_RX) {
-
-		pr_err("CAD:ACDB=> Don't know what is the default device\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* query the device cal */
-	memset(&acdb_cmd, 0, sizeof(acdb_cmd));
-
-	acdb_cmd.command_id = ACDB_GET_DEVICE_TABLE;
-	acdb_cmd.device_id = new_device;
-
-	route_id = get_device_id(new_device);
-	if (route_id == CAD_HW_DEVICE_ID_INVALID) {
-		pr_err("CAD:ACDB=> Unknown devices %d\n", old_device);
-		return CAD_RES_FAILURE;
-	}
-
-	if (ard_state.ard_device[route_id].stream_count > 0)
-		acdb_cmd.sample_rate_id = ard_state.
-			ard_device[route_id].device_sample_rate;
-	else {
-		ard_state.ard_device[route_id].device_sample_rate =
-			ard_acdb_get_sample_rate(session_id, route_id);
-
-		acdb_cmd.sample_rate_id =
-			ard_state.ard_device[route_id].device_sample_rate;
-	}
-
-	if (acdb_cmd.sample_rate_id == ARD_ACDB_SR_INVALID) {
-		pr_err("CAD:ACDB=> Can not select device sample rate\n");
-		return CAD_RES_FAILURE;
-	}
-
-	acdb_cmd.total_bytes = ARD_ACDB_DEFAULT_BUF_SIZE;
-	acdb_cmd.unmapped_buf = g_audio_base + ARD_ACDB_BUF_OFFSET;
-
-	D("CAD:ACDB=>Query acdb(dev:%d, sample_rate: %d\n",
-		acdb_cmd.device_id, acdb_cmd.sample_rate_id);
-
-	/* query acdb */
-	err = dalrpc_fcn_8(ACDB_DalACDB_ioctl, acdb_handle,
-		(const void *)&acdb_cmd, sizeof(acdb_cmd),
-		&acdb_cmd_result, sizeof(acdb_cmd_result));
-	if (err) {
-		pr_err("CAD:ACDB=> Can not query acdb\n");
-		return CAD_RES_FAILURE;
-	}
-
-	if (acdb_cmd_result.result != ACDB_RES_SUCCESS) {
-		pr_err("CAD:ACDB=> Failed to query the ACDB (%d)\n",
-			acdb_cmd_result.result);
-		return CAD_RES_FAILURE;
-	}
-
-	/* push the device cal to Q6 */
-	memset(&q6_cmd, 0, sizeof(q6_cmd));
-	q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_SET_DEVICE_CONFIG_TABLE;
-	q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-	q6_cmd.device_id = q6_device_id_mapping(acdb_cmd.device_id);
-	q6_cmd.phys_mem.addr = acdb_cmd.unmapped_buf;
-	q6_cmd.phys_mem.total = acdb_cmd.total_bytes;
-	q6_cmd.phys_mem.used = acdb_cmd_result.used_bytes;
-
-	D("CAD:ACDB=>Push cal data to Q6: %d\n", q6_cmd.device_id);
-
-	err = cad_rpc_control(device_control_session,
-		ardsession[device_control_session]->group_id,
-		(void *)&q6_cmd, sizeof(q6_cmd), &q6_cmd_result);
-
-	if (err) {
-		pr_err("CAD:ACDB=> Can not push the cal data to Q6\n");
-		return CAD_RES_FAILURE;
-	}
-
-	if ((q6_cmd_result.no_payload.status != ADSP_AUDIO_SUCCESS) &&
-		(q6_cmd_result.no_payload.status !=
-			ADSP_AUDIO_EALREADYLOADED)) {
-		pr_err("CAD:ACDB=> Can not push the cal data to Q6(%d)\n",
-			q6_cmd_result.no_payload.status);
-		return CAD_RES_FAILURE;
-	}
-	return CAD_RES_SUCCESS;
-}
-
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_ard_adie.c b/arch/arm/mach-msm/qdsp6/msm8k_ard_adie.c
deleted file mode 100644
index 4ea8cda..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_ard_adie.c
+++ /dev/null
@@ -1,697 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/proc_fs.h>
-#include <linux/slab.h>
-
-#include <mach/pmic.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_ard_adiei.h>
-#include <mach/qdsp6/msm8k_adie_codec_rpc.h>
-#include <mach/qdsp6/msm8k_adie_codec_dev.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_ard_clk.h>
-#include <mach/htc_acoustic_qsd.h>
-#include <mach/msm_qdsp6_audio.h>
-
-struct adie_state_struct_type	adie_state;
-
-static bool need_turn_off_speaker;
-static bool need_turn_off_fm;
-static atomic_t force_speaker_mode = ATOMIC_INIT(0);
-static atomic_t fm_mode = ATOMIC_INIT(0);
-
-static int pmic_is_stereo;
-
-static u32 adie_spkr_mono_ref1_cnt;
-static u32 adie_spkr_stereo_ref1_cnt;
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "adie: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-static struct q6audio_analog_ops *analog_ops;
-
-void q6audio_register_analog_ops(struct q6audio_analog_ops *ops)
-{
-	analog_ops = ops;
-}
-
-void switch_bt_sco(int enable)
-{
-	if (analog_ops->bt_sco_enable)
-		analog_ops->bt_sco_enable(enable);
-}
-
-int get_force_speaker_mode(void)
-{
-	return atomic_read(&force_speaker_mode);
-}
-
-void set_force_speaker_mode(int mode)
-{
-	if (mode < 0 || mode > 1)
-		return;
-	atomic_set(&force_speaker_mode, mode);
-}
-
-int get_fm_mode(void)
-{
-	return atomic_read(&fm_mode);
-}
-
-void set_fm_mode(int mode)
-{
-	if (mode < 0 || mode > 2)
-		return;
-	atomic_set(&fm_mode, mode);
-}
-
-u32 get_path_id(u32 dev_id)
-{
-	u32 adie_path_id = 0;
-
-	switch (dev_id) {
-	case CAD_HW_DEVICE_ID_HANDSET_MIC:
-		adie_path_id = DAL_ADIE_CODEC_HANDSET_TX;
-		break;
-	case CAD_HW_DEVICE_ID_HANDSET_SPKR:
-		adie_path_id = DAL_ADIE_CODEC_HANDSET_RX;
-		break;
-	case CAD_HW_DEVICE_ID_HEADSET_MIC:
-		adie_path_id = DAL_ADIE_CODEC_HEADSET_MONO_TX;
-		break;
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO:
-		adie_path_id = DAL_ADIE_CODEC_HEADSET_MONO_RX;
-		break;
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO:
-		adie_path_id = DAL_ADIE_CODEC_HEADSET_STEREO_RX;
-		break;
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_MIC:
-		adie_path_id = DAL_ADIE_CODEC_SPEAKER_TX;
-		break;
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_MONO:
-		adie_path_id = DAL_ADIE_CODEC_SPEAKER_RX;
-		break;
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO:
-		adie_path_id = DAL_ADIE_CODEC_SPEAKER_STEREO_RX;
-		break;
-	case CAD_HW_DEVICE_ID_TTY_HEADSET_MIC:
-		adie_path_id = DAL_ADIE_CODEC_TTY_HEADSET_TX;
-		break;
-	case CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR:
-		adie_path_id = DAL_ADIE_CODEC_TTY_HEADSET_RX;
-		break;
-	case CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_STEREO_RX:
-		adie_path_id = DAL_ADIE_CODEC_SPKR_STEREO_HDPH_MONO_RX;
-		break;
-	case CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_MONO_RX:
-		adie_path_id = DAL_ADIE_CODEC_SPKR_MONO_HDPH_MONO_RX;
-		break;
-	case CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX:
-		adie_path_id = DAL_ADIE_CODEC_SPKR_MONO_HDPH_STEREO_RX;
-		break;
-	case CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_STEREO_RX:
-		adie_path_id = DAL_ADIE_CODEC_SPKR_STEREO_HDPH_STEREO_RX;
-		break;
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO_LB:
-		adie_path_id = DAL_ADIE_CODEC_AUXPGA_HDPH_STEREO_LB;
-		break;
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO_LB:
-		adie_path_id = DAL_ADIE_CODEC_AUXPGA_HDPH_MONO_LB;
-		break;
-	case CAD_HW_DEVICE_ID_SPEAKER_SPKR_STEREO_LB:
-		adie_path_id = DAL_ADIE_CODEC_AUXPGA_LINEOUT_STEREO_LB;
-		break;
-	case CAD_HW_DEVICE_ID_SPEAKER_SPKR_MONO_LB:
-		adie_path_id = DAL_ADIE_CODEC_AUXPGA_LINEOUT_MONO_LB;
-		break;
-	case CAD_HW_DEVICE_ID_BT_SCO_MIC:
-	case CAD_HW_DEVICE_ID_BT_SCO_SPKR:
-	case CAD_HW_DEVICE_ID_BT_A2DP_SPKR:
-	case CAD_HW_DEVICE_ID_BT_A2DP_TX:
-	default:
-		pr_err("ARD ADIE Paths not supported for dev_id %d\n", dev_id);
-		break;
-	}
-	return adie_path_id;
-}
-
-
-
-u32 get_path_type(u32 cad_dev_type)
-{
-	u32 adie_dev_type;
-
-	switch (cad_dev_type) {
-	case CAD_RX_DEVICE:
-		adie_dev_type = ADIE_CODEC_RX;
-		break;
-	case CAD_TX_DEVICE:
-		adie_dev_type = ADIE_CODEC_TX;
-		break;
-	default:
-		adie_dev_type = ADIE_CODEC_LB;
-		break;
-	}
-	D("ARD ADIE DEV TYPE = %d\n", adie_dev_type);
-
-	return adie_dev_type;
-}
-
-
-
-s32 adie_init(void)
-{
-	s32	dal_rc;
-	u8	dev_type;
-
-	dal_rc = CAD_RES_SUCCESS;
-	dev_type = 0;
-
-	/* NULL is ok, as it will not use the param. */
-	if (pmic_spkr_is_stereo_en(NULL))
-		pmic_is_stereo = 1;
-
-	dal_rc = daldevice_attach(DALDEVICEID_ADIE_CODEC, ADIE_CODEC_PORT_NAME,
-			ADIE_CODEC_CPU, &adie_state.adie_handle);
-	if (CAD_RES_SUCCESS != dal_rc)
-		pr_err("ARD: ADIE Device Attach failed\n");
-
-	adie_state.adie_opened = ADIE_FALSE;
-
-	/* Initialize the rest of the state variables */
-	for (dev_type = 0; dev_type < MAX_ADIE_PATH_TYPES; dev_type++) {
-		adie_state.adie_path_type[dev_type].enabled = ADIE_FALSE;
-		adie_state.adie_path_type[dev_type].enable_request = ADIE_FALSE;
-		adie_state.adie_path_type[dev_type].state = ADIE_STATE_RESET;
-	}
-
-	/* Initialize the PMIC MIC and SPKR */
-	if (analog_ops->init)
-		analog_ops->init();
-
-	return dal_rc;
-}
-
-s32 adie_dinit(void)
-{
-	s32	dal_rc;
-	u8	dev_type;
-
-	dal_rc = CAD_RES_SUCCESS;
-	dev_type = 0;
-
-	dal_rc = daldevice_detach(adie_state.adie_handle);
-	if (CAD_RES_SUCCESS != dal_rc)
-		pr_err("ARD: ADIE Device Detach failed\n");
-
-	for (dev_type = 0; dev_type < MAX_ADIE_PATH_TYPES; dev_type++) {
-		adie_state.adie_path_type[dev_type].enabled = ADIE_FALSE;
-		adie_state.adie_path_type[dev_type].enable_request = ADIE_FALSE;
-		adie_state.adie_path_type[dev_type].state = ADIE_STATE_RESET;
-	}
-
-	adie_state.adie_opened = ADIE_FALSE;
-
-	return dal_rc;
-}
-
-s32 adie_open(u32 dev_type)
-{
-	s32 cad_rc, dal_rc;
-
-	cad_rc = dal_rc = CAD_RES_SUCCESS;
-
-
-	if (adie_state.adie_opened != ADIE_TRUE) {
-		dal_rc = daldevice_open(adie_state.adie_handle, 0);
-
-		if (dal_rc != CAD_RES_SUCCESS) {
-			pr_err("ARD ADIE DAL Open failed, dev_type = %d\n",
-				dev_type);
-			cad_rc = CAD_RES_FAILURE;
-		} else {
-			adie_state.adie_opened = ADIE_TRUE;
-			D("ARD ADIE DRIVER OPENED\n");
-		}
-	}
-	return cad_rc;
-}
-
-
-s32 adie_close(u32 dev_type)
-{
-	s32 rc;
-
-	rc = CAD_RES_SUCCESS;
-
-	if (adie_state.adie_opened == ADIE_TRUE) {
-		if (((adie_state.adie_path_type[CAD_RX_DEVICE]).enabled
-					== ADIE_TRUE) ||
-			((adie_state.adie_path_type[CAD_TX_DEVICE]).enabled
-					== ADIE_TRUE) ||
-			((adie_state.adie_path_type[CAD_AUXPGA_DEVICE]).enabled
-					== ADIE_TRUE)) {
-			/* Do not close if at least 1 path is still enabled */
-		} else {
-			rc = daldevice_close(adie_state.adie_handle);
-			adie_state.adie_opened = ADIE_FALSE;
-		}
-	}
-
-	return rc;
-}
-
-s32 adie_enable(u32 dev_type, u32 dev_id)
-{
-	s32 rc = CAD_RES_SUCCESS;
-
-	if (adie_state.adie_path_type[dev_type].enabled != ADIE_TRUE) {
-		adie_state.adie_path_type[dev_type].enable_request = ADIE_TRUE;
-		rc = adie_state_control(dev_type, dev_id);
-		if (rc != CAD_RES_SUCCESS)
-			pr_err("ADIE ENABLE STATE M/C FAILED, dev_id = %d\n",
-			       dev_id);
-		else
-			pr_info("ADIE ENABLED dev_type = %d dev_id = %d\n",
-				dev_type, dev_id);
-	} else
-		rc = CAD_RES_FAILURE;
-
-	return rc;
-}
-
-s32 adie_disable(u32 dev_type, u32 dev_id)
-{
-	s32 rc = CAD_RES_SUCCESS;
-
-	if (adie_state.adie_path_type[dev_type].enabled != ADIE_FALSE) {
-		adie_state.adie_path_type[dev_type].enabled = ADIE_FALSE;
-
-		rc = adie_state_control(dev_type, dev_id);
-		if (rc != CAD_RES_SUCCESS)
-			pr_err("ADIE DISABLE STATE M/C FAILED"
-			       "dev_id = %d\n", dev_id);
-		else
-			pr_info("ADIE DISABLED dev_type = %d dev_id = %d\n"
-					, dev_type, dev_id);
-	} else {
-		pr_err("ADIE ALREADY DISABLED, dev_id = %d\n", dev_id);
-		rc = CAD_RES_FAILURE;
-	}
-
-	return rc;
-}
-
-u32 adie_state_control(u32 dev_type, u32 dev_id)
-{
-	s32				cad_res;
-	enum adie_state_ret_enum_type	rc;
-
-	cad_res = CAD_RES_SUCCESS;
-	rc = ADIE_STATE_RC_SUCCESS;
-
-	do {
-		D("ARD ADIE dev_type %d, adie state %d\n",
-			dev_type, adie_state.adie_path_type[dev_type].state);
-
-		switch (adie_state.adie_path_type[dev_type].state) {
-		case ADIE_STATE_RESET:
-			rc = adie_state_reset(dev_type, dev_id);
-			break;
-		case ADIE_STATE_DIGITAL_ACTIVE:
-			rc = adie_state_digital_active(dev_type, dev_id);
-			break;
-		case ADIE_STATE_DIGITAL_ANALOG_ACTIVE:
-			rc = adie_state_digital_analog_active(dev_type, dev_id);
-			break;
-		default:
-			break;
-		}
-	} while (rc == ADIE_STATE_RC_CONTINUE);
-
-	if (rc == ADIE_STATE_RC_FAILURE)
-		cad_res = CAD_RES_FAILURE;
-
-	return cad_res;
-}
-
-enum adie_state_ret_enum_type adie_state_reset(u32 dev_type, u32 dev_id)
-{
-	enum adie_state_ret_enum_type	rc;
-	s32				dal_rc;
-	enum adie_codec_path_type_enum	path_type;
-	u32				path_id;
-	u32				freq_plan;
-
-	rc = ADIE_STATE_RC_SUCCESS;
-	dal_rc = CAD_RES_SUCCESS;
-	if (adie_state.adie_path_type[dev_type].enable_request != ADIE_TRUE) {
-		rc = ADIE_STATE_RC_SUCCESS;
-		adie_state.adie_path_type[dev_type].enabled = ADIE_FALSE;
-		goto done;
-	}
-
-	path_id = get_path_id(dev_id);
-	path_type = get_path_type(dev_type);
-
-	if (path_type == ADIE_CODEC_RX)
-		freq_plan = 48000;
-	else {
-		if (g_clk_info.tx_clk_freq > 8000)
-			freq_plan = 48000;
-		else
-			freq_plan = 8000;
-	}
-
-	/* Set the path */
-	dal_rc = rpc_adie_codec_set_path(adie_state.adie_handle, path_id,
-			path_type);
-
-	if (dal_rc != CAD_RES_SUCCESS) {
-		pr_err("ARD ADIE Set Path failed for dev_type %d\n", dev_type);
-		rc = ADIE_STATE_RC_FAILURE;
-		goto done;
-	}
-
-	/* Set the freq plan */
-	dal_rc = rpc_adie_codec_set_path_freq_plan(adie_state.adie_handle,
-			path_type, freq_plan);
-
-	if (dal_rc != CAD_RES_SUCCESS) {
-		pr_err("ARD ADIE Set Path Freq Plan failed for dev_type %d\n",
-			dev_type);
-		rc = ADIE_STATE_RC_FAILURE;
-		goto done;
-	}
-
-	/* Proceed to stage */
-	dal_rc = rpc_adie_codec_proceed_to_stage(adie_state.adie_handle,
-			path_type, ADIE_CODEC_DIGITAL_READY);
-
-	if (dal_rc != CAD_RES_SUCCESS) {
-		pr_err("ARD ADIE Proceed to Stage failed for dev_type %d\n",
-			dev_type);
-		rc = ADIE_STATE_RC_FAILURE;
-		goto done;
-	}
-
-	adie_state.adie_path_type[dev_type].state = ADIE_STATE_DIGITAL_ACTIVE;
-	rc = ADIE_STATE_RC_CONTINUE;
-done:
-	return rc;
-}
-
-static int is_speaker_mono(u32 dev_id)
-{
-	if ((dev_id == CAD_HW_DEVICE_ID_SPKR_PHONE_MONO) ||
-		(dev_id == CAD_HW_DEVICE_ID_SPEAKER_SPKR_MONO_LB) ||
-		(dev_id == CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_MONO_RX) ||
-		(dev_id == CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX))
-		return 1;
-	else
-		return 0;
-}
-
-static int is_speaker_stereo(u32 dev_id)
-{
-	if ((CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO == dev_id) ||
-		(CAD_HW_DEVICE_ID_SPEAKER_SPKR_STEREO_LB == dev_id) ||
-		(CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_STEREO_RX
-				== dev_id) ||
-		(CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_STEREO_RX
-				== dev_id))
-		return 1;
-	else
-		return 0;
-}
-
-enum adie_state_ret_enum_type adie_state_digital_active(u32 dev_type,
-							u32 dev_id)
-{
-	enum adie_state_ret_enum_type	rc;
-	enum adie_codec_path_type_enum	path_type;
-	s32				dal_rc;
-
-	rc = ADIE_STATE_RC_SUCCESS;
-	dal_rc = CAD_RES_SUCCESS;
-
-	path_type = get_path_type(dev_type);
-	if (adie_state.adie_path_type[dev_type].enable_request == ADIE_TRUE) {
-
-		/* Prepare the PMIC, if necessary. Configure and power on,
-		   but mute it until codec output is ready. */
-		if (path_type == ADIE_CODEC_TX)
-			if ((dev_id == CAD_HW_DEVICE_ID_HANDSET_MIC) ||
-			    (dev_id == CAD_HW_DEVICE_ID_HEADSET_MIC) ||
-			    (dev_id == CAD_HW_DEVICE_ID_TTY_HEADSET_MIC) ||
-			    (dev_id == CAD_HW_DEVICE_ID_SPKR_PHONE_MIC)) {
-				pmic_mic_en(ON_CMD);
-				if (analog_ops->ext_mic_enable)
-					analog_ops->ext_mic_enable(1);
-			} else {
-				/* need to turn off MIC bias
-				   for TTY_HEADSET_MIC */
-				pmic_mic_en(OFF_CMD);
-				if (analog_ops->ext_mic_enable)
-					analog_ops->ext_mic_enable(0);
-			}
-		else if ((path_type == ADIE_CODEC_RX) ||
-			(path_type == ADIE_CODEC_LB)) {
-			struct spkr_config_mode scm;
-			memset(&scm, 0, sizeof(struct spkr_config_mode));
-
-			if (is_speaker_mono(dev_id)) {
-				if (!adie_spkr_mono_ref1_cnt) {
-					if (analog_ops->speaker_enable)
-						analog_ops->speaker_enable(1);
-				}
-				/* keep a reference for stereo speaker.
-				   case when Rx spkr is disabled when LB speaker
-				   is already enabled. */
-				adie_spkr_mono_ref1_cnt++;
-			} else if (is_speaker_stereo(dev_id) ||
-				   get_force_speaker_mode()) {
-				if (!adie_spkr_stereo_ref1_cnt) {
-					if (analog_ops->speaker_enable)
-						analog_ops->speaker_enable(1);
-				}
-
-				/* keep a reference for stereo speaker.
-				   case when Rx spkr is disabled when LB speaker
-				   is already enabled. */
-				adie_spkr_stereo_ref1_cnt++;
-			}
-		} else {
-			pr_err("bad path type\n");
-		}
-
-		/* Proceed to next stage */
-		dal_rc = rpc_adie_codec_proceed_to_stage(adie_state.adie_handle,
-				path_type, ADIE_CODEC_DIGITAL_ANALOG_READY);
-
-		if (dal_rc != CAD_RES_SUCCESS) {
-			pr_err("ARD ADIE Proceed to Stage failed,"
-				" dev_type %d\n", dev_type);
-			rc = ADIE_STATE_RC_FAILURE;
-			goto done;
-		}
-
-		adie_state.adie_path_type[dev_type].state =
-			ADIE_STATE_DIGITAL_ANALOG_ACTIVE;
-		adie_state.adie_path_type[dev_type].enabled = ADIE_TRUE;
-		adie_state.adie_path_type[dev_type].enable_request = ADIE_FALSE;
-		rc = ADIE_STATE_RC_CONTINUE;
-	} else {
-
-		if (path_type == ADIE_CODEC_TX) {
-			pmic_mic_en(OFF_CMD);
-			if (analog_ops->ext_mic_enable)
-				analog_ops->ext_mic_enable(0);
-		} else if ((path_type == ADIE_CODEC_RX) ||
-				(path_type == ADIE_CODEC_LB)) {
-			if (is_speaker_mono(dev_id)) {
-
-				/* disable a speaker LB or RX */
-				adie_spkr_mono_ref1_cnt--;
-
-				/* if no active speaker ref then disable pmic */
-				if (!adie_spkr_mono_ref1_cnt) {
-					if (analog_ops->speaker_enable)
-						analog_ops->speaker_enable(0);
-				}
-
-			} else if (is_speaker_stereo(dev_id) ||
-				   need_turn_off_speaker) {
-
-				/* disable a speaker LB or RX */
-				adie_spkr_stereo_ref1_cnt--;
-
-				/* if no active speaker ref then disable pmic */
-				if (!adie_spkr_stereo_ref1_cnt) {
-					if (analog_ops->speaker_enable)
-						analog_ops->speaker_enable(0);
-				}
-				need_turn_off_speaker = false;
-			}
-		}
-
-
-
-
-		/* Proceed to digital off stage */
-		dal_rc = rpc_adie_codec_proceed_to_stage(adie_state.adie_handle,
-				path_type, ADIE_CODEC_DIGITAL_OFF);
-
-		if (dal_rc != CAD_RES_SUCCESS) {
-			pr_err("ARD ADIE Proceed to Stage failed,"
-				" dev_type %d\n", dev_type);
-			rc = ADIE_STATE_RC_FAILURE;
-			goto done;
-		}
-
-		adie_state.adie_path_type[dev_type].state = ADIE_STATE_RESET;
-		rc = ADIE_STATE_RC_CONTINUE;
-	}
-done:
-	return rc;
-}
-
-enum adie_state_ret_enum_type adie_state_digital_analog_active(u32 dev_type,
-							       u32 dev_id)
-{
-	s32				dal_rc;
-	enum adie_state_ret_enum_type   rc;
-	enum adie_codec_path_type_enum	path_type;
-
-	dal_rc = CAD_RES_SUCCESS;
-	rc = ADIE_STATE_RC_SUCCESS;
-	path_type = get_path_type(dev_type);
-
-	if (adie_state.adie_path_type[dev_type].enabled == ADIE_TRUE) {
-		/* Stay in this state till teardown or reconfigure */
-
-		if ((path_type == ADIE_CODEC_RX) ||
-			(path_type == ADIE_CODEC_LB)) {
-			if (dev_id == CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO ||
-			    dev_id == CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR ||
-			    dev_id == CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO) {
-				if (analog_ops->headset_enable)
-					analog_ops->headset_enable(1);
-				if (get_force_speaker_mode()) {
-					pr_info("force speaker on\n");
-					force_headset_speaker_on(1);
-					need_turn_off_speaker = true;
-				}
-			}
-			if (get_fm_mode()) {
-				pr_info("enable fm speaker\n");
-				enable_aux_loopback(1);
-				need_turn_off_fm = true;
-			}
-		} else {
-			D("ARD ADIE Loopback Device\n");
-		}
-
-	} else {
-
-		if ((path_type == ADIE_CODEC_RX) ||
-			(path_type == ADIE_CODEC_LB)) {
-			if (dev_id == CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO ||
-			    dev_id == CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR ||
-			    dev_id == CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO) {
-				if (analog_ops->headset_enable)
-					analog_ops->headset_enable(0);
-				if (need_turn_off_speaker) {
-					pr_info("force speaker off\n");
-					force_headset_speaker_on(0);
-				}
-			}
-			if (need_turn_off_fm) {
-				pr_info("disable fm speaker\n");
-				enable_aux_loopback(0);
-				need_turn_off_fm = false;
-			}
-		} else {
-			D("ARD ADIE Loopback Device\n");
-		}
-
-		/* Proceed to digital off stage */
-		dal_rc = rpc_adie_codec_proceed_to_stage(adie_state.adie_handle,
-				path_type, ADIE_CODEC_ANALOG_OFF);
-
-		if (dal_rc != CAD_RES_SUCCESS) {
-			pr_err("ARD ADIE Proceed to Stage failed,"
-				" dev_type %d\n", dev_type);
-			rc = ADIE_STATE_RC_FAILURE;
-			goto done;
-		}
-
-		adie_state.adie_path_type[dev_type].state =
-			ADIE_STATE_DIGITAL_ACTIVE;
-		adie_state.adie_path_type[dev_type].enable_request = ADIE_FALSE;
-		rc = ADIE_STATE_RC_CONTINUE;
-	}
-done:
-	return rc;
-}
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_ard_clk.c b/arch/arm/mach-msm/qdsp6/msm8k_ard_clk.c
deleted file mode 100644
index 01567dc..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_ard_clk.c
+++ /dev/null
@@ -1,360 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/mutex.h>
-#include <linux/clk.h>
-#include <linux/init.h>
-#include "../clock.h"
-#include <mach/qdsp6/msm8k_ard_clk.h>
-
-static struct clk	*rx_clk;
-static struct clk	*tx_clk;
-static struct clk	*ecodec_clk;
-static struct clk	*sdac_clk;
-
-static bool rx_clk_enabled = false;
-static bool tx_clk_enabled = false;
-static bool ecodec_clk_enabled = false;
-static bool sdac_clk_enabled = false;
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_cad_clk: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-
-void ard_clk_enable_internal_codec_clk_tx(void)
-{
-	s32 rc = CAD_RES_SUCCESS;
-
-	if (tx_clk == NULL) {
-		tx_clk = clk_get(NULL, "icodec_tx_clk");
-		if (tx_clk == NULL) {
-			pr_err("ard_clk: Invalid TX clk!\n");
-			return;
-		}
-	}
-
-	if (!tx_clk_enabled) {
-		ard_clk_set_icodec_tx_clk();
-
-		rc = clk_enable(tx_clk);
-		if (rc != CAD_RES_SUCCESS)
-			pr_err("ard_clk: TX clk not enabled!\n");
-		else {
-			pr_info("ard_clk: TX clk enabled!\n");
-			tx_clk_enabled = true;
-		}
-	}
-}
-
-
-void ard_clk_enable_internal_codec_clk_rx(void)
-{
-	s32 rc = CAD_RES_SUCCESS;
-
-	if (rx_clk == NULL) {
-		rx_clk = clk_get(NULL, "icodec_rx_clk");
-		if (rx_clk == NULL) {
-			pr_err("ard_clk: Invalid RX clk!\n");
-			return;
-		}
-	}
-
-	if (!rx_clk_enabled) {
-		ard_clk_set_icodec_rx_clk();
-
-		rc = clk_enable(rx_clk);
-		if (rc != CAD_RES_SUCCESS)
-			pr_err("ard_clk: RX clk not enabled!\n");
-		else {
-			pr_info("ard_clk: RX clk enabled!\n");
-			rx_clk_enabled = true;
-		}
-	}
-}
-
-
-void ard_clk_enable_external_codec_clk(void)
-{
-	s32 rc = CAD_RES_SUCCESS;
-
-	if (ecodec_clk == NULL) {
-		ecodec_clk = clk_get(NULL, "ecodec_clk");
-		if (ecodec_clk == NULL) {
-			pr_err("ard_clk: Invalid ECODEC clk!\n");
-			return;
-		}
-	}
-
-	if (!ecodec_clk_enabled) {
-		ard_clk_set_ecodec_clk();
-
-		rc = clk_enable(ecodec_clk);
-		if (rc != CAD_RES_SUCCESS)
-			pr_err("ard_clk: ECODEC clk not enabled!\n");
-		else {
-			pr_info("ard_clk: ECODEC clk enabled!\n");
-			ecodec_clk_enabled = true;
-		}
-	}
-}
-
-void ard_clk_enable_sdac_rx_clk(void)
-{
-	/* Enable and Select SDAC clks if either I2S path is active */
-	s32 rc = CAD_RES_SUCCESS;
-
-	if (sdac_clk == NULL) {
-		sdac_clk = clk_get(NULL, "sdac_clk");
-		if (sdac_clk == NULL) {
-			pr_err("ard_clk: Invalid SDAC RX clk!\n");
-			return;
-		}
-	}
-
-	if (!sdac_clk_enabled) {
-		ard_clk_set_sdac_rx_clk();
-
-		rc = clk_enable(sdac_clk);
-		if (rc != CAD_RES_SUCCESS)
-			pr_err("ard_clk: SDAC RX clk not enabled!\n");
-		else {
-			pr_info("ard_clk: SDAC RX clk enabled!\n");
-			sdac_clk_enabled = true;
-		}
-	}
-
-}
-
-void ard_clk_enable_sdac_tx_clk(void)
-{
-	/* Enable and Select SDAC clks if either I2S path is active */
-	s32 rc = CAD_RES_SUCCESS;
-
-	if (sdac_clk == NULL) {
-		sdac_clk = clk_get(NULL, "sdac_clk");
-		if (sdac_clk == NULL) {
-			pr_err("ard_clk: Invalid SDAC TX clk!\n");
-			return;
-		}
-	}
-
-	if (!sdac_clk_enabled) {
-		ard_clk_set_sdac_tx_clk();
-
-		rc = clk_enable(sdac_clk);
-		if (rc != CAD_RES_SUCCESS)
-			pr_err("ard_clk: SDAC TX clk not enabled!\n");
-		else {
-			pr_info("ard_clk: SDAC TX clk enabled!\n");
-			sdac_clk_enabled = true;
-		}
-	}
-}
-
-void ard_clk_disable_internal_codec_clk_tx(void)
-{
-	if (tx_clk_enabled) {
-		clk_disable(tx_clk);
-		pr_info("ard_clk: TX clk disabled!\n");
-		tx_clk_enabled = false;
-	}
-}
-
-void ard_clk_disable_internal_codec_clk_rx(void)
-{
-	if (rx_clk_enabled) {
-		clk_disable(rx_clk);
-		pr_info("ard_clk: RX clk disabled!\n");
-		rx_clk_enabled = false;
-	}
-}
-
-
-void ard_clk_disable_external_codec_clk(void)
-{
-	if (ecodec_clk_enabled) {
-		clk_disable(ecodec_clk);
-		pr_info("ard_clk: ECODEC clk disabled!\n");
-		ecodec_clk_enabled = false;
-	}
-}
-
-void ard_clk_disable_sdac_clk(void)
-{
-	if (sdac_clk_enabled) {
-		clk_disable(sdac_clk);
-		pr_info("ard_clk: SDAC clk enabled!\n");
-		ecodec_clk_enabled = false;
-	}
-}
-
-void ard_clk_set_icodec_rx_clk(void)
-{
-	s32 rc = CAD_RES_SUCCESS;
-	/* Frequency in Hz - 48KHz */
-	rc = clk_set_rate(rx_clk, 12288000);
-
-	if (rc != CAD_RES_SUCCESS)
-		pr_err("ard_clk: Rate on RX clk not set!\n");
-}
-
-
-void ard_clk_set_icodec_tx_clk(void)
-{
-	s32 rc = CAD_RES_SUCCESS;
-
-	rc = clk_set_rate(tx_clk, g_clk_info.tx_clk_freq*256);
-
-	if (rc != CAD_RES_SUCCESS)
-		pr_err("ard_clk: Rate on TX clk not set!\n");
-}
-
-void ard_clk_set_ecodec_clk(void)
-{
-
-	s32 rc = CAD_RES_SUCCESS;
-	/* Frequency in Hz - 8Khz for AUX PCM now, later need to change to
-	 * support I2S
-	 */
-	rc = clk_set_rate(ecodec_clk, 2048000);
-	if (rc != CAD_RES_SUCCESS)
-		pr_err("ard_clk: Rate on ECODEC clk not set!\n");
-
-}
-void ard_clk_set_sdac_rx_clk(void)
-{
-	s32 rc = CAD_RES_SUCCESS;
-
-	/* Frequency in Hz - 48KHz */
-	rc = clk_set_rate(sdac_clk, 12288000);
-
-	if (rc != CAD_RES_SUCCESS)
-		pr_err("sdac_clk: Rate on RX clk not set!\n");
-}
-
-void ard_clk_set_sdac_tx_clk(void)
-{
-	s32 rc = CAD_RES_SUCCESS;
-
-	/* Frequency in Hz - 8KHz */
-	rc = clk_set_rate(sdac_clk, 2048000);
-
-	if (rc != CAD_RES_SUCCESS)
-		pr_err("sdac_clk: Rate on TX clk not set!\n");
-}
-
-void ard_clk_enable(u32 dev_id)
-{
-	switch (dev_id) {
-	case 0:
-		ard_clk_enable_internal_codec_clk_rx();
-		D("ENABLE RX INT CLK, dev_id %d\n", dev_id);
-		break;
-	case 1:
-		ard_clk_enable_internal_codec_clk_tx();
-		D("ENABLE TX INT CLK, dev_id %d\n", dev_id);
-		break;
-	case 2:
-	case 3:
-		/* No seperate TX and RX clocks for external codec */
-		ard_clk_enable_external_codec_clk();
-		D("ENABLE EXT CLK, dev_id %d\n", dev_id);
-		break;
-	case 6:
-		ard_clk_enable_sdac_rx_clk();
-		D("ENABLE SDAC CLK I2S RX");
-		break;
-	case 7:
-		ard_clk_enable_sdac_tx_clk();
-		D("ARD ENABLE SDAC CLK I2S TX");
-		break;
-	default:
-		pr_err("unsupported clk\n");
-	}
-}
-
-void ard_clk_disable(u32 dev_id)
-{
-	switch (dev_id) {
-	case 0:
-		ard_clk_disable_internal_codec_clk_rx();
-		D("DISABLE RX INT CLK, dev_id %d\n", dev_id);
-		break;
-	case 1:
-		ard_clk_disable_internal_codec_clk_tx();
-		D("DISABLE TX INT CLK, dev_id %d\n", dev_id);
-		break;
-	case 2:
-	case 3:
-		/* No seperate TX and RX clocks for external codec */
-		ard_clk_disable_external_codec_clk();
-		D("DISABLE EXT CLK, dev_id %d\n", dev_id);
-		break;
-	case 6:
-	case 7:
-		ard_clk_disable_sdac_clk();
-		D("ARD ENABLE SDAC CLK, dev_id %d", dev_id);
-		break;
-	default:
-		pr_err("unsupported clk setting\n");
-	}
-}
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_ard_helper.c b/arch/arm/mach-msm/qdsp6/msm8k_ard_helper.c
deleted file mode 100644
index 42af7ce..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_ard_helper.c
+++ /dev/null
@@ -1,237 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-#include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/gpio.h>
-
-#include <mach/qdsp6/msm8k_ard_helper.h>
-#include <mach/qdsp6/msm8k_ard.h>
-#include <mach/qdsp6/msm8k_ardi.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_ard_adie.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "ARD: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-/*
-	Function to get device ID. Currently there are 4 device IDs that can be
-	active at any given time, since there are 4 indpendent DMA paths. These
-	are:
-
-	0 - Internal Codec RX
-	1 - Internal Codec TX
-	2 - External Codec RX
-	3 - External Codec TX
-*/
-
-u32 get_device_id(u32 cad_device_requested)
-{
-	u32 dev_id = 0;
-
-	if ((cad_device_requested == CAD_HW_DEVICE_ID_SPKR_PHONE_MONO) ||
-		(cad_device_requested == CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO) ||
-		(cad_device_requested == CAD_HW_DEVICE_ID_HANDSET_SPKR) ||
-		(cad_device_requested == CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO) ||
-		(cad_device_requested == CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR) ||
-		(cad_device_requested ==
-			CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_MONO_RX) ||
-		(cad_device_requested ==
-			CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_STEREO_RX) ||
-		(cad_device_requested ==
-			CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX) ||
-		(cad_device_requested ==
-			CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_STEREO_RX) ||
-		(cad_device_requested ==
-			CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO)) {
-
-		dev_id = 0;
-	} else if ((cad_device_requested == CAD_HW_DEVICE_ID_SPKR_PHONE_MIC) ||
-		(cad_device_requested == CAD_HW_DEVICE_ID_HEADSET_MIC) ||
-		(cad_device_requested == CAD_HW_DEVICE_ID_TTY_HEADSET_MIC) ||
-		(cad_device_requested == CAD_HW_DEVICE_ID_HANDSET_MIC)) {
-
-		dev_id = 1;
-	} else if ((cad_device_requested == CAD_HW_DEVICE_ID_BT_SCO_SPKR) ||
-		(cad_device_requested == CAD_HW_DEVICE_ID_BT_A2DP_SPKR)) {
-
-		dev_id = 2;
-	} else if (cad_device_requested == CAD_HW_DEVICE_ID_BT_SCO_MIC) {
-		dev_id = 3;
-	} else if (cad_device_requested == CAD_HW_DEVICE_ID_I2S_RX) {
-		dev_id = 6;
-	} else if (cad_device_requested == CAD_HW_DEVICE_ID_I2S_TX) {
-		dev_id = 7;
-	} else {
-		pr_err("ARD No Support for other devices device = %d\n",
-			cad_device_requested);
-		dev_id = CAD_HW_DEVICE_ID_INVALID;
-	}
-	return dev_id;
-}
-
-
-s32 codec_disable(enum codec_enum_type codec_type, u32 dev_type, u32 dev_id)
-{
-	s32 rc = CAD_RES_SUCCESS;
-
-	switch (codec_type) {
-	case CODEC_INT:
-		rc = adie_disable(dev_type, dev_id);
-		if (rc != CAD_RES_FAILURE) {
-			rc = adie_close(dev_type);
-			if (rc != CAD_RES_SUCCESS) {
-				pr_err("ARD Error Closing ADIE, device = %d\n",
-						dev_id);
-				rc = CAD_RES_FAILURE;
-			}
-		} else
-			pr_err("ARD Error Disabling ADIE, device"
-				" = %d\n", dev_id);
-		break;
-	case CODEC_AUX_PCM:
-		switch_bt_sco(0);
-		pr_err("ARD TBD - DISABLING EXT CODEC, device = %d\n", dev_id);
-		break;
-	case CODEC_I2S:
-		pr_err("ARD - DISABLING GPIOs for I2S, device = %d\n", dev_id);
-		break;
-	default:
-		break;
-	}
-	return rc;
-}
-
-
-s32 codec_enable(enum codec_enum_type codec_type, u32 dev_type, u32 dev_id)
-{
-	s32 rc = CAD_RES_SUCCESS;
-
-	switch (codec_type) {
-	case CODEC_INT:
-		rc = adie_open(dev_type);
-		if (rc != CAD_RES_FAILURE) {
-			rc = adie_enable(dev_type, dev_id);
-			if (rc != CAD_RES_SUCCESS) {
-				pr_err("ARD Error enabling ADIE, device = %d\n",
-					dev_id);
-				rc = CAD_RES_FAILURE;
-			}
-		} else
-			pr_err("ARD Error Opening ADIE, device = %d\n", dev_id);
-		break;
-	case CODEC_AUX_PCM:
-		switch_bt_sco(1);
-		break;
-	case CODEC_I2S:
-		pr_err("ARD - ENABLING I2S GPIOs, device = %d\n", dev_id);
-		break;
-	default:
-		break;
-	}
-
-	return rc;
-}
-
-
-enum codec_enum_type get_codec_type(u32 device_in_use)
-{
-	enum codec_enum_type rc;
-
-	switch (device_in_use) {
-	case CAD_HW_DEVICE_ID_HANDSET_SPKR:
-	case CAD_HW_DEVICE_ID_HANDSET_MIC:
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO:
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO:
-	case CAD_HW_DEVICE_ID_HEADSET_MIC:
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_MIC:
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_MONO:
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO:
-	case CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR:
-	case CAD_HW_DEVICE_ID_TTY_HEADSET_MIC:
-	case CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_MONO_RX:
-	case CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_STEREO_RX:
-	case CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX:
-	case CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_STEREO_RX:
-		rc = CODEC_INT;
-		break;
-	case CAD_HW_DEVICE_ID_BT_SCO_MIC:
-	case CAD_HW_DEVICE_ID_BT_SCO_SPKR:
-		rc = CODEC_AUX_PCM;
-		break;
-	case CAD_HW_DEVICE_ID_I2S_TX:
-	case CAD_HW_DEVICE_ID_I2S_RX:
-		rc = CODEC_I2S;
-		break;
-	default:
-		rc = CODEC_INT;
-		pr_err("unsupported device %d\n", device_in_use);
-		break;
-	}
-
-	return rc;
-}
-
-enum ard_ret_enum_type test_clocks(void)
-{
-	return ARD_FALSE;
-}
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_ard_q6.c b/arch/arm/mach-msm/qdsp6/msm8k_ard_q6.c
deleted file mode 100644
index eb51e2e..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_ard_q6.c
+++ /dev/null
@@ -1,521 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <mach/qdsp6/msm8k_ard_q6.h>
-#include <mach/qdsp6/msm8k_ardi.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_itypes.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_cad_rpc.h>
-#include <mach/qdsp6/msm8k_cad_q6dec_drvi.h>
-#include <mach/qdsp6/msm8k_cad_q6enc_drvi.h>
-#include <mach/qdsp6/msm8k_q6_api_flip_utils.h>
-#include <mach/qdsp6/msm8k_adsp_audio_error.h>
-#include <mach/qdsp6/msm8k_adsp_audio_device.h>
-#include <mach/qdsp6/msm8k_adsp_audio_ioctl.h>
-#include <mach/qdsp6/msm8k_adsp_audio_stream_ioctl.h>
-#include <mach/qdsp6/msm8k_adsp_audio_command.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_cad_ard_q6: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MAX_RETRY_COUNT 5
-#define RETRY_DELAY 10
-
-s32 qdsp6_open(s32 session_id)
-{
-	s32                 rc, dal_rc;
-	struct cadi_open_struct_type		*ref_cadr = NULL;
-	struct cad_stream_device_struct_type	*ref_cadr_device = NULL;
-	struct cad_stream_info_struct_type	*ref_cadr_stream = NULL;
-
-	struct adsp_audio_open_command		*cadr = NULL;
-	union adsp_audio_event			*evt_buf = NULL;
-
-	rc = dal_rc = CAD_RES_SUCCESS;
-
-
-	ref_cadr = ardsession[session_id]->sess_open_info;
-	ref_cadr_stream = &(ref_cadr->cad_stream);
-	ref_cadr_device = &(ref_cadr->cad_device);
-
-	if (ref_cadr_stream->app_type == CAD_STREAM_APP_VOICE) {
-		D("ARD Q6 OPEN VOICE Session, so do nothing %d\n",
-			session_id);
-		goto done;
-	}
-
-	/* Allocate memory for the event payload */
-	evt_buf = kmalloc(sizeof(*evt_buf),
-		GFP_KERNEL);
-
-	if (evt_buf == NULL) {
-		rc = CAD_RES_FAILURE;
-		pr_err("ARD Malloc failed\n");
-		goto done;
-	}
-
-	cadr = kmalloc(sizeof(*cadr),
-		GFP_KERNEL);
-
-	if (cadr == NULL) {
-		rc = CAD_RES_FAILURE;
-		pr_err("ARD kmalloc failed\n");
-		goto done;
-	}
-
-	memset(cadr, 0, sizeof(*cadr));
-	cadr->cmd.op_code = q6_open_op_mapping(ref_cadr->cad_open.op_code);
-	cadr->cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-	if (ref_cadr->cad_open.op_code != CAD_OPEN_OP_DEVICE_CTRL) {
-		cadr->stream_device.stream_context =
-			q6_stream_context_mapping(
-			ref_cadr->cad_stream.app_type,
-			&(cadr->stream_device.mode));
-
-		cadr->stream_device.buf_max_size =
-			ref_cadr->cad_stream.ses_buf_max_size;
-		cadr->stream_device.priority = ref_cadr->cad_stream.priority;
-
-		if (ref_cadr->cad_device.device_len >=
-			ADSP_AUDIO_MAX_DEVICES) {
-
-			pr_err("CAD:ARD device number is too large\n");
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		cadr->stream_device.num_devices =
-			ref_cadr->cad_device.device_len;
-
-		if (ref_cadr->cad_device.device == NULL) {
-			pr_err("CAD:ARD no device for control session\n");
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		cadr->stream_device.device[0] = q6_device_id_mapping
-			(ref_cadr->cad_device.device[0]);
-
-		D("ARD device id= %d, device len = %d\n",
-				cadr->stream_device.device[0],
-				cadr->stream_device.num_devices);
-
-		rc = convert_format_block(session_id, cadr, ref_cadr);
-		if (rc != CAD_RES_SUCCESS) {
-			pr_err("ARD converting format block failed\n");
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-	}
-
-	if (ref_cadr->dls_table.length > 0) {
-		cadr->stream_device.len = ref_cadr->dls_table.length;
-		cadr->stream_device.addr = ref_cadr->dls_table.addr;
-	}
-
-	if (ardsession[session_id]->qdsp6_opened == ARD_FALSE) {
-		/* Only ARD will open a session with Q6 */
-		D("ARD Sending RPC Open, session %d\n", session_id);
-		dal_rc = cad_rpc_control(session_id,
-			ardsession[session_id]->group_id, (void *)cadr,
-			sizeof(*cadr), evt_buf);
-
-		if (dal_rc != CAD_RES_SUCCESS) {
-			rc = CAD_RES_FAILURE;
-			pr_err("ARD RPC Open failed %d\n", session_id);
-			goto done;
-		}
-
-		if ((evt_buf->no_payload.source.minor == (u32)session_id) &&
-			(evt_buf->no_payload.status != ADSP_AUDIO_SUCCESS)) {
-			pr_err("ARD Open RPC failed for ses: %d, status %d\n",
-				session_id, evt_buf->no_payload.status);
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		ardsession[session_id]->qdsp6_opened = ARD_TRUE;
-	}
-
-done:
-	if (ardsession[session_id]->local_format_block)
-		ardsession[session_id]->local_format_block = NULL;
-
-	kfree(evt_buf);
-	kfree(cadr);
-
-	  return rc;
-}
-
-
-s32 qdsp6_start(s32 session_id)
-{
-	s32					rc, dal_rc;
-	struct cadi_open_struct_type		*cadr = NULL;
-	struct cad_stream_info_struct_type	*cadr_stream = NULL;
-	union adsp_audio_event			*evt_buf = NULL;
-	struct adsp_audio_no_payload_command	q6_cmd;
-
-	rc = dal_rc = CAD_RES_SUCCESS;
-
-
-	memset(&q6_cmd, 0, sizeof(q6_cmd));
-
-	cadr = ardsession[session_id]->sess_open_info;
-	cadr_stream = &(cadr->cad_stream);
-
-	if (cadr_stream->app_type == CAD_STREAM_APP_VOICE) {
-		D("ARD Q6 START VOICE Session, so do nothing %d\n",
-			session_id);
-		goto done;
-	}
-
-	/* Allocate memory for the event payload */
-	evt_buf = kmalloc(sizeof(*evt_buf),
-		GFP_KERNEL);
-
-	if (evt_buf == NULL) {
-		rc = CAD_RES_FAILURE;
-		pr_err("ARD Malloc failed\n");
-		goto done;
-	}
-
-	D("ARD Sending RPC CADI_IOCTL_CMD_DSP_START, session %d\n",
-		session_id);
-
-	if (cadr->cad_open.op_code != CAD_OPEN_OP_DEVICE_CTRL) {
-		q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_SESSION_START;
-		q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-		/* Send START IOCTL CMD - This command has no payload */
-		dal_rc = cad_rpc_control(session_id,
-			ardsession[session_id]->group_id,
-			(void *)&q6_cmd,
-			sizeof(q6_cmd), evt_buf);
-	} else {
-		q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_DEVICE_SWITCH_COMMIT;
-		q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-		/* Send DEVICE_SWITCH_COMMIT - This command has no payload */
-		dal_rc = cad_rpc_control(session_id,
-			ardsession[session_id]->group_id,
-			(void *)&q6_cmd,
-			sizeof(q6_cmd), evt_buf);
-	}
-
-
-	if (dal_rc != CAD_RES_SUCCESS) {
-		rc = CAD_RES_FAILURE;
-		pr_err("ARD CADI_IOCTL_CMD_DSP_START failed %d\n",
-			session_id);
-		goto done;
-	}
-
-	if ((evt_buf->no_payload.source.minor == (u32)session_id) &&
-		(evt_buf->no_payload.status != ADSP_AUDIO_SUCCESS)) {
-		pr_err("ARD CADI_IOCTL_CMD_DSP_START failed ses: %d, "
-			"status %d\n", session_id,
-			evt_buf->no_payload.status);
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-done:
-	kfree(evt_buf);
-
-	return rc;
-}
-
-
-s32 qdsp6_close(s32 session_id)
-{
-	s32					rc, dal_rc;
-	struct cadi_open_struct_type		*cadr = NULL;
-	struct cad_stream_info_struct_type      *cadr_stream = NULL;
-	union adsp_audio_event			*evt_buf = NULL;
-	struct adsp_audio_no_payload_command	q6_cmd;
-
-	rc = dal_rc = CAD_RES_SUCCESS;
-
-	memset(&q6_cmd, 0, sizeof(q6_cmd));
-
-	cadr = ardsession[session_id]->sess_open_info;
-	cadr_stream = &(cadr->cad_stream);
-
-	if (cadr_stream->app_type == CAD_STREAM_APP_VOICE) {
-		D("ARD Q6 CLOSE VOICE Session, so do nothing %d\n",
-			session_id);
-		goto done;
-	}
-
-	/* Allocate memory for the event payload */
-	evt_buf = kmalloc(sizeof(*evt_buf),
-		GFP_KERNEL);
-
-	if (evt_buf == NULL) {
-		rc = CAD_RES_FAILURE;
-		pr_err("ARD Malloc failed\n");
-		goto done;
-	}
-
-	if (ardsession[session_id]->qdsp6_opened == ARD_TRUE) {
-		D("ARD Sending RPC Close, session %d\n", session_id);
-		q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_CLOSE;
-		q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-		/* Send IOCTL_CMD_CLOSE - This command has no payload */
-		dal_rc = cad_rpc_control(session_id,
-			ardsession[session_id]->group_id,
-			(void *)&q6_cmd,
-			sizeof(q6_cmd), evt_buf);
-
-		if (dal_rc != CAD_RES_SUCCESS) {
-			pr_err("ARD RPC Close failed %d\n", session_id);
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		ardsession[session_id]->qdsp6_opened = ARD_FALSE;
-		ardsession[session_id]->qdsp6_started = ARD_FALSE;
-
-		if ((evt_buf->no_payload.source.minor == (u32)session_id) &&
-			(evt_buf->no_payload.status != ADSP_AUDIO_SUCCESS)) {
-
-			pr_err("ARD Close RPC failed for session %d,"
-				" status %d\n", session_id,
-				evt_buf->no_payload.status);
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-	}
-done:
-	kfree(evt_buf);
-
-	  return rc;
-}
-
-
-
-s32 qdsp6_devchg_notify(s32 session_id, u32 dev_id)
-{
-	s32					rc, dal_rc;
-	struct adsp_audio_device_switch_command	dev_chg;
-	struct ard_state_struct_type		*local_ard_state = NULL;
-	struct cadi_open_struct_type		*cadr = NULL;
-	struct cad_stream_info_struct_type	*cadr_stream = NULL;
-	union adsp_audio_event			*evt_buf = NULL;
-
-	rc = dal_rc = CAD_RES_SUCCESS;
-
-	cadr = ardsession[session_id]->sess_open_info;
-	cadr_stream = &(cadr->cad_stream);
-
-	local_ard_state = &ard_state;
-
-
-	/* Check if handle opened with the QDSP6 */
-	if (ardsession[session_id]->qdsp6_opened != ARD_TRUE)
-		qdsp6_open(session_id);
-
-	if (cadr_stream->app_type == CAD_STREAM_APP_VOICE) {
-		pr_err("ARD Q6 DEV NOTIFY VOICE Session, so do nothing %d\n",
-			session_id);
-		goto done;
-	}
-
-	/* Allocate memory for the event payload */
-	evt_buf = kmalloc(sizeof(*evt_buf),
-		GFP_KERNEL);
-
-	if (evt_buf == NULL) {
-		rc = CAD_RES_FAILURE;
-		pr_err("ARD Malloc failed\n");
-		goto done;
-	}
-
-	dev_chg.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_DEVICE_SWITCH_PREPARE;
-	dev_chg.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-	/*0 - Default - Default Device*/
-	dev_chg.device_class = 0;
-	dev_chg.device_type = q6_device_direction_mapping
-		(local_ard_state->ard_device[dev_id].device_type);
-
-	switch (dev_chg.device_type) {
-	case ADSP_AUDIO_RX_DEVICE:
-		dev_chg.new_device =
-			q6_device_id_mapping(local_ard_state->new_rx_device);
-		dev_chg.old_device =
-			q6_device_id_mapping(local_ard_state->def_rx_device);
-		break;
-	case ADSP_AUDIO_TX_DEVICE:
-		dev_chg.new_device =
-			q6_device_id_mapping(local_ard_state->new_tx_device);
-		dev_chg.old_device =
-			q6_device_id_mapping(local_ard_state->def_tx_device);
-		break;
-	default:
-		pr_err("ARD DAL RPC IOCTL failed %d\n", session_id);
-		break;
-	}
-
-	D("ARD Sending RPC CMD_DEVICE_SWITCH_PREPARE, session %d\n",
-		session_id);
-
-	dal_rc = cad_rpc_control(session_id,
-			ardsession[session_id]->group_id,
-		(void *)&dev_chg,
-			sizeof(dev_chg), evt_buf);
-
-	if (dal_rc != CAD_RES_SUCCESS) {
-		rc = CAD_RES_FAILURE;
-		pr_err("ARD CADI_IOCTL_CMD_DSP_PREP_DEV_CHG failed %d\n",
-			session_id);
-		goto done;
-	}
-
-	if ((evt_buf->no_payload.source.minor == (u32)session_id) &&
-		(evt_buf->no_payload.status != ADSP_AUDIO_SUCCESS)) {
-		rc = CAD_RES_FAILURE;
-		pr_err("ARD DSP_PREP_DEV_CHG failed, ses %d, status %d\n",
-			session_id, evt_buf->no_payload.status);
-		goto done;
-	}
-done:
-	kfree(evt_buf);
-
-	return rc;
-}
-
-
-s32 qdsp6_standby(s32 session_id)
-{
-	/*Send IOCTL to Q6*/
-	s32					rc, dal_rc;
-	struct cadi_open_struct_type		*cadr = NULL;
-	struct cad_stream_info_struct_type	*cadr_stream = NULL;
-	union adsp_audio_event			*evt_buf = NULL;
-	struct adsp_audio_no_payload_command	q6_cmd;
-
-	rc = dal_rc = CAD_RES_SUCCESS;
-
-
-	memset(&q6_cmd, 0, sizeof(q6_cmd));
-
-	cadr = ardsession[session_id]->sess_open_info;
-	cadr_stream = &(cadr->cad_stream);
-
-	/*Check if handle opened with the QDSP6*/
-	if (ardsession[session_id]->qdsp6_opened != ARD_TRUE)
-		qdsp6_open(session_id);
-
-	if (cadr_stream->app_type == CAD_STREAM_APP_VOICE) {
-		D("ARD Q6 Standby VOICE Session, so do nothing %d\n",
-			session_id);
-		goto done;
-	}
-
-	/* Allocate memory for the event payload */
-	evt_buf = kmalloc(sizeof(*evt_buf),
-		GFP_KERNEL);
-
-	if (evt_buf == NULL) {
-		rc = CAD_RES_FAILURE;
-		pr_err("ARD Malloc failed\n");
-		goto done;
-	}
-
-	if (ardsession[session_id]->session_type == DEVICE_CTRL_TYPE) {
-		D("ARD Sending RPC CADI_IOCTL_CMD_DSP_STANDBY,"
-			" session %d\n", session_id);
-
-		q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_DEVICE_SWITCH_STANDBY;
-		q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-		/* Send START IOCTL CMD - This command has no payload */
-		dal_rc = cad_rpc_control(session_id,
-			ardsession[session_id]->group_id,
-			(void *)&q6_cmd,
-			sizeof(q6_cmd), evt_buf);
-
-		if (dal_rc != CAD_RES_SUCCESS) {
-			rc = CAD_RES_FAILURE;
-			pr_err("ARD CADI_IOCTL_CMD_DSP_STANDBY failed %d\n",
-				session_id);
-			goto done;
-		}
-
-		if ((evt_buf->no_payload.source.minor == session_id) &&
-			(evt_buf->no_payload.status != ADSP_AUDIO_SUCCESS)) {
-			rc = CAD_RES_FAILURE;
-			pr_err("ARD DSP_STANDBY failed, ses %d, status %d\n",
-				session_id, evt_buf->no_payload.status);
-			goto done;
-		}
-	}
-done:
-	kfree(evt_buf);
-
-	return rc;
-}
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_audio_dev_ctrl.c b/arch/arm/mach-msm/qdsp6/msm8k_audio_dev_ctrl.c
deleted file mode 100644
index 2b28a99..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_audio_dev_ctrl.c
+++ /dev/null
@@ -1,551 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/uaccess.h>
-#include <linux/msm_audio.h>
-
-#include <asm/ioctls.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_cad_volume.h>
-#include <mach/qdsp6/msm8k_ard_adie.h>
-
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_audio_dev_ctrl: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MSM8K_AUDIO_PROC_NAME "msm8k_audio_dev_ctrl"
-
-#define AUDIO_MAGIC 'a'
-
-struct msm8k_audio_dev_ctrl {
-	u32 cad_ctrl_handle;
-	u32 current_volume;
-	int current_rx_device;
-	int current_tx_device;
-};
-
-struct msm8k_audio_dev_ctrl g_ctrl;
-static atomic_t tx_mute = ATOMIC_INIT(0);
-
-static int msm8k_audio_dev_ctrl_open(struct inode *inode, struct file *f)
-{
-	struct msm8k_audio_dev_ctrl *ctrl = &g_ctrl;
-	D("%s\n", __func__);
-
-	f->private_data = ctrl;
-
-	return CAD_RES_SUCCESS;
-}
-
-static int msm8k_audio_dev_ctrl_release(struct inode *inode, struct file *f)
-{
-	int rc = CAD_RES_SUCCESS;
-
-	D("%s\n", __func__);
-
-	return rc;
-}
-
-static ssize_t msm8k_audio_dev_ctrl_read(struct file *f, char __user *buf,
-	size_t cnt, loff_t *pos)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-static ssize_t msm8k_audio_dev_ctrl_write(struct file *f,
-	const char __user *buf, size_t cnt, loff_t *pos)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-int audio_switch_device(int new_device)
-{
-	int rc;
-	struct msm8k_audio_dev_ctrl *ctrl = &g_ctrl;
-	struct cad_device_struct_type cad_dev;
-	int prev_force_spkr_mode = get_force_speaker_mode();
-	int prev_fm_mode = get_fm_mode();
-
-	D("%s\n", __func__);
-
-	memset(&cad_dev, 0, sizeof(struct cad_device_struct_type));
-
-	switch (new_device) {
-	case HANDSET_MIC:
-		cad_dev.device = CAD_HW_DEVICE_ID_HANDSET_MIC;
-		cad_dev.reserved = CAD_TX_DEVICE;
-		break;
-	case HANDSET_SPKR:
-		cad_dev.device = CAD_HW_DEVICE_ID_HANDSET_SPKR;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case HEADSET_MIC:
-		cad_dev.device = CAD_HW_DEVICE_ID_HEADSET_MIC;
-		cad_dev.reserved = CAD_TX_DEVICE;
-		break;
-	case HEADSET_SPKR_MONO:
-		cad_dev.device = CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case HEADSET_SPKR_STEREO:
-		cad_dev.device = CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case SPKR_PHONE_MIC:
-		cad_dev.device = CAD_HW_DEVICE_ID_SPKR_PHONE_MIC;
-		cad_dev.reserved = CAD_TX_DEVICE;
-		break;
-	case SPKR_PHONE_MONO:
-		cad_dev.device = CAD_HW_DEVICE_ID_SPKR_PHONE_MONO;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case SPKR_PHONE_STEREO:
-		cad_dev.device = CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case BT_SCO_MIC:
-		cad_dev.device = CAD_HW_DEVICE_ID_BT_SCO_MIC;
-		cad_dev.reserved = CAD_TX_DEVICE;
-		break;
-	case BT_SCO_SPKR:
-		cad_dev.device = CAD_HW_DEVICE_ID_BT_SCO_SPKR;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case BT_A2DP_SPKR:
-		cad_dev.device = CAD_HW_DEVICE_ID_BT_A2DP_SPKR;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case TTY_HEADSET_MIC:
-		cad_dev.device = CAD_HW_DEVICE_ID_TTY_HEADSET_MIC;
-		cad_dev.reserved = CAD_TX_DEVICE;
-		break;
-	case TTY_HEADSET_SPKR:
-		cad_dev.device = CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case HEADSET_MONO_PLUS_SPKR_MONO_RX:
-		cad_dev.device =
-			CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_MONO_RX;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case HEADSET_MONO_PLUS_SPKR_STEREO_RX:
-		cad_dev.device =
-			CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_STEREO_RX;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case HEADSET_STEREO_PLUS_SPKR_MONO_RX:
-		cad_dev.device =
-			CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case HEADSET_STEREO_PLUS_SPKR_STEREO_RX:
-		cad_dev.device =
-			CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_STEREO_RX;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case I2S_RX:
-		cad_dev.device = CAD_HW_DEVICE_ID_I2S_RX;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case I2S_TX:
-		cad_dev.device = CAD_HW_DEVICE_ID_I2S_TX;
-		cad_dev.reserved = CAD_TX_DEVICE;
-		break;
-	case SPKR_PHONE_HEADSET_STEREO:
-		cad_dev.device = CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case FM_HEADSET:
-		cad_dev.device = CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	case FM_SPKR:
-		cad_dev.device = CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO;
-		cad_dev.reserved = CAD_RX_DEVICE;
-		break;
-	default:
-		return -ENODEV;
-	}
-
-	/* Set and check if force_speaker_mode is changed */
-	if (cad_dev.reserved == CAD_RX_DEVICE) {
-		if (new_device == SPKR_PHONE_HEADSET_STEREO)
-			set_force_speaker_mode(1);
-		else
-			set_force_speaker_mode(0);
-
-		if (new_device == FM_HEADSET)
-			set_fm_mode(1);
-		else if (new_device == FM_SPKR)
-			set_fm_mode(2);
-		else
-			set_fm_mode(0);
-	}
-	if (prev_force_spkr_mode != get_force_speaker_mode() ||
-	    prev_fm_mode != get_fm_mode())
-		cad_dev.force_update = 1;
-
-	pr_info("SWITCH DEVICE %d\n", cad_dev.device);
-	rc = cad_ioctl(ctrl->cad_ctrl_handle,
-			CAD_IOCTL_CMD_DEVICE_SET_GLOBAL_DEFAULT,
-			&cad_dev,
-			sizeof(struct cad_device_struct_type));
-	if (rc) {
-		pr_err("cad_ioctl() SET_GLOBAL_DEFAULT failed\n");
-		return rc;
-	}
-
-	if (cad_dev.reserved == CAD_RX_DEVICE)
-		ctrl->current_rx_device = cad_dev.device;
-	else
-		ctrl->current_tx_device = cad_dev.device;
-
-#if 1
-	if (cad_dev.reserved == CAD_TX_DEVICE) {
-		struct msm_mute_info info;
-		info.path = 1;
-		info.mute = 0;
-		pr_info("UNMUTE DEVICE %d\n", cad_dev.device);
-		audio_set_device_mute(&info);
-	}
-#else
-	if (cad_dev.reserved == CAD_TX_DEVICE &&
-	    atomic_read(&tx_mute)) {
-		/* keep tx mute status if path is changed. */
-		struct msm_mute_info info;
-		info.path = info.mute = 1;
-		pr_info("MUTE DEVICE %d\n", cad_dev.device);
-		audio_set_device_mute(&info);
-	}
-#endif
-	return rc;
-}
-EXPORT_SYMBOL(audio_switch_device);
-
-
-int audio_set_device_volume_path(struct msm_vol_info *v)
-{
-	int rc;
-	struct cad_flt_cfg_dev_vol cad_dev_volume;
-	struct cad_filter_struct flt;
-	struct msm8k_audio_dev_ctrl *ctrl = &g_ctrl;
-
-	D("%s\n", __func__);
-
-	if ((v->vol < 0) || (v->vol > 100)) {
-		D("invalid volume value\n");
-		return -EINVAL;
-	}
-
-	if ((v->path != CAD_RX_DEVICE) && (v->path != CAD_TX_DEVICE)) {
-		pr_err("%s: invalid path\n", __func__);
-		return -1;
-	}
-
-	memset(&flt, 0,	sizeof(struct cad_filter_struct));
-	memset(&cad_dev_volume, 0,
-			sizeof(struct cad_flt_cfg_dev_vol));
-	ctrl->current_volume = v->vol;
-	cad_dev_volume.volume = ctrl->current_volume;
-
-	cad_dev_volume.path = v->path;
-	if (v->path == CAD_RX_DEVICE)
-	cad_dev_volume.device_id = ctrl->current_rx_device;
-	else
-		cad_dev_volume.device_id = ctrl->current_tx_device;
-
-	flt.filter_type = CAD_DEVICE_FILTER_TYPE_VOL;
-	flt.cmd = CAD_FILTER_CONFIG_DEVICE_VOLUME;
-	flt.format_block = &cad_dev_volume;
-	flt.format_block_len = sizeof(struct cad_flt_cfg_dev_vol);
-
-	pr_info("msm8k_audio_dev_ctrl set volume %d\n", ctrl->current_volume);
-	rc = cad_ioctl(ctrl->cad_ctrl_handle,
-		CAD_IOCTL_CMD_SET_DEVICE_FILTER_CONFIG,
-		&flt,
-		sizeof(struct cad_filter_struct));
-	if (rc)
-		pr_err("cad_ioctl() set volume failed\n");
-
-	return rc;
-}
-EXPORT_SYMBOL(audio_set_device_volume_path);
-
-
-int audio_set_device_volume(int vol)
-{
-	struct msm_vol_info vi;
-
-	vi.vol = vol;
-	vi.path = CAD_RX_DEVICE;
-
-	return audio_set_device_volume_path(&vi);
-}
-EXPORT_SYMBOL(audio_set_device_volume);
-
-
-int audio_set_device_mute(struct msm_mute_info *m)
-{
-	int rc;
-	struct cad_filter_struct flt;
-	struct cad_flt_cfg_dev_mute dev_mute_buf;
-	struct msm8k_audio_dev_ctrl *ctrl = &g_ctrl;
-
-	D("%s\n", __func__);
-
-	if ((m->path != CAD_RX_DEVICE) && (m->path != CAD_TX_DEVICE)) {
-		pr_err("%s: invalid path\n", __func__);
-		return -1;
-	}
-
-	memset(&flt, 0, sizeof(struct cad_filter_struct));
-	memset(&dev_mute_buf, 0,
-		sizeof(struct cad_flt_cfg_dev_mute));
-
-	dev_mute_buf.ver_id = CAD_FILTER_CONFIG_DEVICE_VOLUME_VERID;
-
-	if (m->path == CAD_RX_DEVICE)
-		dev_mute_buf.device_id = ctrl->current_rx_device;
-	else
-		dev_mute_buf.device_id = ctrl->current_tx_device;
-
-	dev_mute_buf.path = m->path;
-	dev_mute_buf.mute = m->mute;
-
-	flt.cmd = CAD_FILTER_CONFIG_DEVICE_MUTE;
-	flt.filter_type = CAD_DEVICE_FILTER_TYPE_VOL;
-	flt.format_block_len =
-		sizeof(struct cad_flt_cfg_dev_mute);
-	flt.format_block = &dev_mute_buf;
-	pr_info("msm8k_audio_dev_ctrl set device mute %d %d\n",
-		dev_mute_buf.path, dev_mute_buf.mute);
-	rc = cad_ioctl(ctrl->cad_ctrl_handle,
-		CAD_IOCTL_CMD_SET_DEVICE_FILTER_CONFIG,
-		&flt,
-		sizeof(struct cad_filter_struct));
-	if (rc)
-		pr_err("cad_ioctl() set mute failed\n");
-	else if (m->path == CAD_TX_DEVICE) {
-		/* Keep latest TX mute status */
-		atomic_set(&tx_mute, m->mute);
-	}
-	return rc;
-}
-EXPORT_SYMBOL(audio_set_device_mute);
-
-
-static int msm8k_audio_dev_ctrl_ioctl(struct inode *inode, struct file *f,
-		unsigned int cmd, unsigned long arg)
-{
-	int rc;
-	u32 uparam;
-	struct msm_mute_info m;
-	struct msm_vol_info v;
-
-	D("%s\n", __func__);
-
-	switch (cmd) {
-	case AUDIO_SWITCH_DEVICE:
-		if (copy_from_user(&uparam, (void *)arg,
-				sizeof(uparam)))
-			return CAD_RES_FAILURE;
-
-		rc = audio_switch_device(uparam);
-		break;
-	case AUDIO_SET_VOLUME:
-		if (copy_from_user(&uparam, (void *)arg,
-				sizeof(uparam)))
-			return CAD_RES_FAILURE;
-
-		rc = audio_set_device_volume(uparam);
-
-		break;
-	case AUDIO_SET_VOLUME_PATH:
-		if (copy_from_user(&v, (void *)arg,
-				sizeof(struct msm_vol_info)))
-			return CAD_RES_FAILURE;
-
-		rc = audio_set_device_volume_path(&v);
-
-		break;
-	case AUDIO_SET_MUTE:
-		rc = copy_from_user(&m, (void *)arg,
-				sizeof(struct msm_mute_info));
-		if (rc) {
-			pr_err("AUDIO_SET_MUTE copy from user failed\n");
-			break;
-		}
-
-		rc = audio_set_device_mute(&m);
-
-		break;
-	case AUDIO_SET_MAX_VOL_ALL:
-		rc = volume_set_max_vol_all();
-
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-#ifdef CONFIG_PROC_FS
-int msm8k_audio_dev_ctrl_read_proc(char *pbuf, char **start, off_t offset,
-			int count, int *eof, void *data)
-{
-	int len = 0;
-	len += snprintf(pbuf, 16, "audio\n");
-
-	*eof = 1;
-	return len;
-}
-#endif
-
-static const struct file_operations msm8k_audio_dev_ctrl_fops = {
-	.owner = THIS_MODULE,
-	.open = msm8k_audio_dev_ctrl_open,
-	.release = msm8k_audio_dev_ctrl_release,
-	.read = msm8k_audio_dev_ctrl_read,
-	.write = msm8k_audio_dev_ctrl_write,
-	.ioctl = msm8k_audio_dev_ctrl_ioctl,
-	.llseek = no_llseek,
-};
-
-
-struct miscdevice msm8k_audio_dev_ctrl_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_audio_dev_ctrl",
-	.fops	= &msm8k_audio_dev_ctrl_fops,
-};
-
-static int __init msm8k_audio_dev_ctrl_init(void)
-{
-	struct cad_open_struct_type  cos;
-	int rc;
-	struct msm8k_audio_dev_ctrl *ctrl = &g_ctrl;
-
-	D("%s\n", __func__);
-
-	rc = misc_register(&msm8k_audio_dev_ctrl_misc);
-	if (rc) {
-		pr_err("failed to register audio control device\n");
-		return CAD_RES_FAILURE;
-	}
-
-	cos.format = 0;
-	cos.op_code = CAD_OPEN_OP_DEVICE_CTRL;
-	ctrl->cad_ctrl_handle = cad_open(&cos);
-	ctrl->current_rx_device = CAD_HW_DEVICE_ID_HANDSET_SPKR;
-	ctrl->current_tx_device = CAD_HW_DEVICE_ID_HANDSET_MIC;
-
-	if (ctrl->cad_ctrl_handle < 0) {
-		pr_err("Dev CTRL handle < 0\n");
-		return CAD_RES_FAILURE;
-	}
-
-	set_audio_ctrl_handle(ctrl->cad_ctrl_handle);
-
-	rc = cad_ioctl(ctrl->cad_ctrl_handle,
-			CAD_IOCTL_CMD_STREAM_START,
-			NULL,
-			0);
-	if (rc) {
-		pr_err("%s: cad_ioctl() STREAM_START failed\n", __func__);
-		return CAD_RES_FAILURE;
-	}
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(MSM8K_AUDIO_PROC_NAME,
-			0, NULL, msm8k_audio_dev_ctrl_read_proc, NULL);
-#endif
-
-	return rc;
-}
-
-static void __exit msm8k_audio_dev_ctrl_exit(void)
-{
-	struct msm8k_audio_dev_ctrl *ctrl = &g_ctrl;
-	D("%s\n", __func__);
-
-	cad_close(ctrl->cad_ctrl_handle);
-
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(MSM8K_AUDIO_PROC_NAME, NULL);
-#endif
-}
-
-
-module_init(msm8k_audio_dev_ctrl_init);
-module_exit(msm8k_audio_dev_ctrl_exit);
-
-MODULE_DESCRIPTION("MSM Audio Device Control driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_cad.c b/arch/arm/mach-msm/qdsp6/msm8k_cad.c
deleted file mode 100644
index 0eb4330..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_cad.c
+++ /dev/null
@@ -1,572 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/spinlock.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-
-#include <mach/qdsp6/msm8k_cad_module.h>
-#include <mach/qdsp6/msm8k_cad_q6dec_drv.h>
-#include <mach/qdsp6/msm8k_cad_itypes.h>
-#include <mach/qdsp6/msm8k_cad_volume.h>
-
-#define MODULE_NAME "CAD"
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_cad: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define CAD_SESSION_INUSE 1
-#define CAD_SESSION_FREE  0
-
-#define CAD_SESSION_DEV_CTRL 1
-#define CAD_SESSION_VOICE_TX 2
-#define CAD_SESSION_VOICE_RX 3
-#define CAD_SESSION_PCM 4
-#define CAD_SESSION_PCM_IN 5
-#define CAD_SESSION_FM 6
-
-#if CONFIG_QSD_HTC_FM
-#define CAD_SESSION_HW_CODEC_POOL_START 7
-#define CAD_SESSION_HW_CODEC_POOL_END 9
-#else
-#define CAD_SESSION_HW_CODEC_POOL_START 6
-#define CAD_SESSION_HW_CODEC_POOL_END 9
-#endif
-
-
-struct cad_session_info_struct_type {
-	s8				status;
-	struct mutex			sync;
-	struct cad_func_tbl_type	*hw_accel;
-};
-
-struct cad_aux_pcm_gpios {
-	int	dout;
-	int	din;
-	int	syncout;
-	int	clkin_a;
-};
-
-struct cad_state_struct_type {
-	struct mutex			sync;
-	struct cad_func_tbl_type	*resource_alloc;
-	struct cad_func_tbl_type	*volume;
-	struct cad_func_tbl_type	*dtmf;
-	struct cad_func_tbl_type	*equalizer;
-	struct cad_func_tbl_type	*audiodec;
-	struct cad_func_tbl_type	*audioenc;
-	struct cad_func_tbl_type	*voicedec;
-	struct cad_func_tbl_type	*voiceenc;
-	struct cad_func_tbl_type	*device_filter;
-	struct cad_func_tbl_type	*ard;
-
-	struct cad_session_info_struct_type session_info[CAD_MAX_SESSION];
-	struct cad_aux_pcm_gpios	aux_pcm;
-};
-
-struct cad_singleton_info_struct_type {
-	u8	cad_ref_ct;
-};
-
-
-static DEFINE_SPINLOCK(slock);
-
-static struct cad_state_struct_type cad;
-static struct cad_singleton_info_struct_type cad_singleton;
-
-u8 *g_audio_mem;
-u32 g_audio_base;
-u32 g_audio_size;
-
-static u8 add_ref_count(void);
-static u8 release_ref_count(void);
-
-static int __init cad_probe(struct platform_device *pdev)
-{
-	u8			ref_count;
-	s32			rc;
-
-	rc = CAD_RES_SUCCESS;
-
-	ref_count = add_ref_count();
-
-	if (ref_count != 1) {
-		pr_err("CAD already Initialized %d\n",
-			cad_singleton.cad_ref_ct);
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	D("%s: %s called\n", MODULE_NAME, __func__);
-
-	mutex_init(&cad.sync);
-
-	g_audio_base = pdev->resource[0].start;
-	g_audio_size = pdev->resource[0].end - pdev->resource[0].start + 1;
-
-	g_audio_mem = ioremap(g_audio_base, g_audio_size);
-	if (g_audio_mem == NULL)
-		return -ENOMEM;
-
-	cad.ard			= NULL;
-	cad.audiodec		= NULL;
-	cad.audioenc		= NULL;
-	cad.device_filter	= NULL;
-	cad.voicedec		= NULL;
-	cad.voiceenc		= NULL;
-	cad.resource_alloc	= NULL;
-
-	rc = cad_audio_dec_init(&cad.audiodec);
-	if (rc != CAD_RES_SUCCESS) {
-		pr_err("cad_audio_dec_init failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	rc = cad_audio_enc_init(&cad.audioenc);
-	if (rc != CAD_RES_SUCCESS) {
-		pr_err("cad_audio_enc_init failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	rc = cad_ard_init(&cad.ard);
-	if (rc != CAD_RES_SUCCESS) {
-		pr_err("cad_ard_init failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	rc = cad_volume_init(&cad.volume);
-	if (rc != CAD_RES_SUCCESS) {
-		pr_err("cad_volume_init failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	rc = cad_dtmf_init(&cad.dtmf);
-	if (rc != CAD_RES_SUCCESS) {
-		pr_err("cad_dtmf_init failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	rc = cad_filter_eq_init(&cad.equalizer);
-	if (rc != CAD_RES_SUCCESS) {
-		pr_err("cad_filter_eq_init failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-done:
-	return rc;
-}
-
-s32 cad_open(struct cad_open_struct_type *open_param)
-{
-	s32 handle;
-	s8 resource_alloc, ard, hw_accel;
-	s32 rc;
-	int i;
-
-	D("%s: %s called\n", MODULE_NAME, __func__);
-
-	rc = CAD_RES_FAILURE;
-	handle = resource_alloc = ard = hw_accel = 0;
-
-	mutex_lock(&cad.sync);
-
-	if (open_param != NULL) {
-		switch (open_param->format) {
-		case CAD_FORMAT_PCM:
-			if (open_param->op_code == CAD_OPEN_OP_DEVICE_CTRL)
-				handle = CAD_SESSION_DEV_CTRL;
-			else if (open_param->op_code == CAD_OPEN_OP_WRITE)
-				handle = CAD_SESSION_PCM;
-			else if (open_param->op_code == CAD_OPEN_OP_READ)
-				handle = CAD_SESSION_PCM_IN;
-			break;
-		case CAD_FORMAT_MP3:
-		case CAD_FORMAT_AAC:
-			for (i = CAD_SESSION_HW_CODEC_POOL_START;
-				i <= CAD_SESSION_HW_CODEC_POOL_END; i++) {
-				if (cad.session_info[i].status ==
-					CAD_SESSION_FREE) {
-					handle = i;
-					break;
-				}
-			}
-			break;
-		case CAD_FORMAT_FM:
-			handle = CAD_SESSION_FM;
-			open_param->format = CAD_FORMAT_PCM;
-			break;
-		case CAD_FORMAT_VOICE:
-			if (open_param->op_code == CAD_OPEN_OP_WRITE)
-				handle = CAD_SESSION_VOICE_TX;
-			else if (open_param->op_code == CAD_OPEN_OP_READ)
-				handle = CAD_SESSION_VOICE_RX;
-			break;
-		default:
-			break;
-		}
-
-		if ((handle > 0) &&
-			cad.session_info[handle].status ==
-					CAD_SESSION_FREE) {
-			pr_info("cad_open: use session %d\n", handle);
-				if (open_param->op_code == CAD_OPEN_OP_READ) {
-				cad.session_info[handle].hw_accel
-							= cad.audioenc;
-				} else if (open_param->op_code ==
-					CAD_OPEN_OP_WRITE) {
-
-					if (open_param->format !=
-						CAD_FORMAT_DTMF)
-
-					cad.session_info[handle].
-							hw_accel = cad.audiodec;
-					else
-					cad.session_info[handle].
-							hw_accel = cad.dtmf;
-				}
-				rc = CAD_RES_SUCCESS;
-		}
-	} else {
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	if (rc == CAD_RES_FAILURE)
-		goto done;
-
-	if (cad.resource_alloc != NULL) {
-		if (cad.resource_alloc->open != NULL) {
-
-			rc = cad.resource_alloc->open(handle,
-							open_param);
-
-			if (rc == CAD_RES_FAILURE)
-				goto done;
-			resource_alloc = 1;
-		}
-
-	}
-
-	if ((cad.ard != NULL) && (cad.ard->open != NULL)) {
-
-		rc = cad.ard->open(handle, open_param);
-
-		if (rc == CAD_RES_FAILURE)
-			goto done;
-
-		ard = 1;
-	}
-
-	if ((cad.session_info[handle].hw_accel != NULL) &&
-		(cad.session_info[handle].hw_accel->open != NULL)) {
-
-		rc = cad.session_info[handle].hw_accel->open(
-						handle, open_param);
-
-		if (rc == CAD_RES_FAILURE)
-			goto done;
-
-		hw_accel = 1;
-	}
-
-	mutex_init(&cad.session_info[handle].sync);
-
-	if (rc == CAD_RES_SUCCESS)
-		cad.session_info[handle].status = CAD_SESSION_INUSE;
-
-done:
-	/* This could be implemented with multiple goto labels, but that would
-	   be ugly.
-	*/
-	if (rc == CAD_RES_FAILURE) {
-
-		if (ard && cad.ard->close)
-			cad.ard->close(handle);
-
-		if (hw_accel &&
-			cad.session_info[handle].hw_accel->close) {
-
-			cad.session_info[handle].hw_accel->close(
-								handle);
-		}
-
-		if (resource_alloc && cad.resource_alloc->close)
-			cad.resource_alloc->close(handle);
-
-		handle = 0;
-	}
-	mutex_unlock(&cad.sync);
-
-	return handle;
-}
-EXPORT_SYMBOL(cad_open);
-
-
-
-
-s32 cad_close(s32 driver_handle)
-{
-	s32 rc;
-
-	D("%s: %s called\n", MODULE_NAME, __func__);
-
-	rc = CAD_RES_SUCCESS;
-
-	if (driver_handle > 0) {
-
-		mutex_lock(&cad.session_info[driver_handle].sync);
-
-		if (cad.session_info[driver_handle].hw_accel &&
-			cad.session_info[driver_handle].hw_accel->close)
-			cad.session_info[driver_handle].hw_accel->
-				close(driver_handle);
-
-		if (cad.equalizer && cad.equalizer->close)
-			(void) cad.equalizer->close(driver_handle);
-
-		if (cad.ard && cad.ard->close)
-			(void) cad.ard->close(driver_handle);
-
-		if (cad.resource_alloc && cad.resource_alloc->close)
-			(void) cad.resource_alloc->close(driver_handle);
-
-		mutex_lock(&cad.sync);
-		mutex_unlock(&cad.session_info[driver_handle].sync);
-
-		cad.session_info[driver_handle].status = CAD_SESSION_FREE;
-		cad.session_info[driver_handle].hw_accel = NULL;
-
-		mutex_unlock(&cad.sync);
-	}
-
-	return rc;
-}
-EXPORT_SYMBOL(cad_close);
-
-
-
-s32 cad_read(s32 driver_handle, struct cad_buf_struct_type *buf)
-{
-	s32 data_read;
-
-	D("%s: %s called\n", MODULE_NAME, __func__);
-
-	data_read = CAD_RES_FAILURE;
-
-	if (cad.session_info[driver_handle].hw_accel &&
-		cad.session_info[driver_handle].hw_accel->read)
-		data_read = cad.session_info[driver_handle].hw_accel->
-					read(driver_handle, buf);
-
-	return buf->actual_size;
-}
-EXPORT_SYMBOL(cad_read);
-
-
-s32 cad_write(s32 driver_handle, struct cad_buf_struct_type *buf)
-{
-	s32 data_written;
-
-	D("%s: %s called\n", MODULE_NAME, __func__);
-
-	data_written = CAD_RES_FAILURE;
-
-	if (cad.session_info[driver_handle].hw_accel &&
-		cad.session_info[driver_handle].hw_accel->write)
-		data_written = cad.session_info[driver_handle].hw_accel->
-			write(driver_handle, buf);
-
-	return data_written;
-}
-EXPORT_SYMBOL(cad_write);
-
-
-s32 cad_ioctl(s32 driver_handle, u32 cmd_code, void *cmd_buf, u32 cmd_buf_len)
-{
-	s32 ret_val;
-
-	D("%s: %s called\n", MODULE_NAME, __func__);
-
-	ret_val = CAD_RES_SUCCESS;
-
-	if (cmd_code != CAD_IOCTL_CMD_STREAM_PAUSE &&
-	    cmd_code != CAD_IOCTL_CMD_STREAM_RESUME &&
-	    cmd_code != CAD_FILTER_CONFIG_STREAM_VOLUME)
-		mutex_lock(&cad.session_info[driver_handle].sync);
-
-	if (cad.ard && cad.ard->ioctl)
-		ret_val = cad.ard->ioctl(driver_handle, cmd_code, cmd_buf,
-								cmd_buf_len);
-
-	if ((ret_val != CAD_RES_FAILURE)
-		&& cad.session_info[driver_handle].hw_accel
-		&& cad.session_info[driver_handle].hw_accel->ioctl)
-		ret_val = cad.session_info[driver_handle].hw_accel->
-				ioctl(driver_handle, cmd_code, cmd_buf,
-								cmd_buf_len);
-
-	if ((ret_val == CAD_RES_SUCCESS) && cad.volume && cad.volume->ioctl)
-		ret_val = cad.volume->ioctl(driver_handle, cmd_code, cmd_buf,
-								cmd_buf_len);
-
-	if ((ret_val == CAD_RES_SUCCESS) && cad.equalizer
-			&& cad.equalizer->ioctl)
-		ret_val = cad.equalizer->ioctl(driver_handle, cmd_code,
-							cmd_buf, cmd_buf_len);
-
-	if (cmd_code != CAD_IOCTL_CMD_STREAM_PAUSE &&
-	    cmd_code != CAD_IOCTL_CMD_STREAM_RESUME &&
-	    cmd_code != CAD_FILTER_CONFIG_STREAM_VOLUME)
-		mutex_unlock(&cad.session_info[driver_handle].sync);
-
-	return ret_val;
-}
-EXPORT_SYMBOL(cad_ioctl);
-
-static struct platform_driver cad_driver = {
-	.probe = cad_probe,
-	.driver = {
-		.name = "msm_audio",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init cad_init(void)
-{
-	s32 rc;
-
-	rc = platform_driver_register(&cad_driver);
-
-	return rc;
-}
-
-static void __exit cad_exit(void)
-{
-	u8	ref_count;
-	s32	i = 0;
-
-	ref_count = release_ref_count();
-
-	if (ref_count == 0) {
-		D("%s: %s called\n", MODULE_NAME, __func__);
-
-		mutex_unlock(&cad.sync);
-
-		while (i < CAD_MAX_SESSION)
-			mutex_unlock(&cad.session_info[i++].sync);
-
-		(void)cad_audio_dec_dinit();
-		(void)cad_audio_enc_dinit();
-		(void)cad_ard_dinit();
-		(void)cad_volume_dinit();
-		(void)cad_dtmf_dinit();
-		(void)cad_filter_eq_dinit();
-
-		iounmap(g_audio_mem);
-
-	} else {
-		pr_err("CAD not De-Initialized as cad_ref_ct = %d\n",
-			cad_singleton.cad_ref_ct);
-	}
-}
-
-u8 add_ref_count(void)
-{
-	unsigned long	flags;
-
-	spin_lock_irqsave(&slock, flags);
-	cad_singleton.cad_ref_ct++;
-	spin_unlock_irqrestore(&slock, flags);
-
-	D("add_ref_count(cad_ref_ct = %d)\n", cad_singleton.cad_ref_ct);
-
-	return cad_singleton.cad_ref_ct;
-}
-
-u8 release_ref_count(void)
-{
-	unsigned long	flags;
-
-	spin_lock_irqsave(&slock, flags);
-	cad_singleton.cad_ref_ct--;
-	spin_unlock_irqrestore(&slock, flags);
-
-	D("release_ref_count(cad_ref_ct = %d)\n", cad_singleton.cad_ref_ct);
-
-	return cad_singleton.cad_ref_ct;
-}
-
-module_init(cad_init);
-module_exit(cad_exit);
-
-MODULE_DESCRIPTION("CAD driver");
-MODULE_VERSION("1.0");
-MODULE_LICENSE("GPL v2");
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dec_drv.c b/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dec_drv.c
deleted file mode 100644
index c2d0f26..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dec_drv.c
+++ /dev/null
@@ -1,245 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/err.h>
-#include <linux/slab.h>
-#include <linux/string.h>
-
-#include <mach/qdsp6/msm8k_cad_q6dec_drvi.h>
-#include <mach/qdsp6/msm8k_cad_module.h>
-#include <mach/qdsp6/msm8k_cad_q6dec_session.h>
-
-static struct q6dec_data   cad_q6dec_data;
-
-
-static s32 cad_q6dec_open(s32 session_id,
-			struct cad_open_struct_type *open_param)
-{
-	struct q6dec_session_data *session = NULL;
-	if (!open_param || session_id >= CAD_MAX_SESSION || session_id <= 0)
-		return CAD_RES_FAILURE;
-
-	if (CAD_OPEN_OP_WRITE == open_param->op_code &&
-			cad_q6dec_data.free_session_list) {
-		session = cad_q6dec_data.free_session_list;
-		if (cad_q6dec_session_open(session, session_id, open_param)) {
-			cad_q6dec_session_close(session);
-			return CAD_RES_FAILURE;
-		}
-		cad_q6dec_data.free_session_list =
-			cad_q6dec_data.free_session_list->next;
-		session->next = cad_q6dec_data.used_session_list;
-		cad_q6dec_data.used_session_list = session;
-		pr_info("cad_q6dec_open: got free session\n");
-	} else if (CAD_OPEN_OP_WRITE == open_param->op_code) {
-		pr_err("cad_q6dec_open: cannot get free session\n");
-		return CAD_RES_FAILURE;
-	} else {
-		pr_err("cad_q6dec_open: unsupported op_code %d\n",
-			open_param->op_code);
-		return CAD_RES_FAILURE;
-	}
-	return CAD_RES_SUCCESS;
-}
-
-
-static s32 cad_q6dec_close(s32 session_id)
-{
-	struct q6dec_session_data *session =
-	cad_q6dec_data.used_session_list;
-	struct q6dec_session_data *prev_session = NULL;
-	if (session_id >= CAD_MAX_SESSION || session_id <= 0)
-		return CAD_RES_FAILURE;
-
-	while (session) {
-		if (session->session_id == session_id) {
-			if (prev_session == NULL) {
-				/* first node */
-				cad_q6dec_data.used_session_list =
-					session->next;
-				break;
-			}
-			/* not first node */
-			prev_session->next = session->next;
-			break;
-		}
-		prev_session = session;
-		session = session->next;
-	}
-
-	if (session) {
-		cad_q6dec_session_close(session);
-		session->next = cad_q6dec_data.free_session_list;
-		cad_q6dec_data.free_session_list = session;
-	}
-	return CAD_RES_SUCCESS;
-}
-
-static s32 cad_q6dec_write(s32 session_id,
-			struct cad_buf_struct_type *buf)
-{
-	struct q6dec_session_data *session =
-	cad_q6dec_data.used_session_list;
-	if (!buf)
-		return CAD_RES_FAILURE;
-
-	while (session) {
-		if (session->session_id == session_id) {
-			if (cad_q6dec_session_write(session, buf))
-				return CAD_RES_FAILURE;
-			break;
-		}
-		session = session->next;
-	}
-	return CAD_RES_SUCCESS;
-}
-
-static s32 cad_q6dec_read(s32 session_id,
-			struct cad_buf_struct_type  *buf)
-{
-	pr_err("q6decoder read has not implemnted......\n");
-	return CAD_RES_SUCCESS;
-}
-
-static s32 cad_q6dec_ioctl(s32         session_id,
-				u32         cmd_code,
-				void        *cmd_buf,
-				u32         cmd_len)
-{
-	struct q6dec_session_data *session =
-		cad_q6dec_data.used_session_list;
-
-	while (session) {
-		if (session->session_id == session_id) {
-			if (cad_q6dec_session_ioctl(session, cmd_code,
-				cmd_buf, cmd_len))
-				return CAD_RES_FAILURE;
-			break;
-		}
-		session = session->next;
-	}
-
-	return CAD_RES_SUCCESS;
-}
-
-
-/* public functions */
-
-s32 cad_audio_dec_dinit(void)
-{
-	struct q6dec_session_data *session;
-	while (cad_q6dec_data.free_session_list) {
-		session = cad_q6dec_data.free_session_list->next;
-		cad_q6dec_session_deinit(cad_q6dec_data.free_session_list);
-		kfree(cad_q6dec_data.free_session_list);
-		cad_q6dec_data.free_session_list = session;
-	}
-
-	while (cad_q6dec_data.used_session_list) {
-		session = cad_q6dec_data.used_session_list->next;
-		cad_q6dec_session_deinit(cad_q6dec_data.used_session_list);
-		kfree(cad_q6dec_data.used_session_list);
-		cad_q6dec_data.used_session_list = session;
-	}
-
-	memset(&cad_q6dec_data, 0, sizeof(struct q6dec_data));
-	return CAD_RES_SUCCESS;
-}
-
-
-s32 cad_audio_dec_init(struct cad_func_tbl_type **func_tbl)
-{
-	u32 i;
-	struct q6dec_session_data *node = NULL;
-	static struct cad_func_tbl_type vtable = {
-		cad_q6dec_open,
-		cad_q6dec_close,
-		cad_q6dec_write,
-		cad_q6dec_read,
-		cad_q6dec_ioctl
-	};
-	*func_tbl = NULL;
-
-	memset(&cad_q6dec_data, 0, sizeof(struct q6dec_data));
-
-	/* create session list */
-	for (i = 0; i < Q6_DEC_MAX_STREAM_COUNT; i++) {
-		node = kmalloc(sizeof(struct q6dec_session_data),
-				GFP_KERNEL);
-		if (IS_ERR(node)) {
-			cad_audio_dec_dinit();
-			return CAD_RES_FAILURE;
-		}
-
-		memset(node, 0,
-			sizeof(struct q6dec_session_data));
-
-		if (cad_q6dec_session_init(node)) {
-			cad_q6dec_session_deinit(node);
-			kfree(node);
-			return CAD_RES_FAILURE;
-		}
-
-		node->next = cad_q6dec_data.free_session_list;
-		cad_q6dec_data.free_session_list = node;
-	}
-
-	*func_tbl = &vtable;
-	return CAD_RES_SUCCESS;
-}
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dec_session.c b/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dec_session.c
deleted file mode 100644
index 704eae4..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dec_session.c
+++ /dev/null
@@ -1,611 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/slab.h>
-#include <linux/dma-mapping.h>
-#include <linux/err.h>
-#include <linux/uaccess.h>
-#include <linux/sched.h>
-
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_session_ioctl.h>
-#include <mach/qdsp6/msm8k_cad_q6dec_session.h>
-#include <mach/qdsp6/msm8k_cad_rpc.h>
-#include <mach/qdsp6/msm8k_adsp_audio_stream_ioctl.h>
-
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_cad_q6_dec: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-
-static void cad_q6dec_session_async_callback(union adsp_audio_event *evt,
-							void *data)
-{
-	struct q6dec_session_data *self = (struct q6dec_session_data *)data;
-	struct q6dec_sesson_buffer_node		*node = NULL;
-	struct q6dec_sesson_buffer_node		*prev_node = NULL;
-
-	if ((evt->no_payload.event_data.id == ADSP_AUDIO_IOCTL_CMD_STREAM_EOS)
-		&& (self->cb_data.callback != NULL)) {
-
-		self->cb_data.callback(CAD_EVT_STATUS_EOS, NULL, 0,
-					 self->cb_data.client_data);
-		return;
-	}
-
-
-	if (evt->no_payload.event_data.id != ADSP_AUDIO_EVT_STATUS_BUF_DONE)
-		/* unknow event, and do nothing */
-		return;
-
-	mutex_lock(&self->session_mutex);
-	node = self->used_buf_list;
-	while (node) {
-		if ((u32)node->buf == evt->buffer.client_data.data) {
-			if (prev_node == NULL) {
-				/* first node */
-				self->used_buf_list = node->next;
-				break;
-			}
-			prev_node->next = node->next;
-			break;
-		}
-		prev_node = node;
-		node = node->next;
-	}
-
-	if (node) {
-		D("========>return buffer number %d, 0x%x\n",
-			self->ret_counter, (u32) node);
-		self->ret_counter++;
-		/* find match, add free buffer to the free list */
-		node->next = self->free_buf_list;
-		self->free_buf_list = node;
-
-		if (self->need_buffer_done) {
-			D("Signal buffer done event\n");
-			complete(&self->buf_done_compl);
-		}
-
-		if ((self->used_buf_list == NULL) && self->need_all_buf_done) {
-			D("Signal all buffer done event\n");
-			complete(&self->all_buf_done_compl);
-		}
-
-		if (self->cb_data.callback != NULL)
-			self->cb_data.callback(evt->
-				no_payload.event_data.id, NULL, 0,
-				self->cb_data.client_data);
-	}
-	mutex_unlock(&self->session_mutex);
-
-	return;
-}
-
-
-static struct q6dec_sesson_buffer_node *cad_q6dec_session_get_free_buf(
-	struct q6dec_session_data *self)
-{
-	struct q6dec_sesson_buffer_node *node = NULL;
-
-	mutex_lock(&self->session_mutex);
-	if (self->free_buf_list) {
-		node = self->free_buf_list;
-		self->free_buf_list = self->free_buf_list->next;
-		node->next = NULL;
-	}
-	if (node == NULL)
-		self->need_buffer_done = 1;
-
-	mutex_unlock(&self->session_mutex);
-	return node;
-}
-
-
-static s32 cad_q6dec_session_send_buf(struct q6dec_session_data *self,
-				struct q6dec_sesson_buffer_node *node,
-				u32 buf_len)
-{
-	s32				res = CAD_RES_SUCCESS;
-
-	self->q6_data_buf.buffer.flags = ADSP_AUDIO_BUFFER_FLAG_START_SET |
-		ADSP_AUDIO_BUFFER_FLAG_PHYS_ADDR;
-	self->q6_data_buf.client_data.data = (u32)node->buf;
-	self->q6_data_buf.buffer.buffer_addr = (u32)node->phys_addr;
-	self->q6_data_buf.buffer.max_size = buf_len;
-	self->q6_data_buf.buffer.actual_size = buf_len;
-	self->use_counter++;
-	D("==========> use buffer number %d, 0x%x\n",
-		       self->use_counter, (u32)node->buf);
-
-	/* add to the used list */
-	mutex_lock(&self->session_mutex);
-	node->next = self->used_buf_list;
-	self->used_buf_list = node;
-	mutex_unlock(&self->session_mutex);
-	D("----> Send %d byte of data with buffer 0x%x\n",
-			self->q6_data_buf.buffer.max_size,
-			self->q6_data_buf.buffer.buffer_addr);
-	/* rpc write*/
-	if (cad_rpc_data(self->session_id, self->group_id,
-			(void *)&self->q6_data_buf,
-			sizeof(self->q6_data_buf), NULL) !=
-			CAD_RES_SUCCESS) {
-
-		pr_err("Can not push write buffers to the Q6!!!\n");
-
-		self->use_counter--;
-		self->used_buf_list = self->used_buf_list->next;
-		node->next = self->free_buf_list;
-		self->free_buf_list = node;
-		res = CAD_RES_FAILURE;
-	}
-
-	return res;
-}
-
-
-
-static s32 cad_q6dec_session_write_buffers(struct q6dec_session_data *self,
-						u8  **input_buf,
-						u32 *input_buf_size)
-{
-	unsigned long				bytes_ret;
-	s32					err = CAD_RES_SUCCESS;
-	struct q6dec_sesson_buffer_node		*node = NULL;
-
-	while ((node = cad_q6dec_session_get_free_buf(self)) != NULL) {
-
-		/* copy the data */
-		if (*input_buf_size > self->buffer_size) {
-			/* we need more buffers */
-			bytes_ret = copy_from_user(node->buf, *input_buf,
-					   self->buffer_size);
-			err = cad_q6dec_session_send_buf(
-				self, node, self->buffer_size);
-
-			*input_buf += self->buffer_size;
-			*input_buf_size -= self->buffer_size;
-		} else {
-			/* we are done with the current buffer */
-			bytes_ret = copy_from_user(node->buf, *input_buf,
-				*input_buf_size);
-			err = cad_q6dec_session_send_buf(
-				self, node, *input_buf_size);
-			*input_buf_size = 0;
-			D("========> No more buffer data!!!!!!\n");
-			break;
-		}
-		if (bytes_ret)
-			pr_err("Copy from user failed to copy %ld bytes\n",
-				bytes_ret);
-		if (err) {
-			pr_err("Error writing data to Q6!\n");
-			break;
-		}
-	}
-	return err;
-}
-
-static void cad_q6dec_session_delete_buffer(struct q6dec_sesson_buffer_node
-	**list)
-{
-	struct q6dec_sesson_buffer_node	*node = NULL;
-
-	while (*list) {
-		node = (*list)->next;
-		kfree(*list);
-		*list = node;
-	}
-}
-
-static s32 cad_q6dec_session_create_buffer(struct q6dec_session_data *self,
-						void *cmd_buf)
-{
-	u32					i;
-	s32					result = CAD_RES_SUCCESS;
-	struct q6dec_sesson_buffer_node		*node = NULL;
-	struct cad_stream_info_struct_type	*info;
-
-	info = (struct cad_stream_info_struct_type *)cmd_buf;
-	if ((info->ses_buf_max_size == 0) ||
-		(info->ses_buf_max_size > Q6_DEC_BUFFER_SIZE_MAX) ||
-		(self->session_state != Q6_DEC_RESET)) {
-
-		return CAD_RES_FAILURE;
-	}
-
-	cad_q6dec_session_delete_buffer(&self->free_buf_list);
-	cad_q6dec_session_delete_buffer(&self->used_buf_list);
-	self->buffer_size = info->ses_buf_max_size;
-
-	if (self->shared_buf == NULL) {
-
-		/* Set to virtual address of shared memory */
-		/* reserved for this session. */
-		/* memory for each session is stored as: */
-		/* |b|p|b|p|b|p|b|p|fb|p */
-		/* b - buffer, fb - format block, p - padding */
-		self->shared_buf = g_audio_mem +
-			((Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* self->session_id);
-
-
-		if (self->shared_buf == NULL)
-			return CAD_RES_FAILURE;
-	}
-
-	memset(self->shared_buf, 0, (Q6_DEC_BUFFER_NUM_PER_STREAM *
-		(self->buffer_size + MEMORY_PADDING)));
-
-	for (i = 0; i < Q6_DEC_BUFFER_NUM_PER_STREAM; i++) {
-		node = kmalloc(sizeof(struct q6dec_sesson_buffer_node),
-				GFP_KERNEL);
-
-		if (IS_ERR(node)) {
-			result = CAD_RES_FAILURE;
-			break;
-		}
-		memset(node, 0, sizeof(struct q6dec_sesson_buffer_node));
-		node->next = self->free_buf_list;
-		self->free_buf_list = node;
-		D("----> create buffer node 0x%x\n", (u32)node);
-		/* Set each buffer to next block of buffer memory */
-		/* for this session */
-		node->buf = self->shared_buf + i * (self->buffer_size +
-			MEMORY_PADDING);
-
-		/* Set to the physical address of buffer memory */
-		node->phys_addr = g_audio_base +
-			(Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* self->session_id + i *
-			(self->buffer_size + MEMORY_PADDING);
-	}
-	return result;
-
-}
-
-
-s32 cad_q6dec_session_init(struct q6dec_session_data *self)
-{
-	mutex_init(&self->session_mutex);
-	mutex_init(&self->close_mutex);
-
-	self->q6_data_buf.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_DATA_RX;
-	self->q6_data_buf.cmd.response_type = ADSP_AUDIO_RESPONSE_ASYNC;
-
-	return CAD_RES_SUCCESS;
-}
-
-s32 cad_q6dec_session_deinit(struct q6dec_session_data *self)
-{
-	if (self->session_state != Q6_DEC_RESET)
-		cad_q6dec_session_close(self);
-
-	mutex_destroy(&self->session_mutex);
-	mutex_destroy(&self->close_mutex);
-	return CAD_RES_SUCCESS;
-}
-
-
-s32 cad_q6dec_session_open(struct q6dec_session_data *self,
-				s32 session_id,
-				struct cad_open_struct_type *open_param)
-{
-	init_completion(&self->buf_done_compl);
-	init_completion(&self->all_buf_done_compl);
-
-	if (cad_rpc_reg_callback(session_id,
-		cad_q6dec_session_async_callback, self) ==
-		CAD_RES_FAILURE) {
-
-		return CAD_RES_FAILURE;
-	}
-
-	self->session_id = session_id;
-	self->group_id = open_param->group_id;
-	self->use_counter = 1;
-	self->ret_counter = 1;
-	self->need_buffer_done = 0;
-	self->need_all_buf_done = 0;
-	self->cb_data.client_data = NULL;
-	self->cb_data.callback = NULL;
-	D("Q6dec session open successful %d\n", session_id);
-	return CAD_RES_SUCCESS;
-}
-
-s32 cad_q6dec_session_close(struct q6dec_session_data *self)
-{
-	union adsp_audio_event			ret_status;
-	struct adsp_audio_no_payload_command	q6_cmd;
-
-	init_completion(&self->all_buf_done_compl);
-
-	mutex_lock(&self->session_mutex);
-
-	if (self->session_state == Q6_DEC_CLOSING) {
-		pr_err("CAD:Q6DEC ===> Session already closing, "
-			"no need to close.\n");
-		mutex_unlock(&self->session_mutex);
-		return CAD_RES_SUCCESS;
-	}
-
-	self->session_state = Q6_DEC_CLOSING;
-	if (self->need_buffer_done)
-		complete(&self->buf_done_compl);
-
-	mutex_unlock(&self->session_mutex);
-
-	if ((self->session_state != Q6_DEC_VOICE) && self->need_flush) {
-		q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_STREAM_STOP;
-		q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-		cad_rpc_control(self->session_id, self->group_id,
-			(void *)&q6_cmd, sizeof(q6_cmd), &ret_status);
-	}
-
-	mutex_lock(&self->close_mutex);
-	mutex_lock(&self->session_mutex);
-
-	if (self->used_buf_list)
-		self->need_all_buf_done = 1;
-
-	mutex_unlock(&self->session_mutex);
-
-	if (self->need_all_buf_done) {
-		D("CAD:Q6DEC ===> wait for all buffer done event\n");
-		wait_for_completion(&self->all_buf_done_compl);
-	}
-
-	cad_rpc_dereg_callback(self->session_id,
-				cad_q6dec_session_async_callback);
-
-	mutex_lock(&self->session_mutex);
-	cad_q6dec_session_delete_buffer(&self->free_buf_list);
-	cad_q6dec_session_delete_buffer(&self->used_buf_list);
-	if (self->shared_buf != NULL)
-		self->shared_buf = NULL;
-	self->session_id = 0;
-	self->session_state = Q6_DEC_RESET;
-	self->need_buffer_done = 0;
-	self->need_all_buf_done = 0;
-	self->need_flush = 0;
-	mutex_unlock(&self->session_mutex);
-	mutex_unlock(&self->close_mutex);
-	D("Decode session close successful\n");
-
-	return CAD_RES_SUCCESS;
-}
-
-s32 cad_q6dec_session_ioctl(struct q6dec_session_data *self,
-				u32 cmd_code,
-				void *cmd_buf,
-				u32 cmd_len)
-{
-	s32					result = CAD_RES_SUCCESS;
-	union adsp_audio_event			ret_status;
-	struct adsp_audio_no_payload_command	q6_cmd;
-	struct cad_event_struct_type		*cb_struct;
-
-	switch (cmd_code) {
-	case CAD_IOCTL_CMD_SET_STREAM_EVENT_LSTR:
-		if (cmd_buf == NULL) {
-			pr_err("Invalid buffer passed to decoder ioctl\n");
-			break;
-		}
-
-		cb_struct = (struct cad_event_struct_type *)cmd_buf;
-		if ((cb_struct->callback == NULL) ||
-			(cb_struct->client_data == NULL)) {
-
-			pr_err("Can not set listener function\n");
-			break;
-		}
-		self->cb_data.client_data = cb_struct->client_data;
-		self->cb_data.callback = cb_struct->callback;
-		break;
-	case CAD_IOCTL_CMD_STREAM_START:
-		if (self->session_state != Q6_DEC_INIT) {
-			pr_err("Cannot start, decoder is in wrong state\n");
-		} else {
-			self->session_state = Q6_DEC_READY;
-			self->need_flush = 1;
-		}
-		break;
-	case CAD_IOCTL_CMD_SET_STREAM_INFO:
-		/* don't need Q6 decoder for voice call */
-		if (((struct cad_stream_info_struct_type *)cmd_buf)->app_type
-				== CAD_STREAM_APP_VOICE) {
-			self->session_state = Q6_DEC_VOICE;
-			break;
-		}
-		result = cad_q6dec_session_create_buffer(self, cmd_buf);
-		if (result == CAD_RES_SUCCESS)
-			self->session_state = Q6_DEC_INIT;
-		break;
-	case CAD_IOCTL_CMD_STREAM_FLUSH:
-	case CAD_IOCTL_CMD_SESSION_FLUSH:
-		mutex_lock(&self->session_mutex);
-
-		self->session_state = Q6_DEC_FLUSHING;
-		if (self->need_buffer_done)
-			complete(&self->buf_done_compl);
-
-		mutex_unlock(&self->session_mutex);
-
-
-		q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_SESSION_FLUSH;
-		q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-		result = cad_rpc_control(self->session_id, self->group_id,
-			(void *)&q6_cmd, sizeof(q6_cmd), &ret_status);
-		self->need_flush = 0;
-		break;
-	case CAD_IOCTL_CMD_STREAM_PAUSE:
-	case CAD_IOCTL_CMD_SESSION_PAUSE:
-		q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_SESSION_PAUSE;
-		q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-		result = cad_rpc_control(self->session_id, self->group_id,
-			(void *)&q6_cmd, sizeof(q6_cmd), &ret_status);
-
-		if ((!result) && (cmd_buf != NULL) && (cmd_len == sizeof(u64)))
-			*((u64 *)cmd_buf) = ret_status.unsigned64.value;
-		break;
-	case CAD_IOCTL_CMD_STREAM_END_OF_STREAM:
-		q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_STREAM_EOS;
-		q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_ASYNC;
-
-		result = cad_rpc_control(self->session_id, self->group_id,
-			(void *)&q6_cmd, sizeof(q6_cmd), &ret_status);
-		break;
-	case CAD_IOCTL_CMD_STREAM_RESUME:
-	case CAD_IOCTL_CMD_SESSION_RESUME:
-		if ((self->session_state == Q6_DEC_READY) ||
-			(self->session_state == Q6_DEC_FLUSHING)) {
-
-			self->session_state = Q6_DEC_READY;
-
-			q6_cmd.cmd.op_code =
-				ADSP_AUDIO_IOCTL_CMD_SESSION_RESUME;
-			q6_cmd.cmd.response_type =
-				ADSP_AUDIO_RESPONSE_COMMAND;
-
-			result = cad_rpc_control(self->session_id,
-				self->group_id, (void *)&q6_cmd,
-				sizeof(q6_cmd), &ret_status);
-
-			if ((!result) && (cmd_buf != NULL) &&
-				(cmd_len == sizeof(u64)))
-
-				*((u64 *)cmd_buf) =
-					ret_status.unsigned64.value;
-		} else {
-			result = CAD_RES_FAILURE;
-		}
-		break;
-	default:
-		break;
-	}
-
-	return result;
-}
-
-s32 cad_q6dec_session_write(struct q6dec_session_data *self,
-				struct cad_buf_struct_type *buffer)
-{
-	u8				*buf;
-	u32				buf_size;
-	s32				err;
-
-	buf = (u8 *)buffer->buffer;
-	buf_size = buffer->max_size;
-
-	self->q6_data_buf.buffer.start = buffer->time_stamp;
-	init_completion(&self->buf_done_compl);
-
-	mutex_lock(&self->close_mutex);
-	mutex_lock(&self->session_mutex);
-	if ((self->session_state != Q6_DEC_READY) &&
-		(self->session_state != Q6_DEC_FLUSHING)) {
-
-		pr_err("Received write command in wrong state for ses: %d\n",
-			self->session_id);
-		mutex_unlock(&self->close_mutex);
-		mutex_unlock(&self->session_mutex);
-		return CAD_RES_FAILURE;
-	}
-	self->session_state = Q6_DEC_READY;
-	mutex_unlock(&self->session_mutex);
-
-	D("========> Start send %d byte buffer data......\n", buf_size);
-	while (buf_size > 0) {
-		err = cad_q6dec_session_write_buffers(self, &buf, &buf_size);
-
-		if (err)
-			pr_err("Failed write to Q6\n");
-		if (buf_size == 0) {
-			D("========> Done sending the buffer data!\n");
-			break;
-		}
-
-		D("-------> Wait for buffer done event\n");
-		wait_for_completion(&self->buf_done_compl);
-
-		mutex_lock(&self->session_mutex);
-		self->need_buffer_done = 0;
-		if (self->session_state != Q6_DEC_READY) {
-			mutex_unlock(&self->session_mutex);
-			D("CAD:Q6DEC ===> No need to send the data in "
-				"state %d\n", self->session_state);
-			break;
-		}
-		mutex_unlock(&self->session_mutex);
-	}
-	self->need_buffer_done = 0;
-	mutex_unlock(&self->close_mutex);
-	return CAD_RES_SUCCESS;
-}
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dtmf_drv.c b/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dtmf_drv.c
deleted file mode 100644
index 134e2ec..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dtmf_drv.c
+++ /dev/null
@@ -1,237 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-
-#include <mach/qdsp6/msm8k_cad_module.h>
-#include <mach/qdsp6/msm8k_cad_q6dtmf_drv.h>
-#include <mach/qdsp6/msm8k_cad_q6dtmf_drvi.h>
-#include <mach/qdsp6/msm8k_cad_q6dtmf_session.h>
-
-static struct q6dtmf_driver q6_dtmf_data;
-
-static s32 cad_dtmf_open(s32 session_id,
-			struct cad_open_struct_type *open_param)
-{
-	struct q6dtmf_session		*session = NULL;
-	s32				rc = CAD_RES_SUCCESS;
-
-	if (!open_param || (session_id >= CAD_MAX_SESSION) ||
-		(session_id <= 0)) {
-
-		pr_err("Invalid prameters to dtmf open, session: %d\n",
-				session_id);
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	if (open_param->format != CAD_FORMAT_DTMF) {
-		pr_err("Format is not DTMF\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	if (q6_dtmf_data.free_session_list == NULL) {
-		pr_err("No more free DTMF sessions\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	session = q6_dtmf_data.free_session_list;
-	if (cad_dtmf_session_open(session, session_id,
-			open_param) != CAD_RES_SUCCESS) {
-		cad_dtmf_session_close(session);
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	q6_dtmf_data.free_session_list =
-		q6_dtmf_data.free_session_list->next;
-	session->next = q6_dtmf_data.used_session_list;
-	q6_dtmf_data.used_session_list = session;
-done:
-	return rc;
-}
-
-static s32 cad_dtmf_close(s32 session_id)
-{
-	struct q6dtmf_session	*prev_session = NULL;
-	struct q6dtmf_session	*session = q6_dtmf_data.used_session_list;
-	s32			rc = CAD_RES_SUCCESS;
-
-	if ((session_id >= CAD_MAX_SESSION) || (session_id <= 0)) {
-		pr_err("Invalid session ID for dtmf close, session_id:  %d\n",
-			session_id);
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	while (session) {
-		if (session->session_id == session_id) {
-			if (prev_session == NULL) {
-				/* first node */
-				q6_dtmf_data.used_session_list = session->next;
-				break;
-			}
-			/* not the first node */
-			prev_session->next = session->next;
-			break;
-		}
-		/* no match */
-		prev_session = session;
-		session = session->next;
-	}
-
-	if (session) {
-		cad_dtmf_session_close(session);
-		session->next = q6_dtmf_data.free_session_list;
-		q6_dtmf_data.free_session_list = session;
-	}
-done:
-	return rc;
-}
-
-
-
-static s32 cad_dtmf_ioctl(s32 session_id, u32 cmd_code, void *cmd_buf,
-				u32 cmd_len)
-{
-	struct q6dtmf_session	*session = q6_dtmf_data.used_session_list;
-	s32			rc = CAD_RES_SUCCESS;
-
-	while (session) {
-		if (session->session_id == session_id) {
-			if (cad_dtmf_session_ioctl(session, cmd_code, cmd_buf,
-				cmd_len) != CAD_RES_SUCCESS) {
-
-				pr_err("Call to dtmf session ioctl failed\n");
-				rc = CAD_RES_FAILURE;
-				goto done;
-			}
-			break;
-		}
-		session = session->next;
-	}
-done:
-	return rc;
-}
-s32 cad_dtmf_dinit(void)
-{
-	struct q6dtmf_session	*session;
-
-	while (q6_dtmf_data.free_session_list) {
-		session = q6_dtmf_data.free_session_list->next;
-		cad_dtmf_session_dinit(q6_dtmf_data.free_session_list);
-		kfree(q6_dtmf_data.free_session_list);
-		q6_dtmf_data.free_session_list = session;
-	}
-
-	while (q6_dtmf_data.used_session_list) {
-		session = q6_dtmf_data.used_session_list->next;
-		cad_dtmf_session_dinit(q6_dtmf_data.used_session_list);
-		kfree(q6_dtmf_data.used_session_list);
-		q6_dtmf_data.used_session_list = session;
-	}
-	memset(&q6_dtmf_data, 0, sizeof(q6_dtmf_data));
-	return CAD_RES_SUCCESS;
-}
-
-
-s32 cad_dtmf_init(struct cad_func_tbl_type **func_tbl)
-{
-	u32				i;
-	s32				rc = CAD_RES_SUCCESS;
-	struct q6dtmf_session		*session = NULL;
-
-	static struct cad_func_tbl_type		vtable = {
-		cad_dtmf_open,
-		cad_dtmf_close,
-		NULL,
-		NULL,
-		cad_dtmf_ioctl
-	};
-
-	memset(&q6_dtmf_data, 0, sizeof(q6_dtmf_data));
-
-	for (i = 0; i < CAD_DTMF_SESSION_MAX; i++) {
-		session = kmalloc(sizeof(*session), GFP_KERNEL);
-		if (session == NULL) {
-			pr_err("Could not allocate memory for the session\n");
-			cad_dtmf_dinit();
-			rc = CAD_RES_FAILURE;
-			goto done;
-
-		}
-
-		memset(session, 0, sizeof(*session));
-		if (cad_dtmf_session_init(session) != CAD_RES_SUCCESS) {
-			pr_err("Call to dtmf session init failed\n");
-			cad_dtmf_dinit();
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		session->next = q6_dtmf_data.free_session_list;
-		q6_dtmf_data.free_session_list = session;
-	}
-
-	*func_tbl = &vtable;
-done:
-	return rc;
-}
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dtmf_session.c b/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dtmf_session.c
deleted file mode 100644
index 168810c..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6dtmf_session.c
+++ /dev/null
@@ -1,128 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <mach/qdsp6/msm8k_cad_q6dtmf_session.h>
-#include <mach/qdsp6/msm8k_cad_rpc.h>
-#include <mach/qdsp6/msm8k_cad_volume.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_adsp_audio_stream_ioctl.h>
-#include <mach/qdsp6/msm8k_adsp_audio_command.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_cad: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-s32 cad_dtmf_session_init(struct q6dtmf_session *self)
-{
-	return CAD_RES_SUCCESS;
-}
-
-
-s32 cad_dtmf_session_dinit(struct q6dtmf_session *self)
-{
-	return CAD_RES_SUCCESS;
-}
-
-
-s32 cad_dtmf_session_open(struct q6dtmf_session *self, s32 session_id,
-				struct cad_open_struct_type *open_param)
-{
-	self->session_id = session_id;
-	D("CAD:DTMF ===> Session open successful\n");
-	return CAD_RES_SUCCESS;
-}
-
-
-s32 cad_dtmf_session_close(struct q6dtmf_session *self)
-{
-	self->session_id = 0;
-	D("CAD:DTMF ===> Session close successful\n");
-	return CAD_RES_SUCCESS;
-}
-
-
-s32 cad_dtmf_session_ioctl(struct q6dtmf_session *self, s32 cmd_code,
-				void *cmd_buf, s32 cmd_len)
-{
-	union adsp_audio_event			return_status;
-	struct adsp_audio_dtmf_start_command	dtmf_cmd;
-	struct cad_cmd_gen_dtmf			*data;
-	s32					result = CAD_RES_SUCCESS;
-
-	switch (cmd_code) {
-	case CAD_IOCTL_CMD_GEN_DTMF:
-		data = (struct cad_cmd_gen_dtmf *)cmd_buf;
-		dtmf_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_SESSION_DTMF_START;
-		dtmf_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-		dtmf_cmd.tone1_hz = data->dtmf_hi;
-		dtmf_cmd.tone2_hz = data->dtmf_low;
-		dtmf_cmd.duration_usec = data->duration * 1000;
-		dtmf_cmd.gain_mb = data->rx_gain;
-		D("CAD:DTMF ===> send %d, %d, %d, %d\n", dtmf_cmd.tone1_hz,
-			dtmf_cmd.tone2_hz, dtmf_cmd.duration_usec,
-			dtmf_cmd.gain_mb);
-
-		/* send the dtmf start with the configuration */
-		result = cad_rpc_control(self->session_id, self->group_id,
-			(void *)&dtmf_cmd, sizeof(dtmf_cmd), &return_status);
-		break;
-	}
-
-	return result;
-}
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6enc_drv.c b/arch/arm/mach-msm/qdsp6/msm8k_cad_q6enc_drv.c
deleted file mode 100644
index 4ee0408..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6enc_drv.c
+++ /dev/null
@@ -1,242 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/mutex.h>
-#include <linux/slab.h>
-#include <linux/semaphore.h>
-
-#include <mach/qdsp6/msm8k_cad_q6enc_drvi.h>
-#include <mach/qdsp6/msm8k_cad_module.h>
-#include <mach/qdsp6/msm8k_cad_rpc.h>
-#include <mach/qdsp6/msm8k_cad_q6enc_session.h>
-
-
-static struct q6_audio_enc_data  q6_enc_data;
-
-
-static s32 cad_q6enc_open(s32 session_id,
-		struct cad_open_struct_type *open_param)
-{
-	struct q6_enc_session_data	*session = NULL;
-
-	if (!open_param || (session_id >= CAD_MAX_SESSION) || session_id <= 0)
-		return CAD_RES_FAILURE;
-
-	if ((open_param->op_code == CAD_OPEN_OP_READ) &&
-		q6_enc_data.q6_enc_free_sessions) {
-
-		session = q6_enc_data.q6_enc_free_sessions;
-
-		if (cad_q6enc_session_open(session, session_id, open_param) !=
-			CAD_RES_SUCCESS) {
-
-			cad_q6enc_session_close(session);
-			return CAD_RES_FAILURE;
-		}
-		q6_enc_data.q6_enc_free_sessions =
-			q6_enc_data.q6_enc_free_sessions->next;
-
-		session->next = q6_enc_data.q6_enc_used_sessions;
-		q6_enc_data.q6_enc_used_sessions = session;
-		pr_info("cad_q6enc_open: got free session\n");
-	} else if (CAD_OPEN_OP_READ == open_param->op_code) {
-		pr_err("cad_q6enc_open: cannot get free session\n");
-		return CAD_RES_FAILURE;
-	} else {
-		pr_err("cad_q6enc_open: unsupported op_code %d\n",
-			open_param->op_code);
-		return CAD_RES_FAILURE;
-	}
-	return CAD_RES_SUCCESS;
-}
-
-
-static s32 cad_q6enc_close(s32 session_id)
-{
-	struct q6_enc_session_data *prev_session = NULL;
-	struct q6_enc_session_data *session = q6_enc_data.q6_enc_used_sessions;
-
-	if ((session_id >= CAD_MAX_SESSION) || (session_id <= 0))
-		return CAD_RES_FAILURE;
-
-	/* get the right session */
-	while (session) {
-		if (session_id == session->session_id) {
-			if (prev_session == NULL) {
-				/* first node */
-				q6_enc_data.q6_enc_used_sessions =
-					session->next;
-				break;
-			}
-			/* not first node */
-			prev_session->next = session->next;
-			break;
-		}
-		prev_session = session;
-		session = session->next;
-	}
-
-	if (session != NULL) {
-		cad_q6enc_session_close(session);
-		session->next = q6_enc_data.q6_enc_free_sessions;
-		q6_enc_data.q6_enc_free_sessions = session;
-	}
-
-	return CAD_RES_SUCCESS;
-}
-
-static s32 cad_q6enc_write(s32 session_id, struct cad_buf_struct_type *buf)
-{
-	return CAD_RES_SUCCESS;
-}
-
-static s32 cad_q6enc_read(s32 session_id, struct cad_buf_struct_type *buf)
-{
-	struct q6_enc_session_data *session = q6_enc_data.q6_enc_used_sessions;
-
-	if (!buf)
-		return CAD_RES_FAILURE;
-
-	while (session != NULL) {
-		if (session_id == session->session_id) {
-			if (cad_q6enc_session_read(session, buf)
-					!= CAD_RES_SUCCESS)
-				return CAD_RES_FAILURE;
-			break;
-		}
-		session = session->next;
-	}
-	return CAD_RES_SUCCESS;
-}
-
-static s32 cad_q6enc_ioctl(s32 session_id, u32 cmd_code, void *cmd_buf,
-			u32 cmd_len)
-{
-	struct q6_enc_session_data *session = q6_enc_data.q6_enc_used_sessions;
-
-	while (session != NULL) {
-		if (session_id == session->session_id) {
-			if (cad_q6enc_session_ioctl(session, cmd_code, cmd_buf,
-				cmd_len) != CAD_RES_SUCCESS)
-				return CAD_RES_FAILURE;
-			break;
-		}
-		session = session->next;
-	}
-	return CAD_RES_SUCCESS;
-}
-
-
-s32 cad_audio_enc_dinit(void)
-{
-	struct q6_enc_session_data *session = NULL;
-
-	while (q6_enc_data.q6_enc_free_sessions) {
-		session = q6_enc_data.q6_enc_free_sessions->next;
-		cad_q6enc_session_dinit(q6_enc_data.q6_enc_free_sessions);
-		kfree(q6_enc_data.q6_enc_free_sessions);
-		q6_enc_data.q6_enc_free_sessions = session;
-	}
-
-	while (q6_enc_data.q6_enc_used_sessions) {
-		session = q6_enc_data.q6_enc_used_sessions->next;
-		cad_q6enc_session_dinit(q6_enc_data.q6_enc_used_sessions);
-		kfree(q6_enc_data.q6_enc_used_sessions);
-		q6_enc_data.q6_enc_used_sessions = session;
-	}
-
-	memset(&q6_enc_data, 0, sizeof(q6_enc_data));
-	return CAD_RES_SUCCESS;
-}
-
-
-s32 cad_audio_enc_init(struct cad_func_tbl_type **func_ptr_tbl)
-{
-	u32 i;
-	struct q6_enc_session_data *node = NULL;
-
-	static struct cad_func_tbl_type  vtable = {
-		cad_q6enc_open,
-		cad_q6enc_close,
-		cad_q6enc_write,
-		cad_q6enc_read,
-		cad_q6enc_ioctl
-	};
-
-	memset(&q6_enc_data, 0, sizeof(q6_enc_data));
-
-	/* create session list */
-	for (i = 0; i < Q6_ENC_MAX_SESSION_COUNT; i++) {
-
-		node = kmalloc(sizeof(struct q6_enc_session_data), GFP_KERNEL);
-		if (node == NULL) {
-			cad_audio_enc_dinit();
-			return CAD_RES_FAILURE;
-		}
-
-		memset(node, 0, sizeof(struct q6_enc_session_data));
-		if (cad_q6enc_session_init(node) != CAD_RES_SUCCESS) {
-			cad_audio_enc_dinit();
-			return CAD_RES_FAILURE;
-		}
-		node->next = q6_enc_data.q6_enc_free_sessions;
-		q6_enc_data.q6_enc_free_sessions = node;
-	}
-	*func_ptr_tbl = &vtable;
-	return CAD_RES_SUCCESS;
-}
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6enc_session.c b/arch/arm/mach-msm/qdsp6/msm8k_cad_q6enc_session.c
deleted file mode 100644
index 6aedbf7..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6enc_session.c
+++ /dev/null
@@ -1,562 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/mutex.h>
-#include <linux/slab.h>
-#include <linux/uaccess.h>
-
-#include <mach/qdsp6/msm8k_cad_session_ioctl.h>
-#include <mach/qdsp6/msm8k_cad_q6enc_session.h>
-#include <mach/qdsp6/msm8k_cad_rpc.h>
-#include <mach/qdsp6/msm8k_cad_q6dec_drvi.h>
-#include <mach/qdsp6/msm8k_adsp_audio_stream_ioctl.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_cad_q6_enc: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-/* release the buffer memory */
-static void release_buffers(struct q6_enc_session_buf_node **head)
-{
-	struct q6_enc_session_buf_node *node;
-	while (*head) {
-		node = (*head)->next;
-		kfree(*head);
-		*head = node;
-	}
-}
-
-/* create the buffer node */
-static s32 create_buffers(struct q6_enc_session_data *self, void *cmd_buf)
-{
-	u32					i;
-	s32					res;
-	struct q6_enc_session_buf_node		*node = NULL;
-	struct cad_stream_info_struct_type	*info;
-
-	res = CAD_RES_SUCCESS;
-	info = (struct cad_stream_info_struct_type *)cmd_buf;
-
-	/* limit the buffer size and create buf only in reset state */
-	if (info->ses_buf_max_size == 0  ||
-		info->ses_buf_max_size > Q6_ENC_BUF_MAX_SIZE ||
-		self->session_state != Q6_ENC_STATE_RESET) {
-
-		return CAD_RES_FAILURE;
-	}
-
-	self->buf_size = info->ses_buf_max_size;
-	/* for safty, clean all the buffer lists */
-	release_buffers(&self->full_nodes_head);
-	self->full_nodes_head = NULL;
-	self->full_nodes_tail = NULL;
-	release_buffers(&self->used_nodes);
-	release_buffers(&self->free_nodes);
-
-	if (self->shared_buffer == NULL) {
-
-		/* Set to virtual address of shared memory */
-		/* reserved for this session. */
-		/* memory for each session is stored as: */
-		/* |b|p|b|p|b|p|b|p|fb|p */
-		/* b - buffer, fb - format block, p - padding */
-		self->shared_buffer = g_audio_mem +
-			((Q6_ENC_BUFFER_NUM_PER_STREAM *
-			(Q6_ENC_BUF_MAX_SIZE + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* self->session_id);
-
-		if (self->shared_buffer == NULL)
-			return CAD_RES_FAILURE;
-	}
-
-	memset(self->shared_buffer, 0, (Q6_ENC_BUFFER_NUM_PER_STREAM *
-		(self->buf_size + MEMORY_PADDING)));
-
-	/* it's time the create the read buffers */
-	for (i = 0; i < Q6_ENC_BUFFER_NUM_PER_STREAM; i++) {
-
-		node = kmalloc(sizeof(struct q6_enc_session_buf_node),
-				GFP_KERNEL);
-		if (node == NULL) {
-			release_buffers(&self->free_nodes);
-			res = CAD_RES_FAILURE;
-			break;
-		}
-
-		memset(node, 0, sizeof(struct q6_enc_session_buf_node));
-		node->next = self->free_nodes;
-		self->free_nodes = node;
-		D("----> create buffer node 0x%x\n", (u32)node);
-		/* Set each buffer to next block of buffer memory */
-		/* for this session */
-		node->buf = (u8 *)((u32)self->shared_buffer +
-			i * (self->buf_size + MEMORY_PADDING));
-
-		/* Set to the physical address of buffer memory */
-		node->phys_addr = g_audio_base +
-			(Q6_ENC_BUFFER_NUM_PER_STREAM *
-			(Q6_ENC_BUF_MAX_SIZE + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* self->session_id + i *
-			(self->buf_size + MEMORY_PADDING);
-	}
-	return res;
-}
-
-/* push all the free buffers to the Q6 */
-static s32 send_buffers(struct q6_enc_session_data *self)
-{
-	struct q6_enc_session_buf_node	*node = NULL;
-	s32				res = CAD_RES_SUCCESS;
-
-	mutex_lock(&self->session_mutex);
-	while (self->free_nodes) {
-		node = self->free_nodes;
-		self->free_nodes = node->next;
-
-		self->q6_data_buf.client_data.data = (u32)node->buf;
-		self->q6_data_buf.buffer.flags =
-			ADSP_AUDIO_BUFFER_FLAG_PHYS_ADDR;
-		self->q6_data_buf.buffer.buffer_addr = node->phys_addr;
-		self->q6_data_buf.buffer.actual_size = self->buf_size;
-		self->q6_data_buf.buffer.max_size = self->buf_size;
-
-		/* add to used list */
-		node->next = self->used_nodes;
-		self->used_nodes = node;
-		mutex_unlock(&self->session_mutex);
-
-		if (cad_rpc_data(self->session_id, self->group_id,
-			(void *)&self->q6_data_buf,
-			sizeof(self->q6_data_buf), NULL) !=
-			CAD_RES_SUCCESS) {
-
-			pr_err("Can not push read buffers to the Q6!!!\n");
-			mutex_lock(&self->session_mutex);
-			self->used_nodes = self->used_nodes->next;
-			node->next = self->free_nodes;
-			self->free_nodes = node;
-			mutex_unlock(&self->session_mutex);
-			res = CAD_RES_FAILURE;
-			break;
-		}
-		D("Send Buffer (0x%x) to Q6\n",
-			self->q6_data_buf.buffer.buffer_addr);
-		/* lock for next loop iteration */
-		mutex_lock(&self->session_mutex);
-	}
-	mutex_unlock(&self->session_mutex);
-	return res;
-}
-
-static void cad_q6enc_session_handle_async_evt(
-	union adsp_audio_event *return_event, void *client_data)
-{
-	struct q6_enc_session_buf_node	*node = NULL;
-	struct q6_enc_session_buf_node	*prev_node = NULL;
-	struct q6_enc_session_data	*self = client_data;
-
-	if (return_event->no_payload.event_data.id !=
-		ADSP_AUDIO_EVT_STATUS_BUF_DONE) {
-
-		/* unhandled event */
-		pr_err("invalid event ID: %d\n",
-			return_event->no_payload.event_data.id);
-		return;
-	}
-
-	mutex_lock(&self->session_mutex);
-	node = self->used_nodes;
-
-	while (node) {
-		if ((u32)node->buf ==
-			return_event->buffer.client_data.data) {
-
-			if (prev_node == NULL) {
-				self->used_nodes = node->next;
-				break;
-			}
-			prev_node->next = node->next;
-			break;
-		}
-		prev_node = node;
-		node = node->next;
-	}
-
-	if (node) {
-		node->buf_len = return_event->
-			buffer.buffer.actual_size;
-
-		/* put this node into full list */
-		D("Get full read buffer(0x%x)!\n",
-			return_event->buffer.buffer.buffer_addr);
-
-		if (self->full_nodes_head == NULL) {
-			self->full_nodes_head = node;
-			self->full_nodes_tail = node;
-		} else {
-			self->full_nodes_tail->next = node;
-			self->full_nodes_tail = node;
-		}
-
-		/* signal buf done event */
-		if (self->signal_buf_done)
-			complete(&self->buf_done_compl);
-		/* check if we need all buf done */
-		if ((self->used_nodes == NULL) && self->signal_all_buf_done)
-			complete(&self->all_buf_done_compl);
-
-		if (self->cb_data.callback != NULL)
-			self->cb_data.callback(return_event->no_payload.
-			event_data.id, NULL, 0, self->cb_data.client_data);
-	}
-	mutex_unlock(&self->session_mutex);
-	return;
-}
-
-
-s32 cad_q6enc_session_init(struct q6_enc_session_data *self)
-{
-	mutex_init(&self->session_mutex);
-	mutex_init(&self->close_mutex);
-	init_completion(&self->all_buf_done_compl);
-	init_completion(&self->buf_done_compl);
-
-	self->q6_data_buf.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_DATA_TX;
-	self->q6_data_buf.cmd.response_type = ADSP_AUDIO_RESPONSE_ASYNC;
-
-	return CAD_RES_SUCCESS;
-}
-
-s32 cad_q6enc_session_dinit(struct q6_enc_session_data *self)
-{
-	/* just an extra check */
-	if (self->session_state != Q6_ENC_STATE_RESET)
-		cad_q6enc_session_close(self);
-
-	mutex_unlock(&self->session_mutex);
-	mutex_unlock(&self->close_mutex);
-
-	return CAD_RES_SUCCESS;
-}
-
-
-s32 cad_q6enc_session_open(struct q6_enc_session_data *self, s32 session_id,
-			struct cad_open_struct_type *open_param)
-{
-	if (self->session_state != Q6_ENC_STATE_RESET) {
-		pr_err("wrong state to open read session! state: %d\n",
-			self->session_state);
-		return CAD_RES_FAILURE;
-	}
-
-	/* delay creation of the buffers until IOCTL STREAM CONFIG */
-	/* register async callback for event handle */
-	if (cad_rpc_reg_callback(session_id,
-		cad_q6enc_session_handle_async_evt, self) != CAD_RES_SUCCESS)
-		return CAD_RES_FAILURE;
-
-	self->session_id = session_id;
-	self->group_id = open_param->group_id;
-	self->signal_buf_done = 0;
-	self->signal_all_buf_done = 0;
-	self->need_flush = 0;
-	self->cb_data.client_data = NULL;
-	self->cb_data.callback = NULL;
-	D("Q6enc session open successful %d\n", session_id);
-	return CAD_RES_SUCCESS;
-}
-
-
-
-s32 cad_q6enc_session_ioctl(struct q6_enc_session_data *self, u32 cmd,
-			 void *cmd_buf, u32 cmd_buf_len)
-{
-	struct cad_event_struct_type		*cb_struct;
-	union adsp_audio_event			ret_status;
-	struct adsp_audio_no_payload_command	q6_cmd;
-	s32					res = CAD_RES_SUCCESS;
-
-	switch (cmd) {
-	case CAD_IOCTL_CMD_STREAM_PAUSE:
-	case CAD_IOCTL_CMD_SESSION_PAUSE:
-		q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_SESSION_PAUSE;
-		q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-		res = cad_rpc_control(self->session_id, self->group_id,
-			(void *)&q6_cmd, sizeof(q6_cmd), &ret_status);
-	case CAD_IOCTL_CMD_STREAM_RESUME:
-	case CAD_IOCTL_CMD_SESSION_RESUME:
-		q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_SESSION_RESUME;
-		q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-		res = cad_rpc_control(self->session_id, self->group_id,
-			(void *)&q6_cmd, sizeof(q6_cmd), &ret_status);
-	case CAD_IOCTL_CMD_SET_STREAM_EVENT_LSTR:
-		/* register the session callback function */
-		if (cmd_buf == NULL) {
-			pr_err("Invalid buffer passed to encoder ioctl\n");
-			break;
-		}
-		if (cmd_buf_len != sizeof(*cb_struct)) {
-			pr_err("Buf len dosen't match cad_event_struct_type"
-				" for encoder LSTR event\n");
-		}
-
-		cb_struct = (struct cad_event_struct_type *)cmd_buf;
-		if ((cb_struct->callback == NULL) ||
-			(cb_struct->client_data == NULL)) {
-
-			pr_err("We can not set listener function\n");
-			break;
-		}
-		self->cb_data.client_data = cb_struct->client_data;
-		self->cb_data.callback = cb_struct->callback;
-		break;
-	case CAD_IOCTL_CMD_STREAM_START:
-		if ((self->session_state != Q6_ENC_STATE_INIT) ||
-			(self->free_nodes == NULL)) {
-
-			pr_err("CAD:Q6ENC ===> can't start in wrong state!, "
-				"state: %d\n", self->session_state);
-			break;
-		}
-		/* start to push the read buffers */
-		res = send_buffers(self);
-		if (res != CAD_RES_SUCCESS)
-			pr_err("!!!!!!Problems in pushing the read buffer!\n");
-
-		/* goes to process state no matter if there is problem or not */
-		self->session_state = Q6_ENC_STATE_PROCESS;
-		self->need_flush = 1;
-		break;
-	case CAD_IOCTL_CMD_SET_STREAM_INFO:
-		/* for voice call, we don't need q6 encoder */
-		if (((struct cad_stream_info_struct_type *)cmd_buf)->app_type
-			== CAD_STREAM_APP_VOICE) {
-
-			pr_err("ignore stream info for voice call\n");
-			self->session_state = Q6_ENC_STATE_VOICE;
-			break;
-		}
-
-		if (cmd_buf == NULL) {
-			pr_err("Invalid buffer passed to encoder ioctl\n");
-			break;
-		}
-		res = create_buffers(self, cmd_buf);
-		if (res == CAD_RES_SUCCESS)
-			self->session_state = Q6_ENC_STATE_INIT;
-		break;
-	default:
-		break;
-	}
-    return res;
-}
-
-s32 cad_q6enc_session_read(struct q6_enc_session_data *self,
-			struct cad_buf_struct_type *read_buf)
-{
-	struct q6_enc_session_buf_node *node = NULL;
-
-	init_completion(&self->buf_done_compl);
-
-	mutex_lock(&self->close_mutex);
-	mutex_lock(&self->session_mutex);
-	if (self->session_state != Q6_ENC_STATE_PROCESS) {
-		pr_err("wrong state to handle read! state: %d\n",
-			self->session_state);
-		mutex_unlock(&self->session_mutex);
-		mutex_unlock(&self->close_mutex);
-		return CAD_RES_FAILURE;
-	}
-
-	if (self->full_nodes_head == NULL)
-		self->signal_buf_done = 1;
-
-	mutex_unlock(&self->session_mutex);
-
-	if (self->signal_buf_done) {
-		D("Waiting for new buffer......\n");
-		wait_for_completion(&self->buf_done_compl);
-	}
-
-	/* now we will have some buffers in the full node list */
-	mutex_lock(&self->session_mutex);
-	if (self->session_state != Q6_ENC_STATE_PROCESS) {
-		pr_err("wrong state to handle read!\n");
-		mutex_unlock(&self->session_mutex);
-		mutex_unlock(&self->close_mutex);
-		return CAD_RES_FAILURE;
-	}
-
-	self->signal_buf_done = 0;
-
-	if (self->full_nodes_head == NULL) {
-		D("No Data to Read!\n");
-		mutex_unlock(&self->session_mutex);
-		mutex_unlock(&self->close_mutex);
-		return CAD_RES_FAILURE;
-	}
-
-	node = self->full_nodes_head;
-
-	if (read_buf->max_size < node->buf_len) {
-		/* copy data from buffer to user data. */
-		if (copy_to_user(read_buf->buffer, node->buf, node->buf_len))
-			pr_err("Error: Could not copy record data into user "
-			"buffer\n");
-
-		read_buf->actual_size = read_buf->max_size;
-		node->buf_len -= read_buf->max_size;
-		node->read_ptr += read_buf->max_size;
-		D("CAD:Q6ENC1 ===> READ %d bytes of data\n",
-			read_buf->max_size);
-		mutex_unlock(&self->session_mutex);
-	} else {
-		/* Copy the entire node and remove the node from the list*/
-		self->full_nodes_head = self->full_nodes_head->next;
-		if (self->full_nodes_head == NULL)
-			self->full_nodes_tail = NULL;
-
-		node->next = NULL;
-
-		/* copy data from buffer to user data. */
-		if (copy_to_user(read_buf->buffer, node->buf, node->buf_len))
-			pr_err("Error: Could not copy record data into user"
-				"buffer\n");
-
-		read_buf->actual_size = node->buf_len;
-		D("CAD:Q6ENC2 ===> READ %d bytes of data", node->buf_len);
-		node->buf_len = 0;
-		node->next = self->free_nodes;
-		self->free_nodes = node;
-		mutex_unlock(&self->session_mutex);
-
-		send_buffers(self);
-	}
-	mutex_unlock(&self->close_mutex);
-	return CAD_RES_SUCCESS;
-}
-
-s32 cad_q6enc_session_close(struct q6_enc_session_data *self)
-{
-	union adsp_audio_event			ret_status;
-	struct adsp_audio_no_payload_command	q6_cmd;
-
-	init_completion(&self->all_buf_done_compl);
-	mutex_lock(&self->session_mutex);
-	if (self->session_state == Q6_ENC_STATE_CLOSING) {
-		pr_err("CAD:Q6ENC ===> Session already closing,"
-			"no need to close.\n");
-		mutex_unlock(&self->session_mutex);
-		return CAD_RES_FAILURE;
-	}
-	self->session_state = Q6_ENC_STATE_CLOSING;
-	mutex_unlock(&self->session_mutex);
-
-	if ((self->session_state != Q6_ENC_STATE_VOICE) && self->need_flush) {
-		q6_cmd.cmd.op_code = ADSP_AUDIO_IOCTL_CMD_STREAM_STOP;
-		q6_cmd.cmd.response_type = ADSP_AUDIO_RESPONSE_COMMAND;
-
-		cad_rpc_control(self->session_id, self->group_id,
-			(void *)&q6_cmd, sizeof(q6_cmd), &ret_status);
-	}
-
-	mutex_lock(&self->close_mutex);
-	mutex_lock(&self->session_mutex);
-	if (self->used_nodes) {
-		D("CAD:Q6ENC ===> enable all buf done signal");
-		self->signal_all_buf_done = 1;
-	}
-	mutex_unlock(&self->session_mutex);
-
-	if (self->signal_all_buf_done) {
-		D("Wait for all buf gets returned\n");
-		wait_for_completion(&self->all_buf_done_compl);
-	}
-
-	/* deregister the callback function */
-	cad_rpc_dereg_callback(self->session_id,
-		cad_q6enc_session_handle_async_evt);
-
-	mutex_lock(&self->session_mutex);
-	self->signal_buf_done = 0;
-	self->signal_all_buf_done = 0;
-	/* release all buffers */
-	release_buffers(&self->full_nodes_head);
-	self->full_nodes_tail = NULL;
-	release_buffers(&self->used_nodes);
-	release_buffers(&self->free_nodes);
-
-	if (self->shared_buffer)
-		self->shared_buffer = NULL;
-
-	self->session_id = 0;
-	self->session_state = Q6_ENC_STATE_RESET;
-	self->buf_size = 0;
-	self->need_flush = 0;
-	mutex_unlock(&self->session_mutex);
-	mutex_unlock(&self->close_mutex);
-	D("Encode session close successful\n");
-
-	return CAD_RES_SUCCESS;
-}
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6equalizer.c b/arch/arm/mach-msm/qdsp6/msm8k_cad_q6equalizer.c
deleted file mode 100644
index dac0210..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_cad_q6equalizer.c
+++ /dev/null
@@ -1,268 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/uaccess.h>
-
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_cad_rpc.h>
-#include <mach/qdsp6/msm8k_cad_module.h>
-#include <mach/qdsp6/msm8k_ard_helper.h>
-#include <mach/qdsp6/msm8k_ardi.h>
-#include <mach/qdsp6/msm8k_cad_q6eq_drvi.h>
-#include <mach/qdsp6/msm8k_adsp_audio_error.h>
-
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_eqlzr: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-static struct cad_filter_eq_driver_struct cad_filter_eq_data;
-
-s32 cad_filter_eq_send_stream_config(u32 sess_id)
-{
-	static union adsp_audio_event	result;
-	s32				rc = CAD_RES_SUCCESS;
-
-	if (ardsession[sess_id]->group_id == 0) {
-		pr_err("CAD::EQ=>Can not get group id");
-		return CAD_RES_FAILURE;
-	}
-
-	rc = cad_rpc_control(sess_id, ardsession[sess_id]->group_id,
-		(void *)&cad_filter_eq_data.eq_stream_data[sess_id],
-		sizeof(cad_filter_eq_data.eq_stream_data[sess_id]),
-		&result);
-
-	if ((rc != CAD_RES_SUCCESS) &&
-			(result.no_payload.status != ADSP_AUDIO_SUCCESS)) {
-		pr_err("%s: failed to set eq config\n", __func__);
-		return CAD_RES_FAILURE;
-	}
-
-	return CAD_RES_SUCCESS;
-}
-
-s32 cad_filter_eq_process_stream_config(s32 sess_id,
-		struct adsp_audio_set_equalizer_command *fesc)
-{
-	s32 rc = CAD_RES_SUCCESS;
-	u32 i;
-
-	/* cache the data */
-	memset(&(cad_filter_eq_data.eq_stream_data[sess_id]), 0,
-		sizeof(cad_filter_eq_data.eq_stream_data[sess_id]));
-
-	cad_filter_eq_data.eq_stream_data[sess_id].enable =
-		fesc->enable;
-	cad_filter_eq_data.eq_stream_data[sess_id].num_bands =
-		fesc->num_bands;
-
-	for (i = 0; i < fesc->num_bands; i++) {
-		cad_filter_eq_data.eq_stream_data[sess_id].eq_bands[i].
-			band_idx = fesc->eq_bands[i].band_idx;
-		cad_filter_eq_data.eq_stream_data[sess_id].eq_bands[i].
-			filter_type = fesc->eq_bands[i].filter_type;
-		cad_filter_eq_data.eq_stream_data[sess_id].eq_bands[i].
-			center_freq_hz = fesc->eq_bands[i].center_freq_hz;
-		cad_filter_eq_data.eq_stream_data[sess_id].eq_bands[i].
-			filter_gain = fesc->eq_bands[i].filter_gain;
-		cad_filter_eq_data.eq_stream_data[sess_id].eq_bands[i].
-			q_factor = fesc->eq_bands[i].q_factor;
-	}
-
-	/* check the stream status */
-	if (!ardsession[sess_id]->active) {
-		D("%s: stream is not active.\n", __func__);
-		return CAD_RES_SUCCESS;
-	}
-
-	/* send it if stream is active */
-	rc = cad_filter_eq_send_stream_config(sess_id);
-	return CAD_RES_SUCCESS;
-}
-
-s32 cad_filter_eq_process_stream_start(s32 sess_id)
-{
-	struct cadi_open_struct_type *open_struct =
-		ardsession[sess_id]->sess_open_info;
-
-	/* store the device control session */
-	if (open_struct->cad_open.op_code == CAD_OPEN_OP_DEVICE_CTRL) {
-		cad_filter_eq_data.device_session_id = sess_id;
-		D("%s: stored device control session\n", __func__);
-		return CAD_RES_SUCCESS;
-	}
-	/* skip if this is TX session */
-	if (open_struct->cad_open.op_code != CAD_OPEN_OP_WRITE) {
-		D("%s: skip TX stream session\n", __func__);
-		return CAD_RES_SUCCESS;
-	}
-	/* skip if no stream eq data */
-	if (cad_filter_eq_data.eq_stream_data[sess_id].enable ==
-			CAD_EQ_INVALID_DATA) {
-		D("%s: no valid stream eq data for session (%d)\n",
-				__func__, sess_id);
-		return CAD_RES_SUCCESS;
-	}
-	/* send stream based eq*/
-	return cad_filter_eq_send_stream_config(sess_id);
-}
-
-static s32 cad_filter_eq_close(s32 sess_id)
-{
-	/* reset the device control session */
-	if ((u32)sess_id == cad_filter_eq_data.device_session_id) {
-		cad_filter_eq_data.device_session_id = 0;
-		return CAD_RES_SUCCESS;
-	}
-
-	/* this is stream session */
-	/* reset the stream eq table since we don't cache the stream eq data */
-	cad_filter_eq_data.eq_stream_data[sess_id].enable =
-		CAD_EQ_INVALID_DATA;
-	return CAD_RES_SUCCESS;
-}
-
-static s32 cad_filter_eq_ioctl(s32 sess_id, u32 cmd, void *cmd_buf,
-		u32 cmd_buf_len)
-{
-	s32 rc = CAD_RES_SUCCESS;
-	struct cad_filter_struct *filt =
-			(struct cad_filter_struct *)cmd_buf;
-
-	switch (cmd) {
-	case CAD_IOCTL_CMD_SET_STREAM_FILTER_CONFIG:
-	case CAD_IOCTL_CMD_SET_DEVICE_FILTER_CONFIG:
-	{
-		if (cmd_buf_len != sizeof(*filt))
-			break;
-
-		/* check if this is IOCTL for EQ filter */
-		if (filt->filter_type != CAD_DEVICE_FILTER_TYPE_EQ)
-			break;
-
-		switch (filt->cmd) {
-		case CAD_FILTER_EQ_DEVICE_CONFIG:
-			if (filt->format_block_len !=
-				sizeof(struct
-				adsp_audio_set_equalizer_command)) {
-				D("%s: wrong device config format block\n",
-					__func__);
-				break;
-			}
-			/* NO OP */
-			break;
-		case CAD_FILTER_EQ_STREAM_CONFIG:
-			if (filt->format_block_len !=
-				sizeof(struct
-				adsp_audio_set_equalizer_command)) {
-
-				D("%s: wrong stream config format block.\n",
-					__func__);
-				break;
-			}
-			rc = cad_filter_eq_process_stream_config(
-				sess_id,
-				(struct adsp_audio_set_equalizer_command *)
-					filt->format_block);
-			break;
-		}
-		break;
-	}
-	case CAD_IOCTL_CMD_STREAM_START:
-		rc = cad_filter_eq_process_stream_start(sess_id);
-		break;
-	}
-	return rc;
-}
-
-s32 cad_filter_eq_init(struct cad_func_tbl_type **func_tbl)
-{
-	u32 i;
-	static struct cad_func_tbl_type vtable = {
-		NULL,
-		cad_filter_eq_close,
-		NULL,
-		NULL,
-		cad_filter_eq_ioctl
-	};
-
-	*func_tbl = &vtable;
-
-	/* init the stream/device eq tables */
-	/* set stream data to invalid */
-	for (i = 0; i < CAD_MAX_SESSION; i++) {
-		cad_filter_eq_data.eq_stream_data[i].enable =
-			CAD_EQ_INVALID_DATA;
-
-		cad_filter_eq_data.eq_stream_data[i].cmd.op_code =
-			ADSP_AUDIO_IOCTL_SET_SESSION_EQ_CONFIG;
-		cad_filter_eq_data.eq_stream_data[i].cmd.response_type =
-			ADSP_AUDIO_RESPONSE_COMMAND;
-	}
-
-	return CAD_RES_SUCCESS;
-}
-
-s32 cad_filter_eq_dinit(void)
-{
-	return CAD_RES_SUCCESS;
-}
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_cad_rpc.c b/arch/arm/mach-msm/qdsp6/msm8k_cad_rpc.c
deleted file mode 100644
index 5f4838c..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_cad_rpc.c
+++ /dev/null
@@ -1,487 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/mutex.h>
-#include <linux/sched.h>
-#include <linux/kthread.h>
-#include <linux/slab.h>
-#include <linux/dma-mapping.h>
-#include <linux/semaphore.h>
-#include <linux/completion.h>
-
-#include <mach/qdsp6/msm8k_adsp_audio_command.h>
-#include <mach/qdsp6/msm8k_cad_rpc.h>
-#include <mach/qdsp6/msm8k_cad_rpc_type.h>
-#include <mach/dal.h>
-
-
-/* this will be replace by include file daldeviceid.h later*/
-#define DALDEVICEID_AUDIO_QDSP          0x02000028
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_cad_rpc: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-/* rpc table index */
-enum {
-	ADSP_RPC_CONTROL = DALDEVICE_FIRST_DEVICE_API_IDX,
-	ADSP_RPC_DATA,
-	ADSP_RPC_INIT
-};
-
-struct callback_function_node;
-struct callback_function_node {
-	RPC_CB_FCN			cb_funct;
-	void				*client_data;
-	struct callback_function_node	*next;
-};
-
-struct cad_rpc_data_struct {
-	enum cad_rpc_process_type       processor_id;
-	struct mutex                    resource_mutex;
-	struct mutex                    rpc_cb_mutex;
-	u32                             initialized;
-	void				*remote_handle;
-
-	/* 0 = async wakeup event, 1...CAD_MAX_SESSION = sync wakeup evnt*/
-	struct completion		compl_list[CAD_MAX_SESSION];
-
-	/* sync mutex for each session call */
-	struct mutex			remote_mutex_list[CAD_MAX_SESSION];
-
-	union adsp_audio_event		sync_evt_queue[CAD_MAX_SESSION];
-
-
-	struct callback_function_node   *dal_callback_list[CAD_MAX_SESSION];
-};
-
-static struct cad_rpc_data_struct cad_rpc_data_type;
-
-static s32 cad_rpc_async_callback(union adsp_audio_event *evt)
-{
-	struct callback_function_node	*node = NULL;
-
-	D("<-------------- ARM Async callback function fired.......\n");
-	D("Get new async event(0x%x), handle: %d!!!!!!\n",
-		evt->buffer.buffer.buffer_addr,
-		evt->no_payload.source.minor);
-
-	mutex_lock(&cad_rpc_data_type.rpc_cb_mutex);
-	node = cad_rpc_data_type.dal_callback_list[evt->
-		no_payload.source.minor];
-
-	while (node) {
-		node->cb_funct(evt, node->client_data);
-		node = node->next;
-	}
-	mutex_unlock(&cad_rpc_data_type.rpc_cb_mutex);
-
-	return CAD_RES_SUCCESS;
-}
-
-static void remote_cb_function(void *context, u32 param,
-				void *evt_buf, u32 len)
-{
-	struct cad_rpc_data_struct	*self = context;
-	union adsp_audio_event		*evt = evt_buf;
-
-	if (evt->no_payload.source.domain !=
-		(u32)cad_rpc_data_type.processor_id) {
-
-		pr_err("CAD:RPC invalid domain: %d\n",
-			evt->no_payload.source.domain);
-		return;
-	}
-
-	if ((evt->no_payload.source.minor >=
-		CAD_MAX_SESSION)) {
-
-		pr_err("CAD:RPC invalid minor number: %d\n",
-			evt->no_payload.source.minor);
-		return;
-	}
-
-	switch (evt->no_payload.event_data.response_type) {
-	case ADSP_AUDIO_RESPONSE_ASYNC:
-		/* async event */
-		D("<-------CB: get async event!!!\n");
-		if (cad_rpc_async_callback(evt) != CAD_RES_SUCCESS)
-			pr_err("Async callback not fired for session %d\n",
-				evt->no_payload.source.minor);
-		break;
-
-	case ADSP_AUDIO_RESPONSE_COMMAND:
-		/* sync event */
-		memcpy(&self->sync_evt_queue[evt->no_payload.source.minor],
-			evt, sizeof(*evt));
-
-		/* now wake up the blocking thread */
-		complete(&cad_rpc_data_type.compl_list
-			[evt->no_payload.source.minor]);
-	}
-	return;
-}
-
-
-static s32 cad_rpc_get_remote_handle(void)
-{
-	s32				err = CAD_RES_SUCCESS;
-	struct cad_rpc_config_info	info;
-
-	mutex_lock(&cad_rpc_data_type.resource_mutex);
-	if (!cad_rpc_data_type.initialized) {
-		mutex_unlock(&cad_rpc_data_type.resource_mutex);
-		pr_err("cad_rpc_data not initialized.\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* already exist the handle */
-	if (cad_rpc_data_type.remote_handle) {
-		mutex_unlock(&cad_rpc_data_type.resource_mutex);
-		return CAD_RES_SUCCESS;
-	}
-
-	/* get device handle */
-	/* <peter> N-way SMD dependent.*/
-	err = daldevice_attach(DALDEVICEID_AUDIO_QDSP,
-		"DSP_DAL_AQ_AUD",
-		1/*DALRPC_DEST_QDSP*/,
-		&(cad_rpc_data_type.remote_handle));
-	if (err) {
-		mutex_unlock(&cad_rpc_data_type.resource_mutex);
-		pr_err("daldevice_attach DAL_AQ_AUD failed.\n");
-		return err;
-	}
-
-	D("Attached for session %d!\n", session_id);
-	/*  get physical addresss of the buffer */
-	memset(&info, 0, sizeof(struct cad_rpc_config_info));
-	info.domain_id = cad_rpc_data_type.processor_id;
-	info.cb_evt = dalrpc_alloc_cb(cad_rpc_data_type.
-		remote_handle,
-		&remote_cb_function, &cad_rpc_data_type);
-
-	D("Try to configure the remote session %d!\n", session_id);
-	/* initlize the rpc call */
-	err = dalrpc_fcn_5(ADSP_RPC_INIT,
-		cad_rpc_data_type.remote_handle,
-		(void *)&info,
-		sizeof(struct cad_rpc_config_info));
-	D("Configured remote session %d!\n", session_id);
-	mutex_unlock(&cad_rpc_data_type.resource_mutex);
-	return err;
-}
-
-/* public functions */
-s32 cad_rpc_init(u32 processor_id)
-{
-	u32 i;
-
-	memset(&cad_rpc_data_type, 0, sizeof(cad_rpc_data_type));
-
-	if (processor_id >= CAD_RPC_PROCESSPR_MAX)
-		return CAD_RES_FAILURE;
-
-	cad_rpc_data_type.processor_id = processor_id;
-
-	/* create mutex for data resource */
-	mutex_init(&cad_rpc_data_type.resource_mutex);
-	mutex_init(&cad_rpc_data_type.rpc_cb_mutex);
-
-	for (i = 0; i < CAD_MAX_SESSION; i++) {
-		mutex_init(&cad_rpc_data_type.remote_mutex_list[i]);
-		init_completion(&cad_rpc_data_type.compl_list[i]);
-	}
-
-	cad_rpc_data_type.initialized = 1;
-
-	/* handle zero for async rpc dh */
-	if (cad_rpc_get_remote_handle()) {
-		pr_err("RPC failed to get Q6 remote handle\n");
-		cad_rpc_deinit();
-		return CAD_RES_FAILURE;
-	}
-
-	D("DALRPC Interface Initialized!!!\n");
-	return CAD_RES_SUCCESS;
-}
-
-
-/* this function is called when everything is going away.*/
-s32 cad_rpc_deinit()
-{
-	u32 i;
-	struct callback_function_node  *node = NULL;
-
-	D("cad deinit function fired   ....... \n");
-
-	/* release remote device handle*/
-	if (cad_rpc_data_type.remote_handle)
-		daldevice_detach(cad_rpc_data_type.remote_handle);
-
-	mutex_destroy(&cad_rpc_data_type.resource_mutex);
-	mutex_destroy(&cad_rpc_data_type.rpc_cb_mutex);
-
-
-	for (i = 0; i < CAD_MAX_SESSION; i++) {
-
-		mutex_destroy(&cad_rpc_data_type.remote_mutex_list[i]);
-
-		/* clean callback  function array */
-		while (cad_rpc_data_type.dal_callback_list[i]) {
-			node = cad_rpc_data_type.dal_callback_list[i];
-			cad_rpc_data_type.dal_callback_list[i] =
-			(cad_rpc_data_type.dal_callback_list[i])->next;
-			kfree(node);
-		}
-	}
-
-	/*free shared memory first, then close file handle */
-	memset(&cad_rpc_data_type, 0, sizeof(cad_rpc_data_type));
-	D("DeInit the rpc resource interface!!!!!\n");
-	return CAD_RES_SUCCESS;
-}
-
-s32 cad_rpc_reg_callback(u32 stream_id, RPC_CB_FCN cbFCN, void *client_data)
-{
-	s32				err = CAD_RES_SUCCESS;
-	struct callback_function_node	*node = NULL;
-
-
-	if (!cbFCN && (stream_id >= CAD_MAX_SESSION))
-		return CAD_RES_FAILURE;
-
-	mutex_lock(&cad_rpc_data_type.rpc_cb_mutex);
-	if (cad_rpc_data_type.dal_callback_list[stream_id]) {
-		/* check if duplicated callback registration */
-		node = cad_rpc_data_type.dal_callback_list[stream_id];
-		while (node) {
-			if (node->cb_funct == cbFCN) {
-				/* duplicated */
-				err = CAD_RES_FAILURE;
-				break;
-			}
-			node = node->next;
-		}
-	}
-	if (err) {
-		mutex_unlock(&cad_rpc_data_type.rpc_cb_mutex);
-		return err;
-	}
-	node = kmalloc(sizeof(struct callback_function_node),
-				GFP_KERNEL);
-	if (IS_ERR(node)) {
-		mutex_unlock(&cad_rpc_data_type.rpc_cb_mutex);
-		return CAD_RES_FAILURE;
-	}
-	memset(node, 0, sizeof(struct callback_function_node));
-	node->cb_funct = cbFCN;
-	node->client_data = client_data;
-	if (cad_rpc_data_type.dal_callback_list[stream_id]) {
-		/* not first one */
-		node->next = cad_rpc_data_type.dal_callback_list[stream_id];
-		cad_rpc_data_type.dal_callback_list[stream_id] = node;
-	} else {
-		/* first one */
-		cad_rpc_data_type.dal_callback_list[stream_id] = node;
-	}
-
-	mutex_unlock(&cad_rpc_data_type.rpc_cb_mutex);
-	D("Registered the async callback function!!!\n");
-	return CAD_RES_SUCCESS;
-}
-
-s32 cad_rpc_dereg_callback(u32 stream_id, RPC_CB_FCN cbFCN)
-{
-	struct callback_function_node	*node = NULL;
-	struct callback_function_node	*prev = NULL;
-
-	if (!cbFCN && stream_id >= CAD_MAX_SESSION)
-		return CAD_RES_FAILURE;
-
-	mutex_lock(&cad_rpc_data_type.rpc_cb_mutex);
-	node = cad_rpc_data_type.dal_callback_list[stream_id];
-	while (node) {
-		if (node->cb_funct == cbFCN) {
-			if (prev == NULL) {
-				/* first node */
-				cad_rpc_data_type.dal_callback_list[stream_id] =
-					node->next;
-				kfree(node);
-				break;
-			}
-			/* remove the none first node */
-			prev->next = node->next;
-			kfree(node);
-			break;
-		}
-		prev = node;
-		node = node->next;
-	}
-	mutex_unlock(&cad_rpc_data_type.rpc_cb_mutex);
-	D("DeRegistered the async callback function!!!\n");
-	return CAD_RES_SUCCESS;
-}
-
-/*===========================================================================*/
-/* RPC Interface functions: */
-/*===========================================================================*/
-s32 cad_rpc_data(u32 stream_id,
-		u32 group_id,
-		void *data_buf,
-		u32 data_buf_len,
-		union adsp_audio_event *ret_evt)
-
-{
-	s32	err = CAD_RES_SUCCESS;
-
-	if (stream_id >= CAD_MAX_SESSION || group_id >= CAD_MAX_SESSION ||
-		!data_buf)
-
-		return CAD_RES_FAILURE;
-
-	((union adsp_audio_command *)data_buf)->no_payload.dest.domain =
-		(u8)cad_rpc_data_type.processor_id;
-
-	((union adsp_audio_command *)data_buf)->no_payload.dest.service = 0;
-	((union adsp_audio_command *)data_buf)->no_payload.dest.major =
-		(u8)group_id;
-	((union adsp_audio_command *)data_buf)->no_payload.dest.minor =
-		(u8)stream_id;
-
-	mutex_lock(&cad_rpc_data_type.remote_mutex_list[stream_id]);
-
-	err = dalrpc_fcn_5(ADSP_RPC_DATA,
-		cad_rpc_data_type.remote_handle,
-		data_buf,
-		data_buf_len);
-
-	mutex_unlock(&cad_rpc_data_type.remote_mutex_list[stream_id]);
-
-	if (err)
-		pr_err("CAD:RPC Data rpc call returned err: %d\n", err);
-
-	return err;
-}
-
-
-s32 cad_rpc_control(u32 stream_id,
-		u32 group_id,
-		void *cmd_buf,
-		u32 cmd_buf_len,
-		union adsp_audio_event *ret_evt)
-{
-	s32	err = CAD_RES_SUCCESS;
-
-
-	if (stream_id >= CAD_MAX_SESSION || group_id >= CAD_MAX_SESSION ||
-		!cmd_buf)
-
-		return CAD_RES_FAILURE;
-
-	((union adsp_audio_command *)cmd_buf)->no_payload.dest.domain =
-		(u8)cad_rpc_data_type.processor_id;
-
-	((union adsp_audio_command *)cmd_buf)->no_payload.dest.service = 0;
-	((union adsp_audio_command *)cmd_buf)->no_payload.dest.major =
-		(u8)group_id;
-	((union adsp_audio_command *)cmd_buf)->no_payload.dest.minor =
-		(u8)stream_id;
-
-	D("CAD:RPC Control stream (%d), Cmd(0x%x)\n",
-		stream_id,
-		((union adsp_audio_command *)data_buf)->no_payload.cmd.op_code);
-
-	mutex_lock(&cad_rpc_data_type.remote_mutex_list[stream_id]);
-	init_completion(&cad_rpc_data_type.compl_list[stream_id]);
-
-	err = dalrpc_fcn_5(ADSP_RPC_CONTROL,
-		cad_rpc_data_type.remote_handle,
-		cmd_buf,
-		cmd_buf_len);
-
-	if (err)
-		pr_err("CAD:RPC Data rpc call returned err: %d\n", err);
-
-	if (!err && ((union adsp_audio_command *)cmd_buf)->no_payload.
-		cmd.response_type == ADSP_AUDIO_RESPONSE_COMMAND) {
-
-		D("DALRPC Open function start wait!!!\n");
-		wait_for_completion(&cad_rpc_data_type.compl_list[stream_id]);
-		if (ret_evt != NULL) {
-			mutex_lock(&cad_rpc_data_type.resource_mutex);
-			memcpy(ret_evt,
-				&cad_rpc_data_type.sync_evt_queue[stream_id],
-				sizeof(*ret_evt));
-			mutex_unlock(&cad_rpc_data_type.resource_mutex);
-		}
-	}
-	mutex_unlock(&cad_rpc_data_type.remote_mutex_list[stream_id]);
-
-	D("CAD:RPC Control stream (%d), Cmd(0x%x) DONE!\n",
-		stream_id,
-		((union adsp_audio_command *)cmd_buf)->no_payload.cmd.op_code);
-
-	return err;
-}
-
-
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_cad_volume.c b/arch/arm/mach-msm/qdsp6/msm8k_cad_volume.c
deleted file mode 100644
index 63c0202..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_cad_volume.c
+++ /dev/null
@@ -1,977 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/uaccess.h>
-
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_cad_rpc.h>
-#include <mach/qdsp6/msm8k_cad_module.h>
-#include <mach/qdsp6/msm8k_cad_itypes.h>
-#include <mach/qdsp6/msm8k_cad_volume.h>
-#include <mach/qdsp6/msm8k_q6_api_flip_utils.h>
-#include <mach/qdsp6/msm8k_adsp_audio_stream_ioctl.h>
-#include <mach/qdsp6/msm8k_adsp_audio_device_ioctl.h>
-#include <mach/qdsp6/msm8k_adsp_audio_command.h>
-#include <mach/qdsp6/msm8k_ardi.h>
-
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_vol: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-enum cad_int_device_id {
-
-	INT_CAD_HW_DEVICE_ID_DEFAULT_TX,
-	INT_CAD_HW_DEVICE_ID_DEFAULT_RX,
-
-	/* Internal devices */
-	INT_CAD_HW_DEVICE_ID_HANDSET_MIC,
-	INT_CAD_HW_DEVICE_ID_HANDSET_SPKR,
-	INT_CAD_HW_DEVICE_ID_HEADSET_MIC,
-	INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO,
-	INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO,
-	INT_CAD_HW_DEVICE_ID_SPKR_PHONE_MIC,
-	INT_CAD_HW_DEVICE_ID_SPKR_PHONE_MONO,
-	INT_CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO,
-	INT_CAD_HW_DEVICE_ID_BT_SCO_MIC,
-	INT_CAD_HW_DEVICE_ID_BT_SCO_SPKR,
-	INT_CAD_HW_DEVICE_ID_TTY_HEADSET_MIC,
-	INT_CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR,
-
-	INT_CAD_HW_DEVICE_ID_BT_A2DP_SPKR,
-	/* Logical Device to indicate A2DP routing */
-	INT_CAD_HW_DEVICE_ID_BT_A2DP_TX,
-
-	/* I2S */
-	INT_CAD_HW_DEVICE_ID_I2S_RX,
-	INT_CAD_HW_DEVICE_ID_I2S_TX,
-
-	/* AUXPGA */
-	INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO_LB,
-	INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO_LB,
-	INT_CAD_HW_DEVICE_ID_SPEAKER_SPKR_STEREO_LB,
-	INT_CAD_HW_DEVICE_ID_SPEAKER_SPKR_MONO_LB,
-
-	/* Currently support following Single Stream/Multiple Devices combo: */
-	INT_CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_MONO_RX,
-	INT_CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_STEREO_RX,
-	INT_CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX,
-	INT_CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_STEREO_RX,
-
-	INT_CAD_HW_DEVICE_ID_MAX_NUM,
-
-	INT_CAD_HW_DEVICE_ID_INVALID
-};
-
-static struct cad_device_volume_cache
-		qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_MAX_NUM];
-
-static s32 stream_volume_cache;
-
-static u32 audio_ctrl_handle;
-
-void set_audio_ctrl_handle(u32 handle)
-{
-	audio_ctrl_handle = handle;
-}
-
-enum cad_int_device_id qdsp6_volume_device_id_mapping(u32 device_id)
-{
-	switch (device_id) {
-	case CAD_HW_DEVICE_ID_HANDSET_MIC:
-		return INT_CAD_HW_DEVICE_ID_HANDSET_MIC;
-	case CAD_HW_DEVICE_ID_HANDSET_SPKR:
-		return INT_CAD_HW_DEVICE_ID_HANDSET_SPKR;
-	case CAD_HW_DEVICE_ID_HEADSET_MIC:
-		return INT_CAD_HW_DEVICE_ID_HEADSET_MIC;
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO:
-		return INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO;
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO:
-		return INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO;
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_MIC:
-		return INT_CAD_HW_DEVICE_ID_SPKR_PHONE_MIC;
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_MONO:
-		return INT_CAD_HW_DEVICE_ID_SPKR_PHONE_MONO;
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO:
-		return INT_CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO;
-	case CAD_HW_DEVICE_ID_BT_SCO_MIC:
-		return INT_CAD_HW_DEVICE_ID_BT_SCO_MIC;
-	case CAD_HW_DEVICE_ID_BT_SCO_SPKR:
-		return INT_CAD_HW_DEVICE_ID_BT_SCO_SPKR;
-	case CAD_HW_DEVICE_ID_BT_A2DP_SPKR:
-		return INT_CAD_HW_DEVICE_ID_BT_A2DP_SPKR;
-	case CAD_HW_DEVICE_ID_TTY_HEADSET_MIC:
-		return INT_CAD_HW_DEVICE_ID_TTY_HEADSET_MIC;
-	case CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR:
-		return INT_CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR;
-	case CAD_HW_DEVICE_ID_DEFAULT_TX:
-		return INT_CAD_HW_DEVICE_ID_DEFAULT_TX;
-	case CAD_HW_DEVICE_ID_DEFAULT_RX:
-		return INT_CAD_HW_DEVICE_ID_DEFAULT_RX;
-	case CAD_HW_DEVICE_ID_BT_A2DP_TX:
-		return INT_CAD_HW_DEVICE_ID_BT_A2DP_TX;
-	case CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_MONO_RX:
-		return INT_CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_MONO_RX;
-	case CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_STEREO_RX:
-		return INT_CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_STEREO_RX;
-	case CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX:
-		return INT_CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX;
-	case CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_STEREO_RX:
-		return INT_CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_STEREO_RX;
-	case CAD_HW_DEVICE_ID_I2S_RX:
-		return INT_CAD_HW_DEVICE_ID_I2S_RX;
-	case CAD_HW_DEVICE_ID_I2S_TX:
-		return INT_CAD_HW_DEVICE_ID_I2S_TX;
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO_LB:
-		return INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO_LB;
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO_LB:
-		return INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO_LB;
-	case CAD_HW_DEVICE_ID_SPEAKER_SPKR_STEREO_LB:
-		return INT_CAD_HW_DEVICE_ID_SPEAKER_SPKR_STEREO_LB;
-	case CAD_HW_DEVICE_ID_SPEAKER_SPKR_MONO_LB:
-		return INT_CAD_HW_DEVICE_ID_SPEAKER_SPKR_MONO_LB;
-
-	default:
-		return INT_CAD_HW_DEVICE_ID_INVALID;
-	}
-}
-
-/* This computes linear mapping device volume. */
-s32 qdsp6_volume_mapping(u32 device_id, s32 percentage)
-{
-	s32 max_gain = 0;
-	s32 min_gain = 0;
-	u32 tmp_device_id = qdsp6_volume_device_id_mapping(device_id);
-
-	if (tmp_device_id == INT_CAD_HW_DEVICE_ID_INVALID) {
-		pr_err("%s: invalid device\n", __func__);
-		return 0xFFFFFFFF;
-	}
-
-	if (percentage < 0 || percentage > 100) {
-		pr_err("%s: invalid percentage\n", __func__);
-		return 0xFFFFFFFF;
-	}
-
-	max_gain = qdsp6_volume_cache_tbl[device_id].max_gain;
-	min_gain = qdsp6_volume_cache_tbl[device_id].min_gain;
-
-	return min_gain + (((max_gain - min_gain) * percentage) / 100);
-}
-
-s32 qdsp6_volume_open(s32 session_id,
-	struct cad_open_struct_type *open_param)
-{
-	return CAD_RES_SUCCESS;
-}
-
-s32 qdsp6_volume_close(s32 session_id)
-{
-	return CAD_RES_SUCCESS;
-}
-
-s32 qdsp6_volume_write(s32 session_id,
-	struct cad_buf_struct_type *buf_ptr)
-{
-	return CAD_RES_SUCCESS;
-}
-
-s32 qdsp6_volume_read(s32 session_id,
-	struct cad_buf_struct_type *buf_ptr)
-{
-	return CAD_RES_SUCCESS;
-}
-
-s32 qdsp6_volume_ioctl(s32 session_id, u32 cmd_code,
-	void *cmd_buf, u32 cmd_len)
-{
-	enum cad_int_device_id device_id = INT_CAD_HW_DEVICE_ID_INVALID;
-	struct cad_filter_struct *vol_flt = NULL;
-	struct cad_flt_cfg_dev_vol *dev_vol_buf = NULL;
-	struct cad_flt_cfg_strm_vol *stream_vol_buf = NULL;
-	struct cad_flt_cfg_dev_mute *dev_mute_buf = NULL;
-	struct cad_flt_cfg_strm_mute *stream_mute_buf = NULL;
-
-	struct adsp_audio_set_dev_volume_command	*q6_set_dev_vol = NULL;
-	struct adsp_audio_set_volume_command	*q6_set_strm_vol = NULL;
-	struct adsp_audio_set_dev_mute_command	*q6_set_dev_mute = NULL;
-	struct adsp_audio_set_mute_command	*q6_set_strm_mute = NULL;
-
-	int rc = CAD_RES_SUCCESS;
-	s32 device_volume = 0;
-	u8 *rpc_cmd_buf = NULL;
-	u32 rpc_cmd_buf_len = 0;
-	union adsp_audio_event event_payload;
-
-	struct adsp_audio_set_dev_volume_command	*q6_set_dev_vol1 = NULL;
-	struct adsp_audio_set_volume_command	*q6_set_strm_vol1 = NULL;
-	struct adsp_audio_set_dev_mute_command	*q6_set_dev_mute1 = NULL;
-	struct adsp_audio_set_mute_command	*q6_set_strm_mute1 = NULL;
-
-	u8 *rpc_cmd_buf1 = NULL;
-	u32 rpc_cmd_buf_len1 = 0;
-	union adsp_audio_event event_payload1;
-
-
-	memset(&event_payload, 0, sizeof(event_payload));
-	memset(&event_payload1, 0, sizeof(event_payload1));
-	/* Ensure session_id is valid. */
-	if (session_id < 1 || session_id >= CAD_MAX_SESSION)
-		return CAD_RES_FAILURE;
-
-	/* Not handle request other than the following two. */
-	/* Just silently succeed unrecognized IOCTLs. */
-	if (cmd_code != CAD_IOCTL_CMD_SET_STREAM_FILTER_CONFIG &&
-		cmd_code != CAD_IOCTL_CMD_SET_DEVICE_FILTER_CONFIG &&
-		cmd_code != CAD_IOCTL_CMD_STREAM_START)
-		return CAD_RES_SUCCESS;
-
-	/* Defensive programming. */
-	if ((cmd_buf == NULL
-		|| cmd_len != sizeof(struct cad_filter_struct))
-		&& cmd_code != CAD_IOCTL_CMD_STREAM_START) {
-		D("%s: invalid params\n", __func__);
-		return CAD_RES_FAILURE;
-	}
-
-	/* Do not handle stream_start for device control session. */
-	if (cmd_code == CAD_IOCTL_CMD_STREAM_START &&
-		ardsession[session_id]->session_type == DEVICE_CTRL_TYPE) {
-		D("%s: not handling for device control type\n", __func__);
-		return CAD_RES_SUCCESS;
-	}
-
-	/* Handle stream start. */
-	if (cmd_code == CAD_IOCTL_CMD_STREAM_START) {
-		if (ardsession[session_id]->sess_open_info->cad_stream.app_type
-				== CAD_STREAM_APP_VOICE) {
-			D("%s: Do not handle voice session.\n", __func__);
-			return CAD_RES_SUCCESS;
-		}
-
-		q6_set_strm_mute1 = kmalloc(
-			sizeof(*q6_set_strm_mute1),
-			GFP_KERNEL);
-		if (!q6_set_strm_mute1)
-			return CAD_RES_FAILURE;
-
-		memset(q6_set_strm_mute1, 0,
-			sizeof(*q6_set_strm_mute1));
-		/* 2. Assign values to command buffer. */
-		if (stream_volume_cache == CAD_STREAM_MIN_GAIN)
-			q6_set_strm_mute1->mute = 1;
-		else
-			q6_set_strm_mute1->mute = 0;
-
-		rpc_cmd_buf1 = (u8 *)q6_set_strm_mute1;
-		rpc_cmd_buf_len1 = sizeof(*q6_set_strm_mute1);
-		q6_set_strm_mute1->cmd.op_code =
-			ADSP_AUDIO_IOCTL_CMD_SET_STREAM_MUTE;
-		q6_set_strm_mute1->cmd.response_type =
-			ADSP_AUDIO_RESPONSE_COMMAND;
-		/* 3. Send command to Q6. */
-
-		if (ardsession[session_id]->sess_open_info->cad_open.op_code
-				== CAD_OPEN_OP_WRITE) {
-			/* Only issue stream commands for Rx path. */
-			rc = cad_rpc_control(session_id,
-				ardsession[session_id]->group_id,
-				(void *)rpc_cmd_buf1,
-				rpc_cmd_buf_len1,
-				&event_payload1);
-
-			if (rc != CAD_RES_SUCCESS) {
-				pr_err("%s: cad_rpc_control() failure\n",
-					__func__);
-				return rc;
-			}
-		}
-
-		if (stream_volume_cache != CAD_STREAM_MIN_GAIN) {
-			q6_set_strm_vol1 = kmalloc(
-				sizeof(*q6_set_strm_vol1),
-				GFP_KERNEL);
-			if (!q6_set_strm_vol1)
-				return CAD_RES_FAILURE;
-
-			/* 2. Assign values to command buffer. */
-			q6_set_strm_vol1->volume = stream_volume_cache;
-			rpc_cmd_buf1 = (u8 *)q6_set_strm_vol1;
-			rpc_cmd_buf_len1 =
-				sizeof(*q6_set_strm_vol1);
-
-			q6_set_strm_vol1->cmd.op_code =
-				ADSP_AUDIO_IOCTL_CMD_SET_STREAM_VOL;
-			q6_set_strm_vol1->cmd.response_type =
-				ADSP_AUDIO_RESPONSE_COMMAND;
-
-			if (ardsession[session_id]->sess_open_info->
-				cad_open.op_code == CAD_OPEN_OP_WRITE) {
-				/* Only issue stream commands for Rx path. */
-				rc = cad_rpc_control(session_id,
-					ardsession[session_id]->group_id,
-					(void *)rpc_cmd_buf1,
-					rpc_cmd_buf_len1,
-					&event_payload1);
-				if (rc != CAD_RES_SUCCESS) {
-					pr_err("%s: cad_rpc_control() failure\n"
-						, __func__);
-					return rc;
-				}
-			}
-		}
-
-		q6_set_dev_mute1 = kmalloc(
-			sizeof(*q6_set_dev_mute1), GFP_KERNEL);
-		if (!q6_set_dev_mute1) {
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		memset(q6_set_dev_mute1, 0,
-			sizeof(*q6_set_dev_mute1));
-
-		/* Send Device Volume during stream start. */
-		if (ardsession[session_id]->sess_open_info->cad_open.op_code
-				== CAD_OPEN_OP_READ) {
-			device_id = ard_state.def_tx_device;
-
-			if (device_id == INT_CAD_HW_DEVICE_ID_INVALID) {
-				rc = CAD_RES_FAILURE;
-				pr_err("%s: invalid device id %d\n", __func__,
-					ard_state.def_tx_device);
-				goto done;
-			}
-			q6_set_dev_mute1->path = CAD_TX_DEVICE;
-		} else if (ardsession[session_id]->sess_open_info->
-				cad_open.op_code == CAD_OPEN_OP_WRITE) {
-			device_id = ard_state.def_rx_device;
-
-			if (device_id == INT_CAD_HW_DEVICE_ID_INVALID) {
-				rc = CAD_RES_FAILURE;
-				pr_err("%s: invalid device id %d\n", __func__,
-						ard_state.def_rx_device);
-				goto done;
-			}
-			q6_set_dev_mute1->path = CAD_RX_DEVICE;
-		}
-
-		/* 2. Assign values to command buffer. */
-		q6_set_dev_mute1->device_id = q6_device_id_mapping(device_id);
-
-		device_id = qdsp6_volume_device_id_mapping(device_id);
-
-		if ((qdsp6_volume_cache_tbl[device_id].mute == 1) ||
-			(qdsp6_volume_cache_tbl[device_id].current_volume ==
-				qdsp6_volume_cache_tbl[device_id].min_gain))
-			q6_set_dev_mute1->mute = 1;
-		else
-			q6_set_dev_mute1->mute = 0;
-
-		rpc_cmd_buf1 = (u8 *)q6_set_dev_mute1;
-		rpc_cmd_buf_len1 = sizeof(*q6_set_dev_mute1);
-
-		q6_set_dev_mute1->cmd.op_code =
-			ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_MUTE;
-		q6_set_dev_mute1->cmd.response_type =
-			ADSP_AUDIO_RESPONSE_COMMAND;
-
-		rc = cad_rpc_control(audio_ctrl_handle,
-				ardsession[audio_ctrl_handle]->group_id,
-				(void *)rpc_cmd_buf1,
-				rpc_cmd_buf_len1,
-				&event_payload1);
-
-		if (rc != CAD_RES_SUCCESS) {
-			pr_err("%s: cad_rpc_control() failure\n",
-				__func__);
-			return rc;
-		}
-
-		if ((qdsp6_volume_cache_tbl[device_id].mute == 0) &&
-			(qdsp6_volume_cache_tbl[device_id].current_volume !=
-				qdsp6_volume_cache_tbl[device_id].min_gain)) {
-
-			q6_set_dev_vol1 = kmalloc(
-				sizeof(*q6_set_dev_vol1),
-				GFP_KERNEL);
-			if (!q6_set_dev_vol1)
-				return CAD_RES_FAILURE;
-
-			memset(q6_set_dev_vol1, 0,
-				sizeof(*q6_set_dev_vol1));
-
-			if (qdsp6_volume_cache_tbl[device_id].
-						valid_current_volume == 1) {
-				q6_set_dev_vol1->volume =
-					qdsp6_volume_cache_tbl[device_id].
-							current_volume;
-				D("%s: current_volume is %d\n", __func__,
-						q6_set_dev_vol1->volume);
-			} else {
-				q6_set_dev_vol1->volume =
-					qdsp6_volume_cache_tbl[device_id].
-							default_volume;
-				D("%s: current_volume is %d (default)\n",
-					__func__, q6_set_dev_vol1->volume);
-			}
-
-			q6_set_dev_vol1->path = q6_set_dev_mute1->path;
-			q6_set_dev_vol1->device_id =
-				q6_set_dev_mute1->device_id;
-			rpc_cmd_buf1 = (u8 *)q6_set_dev_vol1;
-			rpc_cmd_buf_len1 =
-				sizeof(*q6_set_dev_vol1);
-
-			q6_set_dev_vol1->cmd.op_code =
-				ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_VOL;
-			q6_set_dev_vol1->cmd.response_type =
-				ADSP_AUDIO_RESPONSE_COMMAND;
-
-			rc = cad_rpc_control(audio_ctrl_handle,
-				ardsession[audio_ctrl_handle]->group_id,
-				(void *)rpc_cmd_buf1,
-				rpc_cmd_buf_len1,
-				&event_payload1);
-
-			if (rc != CAD_RES_SUCCESS) {
-				pr_err("%s: cad_rpc_control() failure\n",
-					__func__);
-				return rc;
-			}
-		}
-
-		rc = CAD_RES_SUCCESS;
-		goto done;
-	}
-
-	if ((cmd_buf == NULL) || (cmd_len !=
-			sizeof(struct cad_filter_struct))) {
-		pr_err("%s: invalid ioctl params\n", __func__);
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	vol_flt = (struct cad_filter_struct *)cmd_buf;
-
-	if (vol_flt->filter_type != CAD_DEVICE_FILTER_TYPE_VOL) {
-		D("%s: not volume filter type\n", __func__);
-		rc = CAD_RES_SUCCESS;
-		goto done;
-	}
-
-	/* Find the appropriate command type. */
-	if (cmd_code == CAD_IOCTL_CMD_SET_DEVICE_FILTER_CONFIG
-		&& vol_flt->cmd == CAD_FILTER_CONFIG_DEVICE_VOLUME
-		&& vol_flt->format_block_len ==
-			sizeof(struct cad_flt_cfg_dev_vol))
-		dev_vol_buf =
-			(struct cad_flt_cfg_dev_vol *)
-					vol_flt->format_block;
-	else if (CAD_IOCTL_CMD_SET_DEVICE_FILTER_CONFIG == cmd_code
-		&& vol_flt->cmd == CAD_FILTER_CONFIG_DEVICE_MUTE
-		&& vol_flt->format_block_len ==
-			sizeof(struct cad_flt_cfg_dev_mute))
-		dev_mute_buf = (struct cad_flt_cfg_dev_mute *)
-						vol_flt->format_block;
-
-	/* stream session */
-	else if (cmd_code == CAD_IOCTL_CMD_SET_STREAM_FILTER_CONFIG
-		&& vol_flt->cmd == CAD_FILTER_CONFIG_STREAM_VOLUME
-		&& vol_flt->format_block_len ==
-			sizeof(struct cad_flt_cfg_strm_vol))
-		stream_vol_buf = (struct cad_flt_cfg_strm_vol *)(
-					vol_flt->format_block);
-
-	else if (cmd_code == CAD_IOCTL_CMD_SET_STREAM_FILTER_CONFIG
-		&& vol_flt->cmd == CAD_FILTER_CONFIG_STREAM_MUTE
-		&& vol_flt->format_block_len ==
-			sizeof(struct cad_flt_cfg_strm_mute))
-		stream_mute_buf = (struct cad_flt_cfg_strm_mute *)
-						(vol_flt->format_block);
-
-	else {
-		pr_err("CAD:VOL: Error: wrong type id.\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* Handle volume control command. */
-	switch (vol_flt->cmd) {
-	case CAD_FILTER_CONFIG_DEVICE_VOLUME:
-		D("CAD:VOL: Device Volume\n");
-
-		if (dev_vol_buf->device_id == 0 ||
-			dev_vol_buf->device_id > CAD_HW_DEVICE_ID_MAX_NUM) {
-			pr_err("%s: invalid device id %d.\n",
-					__func__, dev_vol_buf->device_id);
-			rc = CAD_RES_FAILURE;
-			goto done;
-		}
-
-		if (dev_vol_buf->device_id == CAD_HW_DEVICE_ID_DEFAULT_TX)
-			dev_vol_buf->device_id = ard_state.def_tx_device;
-		else if (dev_vol_buf->device_id == CAD_HW_DEVICE_ID_DEFAULT_RX)
-			dev_vol_buf->device_id = ard_state.def_rx_device;
-		else
-			; /* Do nothing. */
-
-		if (ardsession[session_id]->sess_open_info->cad_open.op_code
-				== CAD_OPEN_OP_READ) {
-			if (dev_vol_buf->device_id !=
-					ard_state.def_tx_device) {
-				pr_err("%s: %d is not current device id.\n",
-					__func__, dev_vol_buf->device_id);
-				rc = CAD_RES_FAILURE;
-				goto done;
-			}
-		} else if (ardsession[session_id]->sess_open_info->
-				cad_open.op_code == CAD_OPEN_OP_WRITE) {
-			if (dev_vol_buf->device_id !=
-					ard_state.def_rx_device) {
-				pr_err("%s: %d is not current device id.\n",
-					__func__, dev_vol_buf->device_id);
-				rc = CAD_RES_FAILURE;
-				goto done;
-			}
-		}
-
-		/* For volume != 0%: send unmute command. */
-		if (dev_vol_buf->volume != 0) {
-			/* Construct QDSP6 device mute command. */
-			/* 1. Allocate memory for command buffer. */
-			q6_set_dev_mute = kmalloc(
-				sizeof(*q6_set_dev_mute),
-				GFP_KERNEL);
-			if (!q6_set_dev_mute)
-				return CAD_RES_FAILURE;
-
-			memset(q6_set_dev_mute, 0,
-				sizeof(*q6_set_dev_mute));
-			/* 2. Assign values to command buffer. */
-			q6_set_dev_mute->device_id =
-				q6_device_id_mapping(dev_vol_buf->device_id);
-			q6_set_dev_mute->path = dev_vol_buf->path;
-			q6_set_dev_mute->mute = 0;
-			rpc_cmd_buf = (u8 *)q6_set_dev_mute;
-			rpc_cmd_buf_len =
-				sizeof(*q6_set_dev_mute);
-
-			q6_set_dev_mute->cmd.op_code =
-				ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_MUTE;
-			q6_set_dev_mute->cmd.response_type =
-				ADSP_AUDIO_RESPONSE_COMMAND;
-
-			/* 3. Send command to Q6. */
-			rc = cad_rpc_control(session_id,
-				ardsession[session_id]->group_id,
-				(void *)rpc_cmd_buf,
-				rpc_cmd_buf_len,
-				&event_payload);
-			if (rc != CAD_RES_SUCCESS) {
-				pr_err("%s: cad_rpc_control() failure\n",
-					__func__);
-				return rc;
-			}
-
-		}
-
-		/* Map the device volume to QDSP6. */
-		device_volume = qdsp6_volume_mapping(
-			dev_vol_buf->device_id,
-			dev_vol_buf->volume);
-
-		/* Cache the device volume. */
-		device_id = qdsp6_volume_device_id_mapping(
-				dev_vol_buf->device_id);
-		qdsp6_volume_cache_tbl[device_id]
-			.current_volume = device_volume;
-		qdsp6_volume_cache_tbl[device_id]
-			.valid_current_volume = 1;
-		qdsp6_volume_cache_tbl[device_id]
-			.mute = 0;
-
-		/* Construct QDSP6 device volume command:	*/
-		/* 1. Allocate memory for command buffer.	*/
-		q6_set_dev_vol = kmalloc(
-			sizeof(*q6_set_dev_vol),
-			GFP_KERNEL);
-		if (!q6_set_dev_vol)
-			return CAD_RES_FAILURE;
-
-		memset(q6_set_dev_vol, 0,
-			sizeof(*q6_set_dev_vol));
-
-		/* 2. Assign values to command buffer. */
-		q6_set_dev_vol->device_id =
-			q6_device_id_mapping(dev_vol_buf->device_id);
-		q6_set_dev_vol->path = dev_vol_buf->path;
-		q6_set_dev_vol->volume = device_volume;
-		rpc_cmd_buf = (u8 *)q6_set_dev_vol;
-		rpc_cmd_buf_len =
-			sizeof(*q6_set_dev_vol);
-
-		q6_set_dev_vol->cmd.op_code =
-			ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_VOL;
-		q6_set_dev_vol->cmd.response_type =
-			ADSP_AUDIO_RESPONSE_COMMAND;
-
-		pr_info("audio: set device ID %d, volume %d\n", dev_vol_buf->device_id, device_volume);
-		/* HACK: for volume = 0%: send mute command instead. */
-		if (dev_vol_buf->volume == 0) {
-			/* Construct QDSP6 device mute command. */
-			/* 1. Allocate memory for command buffer. */
-			q6_set_dev_mute = kmalloc(
-				sizeof(*q6_set_dev_mute),
-				GFP_KERNEL);
-			if (!q6_set_dev_mute)
-				return CAD_RES_FAILURE;
-
-			memset(q6_set_dev_mute, 0,
-				sizeof(*q6_set_dev_mute));
-			/* 2. Assign values to command buffer. */
-			q6_set_dev_mute->device_id = q6_set_dev_vol->device_id;
-			q6_set_dev_mute->path = q6_set_dev_vol->path;
-			q6_set_dev_mute->mute = 1; /* mute */
-			rpc_cmd_buf = (u8 *)q6_set_dev_mute;
-			rpc_cmd_buf_len =
-				sizeof(*q6_set_dev_mute);
-
-			q6_set_dev_mute->cmd.op_code =
-				ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_MUTE;
-			q6_set_dev_mute->cmd.response_type =
-				ADSP_AUDIO_RESPONSE_COMMAND;
-		}
-
-		break;
-	case CAD_FILTER_CONFIG_DEVICE_MUTE:
-		D("CAD:VOL: Device Mute\n");
-
-		device_id = qdsp6_volume_device_id_mapping(
-				dev_mute_buf->device_id);
-		qdsp6_volume_cache_tbl[device_id].mute = dev_mute_buf->mute;
-
-		/* Construct QDSP6 device mute command. */
-		/* 1. Allocate memory for command buffer. */
-		q6_set_dev_mute = kmalloc(
-			sizeof(*q6_set_dev_mute),
-			GFP_KERNEL);
-		if (!q6_set_dev_mute)
-			return CAD_RES_FAILURE;
-
-		memset(q6_set_dev_mute, 0,
-			sizeof(*q6_set_dev_mute));
-		/* 2. Assign values to command buffer. */
-		q6_set_dev_mute->device_id =
-			q6_device_id_mapping(dev_mute_buf->device_id);
-		q6_set_dev_mute->path = dev_mute_buf->path;
-		q6_set_dev_mute->mute = dev_mute_buf->mute;
-
-		/* If the valid current volume is 0, just mute. */
-		if (qdsp6_volume_cache_tbl[device_id].valid_current_volume
-			&& (qdsp6_volume_cache_tbl[device_id].current_volume
-				== qdsp6_volume_cache_tbl[
-					device_id].min_gain))
-			q6_set_dev_mute->mute = 1;
-
-		rpc_cmd_buf = (u8 *)q6_set_dev_mute;
-		rpc_cmd_buf_len =
-			sizeof(*q6_set_dev_mute);
-
-		q6_set_dev_mute->cmd.op_code =
-			ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_MUTE;
-		q6_set_dev_mute->cmd.response_type =
-			ADSP_AUDIO_RESPONSE_COMMAND;
-
-		break;
-	case CAD_FILTER_CONFIG_STREAM_VOLUME:
-		D("CAD:VOL: Stream Volume\n");
-
-		stream_volume_cache = stream_vol_buf->volume;
-
-		if (ardsession[session_id]->active != ARD_TRUE) {
-			rc = CAD_RES_SUCCESS;
-			D("not active session, cached stream volume.\n");
-			goto done;
-		}
-
-		/* For volume != min: send unmute command. */
-		if (stream_vol_buf->volume != CAD_STREAM_MIN_GAIN) {
-			/* Construct QDSP6 stream mute command. */
-			/* 1. Allocate memory for command buffer. */
-			q6_set_strm_mute = kmalloc(
-				sizeof(*q6_set_strm_mute),
-				GFP_KERNEL);
-			if (!q6_set_strm_mute)
-				return CAD_RES_FAILURE;
-
-			/* 2. Assign values to command buffer.	*/
-			q6_set_strm_mute->mute = 0;
-			rpc_cmd_buf = (u8 *)q6_set_strm_mute;
-			rpc_cmd_buf_len =
-				sizeof(*q6_set_strm_mute);
-
-			q6_set_strm_mute->cmd.op_code =
-				ADSP_AUDIO_IOCTL_CMD_SET_STREAM_MUTE;
-			q6_set_strm_mute->cmd.response_type =
-				ADSP_AUDIO_RESPONSE_COMMAND;
-
-			/* 3. Send command to Q6. */
-			rc = cad_rpc_control(session_id,
-				ardsession[session_id]->group_id,
-				(void *)rpc_cmd_buf,
-				rpc_cmd_buf_len,
-				&event_payload);
-			if (rc != CAD_RES_SUCCESS) {
-				pr_err("%s: cad_rpc_control() failure\n",
-					__func__);
-				return rc;
-			}
-		}
-
-		/* Construct QDSP6 stream volume command. */
-		/* 1. Allocate memory for command buffer. */
-		q6_set_strm_vol = kmalloc(
-			sizeof(*q6_set_strm_vol),
-			GFP_KERNEL);
-		if (!q6_set_strm_vol)
-			return CAD_RES_FAILURE;
-
-		/* 2. Assign values to command buffer. */
-		q6_set_strm_vol->volume = stream_vol_buf->volume;
-		rpc_cmd_buf = (u8 *)q6_set_strm_vol;
-		rpc_cmd_buf_len = sizeof(*q6_set_strm_vol);
-
-		q6_set_strm_vol->cmd.op_code =
-			ADSP_AUDIO_IOCTL_CMD_SET_STREAM_VOL;
-		q6_set_strm_vol->cmd.response_type =
-			ADSP_AUDIO_RESPONSE_COMMAND;
-
-		/* For volume = min: send mute command instead. */
-		if (stream_vol_buf->volume == CAD_STREAM_MIN_GAIN) {
-			/* Construct QDSP6 stream mute command. */
-			/* 1. Allocate memory for command buffer. */
-			q6_set_strm_mute = kmalloc(
-				sizeof(*q6_set_strm_mute), GFP_KERNEL);
-
-			if (!q6_set_strm_mute)
-				return CAD_RES_FAILURE;
-
-			/* 2. Assign values to command buffer. */
-			q6_set_strm_mute->mute = 1;
-			rpc_cmd_buf = (u8 *)q6_set_strm_mute;
-			rpc_cmd_buf_len =
-				sizeof(*q6_set_strm_mute);
-
-			q6_set_strm_mute->cmd.op_code =
-				ADSP_AUDIO_IOCTL_CMD_SET_STREAM_MUTE;
-			q6_set_strm_mute->cmd.response_type =
-				ADSP_AUDIO_RESPONSE_COMMAND;
-		}
-
-		break;
-	case CAD_FILTER_CONFIG_STREAM_MUTE:
-		D("CAD:VOL: Stream Mute\n");
-
-		/* Construct QDSP6 stream mute command. */
-		/* 1. Allocate memory for command buffer. */
-		q6_set_strm_mute = kmalloc(
-			sizeof(*q6_set_strm_mute), GFP_KERNEL);
-
-		if (!q6_set_strm_mute)
-			return CAD_RES_FAILURE;
-
-		/* 2. Assign values to command buffer. */
-		q6_set_strm_mute->mute = stream_mute_buf->mute;
-		rpc_cmd_buf = (u8 *)q6_set_strm_mute;
-		rpc_cmd_buf_len = sizeof(*q6_set_strm_mute);
-
-		q6_set_strm_mute->cmd.op_code =
-			ADSP_AUDIO_IOCTL_CMD_SET_STREAM_MUTE;
-		q6_set_strm_mute->cmd.response_type =
-			ADSP_AUDIO_RESPONSE_COMMAND;
-
-		break;
-	default:
-		/* Just return without error. */
-		return CAD_RES_SUCCESS;
-	}
-
-	/* Always send device/stream volume command to Q6 for now. */
-	rc = cad_rpc_control(session_id,
-		ardsession[session_id]->group_id,
-		(void *)rpc_cmd_buf,
-		rpc_cmd_buf_len,
-		&event_payload);
-	if (rc != CAD_RES_SUCCESS)
-		pr_err("%s: cad_rpc_control() failure\n", __func__);
-
-done:
-	D("%s: ioctl() processed.\n", __func__);
-
-	kfree(q6_set_dev_vol);
-	kfree(q6_set_strm_vol);
-	kfree(q6_set_dev_mute);
-	kfree(q6_set_strm_mute);
-	kfree(q6_set_dev_vol1);
-	kfree(q6_set_strm_vol1);
-	kfree(q6_set_dev_mute1);
-	kfree(q6_set_strm_mute1);
-
-	return rc;
-}
-
-
-int cad_volume_dinit(void)
-{
-	memset(qdsp6_volume_cache_tbl, 0, sizeof(qdsp6_volume_cache_tbl));
-	stream_volume_cache = 0;
-	return CAD_RES_SUCCESS;
-}
-
-
-int cad_volume_init(struct cad_func_tbl_type **func_tbl)
-{
-
-	static struct cad_func_tbl_type vtable = {
-		qdsp6_volume_open,
-		qdsp6_volume_close,
-		qdsp6_volume_write,
-		qdsp6_volume_read,
-		qdsp6_volume_ioctl
-	};
-
-	*func_tbl = &vtable;
-
-	/* Set up the volume cache table by default values. */
-	memset(qdsp6_volume_cache_tbl, 0, sizeof(qdsp6_volume_cache_tbl));
-
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_HANDSET_SPKR].max_gain
-		= CAD_DEVICE_HANDSET_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_HANDSET_SPKR].min_gain
-		= CAD_DEVICE_HANDSET_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO].max_gain
-		= CAD_DEVICE_HEADSET_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO].min_gain
-		= CAD_DEVICE_HEADSET_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO].
-		max_gain = CAD_DEVICE_HEADSET_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO].
-		min_gain = CAD_DEVICE_HEADSET_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_SPKR_PHONE_MONO].max_gain
-		= CAD_DEVICE_SPEAKER_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_SPKR_PHONE_MONO].min_gain
-		= CAD_DEVICE_SPEAKER_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO].max_gain
-		= CAD_DEVICE_SPEAKER_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO].min_gain
-		= CAD_DEVICE_SPEAKER_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_BT_SCO_SPKR].max_gain
-		= CAD_DEVICE_BT_SCO_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_BT_SCO_SPKR].min_gain
-		= CAD_DEVICE_BT_SCO_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_BT_A2DP_SPKR].max_gain
-		= CAD_DEVICE_BT_A2DP_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_BT_A2DP_SPKR].min_gain
-		= CAD_DEVICE_BT_A2DP_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR].max_gain
-		= CAD_DEVICE_TTY_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR].min_gain
-		= CAD_DEVICE_TTY_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_HANDSET_MIC].max_gain
-		= CAD_DEVICE_HANDSET_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_HANDSET_MIC].min_gain
-		= CAD_DEVICE_HANDSET_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_HEADSET_MIC].max_gain
-		= CAD_DEVICE_HEADSET_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_HEADSET_MIC].min_gain
-		= CAD_DEVICE_HEADSET_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_SPKR_PHONE_MIC].max_gain
-		= CAD_DEVICE_SPEAKER_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_SPKR_PHONE_MIC].min_gain
-		= CAD_DEVICE_SPEAKER_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_BT_SCO_MIC].max_gain
-		= CAD_DEVICE_BT_SCO_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_BT_SCO_MIC].min_gain
-		= CAD_DEVICE_BT_SCO_MIN_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_TTY_HEADSET_MIC].max_gain
-		= CAD_DEVICE_TTY_MAX_GAIN;
-	qdsp6_volume_cache_tbl[INT_CAD_HW_DEVICE_ID_TTY_HEADSET_MIC].min_gain
-		= CAD_DEVICE_TTY_MIN_GAIN;
-
-	stream_volume_cache = 0;
-
-	return CAD_RES_SUCCESS;
-}
-
-int volume_set_max_vol_all(void)
-{
-	int i;
-
-	for (i = 0; i < CAD_HW_DEVICE_ID_MAX_NUM; i++) {
-		qdsp6_volume_cache_tbl[i].valid_current_volume = 1;
-		qdsp6_volume_cache_tbl[i].current_volume =
-			qdsp6_volume_cache_tbl[i].max_gain;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(volume_set_max_vol_all);
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_dtmf.c b/arch/arm/mach-msm/qdsp6/msm8k_dtmf.c
deleted file mode 100644
index 2f00ae9..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_dtmf.c
+++ /dev/null
@@ -1,267 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/uaccess.h>
-#include <linux/msm_audio.h>
-
-#include <asm/ioctls.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_ard.h>
-#include <mach/qdsp6/msm8k_cad_write_pcm_format.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_cad_volume.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_dtmf: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MSM8K_DTMF_PROC_NAME "msm8k_dtmf"
-
-#define AUDIO_MAGIC 'a'
-
-struct dtmf {
-	u32 cad_w_handle;
-};
-
-static int msm8k_dtmf_open(struct inode *inode, struct file *f)
-{
-	struct dtmf *dtmf;
-	struct cad_open_struct_type  cos;
-	D("%s\n", __func__);
-
-	dtmf = kmalloc(sizeof(struct dtmf), GFP_KERNEL);
-	if (dtmf == NULL) {
-		pr_err("Could not allocate memory for dtmf driver\n");
-		return CAD_RES_FAILURE;
-	}
-
-	f->private_data = dtmf;
-
-	memset(dtmf, 0, sizeof(struct dtmf));
-
-	cos.format = CAD_FORMAT_DTMF;
-	cos.op_code = CAD_OPEN_OP_WRITE;
-	dtmf->cad_w_handle = cad_open(&cos);
-
-	if (dtmf->cad_w_handle == 0)
-		return CAD_RES_FAILURE;
-	else
-		return CAD_RES_SUCCESS;
-}
-
-static int msm8k_dtmf_release(struct inode *inode, struct file *f)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct dtmf *dtmf = f->private_data;
-	D("%s\n", __func__);
-
-	cad_close(dtmf->cad_w_handle);
-	kfree(dtmf);
-
-	return rc;
-}
-
-static ssize_t msm8k_dtmf_read(struct file *f, char __user *buf, size_t cnt,
-		loff_t *pos)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-static ssize_t msm8k_dtmf_write(struct file *f, const char __user *buf,
-		size_t cnt, loff_t *pos)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-static int msm8k_dtmf_ioctl(struct inode *inode, struct file *f,
-		unsigned int cmd, unsigned long arg)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct dtmf *p = f->private_data;
-	u32 stream_device[1];
-	struct cad_cmd_gen_dtmf   cad_dtmf;
-
-	struct cad_stream_device_struct_type	cad_stream_dev;
-	struct cad_stream_info_struct_type	cad_stream_info;
-
-	D("%s\n", __func__);
-
-	memset(&cad_stream_dev, 0,
-			sizeof(struct cad_stream_device_struct_type));
-	memset(&cad_stream_info, 0, sizeof(struct cad_stream_info_struct_type));
-
-	switch (cmd) {
-	case AUDIO_PLAY_DTMF:
-		D(" call cad_ioctl(CAD_IOCTL_CMD_GEN_DTMF\n");
-
-		rc = copy_from_user((void *)&cad_dtmf, (void *)arg,
-				sizeof(cad_dtmf));
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_GEN_DTMF,
-			&cad_dtmf, sizeof(cad_dtmf));
-		if (rc) {
-			pr_err("cad_ioctl() CMD_GEN_DTMF failed\n");
-			break;
-		}
-		break;
-	case AUDIO_START:
-		stream_device[0] = CAD_HW_DEVICE_ID_DEFAULT_RX;
-		cad_stream_dev.device = (u32 *)&stream_device[0];
-		cad_stream_dev.device_len = 1;
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_DEVICE,
-			&cad_stream_dev, sizeof(cad_stream_dev));
-		if (rc) {
-			pr_err("cad_ioctl() SET_STREAM_DEVICE failed\n");
-			break;
-		}
-
-		cad_stream_info.app_type = CAD_STREAM_APP_DTMF;
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_INFO,
-			&cad_stream_info, sizeof(cad_stream_info));
-		if (rc) {
-			pr_err("cad_ioctl() SET_STREAM_INFO failed\n");
-			break;
-		}
-
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_START,
-			NULL, 0);
-		if (rc) {
-			pr_err("cad_ioctl() CMD_STREAM_START failed\n");
-			break;
-		}
-
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-#ifdef CONFIG_PROC_FS
-int msm8k_dtmf_read_proc(char *pbuf, char **start, off_t offset,
-			int count, int *eof, void *data)
-{
-	int len = 0;
-	len += snprintf(pbuf, 16, "dtmf\n");
-
-	*eof = 1;
-	return len;
-}
-#endif
-
-static const struct file_operations msm8k_dtmf_fops = {
-	.owner = THIS_MODULE,
-	.open = msm8k_dtmf_open,
-	.release = msm8k_dtmf_release,
-	.read = msm8k_dtmf_read,
-	.write = msm8k_dtmf_write,
-	.ioctl = msm8k_dtmf_ioctl,
-	.llseek = no_llseek,
-};
-
-
-struct miscdevice msm8k_dtmf_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_dtmf",
-	.fops	= &msm8k_dtmf_fops,
-};
-
-static int __init msm8k_dtmf_init(void)
-{
-	int rc;
-	D("%s\n", __func__);
-
-	rc = misc_register(&msm8k_dtmf_misc);
-
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(MSM8K_DTMF_PROC_NAME,
-			0, NULL, msm8k_dtmf_read_proc, NULL);
-#endif
-
-	return rc;
-}
-
-static void __exit msm8k_dtmf_exit(void)
-{
-	D("%s\n", __func__);
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(MSM8K_DTMF_PROC_NAME, NULL);
-#endif
-}
-
-
-module_init(msm8k_dtmf_init);
-module_exit(msm8k_dtmf_exit);
-
-MODULE_DESCRIPTION("MSM DTMF driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_htc_fm.c b/arch/arm/mach-msm/qdsp6/msm8k_htc_fm.c
deleted file mode 100644
index 6ddf167..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_htc_fm.c
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- *
- * Copyright (c) 2009 HTC Corporation
- *
- * All source code in this file is licensed under the following license
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, you can find it at http://www.fsf.org
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
-
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_cad_write_pcm_format.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_htc_fm: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MSM8K_FM_PROC_NAME "msm8k_htc_fm"
-
-#define AUDIO_MAGIC 'a'
-
-struct fm {
-	u32 cad_w_handle;
-	struct mutex lock;
-	int opened;
-};
-
-struct fm g_fm;
-
-static int msm8k_htc_fm_open(struct inode *inode, struct file *f)
-{
-	struct fm *fm = &g_fm;
-	struct cad_open_struct_type  cos;
-	int rc = CAD_RES_SUCCESS;
-	u32 stream_device[1];
-	struct cad_stream_device_struct_type cad_stream_dev;
-	struct cad_stream_info_struct_type cad_stream_info;
-	struct cad_write_pcm_format_struct_type cad_write_pcm_fmt;
-	D("%s\n", __func__);
-
-	mutex_lock(&fm->lock);
-
-	if (fm->opened) {
-		pr_err("fm: busy\n");
-		rc = -EBUSY;
-		goto done;
-	}
-
-	f->private_data = fm;
-
-	cos.format = CAD_FORMAT_FM;
-	cos.op_code = CAD_OPEN_OP_WRITE;
-	fm->cad_w_handle = cad_open(&cos);
-
-	if (fm->cad_w_handle == 0) {
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	cad_stream_info.app_type = CAD_STREAM_APP_PLAYBACK;
-	cad_stream_info.priority = 0;
-	cad_stream_info.buf_mem_type = CAD_STREAM_BUF_MEM_HEAP;
-	cad_stream_info.ses_buf_max_size = 1024 * 10;
-	rc = cad_ioctl(fm->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_INFO,
-		&cad_stream_info,
-		sizeof(struct cad_stream_info_struct_type));
-	if (rc) {
-		pr_err("pcm_out: cad_ioctl() SET_STREAM_INFO failed\n");
-		goto done;
-	}
-	stream_device[0] = CAD_HW_DEVICE_ID_DEFAULT_RX;
-	cad_stream_dev.device = (u32 *)&stream_device[0];
-	cad_stream_dev.device_len = 1;
-	rc = cad_ioctl(fm->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_DEVICE,
-		&cad_stream_dev,
-		sizeof(struct cad_stream_device_struct_type));
-	if (rc) {
-		pr_err("pcm_out: cad_ioctl() SET_STREAM_DEVICE failed\n");
-		goto done;
-	}
-	cad_write_pcm_fmt.us_ver_id = CAD_WRITE_PCM_VERSION_10;
-	cad_write_pcm_fmt.pcm.us_channel_config = 1;
-	cad_write_pcm_fmt.pcm.us_width = 1;
-	cad_write_pcm_fmt.pcm.us_sign = 0;
-	cad_write_pcm_fmt.pcm.us_sample_rate = 11;
-	rc = cad_ioctl(fm->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_CONFIG,
-		&cad_write_pcm_fmt,
-		sizeof(struct cad_write_pcm_format_struct_type));
-	if (rc) {
-		pr_err("pcm_out: cad_ioctl() SET_STREAM_CONFIG failed\n");
-		goto done;
-	}
-	rc = cad_ioctl(fm->cad_w_handle, CAD_IOCTL_CMD_STREAM_START,
-		NULL, 0);
-	if (rc) {
-		pr_err("pcm_out: cad_ioctl() STREAM_START failed\n");
-		goto done;
-	}
-	fm->opened = 1;
-done:
-	mutex_unlock(&fm->lock);
-	return rc;
-}
-
-static int msm8k_htc_fm_release(struct inode *inode, struct file *f)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct fm *fm = f->private_data;
-	D("%s\n", __func__);
-
-	mutex_lock(&fm->lock);
-
-	cad_close(fm->cad_w_handle);
-
-	fm->opened = 0;
-	mutex_unlock(&fm->lock);
-
-	return rc;
-}
-
-static ssize_t msm8k_htc_fm_read(struct file *f, char __user *buf, size_t cnt,
-		loff_t *pos)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-static ssize_t msm8k_htc_fm_write(struct file *f, const char __user *buf,
-		size_t cnt, loff_t *pos)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-static int msm8k_htc_fm_ioctl(struct inode *inode, struct file *f,
-		unsigned int cmd, unsigned long arg)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-#ifdef CONFIG_PROC_FS
-int msm8k_htc_fm_read_proc(char *pbuf, char **start, off_t offset,
-			int count, int *eof, void *data)
-{
-	int len = 0;
-	len += snprintf(pbuf, 16, "fm\n");
-
-	*eof = 1;
-	return len;
-}
-#endif
-
-static const struct file_operations msm8k_htc_fm_fops = {
-	.owner = THIS_MODULE,
-	.open = msm8k_htc_fm_open,
-	.release = msm8k_htc_fm_release,
-	.read = msm8k_htc_fm_read,
-	.write = msm8k_htc_fm_write,
-	.ioctl = msm8k_htc_fm_ioctl,
-	.llseek = no_llseek,
-};
-
-
-struct miscdevice msm8k_htc_fm_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_htc_fm",
-	.fops	= &msm8k_htc_fm_fops,
-};
-
-static int __init msm8k_htc_fm_init(void)
-{
-	int rc;
-	D("%s\n", __func__);
-
-	rc = misc_register(&msm8k_htc_fm_misc);
-	mutex_init(&g_fm.lock);
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(MSM8K_FM_PROC_NAME,
-			0, NULL, msm8k_htc_fm_read_proc, NULL);
-#endif
-
-	return rc;
-}
-
-static void __exit msm8k_htc_fm_exit(void)
-{
-	D("%s\n", __func__);
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(MSM8K_FM_PROC_NAME, NULL);
-#endif
-}
-
-
-module_init(msm8k_htc_fm_init);
-module_exit(msm8k_htc_fm_exit);
-
-MODULE_DESCRIPTION("HTC FM driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_mp3.c b/arch/arm/mach-msm/qdsp6/msm8k_mp3.c
deleted file mode 100644
index e2c9f39..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_mp3.c
+++ /dev/null
@@ -1,425 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/uaccess.h>
-#include <linux/wakelock.h>
-#include <linux/msm_audio.h>
-#include <linux/sched.h>
-
-#include <asm/ioctls.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_ard.h>
-#include <mach/qdsp6/msm8k_cad_write_mp3_format.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_cad_volume.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_mp3: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MSM8K_MP3_PROC_NAME "msm8k_mp3"
-
-#define AUDIO_MAGIC 'a'
-
-struct mp3 {
-	u32 cad_w_handle;
-	u32 volume;
-	struct mutex write_lock;
-	wait_queue_head_t eos_wait;
-	u16 eos_ack;
-	u16 flush_rcvd;
-};
-static struct wake_lock g_mp3_wakelock;
-static atomic_t g_mp3_open_count = ATOMIC_INIT(0);
-
-static void audio_prevent_sleep(void)
-{
-	if (atomic_add_return(1, &g_mp3_open_count) == 1)
-		wake_lock(&g_mp3_wakelock);
-}
-
-static void audio_allow_sleep(void)
-{
-	if (atomic_sub_and_test(1, &g_mp3_open_count))
-		wake_unlock(&g_mp3_wakelock);
-}
-
-static int msm8k_mp3_open(struct inode *inode, struct file *f)
-{
-	struct mp3 *mp3;
-	struct cad_open_struct_type  cos;
-	D("%s\n", __func__);
-
-	mp3 = kmalloc(sizeof(struct mp3), GFP_KERNEL);
-	if (mp3 == NULL) {
-		pr_err("Could not allocate memory for mp3 driver\n");
-		return CAD_RES_FAILURE;
-	}
-
-	f->private_data = mp3;
-
-	memset(mp3, 0, sizeof(struct mp3));
-
-	mp3->eos_ack = 0;
-	mp3->flush_rcvd = 0;
-
-	mutex_init(&mp3->write_lock);
-	init_waitqueue_head(&mp3->eos_wait);
-
-	audio_prevent_sleep();
-	cos.format = CAD_FORMAT_MP3;
-	cos.op_code = CAD_OPEN_OP_WRITE;
-	mp3->cad_w_handle = cad_open(&cos);
-
-	if (mp3->cad_w_handle == 0) {
-		kfree(mp3);
-		audio_allow_sleep();
-		return CAD_RES_FAILURE;
-	} else
-		return CAD_RES_SUCCESS;
-}
-
-static int msm8k_mp3_fsync(struct file *f, struct dentry *dentry, int datasync)
-{
-	int ret = CAD_RES_SUCCESS;
-	struct mp3 *mp3 = f->private_data;
-
-	mutex_lock(&mp3->write_lock);
-	ret = cad_ioctl(mp3->cad_w_handle,
-			CAD_IOCTL_CMD_STREAM_END_OF_STREAM,
-			NULL, 0);
-	mutex_unlock(&mp3->write_lock);
-
-	ret = wait_event_interruptible(mp3->eos_wait, mp3->eos_ack ||
-					 mp3->flush_rcvd);
-
-	ret = (mp3->eos_ack) ? CAD_RES_SUCCESS : CAD_RES_FAILURE;
-	mp3->eos_ack = 0;
-	mp3->flush_rcvd = 0;
-
-	return ret;
-
-}
-
-static int msm8k_mp3_release(struct inode *inode, struct file *f)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct mp3 *mp3 = f->private_data;
-	D("%s %d\n", __func__, mp3->cad_w_handle);
-
-	cad_close(mp3->cad_w_handle);
-	kfree(mp3);
-	audio_allow_sleep();
-
-	return rc;
-}
-
-static ssize_t msm8k_mp3_read(struct file *f, char __user *buf, size_t cnt,
-		loff_t *pos)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-void msm8k_mp3_eos_event_cb(u32 event, void *evt_packet,
-				u32 evt_packet_len, void *client_data)
-{
-	struct mp3 *mp3 = client_data;
-
-	if (event == CAD_EVT_STATUS_EOS) {
-		mp3->eos_ack = 1;
-		wake_up(&mp3->eos_wait);
-	}
-}
-
-static ssize_t msm8k_mp3_write(struct file *f, const char __user *buf,
-		size_t cnt, loff_t *pos)
-{
-	struct cad_buf_struct_type cbs;
-	struct mp3 *mp3 = f->private_data;
-
-	D("%s %d\n", __func__, mp3->cad_w_handle);
-
-	memset(&cbs, 0, sizeof(struct cad_buf_struct_type));
-	cbs.buffer = (void *)buf;
-	cbs.phys_addr = 0;
-	cbs.max_size = cnt;
-
-	cad_write(mp3->cad_w_handle, &cbs);
-
-	return cnt;
-}
-
-static int msm8k_mp3_ioctl(struct inode *inode, struct file *f,
-		unsigned int cmd, unsigned long arg)
-{
-	int rc;
-	struct msm_audio_config cfg;
-	struct mp3 *p = f->private_data;
-	void *cad_arg = (void *)arg;
-	u32 stream_device[1];
-	struct cad_device_struct_type cad_dev;
-	struct cad_stream_device_struct_type cad_stream_dev;
-	struct cad_stream_info_struct_type cad_stream_info;
-	struct cad_write_mp3_format_struct_type cad_write_mp3_fmt;
-	struct cad_flt_cfg_strm_vol cad_strm_volume;
-	struct cad_filter_struct flt;
-	struct cad_filter_struct cfs;
-	struct cad_event_struct_type eos_event;
-	D("%s %d\n", __func__, p->cad_w_handle);
-
-	memset(&cad_dev, 0, sizeof(struct cad_device_struct_type));
-	memset(&cad_stream_dev, 0,
-			sizeof(struct cad_stream_device_struct_type));
-	memset(&cad_stream_info, 0, sizeof(struct cad_stream_info_struct_type));
-	memset(&cad_write_mp3_fmt, 0,
-			sizeof(struct cad_write_mp3_format_struct_type));
-	memset(&cfg, 0, sizeof(struct msm_audio_config));
-	memset(&flt, 0, sizeof(struct cad_filter_struct));
-	memset(&cfs, 0, sizeof(struct cad_filter_struct));
-
-	switch (cmd) {
-	case AUDIO_START:
-		cad_stream_info.app_type = CAD_STREAM_APP_PLAYBACK;
-		cad_stream_info.priority = 0;
-		cad_stream_info.buf_mem_type = CAD_STREAM_BUF_MEM_HEAP;
-		cad_stream_info.ses_buf_max_size = 1024 * 10;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_INFO,
-			&cad_stream_info,
-			sizeof(struct cad_stream_info_struct_type));
-		if (rc) {
-			pr_err("mp3: cad_ioctl() SET_STREAM_INFO failed\n");
-			break;
-		}
-
-		stream_device[0] = CAD_HW_DEVICE_ID_DEFAULT_RX;
-		cad_stream_dev.device = (u32 *)&stream_device[0];
-		cad_stream_dev.device_len = 1;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_DEVICE,
-			&cad_stream_dev,
-			sizeof(struct cad_stream_device_struct_type));
-		if (rc) {
-			pr_err("mp3: cad_ioctl() SET_STREAM_DEVICE failed\n");
-			break;
-		}
-
-		cad_write_mp3_fmt.ver_id = CAD_WRITE_MP3_VERSION_10;
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_CONFIG,
-			&cad_write_mp3_fmt,
-			sizeof(struct cad_write_mp3_format_struct_type));
-		if (rc) {
-			pr_err("mp3: cad_ioctl() SET_STREAM_CONFIG failed\n");
-			break;
-		}
-		eos_event.callback = &msm8k_mp3_eos_event_cb;
-		eos_event.client_data = p;
-
-		rc = cad_ioctl(p->cad_w_handle,
-				CAD_IOCTL_CMD_SET_STREAM_EVENT_LSTR,
-				&eos_event,
-				sizeof(struct cad_event_struct_type));
-
-		if (rc) {
-			pr_err("mp3: cad_ioctl() "
-			       "SET_STREAM_EVENT_LSTR failed\n");
-			break;
-		}
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_START,
-				NULL, 0);
-		if (rc) {
-			pr_err("mp3: cad_ioctl() STREAM_START failed\n");
-			break;
-		}
-		break;
-	case AUDIO_STOP:
-	case AUDIO_ADSP_PAUSE:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_PAUSE,
-			NULL, 0);
-		break;
-	case AUDIO_ADSP_RESUME:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_RESUME,
-			NULL, 0);
-		break;
-	case AUDIO_FLUSH:
-		p->flush_rcvd = 1;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_FLUSH,
-				NULL, 0);
-		wake_up(&p->eos_wait);
-		break;
-	case AUDIO_GET_CONFIG:
-		/* hard-coded until we support this in the CAD */
-		cfg.buffer_size = 4096;
-		cfg.buffer_count = 2;
-		cfg.channel_count = 1;
-		cfg.sample_rate = 48000;
-		if (copy_to_user((void *)arg, &cfg,
-				sizeof(struct msm_audio_config)))
-			return -EFAULT;
-		rc = CAD_RES_SUCCESS;
-		break;
-	case AUDIO_SET_CONFIG:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_CONFIG,
-			cad_arg, sizeof(u32));
-		break;
-	case AUDIO_SET_VOLUME:
-		rc = copy_from_user(&p->volume, (void *)arg, sizeof(u32));
-
-		memset(&cad_strm_volume, 0,
-				sizeof(struct cad_flt_cfg_strm_vol));
-		cad_strm_volume.volume = p->volume;
-		flt.filter_type = CAD_DEVICE_FILTER_TYPE_VOL;
-		flt.format_block = &cad_strm_volume;
-		flt.cmd = CAD_FILTER_CONFIG_STREAM_VOLUME;
-		flt.format_block_len =
-			sizeof(struct cad_flt_cfg_strm_vol);
-
-		rc = cad_ioctl(p->cad_w_handle,
-			CAD_IOCTL_CMD_SET_STREAM_FILTER_CONFIG,
-			&flt,
-			sizeof(struct cad_filter_struct));
-		if (rc) {
-			pr_err("mp3: cad_ioctl() set volume failed\n");
-			break;
-		}
-		break;
-	case AUDIO_SET_EQ:
-		rc = copy_from_user(&cfs, (void *)arg,
-				sizeof(struct cad_filter_struct));
-		rc = cad_ioctl(p->cad_w_handle,
-			CAD_IOCTL_CMD_SET_STREAM_FILTER_CONFIG,
-			&cfs,
-			sizeof(struct cad_filter_struct));
-		if (rc)
-			pr_err("mp3: cad_ioctl() set equalizer failed\n");
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-#ifdef CONFIG_PROC_FS
-int msm8k_mp3_read_proc(char *pbuf, char **start, off_t offset,
-			int count, int *eof, void *data)
-{
-	int len = 0;
-	len += snprintf(pbuf, 16, "mp3\n");
-
-	*eof = 1;
-	return len;
-}
-#endif
-
-static const struct file_operations msm8k_mp3_fops = {
-	.owner = THIS_MODULE,
-	.open = msm8k_mp3_open,
-	.release = msm8k_mp3_release,
-	.read = msm8k_mp3_read,
-	.write = msm8k_mp3_write,
-	.ioctl = msm8k_mp3_ioctl,
-	.llseek = no_llseek,
-	.fsync = msm8k_mp3_fsync,
-};
-
-struct miscdevice msm8k_mp3_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_mp3",
-	.fops	= &msm8k_mp3_fops,
-};
-
-static int __init msm8k_mp3_init(void)
-{
-	int rc;
-	D("%s\n", __func__);
-
-	rc = misc_register(&msm8k_mp3_misc);
-	wake_lock_init(&g_mp3_wakelock, WAKE_LOCK_SUSPEND, "audio_mp3");
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(MSM8K_MP3_PROC_NAME,
-			0, NULL, msm8k_mp3_read_proc, NULL);
-#endif
-
-	return rc;
-}
-
-static void __exit msm8k_mp3_exit(void)
-{
-	D("%s\n", __func__);
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(MSM8K_MP3_PROC_NAME, NULL);
-#endif
-}
-
-
-module_init(msm8k_mp3_init);
-module_exit(msm8k_mp3_exit);
-
-MODULE_DESCRIPTION("MSM MP3 driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_pcm.c b/arch/arm/mach-msm/qdsp6/msm8k_pcm.c
deleted file mode 100644
index da9f3ae..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_pcm.c
+++ /dev/null
@@ -1,427 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/uaccess.h>
-#include <linux/wakelock.h>
-#include <linux/msm_audio.h>
-
-#include <asm/ioctls.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_ard.h>
-#include <mach/qdsp6/msm8k_cad_write_pcm_format.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_cad_volume.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_pcm: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MSM8K_PCM_PROC_NAME "msm8k_pcm"
-
-#define AUDIO_MAGIC 'a'
-
-struct pcm {
-	u32 cad_w_handle;
-	struct msm_audio_config cfg;
-	u32 volume;
-};
-
-static struct wake_lock pcm_wakelock;
-static struct wake_lock pcm_idlelock;
-static struct mutex pcm_lock;
-static int pcm_opened;
-
-static void audio_prevent_sleep(void)
-{
-	pr_info("++++++++++++++++++++++++++++++\n");
-	wake_lock(&pcm_wakelock);
-	wake_lock(&pcm_idlelock);
-}
-
-static void audio_allow_sleep(void)
-{
-	wake_unlock(&pcm_wakelock);
-	wake_unlock(&pcm_idlelock);
-	pr_info("------------------------------\n");
-}
-
-static int msm8k_pcm_open(struct inode *inode, struct file *f)
-{
-	struct pcm *pcm;
-	struct cad_open_struct_type  cos;
-	int rc;
-
-	D("%s\n", __func__);
-
-	mutex_lock(&pcm_lock);
-
-	if (pcm_opened) {
-		pr_err("pcm: busy\n");
-		rc = -EBUSY;
-		goto done;
-	}
-
-	pcm = kmalloc(sizeof(struct pcm), GFP_KERNEL);
-	if (pcm == NULL) {
-		pr_err("Could not allocate memory for pcm driver\n");
-		return CAD_RES_FAILURE;
-	}
-
-	f->private_data = pcm;
-
-	memset(pcm, 0, sizeof(struct pcm));
-	pcm->cfg.buffer_size = 4096;
-	pcm->cfg.buffer_count = 2;
-	pcm->cfg.channel_count = 1;
-	pcm->cfg.sample_rate = 48000;
-
-	audio_prevent_sleep();
-	cos.format = CAD_FORMAT_PCM;
-	cos.op_code = CAD_OPEN_OP_WRITE;
-
-	pcm->cad_w_handle = cad_open(&cos);
-
-	if (pcm->cad_w_handle == 0) {
-		audio_allow_sleep();
-		rc = CAD_RES_FAILURE;
-	} else {
-		pcm_opened = 1;
-		rc = CAD_RES_SUCCESS;
-	}
-done:
-	mutex_unlock(&pcm_lock);
-	return rc;
-}
-
-static int msm8k_pcm_release(struct inode *inode, struct file *f)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct pcm *pcm = f->private_data;
-	D("%s\n", __func__);
-
-	mutex_lock(&pcm_lock);
-	cad_close(pcm->cad_w_handle);
-	kfree(pcm);
-	audio_allow_sleep();
-	pcm_opened = 0;
-	mutex_unlock(&pcm_lock);
-
-	return rc;
-}
-
-static ssize_t msm8k_pcm_read(struct file *f, char __user *buf, size_t cnt,
-		loff_t *pos)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-static ssize_t msm8k_pcm_write(struct file *f, const char __user *buf,
-		size_t cnt, loff_t *pos)
-{
-	struct cad_buf_struct_type cbs;
-	struct pcm *pcm = f->private_data;
-
-	D("%s\n", __func__);
-
-	memset(&cbs, 0, sizeof(struct cad_buf_struct_type));
-	cbs.buffer = (void *)buf;
-	cbs.phys_addr = 0;
-	cbs.max_size = cnt;
-	cbs.actual_size = cnt;
-
-	cad_write(pcm->cad_w_handle, &cbs);
-
-	return cnt;
-}
-
-static int msm8k_pcm_ioctl(struct inode *inode, struct file *f,
-		unsigned int cmd, unsigned long arg)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct pcm *p = f->private_data;
-	u32 stream_device[1];
-	struct cad_device_struct_type cad_dev;
-	struct cad_stream_device_struct_type cad_stream_dev;
-	struct cad_stream_info_struct_type cad_stream_info;
-	struct cad_write_pcm_format_struct_type cad_write_pcm_fmt;
-	struct cad_flt_cfg_strm_vol cad_strm_volume;
-	struct cad_filter_struct flt;
-
-	D("%s\n", __func__);
-
-	memset(&cad_dev, 0, sizeof(struct cad_device_struct_type));
-	memset(&cad_stream_dev, 0,
-			sizeof(struct cad_stream_device_struct_type));
-	memset(&cad_stream_info, 0, sizeof(struct cad_stream_info_struct_type));
-	memset(&cad_write_pcm_fmt, 0,
-			sizeof(struct cad_write_pcm_format_struct_type));
-	memset(&flt, 0, sizeof(struct cad_filter_struct));
-
-	switch (cmd) {
-	case AUDIO_START:
-
-		cad_stream_info.app_type = CAD_STREAM_APP_PLAYBACK;
-		cad_stream_info.priority = 0;
-		cad_stream_info.buf_mem_type = CAD_STREAM_BUF_MEM_HEAP;
-		cad_stream_info.ses_buf_max_size = 1024 * 10;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_INFO,
-			&cad_stream_info,
-			sizeof(struct cad_stream_info_struct_type));
-		if (rc) {
-			pr_err("pcm_out: cad_ioctl() SET_STREAM_INFO failed\n");
-			break;
-		}
-
-		stream_device[0] = CAD_HW_DEVICE_ID_DEFAULT_RX;
-		cad_stream_dev.device = (u32 *)&stream_device[0];
-		cad_stream_dev.device_len = 1;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_DEVICE,
-			&cad_stream_dev,
-			sizeof(struct cad_stream_device_struct_type));
-		if (rc) {
-			pr_err("pcm_out: cad_ioctl() "
-			       "SET_STREAM_DEVICE failed\n");
-			break;
-		}
-
-		cad_write_pcm_fmt.us_ver_id = CAD_WRITE_PCM_VERSION_10;
-		cad_write_pcm_fmt.pcm.us_channel_config = p->cfg.channel_count;
-		cad_write_pcm_fmt.pcm.us_width = 1;
-		cad_write_pcm_fmt.pcm.us_sign = 0;
-
-		switch (p->cfg.sample_rate) {
-		case 96000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 0;
-			break;
-		case 88200:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 1;
-			break;
-		case 64000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 2;
-			break;
-		case 48000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 3;
-			break;
-		case 44100:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 4;
-			break;
-		case 32000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 5;
-			break;
-		case 24000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 6;
-			break;
-		case 22050:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 7;
-			break;
-		case 16000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 8;
-			break;
-		case 12000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 9;
-			break;
-		case 11025:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 10;
-			break;
-		case 8000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 11;
-			break;
-		}
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_CONFIG,
-			&cad_write_pcm_fmt,
-			sizeof(struct cad_write_pcm_format_struct_type));
-		if (rc) {
-			pr_err("pcm_out: cad_ioctl() "
-			       "SET_STREAM_CONFIG failed\n");
-			break;
-		}
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_START,
-			NULL, 0);
-		if (rc) {
-			pr_err("pcm_out: cad_ioctl() STREAM_START failed\n");
-			break;
-		}
-		break;
-	case AUDIO_STOP:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_PAUSE,
-			NULL, 0);
-		break;
-	case AUDIO_FLUSH:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_FLUSH,
-			NULL, 0);
-		break;
-	case AUDIO_GET_CONFIG:
-		if (copy_to_user((void *)arg, &p->cfg,
-				sizeof(struct msm_audio_config)))
-			return -EFAULT;
-		break;
-	case AUDIO_SET_CONFIG:
-		rc = copy_from_user(&p->cfg, (void *)arg,
-				sizeof(struct msm_audio_config));
-		break;
-	case AUDIO_SET_VOLUME:
-		rc = copy_from_user(&p->volume, (void *)arg, sizeof(u32));
-
-		memset(&cad_strm_volume, 0,
-				sizeof(struct cad_flt_cfg_strm_vol));
-		cad_strm_volume.volume = p->volume;
-		flt.filter_type = CAD_DEVICE_FILTER_TYPE_VOL;
-		flt.format_block = &cad_strm_volume;
-		flt.cmd = CAD_FILTER_CONFIG_STREAM_VOLUME;
-		flt.format_block_len =
-			sizeof(struct cad_flt_cfg_strm_vol);
-
-		rc = cad_ioctl(p->cad_w_handle,
-			CAD_IOCTL_CMD_SET_STREAM_FILTER_CONFIG,
-			&flt,
-			sizeof(struct cad_filter_struct));
-		if (rc) {
-			pr_err("cad_ioctl() set volume failed\n");
-			break;
-		}
-		break;
-	case AUDIO_SET_EQ:
-		rc = copy_from_user(&flt, (void *)arg,
-				sizeof(struct cad_filter_struct));
-		rc = cad_ioctl(p->cad_w_handle,
-			CAD_IOCTL_CMD_SET_STREAM_FILTER_CONFIG,
-			&flt,
-			sizeof(struct cad_filter_struct));
-		if (rc)
-			pr_err("cad_ioctl() set equalizer failed\n");
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-#ifdef CONFIG_PROC_FS
-int msm8k_pcm_read_proc(char *pbuf, char **start, off_t offset,
-			int count, int *eof, void *data)
-{
-	int len = 0;
-	len += snprintf(pbuf, 16, "pcm\n");
-
-	*eof = 1;
-	return len;
-}
-#endif
-
-static const struct file_operations msm8k_pcm_fops = {
-	.owner = THIS_MODULE,
-	.open = msm8k_pcm_open,
-	.release = msm8k_pcm_release,
-	.read = msm8k_pcm_read,
-	.write = msm8k_pcm_write,
-	.ioctl = msm8k_pcm_ioctl,
-	.llseek = no_llseek,
-};
-
-
-struct miscdevice msm8k_pcm_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_pcm_out",
-	.fops	= &msm8k_pcm_fops,
-};
-
-static int __init msm8k_pcm_init(void)
-{
-	int rc;
-	D("%s\n", __func__);
-
-	rc = misc_register(&msm8k_pcm_misc);
-	wake_lock_init(&pcm_wakelock, WAKE_LOCK_SUSPEND, "audio_pcm");
-	wake_lock_init(&pcm_idlelock, WAKE_LOCK_IDLE, "audio_pcm_idle");
-	mutex_init(&pcm_lock);
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(MSM8K_PCM_PROC_NAME,
-			0, NULL, msm8k_pcm_read_proc, NULL);
-#endif
-
-	return rc;
-}
-
-static void __exit msm8k_pcm_exit(void)
-{
-	D("%s\n", __func__);
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(MSM8K_PCM_PROC_NAME, NULL);
-#endif
-}
-
-
-module_init(msm8k_pcm_init);
-module_exit(msm8k_pcm_exit);
-
-MODULE_DESCRIPTION("MSM PCM driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_pcm_in.c b/arch/arm/mach-msm/qdsp6/msm8k_pcm_in.c
deleted file mode 100644
index bcecdaa..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_pcm_in.c
+++ /dev/null
@@ -1,383 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/uaccess.h>
-#include <linux/msm_audio.h>
-
-#include <asm/ioctls.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_ard.h>
-#include <mach/qdsp6/msm8k_cad_write_pcm_format.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_pcm_in: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MSM8K_PCM_IN_PROC_NAME "msm8k_pcm_in"
-
-#define AUDIO_MAGIC 'a'
-
-struct pcm {
-	u32 cad_w_handle;
-	struct msm_audio_config cfg;
-	struct msm_voicerec_mode voicerec_mode;
-};
-
-static struct mutex pcm_in_lock;
-static int pcm_in_opened;
-
-static int msm8k_pcm_in_open(struct inode *inode, struct file *f)
-{
-	struct pcm *pcm;
-	struct cad_open_struct_type  cos;
-	int rc;
-	D("%s\n", __func__);
-
-	mutex_lock(&pcm_in_lock);
-
-	if (pcm_in_opened) {
-		pr_err("pcm_in: busy\n");
-		rc = -EBUSY;
-		goto done;
-	}
-
-	pcm = kmalloc(sizeof(struct pcm), GFP_KERNEL);
-	if (pcm == NULL) {
-		pr_err("Could not allocate memory for pcm_in driver\n");
-		return CAD_RES_FAILURE;
-	}
-
-	f->private_data = pcm;
-
-	memset(pcm, 0, sizeof(struct pcm));
-	pcm->cfg.buffer_size = 4096;
-	pcm->cfg.buffer_count = 2;
-	pcm->cfg.channel_count = 1;
-	pcm->cfg.sample_rate = 8000;
-	pcm->voicerec_mode.rec_mode = VOC_REC_UPLINK;
-
-	cos.format = CAD_FORMAT_PCM;
-	cos.op_code = CAD_OPEN_OP_READ;
-	pcm->cad_w_handle = cad_open(&cos);
-
-	if (pcm->cad_w_handle == 0)
-		rc = CAD_RES_FAILURE;
-	else {
-		pcm_in_opened = 1;
-		rc = CAD_RES_SUCCESS;
-	}
-done:
-	mutex_unlock(&pcm_in_lock);
-	return rc;
-}
-
-static int msm8k_pcm_in_release(struct inode *inode, struct file *f)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct pcm *pcm = f->private_data;
-	D("%s\n", __func__);
-
-	mutex_lock(&pcm_in_lock);
-	cad_close(pcm->cad_w_handle);
-	kfree(pcm);
-	pcm_in_opened = 0;
-	mutex_unlock(&pcm_in_lock);
-	return rc;
-}
-
-static ssize_t msm8k_pcm_in_read(struct file *f, char __user *buf, size_t cnt,
-		loff_t *pos)
-{
-	struct pcm			*pcm = f->private_data;
-	struct cad_buf_struct_type	cbs;
-
-	D("%s\n", __func__);
-
-	memset(&cbs, 0, sizeof(struct cad_buf_struct_type));
-	cbs.buffer = (void *)buf;
-	cbs.max_size = cnt;
-	cbs.actual_size = cnt;
-
-
-	cnt = cad_read(pcm->cad_w_handle, &cbs);
-	return cnt;
-}
-
-static ssize_t msm8k_pcm_in_write(struct file *f, const char __user *buf,
-		size_t cnt, loff_t *pos)
-{
-	D("%s\n", __func__);
-
-	return cnt;
-}
-
-static int msm8k_pcm_in_ioctl(struct inode *inode, struct file *f,
-		unsigned int cmd, unsigned long arg)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct pcm *p = f->private_data;
-	u32 stream_device[1];
-	struct cad_device_struct_type cad_dev;
-	struct cad_stream_device_struct_type cad_stream_dev;
-	struct cad_stream_info_struct_type cad_stream_info;
-	struct cad_write_pcm_format_struct_type cad_write_pcm_fmt;
-	D("%s\n", __func__);
-
-	memset(&cad_dev, 0, sizeof(struct cad_device_struct_type));
-	memset(&cad_stream_dev, 0,
-			sizeof(struct cad_stream_device_struct_type));
-	memset(&cad_stream_info, 0, sizeof(struct cad_stream_info_struct_type));
-	memset(&cad_write_pcm_fmt, 0,
-			sizeof(struct cad_write_pcm_format_struct_type));
-
-	switch (cmd) {
-	case AUDIO_START:
-
-		if (p->voicerec_mode.rec_mode == VOC_REC_BOTH)
-			cad_stream_info.app_type = CAD_STREAM_APP_MIXED_RECORD;
-		else
-		cad_stream_info.app_type = CAD_STREAM_APP_RECORD;
-
-		cad_stream_info.priority = 0;
-		cad_stream_info.buf_mem_type = CAD_STREAM_BUF_MEM_HEAP;
-		cad_stream_info.ses_buf_max_size = p->cfg.buffer_size;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_INFO,
-			&cad_stream_info,
-			sizeof(struct cad_stream_info_struct_type));
-		if (rc) {
-			pr_err("pcm_in: cad_ioctl() SET_STREAM_INFO failed\n");
-			break;
-		}
-
-		stream_device[0] = CAD_HW_DEVICE_ID_DEFAULT_TX;
-		cad_stream_dev.device = (u32 *)&stream_device[0];
-		cad_stream_dev.device_len = 1;
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_DEVICE,
-			&cad_stream_dev,
-			sizeof(struct cad_stream_device_struct_type));
-		if (rc) {
-			pr_err("pcm_in: cad_ioctl() "
-			       "SET_STREAM_DEVICE failed\n");
-			break;
-		}
-
-		cad_write_pcm_fmt.us_ver_id = CAD_WRITE_PCM_VERSION_10;
-		cad_write_pcm_fmt.pcm.us_channel_config = p->cfg.channel_count;
-		cad_write_pcm_fmt.pcm.us_width = 1;
-		cad_write_pcm_fmt.pcm.us_sign = 0;
-
-		switch (p->cfg.sample_rate) {
-		case 96000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 0;
-			break;
-		case 88200:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 1;
-			break;
-		case 64000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 2;
-			break;
-		case 48000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 3;
-			break;
-		case 44100:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 4;
-			break;
-		case 32000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 5;
-			break;
-		case 24000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 6;
-			break;
-		case 22050:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 7;
-			break;
-		case 16000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 8;
-			break;
-		case 12000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 9;
-			break;
-		case 11025:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 10;
-			break;
-		case 8000:
-			cad_write_pcm_fmt.pcm.us_sample_rate = 11;
-			break;
-		}
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_CONFIG,
-			&cad_write_pcm_fmt,
-			sizeof(struct cad_write_pcm_format_struct_type));
-		if (rc) {
-			pr_err("pcm_in: cad_ioctl() "
-			       "SET_STREAM_CONFIG failed\n");
-			break;
-		}
-
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_START,
-			NULL, 0);
-		if (rc) {
-			pr_err("pcm_in: cad_ioctl() STREAM_START failed\n");
-			break;
-		}
-		break;
-	case AUDIO_STOP:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_PAUSE,
-			NULL, 0);
-		break;
-	case AUDIO_FLUSH:
-		rc = cad_ioctl(p->cad_w_handle, CAD_IOCTL_CMD_STREAM_FLUSH,
-			NULL, 0);
-		break;
-	case AUDIO_GET_CONFIG:
-		if (copy_to_user((void *)arg, &p->cfg,
-				sizeof(struct msm_audio_config)))
-			return -EFAULT;
-		break;
-	case AUDIO_SET_CONFIG:
-		rc = copy_from_user(&p->cfg, (void *)arg,
-				sizeof(struct msm_audio_config));
-		break;
-	case AUDIO_SET_INCALL:
-		if (copy_from_user(&p->voicerec_mode, (void *)arg,
-				sizeof(struct msm_voicerec_mode)))
-			return -EFAULT;
-		if (p->voicerec_mode.rec_mode != VOC_REC_BOTH &&
-			p->voicerec_mode.rec_mode != VOC_REC_UPLINK &&
-			p->voicerec_mode.rec_mode != VOC_REC_DOWNLINK) {
-			p->voicerec_mode.rec_mode = VOC_REC_UPLINK;
-			pr_err("invalid rec_mode\n");
-			return -EINVAL;
-		}
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-#ifdef CONFIG_PROC_FS
-int msm8k_pcm_in_read_proc(char *pbuf, char **start, off_t offset,
-			int count, int *eof, void *data)
-{
-	int len = 0;
-	len += snprintf(pbuf, 16, "pcm_in\n");
-
-	*eof = 1;
-	return len;
-}
-#endif
-
-static const struct file_operations msm8k_pcm_in_fops = {
-	.owner = THIS_MODULE,
-	.open = msm8k_pcm_in_open,
-	.release = msm8k_pcm_in_release,
-	.read = msm8k_pcm_in_read,
-	.write = msm8k_pcm_in_write,
-	.ioctl = msm8k_pcm_in_ioctl,
-	.llseek = no_llseek,
-};
-
-
-struct miscdevice msm8k_pcm_in_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_pcm_in",
-	.fops	= &msm8k_pcm_in_fops,
-};
-
-static int __init msm8k_pcm_in_init(void)
-{
-	int rc;
-	D("%s\n", __func__);
-
-	rc = misc_register(&msm8k_pcm_in_misc);
-	mutex_init(&pcm_in_lock);
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(MSM8K_PCM_IN_PROC_NAME,
-			0, NULL, msm8k_pcm_in_read_proc, NULL);
-#endif
-
-	return rc;
-}
-
-static void __exit msm8k_pcm_in_exit(void)
-{
-	D("%s\n", __func__);
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(MSM8K_PCM_IN_PROC_NAME, NULL);
-#endif
-}
-
-
-module_init(msm8k_pcm_in_init);
-module_exit(msm8k_pcm_in_exit);
-
-MODULE_DESCRIPTION("MSM PCM IN driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_q6_api_flip_utils.c b/arch/arm/mach-msm/qdsp6/msm8k_q6_api_flip_utils.c
deleted file mode 100644
index f761402..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_q6_api_flip_utils.c
+++ /dev/null
@@ -1,1342 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/slab.h>
-
-#include <mach/qdsp6/msm8k_ard_q6.h>
-#include <mach/qdsp6/msm8k_ardi.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_itypes.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_cad_rpc.h>
-#include <mach/qdsp6/msm8k_q6_api_flip_utils.h>
-#include <mach/qdsp6/msm8k_cad_q6dec_drvi.h>
-#include <mach/qdsp6/msm8k_adsp_audio_device.h>
-#include <mach/qdsp6/msm8k_adsp_audio_ioctl.h>
-#include <mach/qdsp6/msm8k_adsp_audio_media_format.h>
-
-#define AAC_FORMAT_SIZE			8
-
-/* Supported AAC object types */
-/* #define AAC_OBJECT_LC		2 */
-/* #define AAC_OBJECT_SSR		3 */
-/* #define AAC_OBJECT_LTP		4 */
-/* #define AAC_OBJECT_HE		5 */
-/* #define AAC_OBJECT_SCALABLE		6 */
-#define AAC_OBJECT_ER_LC		17
-#define AAC_OBJECT_ER_LTP		19
-#define AAC_OBJECT_ER_SCALABLE		20
-#define AAC_OBJECT_BSAC			22
-#define AAC_OBJECT_ER_LD		23
-/* #define AAC_OBJECT_HE_PS		29 */
-
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "ARD: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-
-/* Utility function */
-u32 q6_stream_context_mapping(enum cad_stream_app_enum_type app_type,
-			      u32 *mode)
-{
-	*mode = ADSP_AUDIO_OPEN_STREAM_MODE_NONE;
-
-	switch (app_type) {
-	case CAD_STREAM_APP_VOICE:
-		/* voice */
-		return ADSP_AUDIO_DEVICE_CONTEXT_VOICE;
-	case CAD_STREAM_APP_RECORD:
-		/* record */
-		return ADSP_AUDIO_DEVICE_CONTEXT_RECORD;
-	case CAD_STREAM_APP_A2DP_MIX_MODE:
-		/* loopback */
-		return ADSP_AUDIO_DEVICE_CONTEXT_PCM_LOOPBACK;
-	case CAD_STREAM_APP_PLAYBACK:
-	case CAD_STREAM_APP_DTMF:
-	case CAD_STREAM_APP_RINGER:
-	case CAD_STREAM_APP_SYSTEM_SOUND:
-		/* playback */
-		return ADSP_AUDIO_DEVICE_CONTEXT_PLAYBACK;
-	case CAD_STREAM_APP_AUDIO_VIDEO:
-		*mode = ADSP_AUDIO_OPEN_STREAM_MODE_AVSYNC;
-		return ADSP_AUDIO_DEVICE_CONTEXT_PLAYBACK;
-	case CAD_STREAM_APP_MIXED_RECORD:
-		return ADSP_AUDIO_DEVICE_CONTEXT_MIXED_RECORD;
-	case CAD_STREAM_APP_UNKNOWN:
-	default:
-		/* error */
-		return 0xFFFFFFFF;
-	}
-}
-
-u32 q6_open_op_mapping(u32 op_code)
-{
-	switch (op_code) {
-	case CAD_OPEN_OP_READ:
-		/* voice */
-		return ADSP_AUDIO_IOCTL_CMD_OPEN_READ;
-	case CAD_OPEN_OP_WRITE:
-		/* record */
-		return ADSP_AUDIO_IOCTL_CMD_OPEN_WRITE;
-	case CAD_OPEN_OP_DEVICE_CTRL:
-		/* loopback */
-		return ADSP_AUDIO_IOCTL_CMD_OPEN_DEVICE;
-	default:
-		/* error */
-		return 0xFFFFFFFF;
-	}
-}
-
-u32 q6_device_id_mapping(u32 device)
-{
-	switch (device) {
-	case CAD_HW_DEVICE_ID_HANDSET_MIC:
-		return ADSP_AUDIO_DEVICE_ID_HANDSET_MIC;
-	case CAD_HW_DEVICE_ID_HANDSET_SPKR:
-		return ADSP_AUDIO_DEVICE_ID_HANDSET_SPKR;
-	case CAD_HW_DEVICE_ID_HEADSET_MIC:
-		return ADSP_AUDIO_DEVICE_ID_HEADSET_MIC;
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO:
-		return ADSP_AUDIO_DEVICE_ID_HEADSET_SPKR_MONO;
-	case CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO:
-		return ADSP_AUDIO_DEVICE_ID_HEADSET_SPKR_STEREO;
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_MIC:
-		return ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MIC;
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_MONO:
-		return ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO;
-	case CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO:
-		return ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO;
-	case CAD_HW_DEVICE_ID_BT_SCO_MIC:
-		return ADSP_AUDIO_DEVICE_ID_BT_SCO_MIC;
-	case CAD_HW_DEVICE_ID_BT_SCO_SPKR:
-		return ADSP_AUDIO_DEVICE_ID_BT_SCO_SPKR;
-	case CAD_HW_DEVICE_ID_TTY_HEADSET_MIC:
-		return ADSP_AUDIO_DEVICE_ID_TTY_HEADSET_MIC;
-	case CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR:
-		return ADSP_AUDIO_DEVICE_ID_TTY_HEADSET_SPKR;
-	case CAD_HW_DEVICE_ID_I2S_RX:
-		return ADSP_AUDIO_DEVICE_ID_I2S_SPKR;
-	case CAD_HW_DEVICE_ID_I2S_TX:
-		return ADSP_AUDIO_DEVICE_ID_I2S_MIC;
-
-	case CAD_HW_DEVICE_ID_BT_A2DP_SPKR:
-		return ADSP_AUDIO_DEVICE_ID_BT_A2DP_SPKR;
-	case CAD_HW_DEVICE_ID_BT_A2DP_TX:
-		return ADSP_AUDIO_DEVICE_ID_MIXED_PCM_LOOPBACK_TX;
-
-	case CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_MONO_RX:
-		return ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO_W_MONO_HEADSET;
-	case CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_STEREO_RX:
-		return ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO_W_MONO_HEADSET;
-	case CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX:
-		return ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO_W_STEREO_HEADSET;
-	case CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_STEREO_RX:
-		return ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO_W_STEREO_HEADSET;
-
-	case CAD_HW_DEVICE_ID_NULL_RX:
-		return ADSP_AUDIO_DEVICE_ID_NULL_SINK;
-
-	case CAD_HW_DEVICE_ID_VOICE:
-		return ADSP_AUDIO_DEVICE_ID_VOICE;
-
-	case CAD_HW_DEVICE_ID_DEFAULT_RX:
-	case CAD_HW_DEVICE_ID_DEFAULT_TX:
-		return ADSP_AUDIO_DEVICE_ID_DEFAULT;
-
-	default:
-		return 0xFFFFFFFF;
-	}
-}
-
-u8 q6_device_direction_mapping(u8 device)
-{
-	switch (device) {
-	case CAD_TX_DEVICE:
-		return ADSP_AUDIO_TX_DEVICE;
-	case CAD_RX_DEVICE:
-		return ADSP_AUDIO_RX_DEVICE;
-	default:
-		return 0xFF;
-	}
-}
-
-s32 convert_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32 result = CAD_RES_SUCCESS;
-
-	if ((cad_open_struct->cad_config.format_block_len != 0) &&
-		(cad_open_struct->cad_config.format_block == NULL))
-		return CAD_RES_FAILURE;
-
-	/* Translate format type and format block. */
-	switch (cad_open_struct->cad_open.format) {
-	case CAD_FORMAT_PCM:
-		result = convert_pcm_format_block(session_id, q6_open_struct,
-			cad_open_struct);
-		break;
-	case CAD_FORMAT_DTMF:
-		result = convert_dtmf_format_block(session_id, q6_open_struct,
-			cad_open_struct);
-		break;
-	case CAD_FORMAT_YADPCM:
-		result = convert_yadpcm_format_block(session_id, q6_open_struct,
-			cad_open_struct);
-		break;
-	case CAD_FORMAT_ADPCM:
-		result = convert_adpcm_format_block(session_id, q6_open_struct,
-			cad_open_struct);
-		break;
-	case CAD_FORMAT_AAC:
-		result = convert_aac_format_block(session_id, q6_open_struct,
-			cad_open_struct);
-		break;
-	case CAD_FORMAT_AMRWB:
-	case CAD_FORMAT_AMRNB:
-		result = convert_amr_format_block(session_id, q6_open_struct,
-			cad_open_struct);
-		break;
-	case CAD_FORMAT_EVRCB:
-	case CAD_FORMAT_EVRC:
-		result = convert_evrc_format_block(session_id, q6_open_struct,
-			cad_open_struct);
-		break;
-	case CAD_FORMAT_QCELP13K:
-		result = convert_v13k_format_block(session_id, q6_open_struct,
-			cad_open_struct);
-		break;
-	case CAD_FORMAT_MIDI:
-		result = convert_midi_format_block(session_id, q6_open_struct,
-			cad_open_struct);
-		break;
-		return CAD_RES_SUCCESS;
-
-	case CAD_FORMAT_MP3:
-		result = convert_mp3_format_block(session_id, q6_open_struct,
-			cad_open_struct);
-		break;
-	case CAD_FORMAT_SBC:
-		result = convert_sbc_format_block(session_id, q6_open_struct,
-			cad_open_struct);
-		break;
-	case CAD_FORMAT_WMA:
-	case CAD_FORMAT_WMA_PRO:
-		result = convert_wma_std_format_block(session_id,
-			q6_open_struct, cad_open_struct);
-		break;
-	default:
-		result = CAD_RES_FAILURE;
-		return result;
-	}
-
-	return result;
-}
-
-s32 convert_pcm_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct cad_write_pcm_struct_type	*cad_format = NULL;
-	struct adsp_audio_standard_format	*q6_format = NULL;
-
-	if ((cad_open_struct->cad_config.format_block == NULL) ||
-		(cad_open_struct->cad_config.format_block_len !=
-		sizeof(struct cad_write_pcm_format_struct_type))) {
-
-		pr_err("No format block provided for pcm\n");
-		return CAD_RES_FAILURE;
-	}
-
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-
-	/* Save and translate the cmdbuff passed in */
-	cad_format = &(((struct cad_write_pcm_format_struct_type *)
-		(cad_open_struct->cad_config.format_block))->pcm);
-	q6_format = (struct adsp_audio_standard_format *)
-		(q6_open_struct->stream_device.format_block);
-
-	q6_format->format = ADSP_AUDIO_FORMAT_PCM;
-	if (cad_open_struct->cad_open.op_code == CAD_OPEN_OP_WRITE) {
-		/* PCM Playback assumed interleaved from Host */
-		q6_format->is_interleaved = true;
-	} else {
-		/* PCM coming out of Device Ses is always non-interleaved */
-		q6_format->is_interleaved = false;
-	}
-	switch (cad_format->us_sample_rate) {
-	case 0:
-		q6_format->sampling_rate = 96000;
-		break;
-	case 1:
-		q6_format->sampling_rate = 88200;
-		break;
-	case 2:
-		q6_format->sampling_rate = 64000;
-		break;
-	case 3:
-		q6_format->sampling_rate = 48000;
-		break;
-	case 4:
-		q6_format->sampling_rate = 44100;
-		break;
-	case 5:
-		q6_format->sampling_rate = 32000;
-		break;
-	case 6:
-		q6_format->sampling_rate = 24000;
-		break;
-	case 7:
-		q6_format->sampling_rate = 22050;
-		break;
-	case 8:
-		q6_format->sampling_rate = 16000;
-		break;
-	case 9:
-		q6_format->sampling_rate = 12000;
-		break;
-	case 10:
-		q6_format->sampling_rate = 11025;
-		break;
-	case 11:
-		q6_format->sampling_rate = 8000;
-		break;
-	default:
-		return CAD_RES_FAILURE;
-	}
-
-	q6_format->channels = cad_format->us_channel_config;
-
-	switch (cad_format->us_width) {
-	case 0:
-		q6_format->bits_per_sample = 8;
-		break;
-	case 1:
-		q6_format->bits_per_sample = 16;
-		break;
-	case 2:
-		q6_format->bits_per_sample = 24;
-		break;
-	default:
-		return CAD_RES_FAILURE;
-	}
-
-	if (cad_format->us_sign == 0)
-		q6_format->is_signed = true;
-
-	q6_open_struct->stream_device.format_block_len =
-		sizeof(*q6_format);
-
-	/* Set to physical address of format block */
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	return result;
-}
-
-
-s32 convert_dtmf_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct adsp_audio_standard_format	*q6_format = NULL;
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-	/* Save and translate the cmdbuff passed in */
-	q6_format = (struct adsp_audio_standard_format *)
-		(q6_open_struct->stream_device.format_block);
-
-	q6_format->format = ADSP_AUDIO_FORMAT_DTMF;
-	q6_format->sampling_rate = 48000;
-	q6_format->channels = 2;
-	q6_format->bits_per_sample = 16;
-	q6_format->is_signed = true;
-	q6_format->is_interleaved = false;
-
-	q6_open_struct->stream_device.format_block_len =
-		sizeof(*q6_format);
-
-	/* Set to physical address of format block */
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	return result;
-}
-
-
-
-s32 convert_yadpcm_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct cad_adpcm_format_struct		*cad_format = NULL;
-	struct adsp_audio_standard_format	*q6_format = NULL;
-
-	if ((cad_open_struct->cad_config.format_block == NULL) ||
-		(cad_open_struct->cad_config.format_block_len !=
-		sizeof(*cad_format))) {
-
-		pr_err("No format block provided for yadpcm\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-
-	/* Save and translate the cmdbuff passed in */
-	cad_format = (struct cad_adpcm_format_struct *)
-		(cad_open_struct->cad_config.format_block);
-	q6_format = (struct adsp_audio_standard_format *)
-		(q6_open_struct->stream_device.format_block);
-
-	q6_format->format = ADSP_AUDIO_FORMAT_YADPCM;
-	q6_format->sampling_rate = cad_format->sampling_rate;
-	q6_format->channels = (u16)(cad_format->channels);
-	q6_format->bits_per_sample = (u16)(cad_format->bit_per_sample);
-
-	if (cad_format->flags == CAD_ADPCM_SIGNED)
-		q6_format->is_signed = true;
-
-	if (cad_format->flags == CAD_ADPCM_INTERLEAVED)
-		q6_format->is_interleaved = true;
-
-	q6_open_struct->stream_device.format_block_len =
-		sizeof(*q6_format);
-
-	/* Set to physical address of format block */
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	return result;
-}
-
-
-s32 convert_adpcm_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct cad_adpcm_format_struct		*cad_format = NULL;
-	struct adsp_audio_adpcm_format		*q6_format = NULL;
-
-	if ((cad_open_struct->cad_config.format_block == NULL) ||
-		(cad_open_struct->cad_config.format_block_len !=
-		sizeof(*cad_format))) {
-
-		pr_err("No format block provided for adpcm\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-
-	/* Save and translate the cmdbuff passed in */
-	cad_format = (struct cad_adpcm_format_struct *)
-		(cad_open_struct->cad_config.format_block);
-	q6_format = (struct adsp_audio_adpcm_format *)
-		(q6_open_struct->stream_device.format_block);
-
-	q6_format->format = ADSP_AUDIO_FORMAT_ADPCM;
-	q6_format->block_size = cad_format->block_size;
-	q6_format->sampling_rate = cad_format->sampling_rate;
-	q6_format->channels = (u16)(cad_format->channels);
-	q6_format->bits_per_sample = (u16)(cad_format->bit_per_sample);
-
-	if (cad_format->flags == CAD_ADPCM_SIGNED)
-		q6_format->is_signed = true;
-
-	if (cad_format->flags == CAD_ADPCM_INTERLEAVED)
-		q6_format->is_interleaved = true;
-
-	q6_open_struct->stream_device.format_block_len =
-		sizeof(*q6_format);
-
-	/* Set to physical address of format block */
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	return result;
-}
-
-s32 convert_aac_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct cad_write_aac_struct_type	*cad_format = NULL;
-	struct adsp_audio_binary_format		*q6_format = NULL;
-	u32					*aac_type = NULL;
-	s32					index = sizeof(u32);
-	u32		op_code = cad_open_struct->cad_open.op_code;
-
-	if ((cad_open_struct->cad_config.format_block == NULL) ||
-		(cad_open_struct->cad_config.format_block_len !=
-		sizeof(struct cad_write_aac_format_struct_type))) {
-
-		pr_err("No format block provided for aac\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-
-	/* Save and translate the cmdbuff passed in */
-	cad_format = &(((struct cad_write_aac_format_struct_type *)
-		(cad_open_struct->cad_config.format_block))->aac);
-	q6_format = (struct adsp_audio_binary_format *)
-		(q6_open_struct->stream_device.format_block);
-
-
-	q6_format->format = ADSP_AUDIO_FORMAT_MPEG4_AAC;
-	aac_type = (u32 *)(q6_format->data);
-	switch (cad_format->block_formats) {
-	case 0xFFFF:
-		if (op_code == CAD_OPEN_OP_READ) {
-			/* AAC Encoder expect MPEG4_ADTS media type */
-			*aac_type = ADSP_AUDIO_AAC_MPEG4_ADTS;
-		} else {
-			*aac_type = ADSP_AUDIO_AAC_ADTS;
-		}
-		break;
-	case 0:
-		if (op_code == CAD_OPEN_OP_READ) {
-			/* for ADIF recording */
-			D("AAC Recording set AAC_ADIF to AAC_RAW for encoder");
-			*aac_type = ADSP_AUDIO_AAC_RAW;
-		} else {
-			*aac_type = ADSP_AUDIO_AAC_ADIF;
-		}
-		break;
-	case 1:
-		/* pseudo raw */
-		*aac_type = ADSP_AUDIO_AAC_RAW;
-		break;
-	case 2:
-		*aac_type = ADSP_AUDIO_AAC_LOAS;
-		break;
-	case 3:
-		/* RAW format, at least one full frame per buffer */
-		/* coming from QTV parser */
-		*aac_type = ADSP_AUDIO_AAC_FRAMED_RAW;
-		break;
-	case 4:
-		/* raw */
-		*aac_type = ADSP_AUDIO_AAC_RAW;
-		break;
-	default:
-		return CAD_RES_FAILURE;
-	}
-
-	q6_format->data[index++] = (u8)(
-			((cad_format->audio_object_type & 0x1F) << 3) |
-			((cad_format->sample_rate >> 1) & 0x7));
-	q6_format->data[index] = (u8)(
-			((cad_format->sample_rate & 0x1) << 7) |
-			((cad_format->channel_config & 0x7) << 3));
-
-	switch (cad_format->audio_object_type) {
-	case AAC_OBJECT_ER_LC:
-	case AAC_OBJECT_ER_LTP:
-	case AAC_OBJECT_ER_LD:
-		/* extension flag */
-		q6_format->data[index++] |= 0x1;
-		q6_format->data[index] = (u8)(
-			((cad_format->aac_section_data_resilience_flag
-			& 0x1) << 7) |
-			((cad_format->aac_scalefactor_data_resilience_flag
-			& 0x1) << 6) |
-			((cad_format->aac_spectral_data_resilience_flag
-			& 0x1) << 5) |
-			((cad_format->ep_config & 0x3) << 2));
-		break;
-
-	case AAC_OBJECT_ER_SCALABLE:
-		q6_format->data[index++] |= 0x1;
-		/* extension flag */
-		q6_format->data[index++] = (u8)(
-			((cad_format->aac_section_data_resilience_flag
-			& 0x1) << 4) |
-			((cad_format->aac_scalefactor_data_resilience_flag
-			& 0x1) << 3) |
-			((cad_format->aac_spectral_data_resilience_flag
-			& 0x1) << 2) |
-			((cad_format->ep_config >> 1) & 0x1));
-		q6_format->data[index] = (u8)((cad_format->ep_config & 0x1)
-			<< 7);
-		break;
-
-	case AAC_OBJECT_BSAC:
-		q6_format->data[++index] = (u8)((cad_format->ep_config & 0x3)
-			<< 6);
-		break;
-
-	default:
-		break;
-	}
-
-	D("CAD:ARD AAC format %x%x%x%x%x%x%x%x, len %d",
-		q6_format->data[0], q6_format->data[1], q6_format->data[2],
-		q6_format->data[3], q6_format->data[4], q6_format->data[5],
-		q6_format->data[6], q6_format->data[7],
-		index+1);
-
-	q6_format->num_bytes = index + 1;
-
-	q6_open_struct->stream_device.format_block_len = sizeof(*q6_format);
-
-	/* Set to physical address of format block */
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	/* Fill in encoder config. */
-	q6_open_struct->stream_device.config.aac_cfg.bit_rate =
-		cad_format->bit_rate;
-
-	if ((cad_format->sbr_on_flag == 0) &&
-		(cad_format->sbr_ps_on_flag == 0)) {
-
-		q6_open_struct->stream_device.config.aac_cfg.encoder_mode =
-			ADSP_AUDIO_ENC_AAC_LC_ONLY_MODE;
-
-	} else if ((cad_format->sbr_on_flag == 1) &&
-		(cad_format->sbr_ps_on_flag == 0)) {
-
-		q6_open_struct->stream_device.config.aac_cfg.encoder_mode =
-			ADSP_AUDIO_ENC_AAC_PLUS_MODE;
-
-	} else if ((cad_format->sbr_on_flag == 1) &&
-		(cad_format->sbr_ps_on_flag == 1)) {
-
-		q6_open_struct->stream_device.config.aac_cfg.encoder_mode =
-			ADSP_AUDIO_ENC_ENHANCED_AAC_PLUS_MODE;
-
-	} else {
-		pr_err("CAD:ARD: cad format block Sbr flags are undefined");
-		return CAD_RES_FAILURE;
-	}
-
-	return result;
-}
-
-s32 convert_amr_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct cad_amr_format			*cad_format = NULL;
-	struct adsp_audio_standard_format	*q6_format = NULL;
-
-	if ((cad_open_struct->cad_config.format_block == NULL) ||
-		(cad_open_struct->cad_config.format_block_len !=
-		sizeof(*cad_format))) {
-
-		pr_err("No format block provided for amr\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));;
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-
-	/* Save and translate the cmdbuff passed in */
-	cad_format = (struct cad_amr_format *)
-		(cad_open_struct->cad_config.format_block);
-	q6_format = (struct adsp_audio_standard_format *)
-		(q6_open_struct->stream_device.format_block);
-
-
-	if (cad_open_struct->cad_open.format == CAD_FORMAT_AMRWB)
-		q6_format->format = ADSP_AUDIO_FORMAT_AMRWB_FS;
-	else
-		q6_format->format = ADSP_AUDIO_FORMAT_AMRNB_FS;
-
-
-	/* AMR NB by definition */
-	q6_format->sampling_rate = 8000;
-	q6_format->channels = 1;
-	q6_format->bits_per_sample = 16;
-	q6_format->is_signed = true;
-	q6_format->is_interleaved = false;
-
-	q6_open_struct->stream_device.format_block_len =
-		sizeof(*q6_format);
-
-	/* Set to physical address of format block */
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	/* Fill in encoder config. */
-	q6_open_struct->stream_device.config.amr_cfg.mode =
-		q6_band_mode_mapping(cad_format->amr_band_mode);
-	if (q6_open_struct->stream_device.config.amr_cfg.mode == 0xFFFFFFFF) {
-		pr_err("CAD:ARD: unsupported amr_band_mode!");
-		return CAD_RES_FAILURE;
-	}
-	q6_open_struct->stream_device.config.amr_cfg.dtx_mode =
-		q6_dtx_mode_mapping(cad_format->amr_dtx_mode);
-	if (q6_open_struct->stream_device.config.amr_cfg.dtx_mode ==
-		0xFFFFFFFF) {
-
-		pr_err("CAD:ARD: unsupported amr_dtx_mode!");
-		return CAD_RES_FAILURE;
-	}
-	q6_open_struct->stream_device.config.amr_cfg.enable = false;
-
-	return result;
-}
-
-
-
-s32 convert_evrc_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct cad_evrc_format			*cad_format = NULL;
-	struct adsp_audio_standard_format	*q6_format = NULL;
-
-	if ((cad_open_struct->cad_config.format_block == NULL) ||
-		(cad_open_struct->cad_config.format_block_len !=
-		sizeof(*cad_format))) {
-
-		pr_err("No format block provided for evrc\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-
-	/* Save and translate the cmdbuff passed in */
-	cad_format = (struct cad_evrc_format *)
-		(cad_open_struct->cad_config.format_block);
-	q6_format = (struct adsp_audio_standard_format *)
-		(q6_open_struct->stream_device.format_block);
-
-
-	if (cad_open_struct->cad_open.format == CAD_FORMAT_EVRCB)
-		q6_format->format = ADSP_AUDIO_FORMAT_EVRCB_FS;
-	else
-		q6_format->format = ADSP_AUDIO_FORMAT_EVRC_FS;
-
-	q6_format->sampling_rate = 8000;
-	q6_format->channels = 1;
-	q6_format->bits_per_sample = 16;
-	q6_format->is_signed = true;
-	q6_format->is_interleaved = false;
-
-	q6_open_struct->stream_device.format_block_len =
-		sizeof(*q6_format);
-
-	/* Set to physical address of format block */
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	/* Fill in encoder config. */
-	q6_open_struct->stream_device.config.evrc_cfg.min_rate =
-		(u16)(cad_format->min_bit_rate);
-	q6_open_struct->stream_device.config.evrc_cfg.max_rate =
-		(u16)(cad_format->max_bit_rate);
-
-	return result;
-}
-
-
-
-s32 convert_v13k_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct cad_qcelp13k_format		*cad_format = NULL;
-	struct adsp_audio_standard_format	*q6_format = NULL;
-
-	if ((cad_open_struct->cad_config.format_block == NULL) ||
-		(cad_open_struct->cad_config.format_block_len !=
-		sizeof(*cad_format))) {
-
-		pr_err("No format block provided for qcelp13k\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-
-	/* Save and translate the cmdbuff passed in */
-	cad_format = (struct cad_qcelp13k_format *)
-		(cad_open_struct->cad_config.format_block);
-	q6_format = (struct adsp_audio_standard_format *)
-		(q6_open_struct->stream_device.format_block);
-
-	q6_format->format = ADSP_AUDIO_FORMAT_V13K_FS;
-	q6_format->sampling_rate = 8000;
-	q6_format->channels = 1;
-	q6_format->bits_per_sample = 16;
-	q6_format->is_signed = true;
-	q6_format->is_interleaved = false;
-
-	q6_open_struct->stream_device.format_block_len =
-		sizeof(*q6_format);
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	/* Fill in encoder config. */
-	q6_open_struct->stream_device.config.qcelp13k_cfg.min_rate =
-		(u16)(cad_format->min_bit_rate);
-	q6_open_struct->stream_device.config.qcelp13k_cfg.max_rate =
-		(u16)(cad_format->max_bit_rate);
-
-	return result;
-}
-
-s32 convert_midi_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct cad_write_midi_struct_type	*cad_format = NULL;
-	struct adsp_audio_midi_format		*q6_format = NULL;
-
-	if ((cad_open_struct->cad_config.format_block == NULL) ||
-		(cad_open_struct->cad_config.format_block_len !=
-		sizeof(struct cad_write_midi_format_struct_type))) {
-
-		pr_err("No format block provided for midi\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-	/* Save and translate the cmdbuff passed in */
-	cad_format = &(((struct cad_write_midi_format_struct_type *)
-		(cad_open_struct->cad_config.format_block))->midi);
-	q6_format = (struct adsp_audio_midi_format *)
-		(q6_open_struct->stream_device.format_block);
-
-	q6_format->format = ADSP_AUDIO_FORMAT_MIDI;
-	q6_format->sampling_rate = 48000;
-	q6_format->channels = cad_format->midi_stereo;
-	q6_format->mode = cad_format->volume_lookup_index;
-
-	q6_open_struct->stream_device.format_block_len =
-		sizeof(*q6_format);
-
-	/* Set to physical address of format block */
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	return result;
-}
-
-
-
-
-s32 convert_mp3_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct adsp_audio_standard_format	*q6_format = NULL;
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-
-	/* Save and translate the cmdbuff passed in */
-	q6_format = (struct adsp_audio_standard_format *)
-		(q6_open_struct->stream_device.format_block);
-
-	q6_format->format = ADSP_AUDIO_FORMAT_MP3;
-	q6_format->sampling_rate = 48000;
-	q6_format->channels = 2;
-	q6_format->bits_per_sample = 16;
-	q6_format->is_signed = true;
-	q6_format->is_interleaved = false;
-
-	q6_open_struct->stream_device.format_block_len =
-		sizeof(*q6_format);
-
-	/* Set to physical address of format block */
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	return result;
-}
-
-
-s32 convert_sbc_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct cad_sbc_enc_cfg_struct_type	*cad_format = NULL;
-	struct adsp_audio_standard_format	*q6_format = NULL;
-
-	if ((cad_open_struct->cad_config.format_block == NULL) ||
-		(cad_open_struct->cad_config.format_block_len !=
-		sizeof(*cad_format))) {
-
-		pr_err("No format block provided for sbc\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-
-	/* Save and translate the cmdbuff passed in */
-	cad_format = (struct cad_sbc_enc_cfg_struct_type *)
-		(cad_open_struct->cad_config.format_block);
-	q6_format = (struct adsp_audio_standard_format *)
-		(q6_open_struct->stream_device.format_block);
-
-	q6_format->format = ADSP_AUDIO_FORMAT_SBC;
-	q6_format->sampling_rate = 48000;
-	q6_format->channels = 2;
-	q6_format->bits_per_sample = 16;
-	q6_format->is_signed = true;
-	q6_format->is_interleaved = false;
-
-	q6_open_struct->stream_device.format_block_len =
-		sizeof(*q6_format);
-
-	/* Set to physical address of format block */
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	/* Fill in encoder config. */
-	q6_open_struct->stream_device.config.sbc_cfg.num_subbands =
-		cad_format->num_subbands;
-	q6_open_struct->stream_device.config.sbc_cfg.block_len =
-		cad_format->block_len;
-	q6_open_struct->stream_device.config.sbc_cfg.channel_mode =
-		cad_format->channel_mode;
-	q6_open_struct->stream_device.config.sbc_cfg.allocation_method =
-		cad_format->allocation_method;
-	q6_open_struct->stream_device.config.sbc_cfg.bit_rate =
-		cad_format->bit_rate;
-
-	return result;
-}
-
-
-s32 convert_wma_std_format_block(s32 session_id,
-				struct adsp_audio_open_command *q6_open_struct,
-				struct cadi_open_struct_type *cad_open_struct)
-{
-	s32					result = CAD_RES_SUCCESS;
-	struct cad_wma_format			*cad_format = NULL;
-	struct adsp_audio_wma_pro_format	*q6_format = NULL;
-
-	if ((cad_open_struct->cad_config.format_block == NULL) ||
-		(cad_open_struct->cad_config.format_block_len !=
-		sizeof(*cad_format))) {
-
-		pr_err("No format block provided for WMA std\n");
-		return CAD_RES_FAILURE;
-	}
-
-	/* Allocate memory for Q6 format block */
-	/* Set to virtual address of format block */
-	/* reserved for this session. */
-	/* memory for each session is stored as: */
-	/* |b|p|b|p|b|p|b|p|fb|p */
-	/* b - buffer, fb - format block, p - padding */
-	ardsession[session_id]->local_format_block =
-		(void *)(g_audio_mem + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	q6_open_struct->stream_device.format_block =
-		ardsession[session_id]->local_format_block;
-
-	memset(ardsession[session_id]->local_format_block, 0,
-		sizeof(*q6_format));
-
-
-	/* Save and translate the cmdbuff passed in */
-	cad_format = (struct cad_wma_format *)
-		(cad_open_struct->cad_config.format_block);
-	q6_format = (struct adsp_audio_wma_pro_format *)
-		(q6_open_struct->stream_device.format_block);
-
-	if (cad_open_struct->cad_open.format == CAD_FORMAT_WMA_PRO)
-		q6_format->format = ADSP_AUDIO_FORMAT_WMA_V9PRO;
-	else
-		q6_format->format = ADSP_AUDIO_FORMAT_WMA_V9;
-
-	q6_format->format_tag = cad_format->format_tag;
-	q6_format->channels = cad_format->channels;
-	q6_format->samples_per_sec = cad_format->samples_per_sec;
-	q6_format->avg_bytes_per_sec = cad_format->avg_bytes_per_sec;
-	q6_format->block_align = cad_format->block_align;
-	q6_format->valid_bits_per_sample = cad_format->valid_bits_per_sample;
-	q6_format->channel_mask = cad_format->channel_mask;
-	q6_format->encode_opt = cad_format->encode_opt;
-	q6_format->advanced_encode_opt = cad_format->advanced_encode_opt;
-	q6_format->advanced_encode_opt2 = cad_format->advanced_encode_opt2;
-	q6_format->drc_peak_reference = cad_format->drc_peak_reference;
-	q6_format->drc_peak_target = cad_format->drc_peak_target;
-	q6_format->drc_average_reference = cad_format->drc_average_reference;
-	q6_format->drc_average_target = cad_format->drc_average_target;
-
-
-
-	q6_open_struct->stream_device.format_block_len =
-		sizeof(*q6_format);
-
-	/* Set to physical address of format block */
-	q6_open_struct->stream_device.format_block =
-		(void *)(g_audio_base + (Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING) +
-			MAX_FORMAT_BLOCK_SIZE + MEMORY_PADDING)
-			* session_id + Q6_DEC_BUFFER_NUM_PER_STREAM *
-			(Q6_DEC_BUFFER_SIZE_MAX + MEMORY_PADDING));
-
-	return result;
-}
-
-u32 q6_dtx_mode_mapping(u32 dtx_mode)
-{
-	switch (dtx_mode) {
-	case CAD_AMR_DTX_OFF:
-		return ADSP_AUDIO_AMR_DTX_MODE_OFF;
-	case CAD_AMR_DTX_VAD1:
-		return ADSP_AUDIO_AMR_DTX_MODE_ON_VAD1;
-	case CAD_AMR_DTX_VAD2:
-		return ADSP_AUDIO_AMR_DTX_MODE_ON_VAD2;
-	case CAD_AMR_DTX_AUTO:
-		return ADSP_AUDIO_AMR_DTX_MODE_ON_AUTO;
-	case CAD_AMR_DTX_EFR:
-	default:
-		/* error */
-		return 0xFFFFFFFF;
-	}
-}
-
-u32 q6_band_mode_mapping(u32 mode)
-{
-	switch (mode) {
-	case CAD_AMR_BM_NB0:
-	case CAD_AMR_BM_WB0:
-		return ADSP_AUDIO_AMR_MR475;
-	case CAD_AMR_BM_NB1:
-	case CAD_AMR_BM_WB1:
-		return ADSP_AUDIO_AMR_MR515;
-	case CAD_AMR_BM_NB2:
-	case CAD_AMR_BM_WB2:
-		return ADSP_AUDIO_AMR_MMR59;
-	case CAD_AMR_BM_NB3:
-	case CAD_AMR_BM_WB3:
-		return ADSP_AUDIO_AMR_MMR67;
-	case CAD_AMR_BM_NB4:
-	case CAD_AMR_BM_WB4:
-		return ADSP_AUDIO_AMR_MMR74;
-	case CAD_AMR_BM_NB5:
-	case CAD_AMR_BM_WB5:
-		return ADSP_AUDIO_AMR_MMR795;
-	case CAD_AMR_BM_NB6:
-	case CAD_AMR_BM_WB6:
-		return ADSP_AUDIO_AMR_MMR102;
-	case CAD_AMR_BM_NB7:
-	case CAD_AMR_BM_WB7:
-		return ADSP_AUDIO_AMR_MMR122;
-	case CAD_AMR_BM_WB8:
-	default:
-		/* error */
-		return 0xFFFFFFFF;
-	}
-}
-
diff --git a/arch/arm/mach-msm/qdsp6/msm8k_voice.c b/arch/arm/mach-msm/qdsp6/msm8k_voice.c
deleted file mode 100644
index c520790..0000000
--- a/arch/arm/mach-msm/qdsp6/msm8k_voice.c
+++ /dev/null
@@ -1,353 +0,0 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, HTC Corporation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * Alternatively, provided that this notice is retained in full, this software
- * may be relicensed by the recipient under the terms of the GNU General Public
- * License version 2 ("GPL") and only version 2, in which case the provisions of
- * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
- * software under the GPL, then the identification text in the MODULE_LICENSE
- * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
- * recipient changes the license terms to the GPL, subsequent recipients shall
- * not relicense under alternate licensing terms, including the BSD or dual
- * BSD/GPL terms.  In addition, the following license statement immediately
- * below and between the words START and END shall also then apply when this
- * software is relicensed under the GPL:
- *
- * START
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License version 2 and only version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * END
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/uaccess.h>
-#include <linux/msm_audio.h>
-#include <linux/delay.h>
-
-#include <asm/ioctls.h>
-#include <mach/qdsp6/msm8k_cad.h>
-#include <mach/qdsp6/msm8k_cad_ioctl.h>
-#include <mach/qdsp6/msm8k_ard.h>
-#include <mach/qdsp6/msm8k_cad_devices.h>
-#include <mach/qdsp6/msm8k_cad_write_amr_format.h>
-
-#if 0
-#define D(fmt, args...) printk(KERN_INFO "msm8k_voice: " fmt, ##args)
-#else
-#define D(fmt, args...) do {} while (0)
-#endif
-
-#define MSM8K_VOICE_PROC_NAME "msm8k_voice"
-
-#define AUDIO_MAGIC 'a'
-
-struct voice {
-	u32 cad_r_handle;
-	u32 cad_w_handle;
-};
-
-static struct mutex voice_lock;
-static int voice_opened;
-
-static int msm8k_voice_open(struct inode *inode, struct file *f)
-{
-	struct voice *voice;
-	struct cad_open_struct_type  cos;
-	struct cad_stream_info_struct_type cad_stream_info;
-	struct cad_stream_device_struct_type cad_stream_dev;
-	struct cad_write_amr_format_struct_type cad_write_amr_fmt;
-	u32 stream_device[1];
-	int rc;
-	D("%s\n", __func__);
-
-	mutex_lock(&voice_lock);
-
-	if (voice_opened) {
-		pr_err("voice: busy\n");
-		rc = -EBUSY;
-		goto done;
-	}
-
-	voice = kmalloc(sizeof(struct voice), GFP_KERNEL);
-	if (voice == NULL) {
-		pr_err("Could not allocate memory for voice driver\n");
-		return CAD_RES_FAILURE;
-	}
-
-	memset(&cad_stream_info, 0, sizeof(struct cad_stream_info_struct_type));
-	memset(&cad_write_amr_fmt, 0,
-			sizeof(struct cad_write_amr_format_struct_type));
-
-	f->private_data = voice;
-
-	memset(voice, 0, sizeof(struct voice));
-
-	cos.format = CAD_FORMAT_VOICE; /*TODO: still need this? */
-	cos.op_code = CAD_OPEN_OP_WRITE;
-	voice->cad_w_handle = cad_open(&cos);
-
-	if (voice->cad_w_handle == 0) {
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	cad_stream_info.app_type = CAD_STREAM_APP_VOICE;
-	cad_stream_info.priority = 0;
-	cad_stream_info.buf_mem_type = CAD_STREAM_BUF_MEM_HEAP;
-	cad_stream_info.ses_buf_max_size = 1024;
-	rc = cad_ioctl(voice->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_INFO,
-		&cad_stream_info,
-		sizeof(struct cad_stream_info_struct_type));
-	if (rc) {
-		pr_err("voice: cad_ioctl() "
-		       "CAD_IOCTL_CMD_SET_STREAM_INFO failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	stream_device[0] = CAD_HW_DEVICE_ID_DEFAULT_RX;
-	cad_stream_dev.device = (u32 *)&stream_device[0];
-	cad_stream_dev.device_len = 1;
-	rc = cad_ioctl(voice->cad_w_handle, CAD_IOCTL_CMD_SET_STREAM_DEVICE,
-		&cad_stream_dev,
-		sizeof(struct cad_stream_device_struct_type));
-	if (rc) {
-		pr_err("voice: cad_ioctl() "
-		       "CAD_IOCTL_CMD_SET_STREAM_DEVICE failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	rc = cad_ioctl(voice->cad_w_handle, CAD_IOCTL_CMD_STREAM_START,
-		NULL, 0);
-	if (rc) {
-		pr_err("voice: cad_ioctl() "
-		       "CAD_IOCTL_CMD_STREAM_START failed\n");
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	cos.format = CAD_FORMAT_VOICE;
-	cos.op_code = CAD_OPEN_OP_READ;
-	voice->cad_r_handle = cad_open(&cos);
-
-	if (voice->cad_r_handle == 0) {
-		rc = CAD_RES_FAILURE;
-		goto done;
-	}
-
-	cad_stream_info.app_type = CAD_STREAM_APP_VOICE;
-	cad_stream_info.priority = 0;
-	cad_stream_info.buf_mem_type = CAD_STREAM_BUF_MEM_HEAP;
-	cad_stream_info.ses_buf_max_size = 1024;
-	rc = cad_ioctl(voice->cad_r_handle, CAD_IOCTL_CMD_SET_STREAM_INFO,
-		&cad_stream_info,
-		sizeof(struct cad_stream_info_struct_type));
-	if (rc) {
-		pr_err("cad_ioctl() CAD_IOCTL_CMD_SET_STREAM_INFO failed\n");
-		return CAD_RES_FAILURE;
-	}
-
-	stream_device[0] = CAD_HW_DEVICE_ID_DEFAULT_TX;
-	cad_stream_dev.device = (u32 *)&stream_device[0];
-	cad_stream_dev.device_len = 1;
-	rc = cad_ioctl(voice->cad_r_handle, CAD_IOCTL_CMD_SET_STREAM_DEVICE,
-		&cad_stream_dev,
-		sizeof(struct cad_stream_device_struct_type));
-	if (rc) {
-		pr_err("cad_ioctl() CAD_IOCTL_CMD_SET_STREAM_DEVICE failed\n");
-		return CAD_RES_FAILURE;
-	}
-
-	rc = cad_ioctl(voice->cad_r_handle, CAD_IOCTL_CMD_STREAM_START,
-		NULL, 0);
-	if (rc) {
-		pr_err("cad_ioctl() CAD_IOCTL_CMD_STREAM_START failed\n");
-		return CAD_RES_FAILURE;
-	}
-
-	voice_opened = 1;
-
-done:
-	mutex_unlock(&voice_lock);
-	return rc;
-}
-
-static int msm8k_voice_release(struct inode *inode, struct file *f)
-{
-	int rc = CAD_RES_SUCCESS;
-	struct voice *voice = f->private_data;
-	D("%s\n", __func__);
-
-	mutex_lock(&voice_lock);
-
-	cad_close(voice->cad_w_handle);
-	cad_close(voice->cad_r_handle);
-	kfree(voice);
-	voice_opened = 0;
-	mutex_unlock(&voice_lock);
-	return rc;
-}
-
-static ssize_t msm8k_voice_read(struct file *f, char __user *buf, size_t cnt,
-		loff_t *pos)
-{
-	D("%s\n", __func__);
-	return -EINVAL;
-}
-
-static ssize_t msm8k_voice_write(struct file *f, const char __user *buf,
-		size_t cnt, loff_t *pos)
-{
-	struct cad_buf_struct_type cbs;
-	struct voice *voice = f->private_data;
-
-	D("%s\n", __func__);
-
-	memset(&cbs, 0, sizeof(struct cad_buf_struct_type));
-	cbs.buffer = (void *)buf;
-	cbs.phys_addr = 0;
-	cbs.max_size = cnt;
-
-	cad_write(voice->cad_w_handle, &cbs);
-
-	return cnt;
-}
-
-static int msm8k_voice_ioctl(struct inode *inode, struct file *f,
-		unsigned int cmd, unsigned long arg)
-{
-	int rc;
-	struct voice *voice = f->private_data;
-	struct cad_stream_info_struct_type cad_stream_info;
-	D("%s\n", __func__);
-
-	memset(&cad_stream_info, 0, sizeof(struct cad_stream_info_struct_type));
-
-	switch (cmd) {
-	case AUDIO_START:
-	case AUDIO_STOP:
-	case AUDIO_FLUSH:
-		rc = CAD_RES_SUCCESS;
-		break;
-	case AUDIO_GET_CONFIG:
-		rc = CAD_RES_SUCCESS;
-		break;
-	case AUDIO_SET_CONFIG:
-		rc = cad_ioctl(voice->cad_w_handle,
-			CAD_IOCTL_CMD_SET_STREAM_INFO,
-			&cad_stream_info,
-			sizeof(struct cad_stream_info_struct_type));
-		if (rc)
-			pr_err("voice: cad_ioctl() "
-			       " CAD_IOCTL_CMD_SET_STREAM_INFO failed\n");
-
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-#ifdef CONFIG_PROC_FS
-int msm8k_voice_read_proc(char *pbuf, char **start, off_t offset,
-			int count, int *eof, void *data)
-{
-	int len = 0;
-	len += snprintf(pbuf, 16, "voice\n");
-
-	*eof = 1;
-	return len;
-}
-#endif
-
-static const struct file_operations msm8k_voice_fops = {
-	.owner = THIS_MODULE,
-	.open = msm8k_voice_open,
-	.release = msm8k_voice_release,
-	.read = msm8k_voice_read,
-	.write = msm8k_voice_write,
-	.ioctl = msm8k_voice_ioctl,
-	.llseek = no_llseek,
-};
-
-
-struct miscdevice msm8k_voice_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_voice",
-	.fops	= &msm8k_voice_fops,
-};
-
-static int __init msm8k_voice_init(void)
-{
-	int rc;
-	D("%s\n", __func__);
-
-	rc = misc_register(&msm8k_voice_misc);
-	mutex_init(&voice_lock);
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(MSM8K_VOICE_PROC_NAME,
-			0, NULL, msm8k_voice_read_proc, NULL);
-#endif
-
-	return rc;
-}
-
-static void __exit msm8k_voice_exit(void)
-{
-	D("%s\n", __func__);
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(MSM8K_VOICE_PROC_NAME, NULL);
-#endif
-}
-
-
-module_init(msm8k_voice_init);
-module_exit(msm8k_voice_exit);
-
-MODULE_DESCRIPTION("MSM Voice driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/arch/arm/mach-msm/qdsp6/msm_q6vdec.c b/arch/arm/mach-msm/qdsp6/msm_q6vdec.c
deleted file mode 100644
index d3fcfe7..0000000
--- a/arch/arm/mach-msm/qdsp6/msm_q6vdec.c
+++ /dev/null
@@ -1,940 +0,0 @@
-/* Copyright (c) 2008-2009, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-/*
-#define DEBUG_TRACE_VDEC
-#define DEBUG
-*/
-
-#include <linux/cdev.h>
-#include <linux/delay.h>
-#include <linux/file.h>
-#include <linux/fs.h>
-#include <linux/list.h>
-#include <linux/miscdevice.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/sched.h>
-#include <linux/spinlock.h>
-#include <linux/uaccess.h>
-#include <linux/wakelock.h>
-
-#include <linux/android_pmem.h>
-#include <linux/msm_q6vdec.h>
-
-#include "dal.h"
-
-#define DALDEVICEID_VDEC_DEVICE		0x02000026
-#define DALDEVICEID_VDEC_PORTNAME	"DSP_DAL_AQ_VID"
-
-#define VDEC_INTERFACE_VERSION		0x00020000
-
-#define MAJOR_MASK			0xFFFF0000
-#define MINOR_MASK			0x0000FFFF
-
-#define VDEC_GET_MAJOR_VERSION(version)	(((version)&MAJOR_MASK)>>16)
-
-#define VDEC_GET_MINOR_VERSION(version)	((version)&MINOR_MASK)
-
-#ifdef DEBUG_TRACE_VDEC
-#define TRACE(fmt,x...)			\
-	do { pr_debug("%s:%d " fmt, __func__, __LINE__, ##x); } while (0)
-#else
-#define TRACE(fmt,x...)		do { } while (0)
-#endif
-
-
-static DEFINE_MUTEX(idlecount_lock);
-static int idlecount;
-static struct wake_lock wakelock;
-static struct wake_lock idlelock;
-
-static void prevent_sleep(void)
-{
-	mutex_lock(&idlecount_lock);
-	if (++idlecount == 1) {
-		wake_lock(&idlelock);
-		wake_lock(&wakelock);
-	}
-	mutex_unlock(&idlecount_lock);
-}
-
-static void allow_sleep(void)
-{
-	mutex_lock(&idlecount_lock);
-	if (--idlecount == 0) {
-		wake_unlock(&idlelock);
-		wake_unlock(&wakelock);
-	}
-	mutex_unlock(&idlecount_lock);
-}
-
-
-enum {
-	VDEC_DALRPC_INITIALIZE = DAL_OP_FIRST_DEVICE_API,
-	VDEC_DALRPC_SETBUFFERS,
-	VDEC_DALRPC_FREEBUFFERS,
-	VDEC_DALRPC_QUEUE,
-	VDEC_DALRPC_SIGEOFSTREAM,
-	VDEC_DALRPC_FLUSH,
-	VDEC_DALRPC_REUSEFRAMEBUFFER,
-	VDEC_DALRPC_GETDECATTRIBUTES,
-};
-
-enum {
-	VDEC_ASYNCMSG_DECODE_DONE = 0xdec0de00,
-	VDEC_ASYNCMSG_REUSE_FRAME,
-};
-
-struct vdec_init_cfg {
-	u32			decode_done_evt;
-	u32			reuse_frame_evt;
-	struct vdec_config	cfg;
-};
-
-struct vdec_buffer_status {
-	u32			data;
-	u32			status;
-};
-
-#define VDEC_MSG_MAX		128
-
-struct vdec_msg_list {
-	struct list_head	list;
-	struct vdec_msg		vdec_msg;
-};
-
-struct vdec_mem_info {
-	u32			buf_type;
-	u32			id;
-	unsigned long		phys_addr;
-	unsigned long		len;
-	struct file		*file;
-};
-
-struct vdec_mem_list {
-	struct list_head	list;
-	struct vdec_mem_info	mem;
-};
-
-struct vdec_data {
-	struct dal_client	*vdec_handle;
-	struct list_head	vdec_msg_list_head;
-	struct list_head	vdec_msg_list_free;
-	wait_queue_head_t	vdec_msg_evt;
-	spinlock_t		vdec_list_lock;
-	struct list_head	vdec_mem_list_head;
-	spinlock_t		vdec_mem_list_lock;
-	int			mem_initialized;
-	int			running;
-	int			close_decode;
-};
-
-static struct class *driver_class;
-static dev_t vdec_device_no;
-static struct cdev vdec_cdev;
-static int ref_cnt;
-static DEFINE_MUTEX(vdec_ref_lock);
-
-static inline int vdec_check_version(u32 client, u32 server)
-{
-	int ret = -EINVAL;
-	if ((VDEC_GET_MAJOR_VERSION(client) == VDEC_GET_MAJOR_VERSION(server))
-	    && (VDEC_GET_MINOR_VERSION(client) <=
-		VDEC_GET_MINOR_VERSION(server)))
-		ret = 0;
-	return ret;
-}
-
-static int vdec_get_msg(struct vdec_data *vd, void *msg)
-{
-	struct vdec_msg_list *l;
-	unsigned long flags;
-	int ret = 0;
-
-	if (!vd->running)
-		return -EPERM;
-
-	spin_lock_irqsave(&vd->vdec_list_lock, flags);
-	list_for_each_entry_reverse(l, &vd->vdec_msg_list_head, list) {
-		if (copy_to_user(msg, &l->vdec_msg, sizeof(struct vdec_msg)))
-			pr_err("vdec_get_msg failed to copy_to_user!\n");
-		if (l->vdec_msg.id == VDEC_MSG_REUSEINPUTBUFFER)
-			TRACE("reuse_input_buffer %d\n", l->vdec_msg.buf_id);
-		else if (l->vdec_msg.id == VDEC_MSG_FRAMEDONE)
-			TRACE("frame_done (stat=%d)\n",
-			      l->vdec_msg.vfr_info.status);
-		else
-			TRACE("unknown msg (msgid=%d)\n", l->vdec_msg.id);
-		list_del(&l->list);
-		list_add(&l->list, &vd->vdec_msg_list_free);
-		ret = 1;
-		break;
-	}
-	spin_unlock_irqrestore(&vd->vdec_list_lock, flags);
-
-	if (vd->close_decode)
-		ret = 1;
-
-	return ret;
-}
-
-static void vdec_put_msg(struct vdec_data *vd, struct vdec_msg *msg)
-{
-	struct vdec_msg_list *l;
-	unsigned long flags;
-	int found = 0;
-
-	spin_lock_irqsave(&vd->vdec_list_lock, flags);
-	list_for_each_entry(l, &vd->vdec_msg_list_free, list) {
-		memcpy(&l->vdec_msg, msg, sizeof(struct vdec_msg));
-		list_del(&l->list);
-		list_add(&l->list, &vd->vdec_msg_list_head);
-		found = 1;
-		break;
-	}
-	spin_unlock_irqrestore(&vd->vdec_list_lock, flags);
-
-	if (found)
-		wake_up(&vd->vdec_msg_evt);
-	else
-		pr_err("vdec_put_msg can't find free list!\n");
-}
-
-static struct vdec_mem_list *vdec_get_mem_from_list(struct vdec_data *vd,
-						    u32 pmem_id, u32 buf_type)
-{
-	struct vdec_mem_list *l;
-	unsigned long flags;
-	int found = 0;
-
-	spin_lock_irqsave(&vd->vdec_mem_list_lock, flags);
-	list_for_each_entry(l, &vd->vdec_mem_list_head, list) {
-		if (l->mem.buf_type == buf_type && l->mem.id == pmem_id) {
-			found = 1;
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&vd->vdec_mem_list_lock, flags);
-
-	if (found)
-		return l;
-	else
-		return NULL;
-
-}
-
-static int vdec_initialize(struct vdec_data *vd, void *argp)
-{
-	struct vdec_config_sps vdec_cfg_sps;
-	struct vdec_init_cfg vi_cfg;
-	struct vdec_buf_req vdec_buf_req;
-	struct u8 *header;
-	int ret = 0;
-
-	ret = copy_from_user(&vdec_cfg_sps,
-			     &((struct vdec_init *)argp)->sps_cfg,
-			     sizeof(vdec_cfg_sps));
-
-	if (ret) {
-		pr_err("%s: copy_from_user failed\n", __func__);
-		return ret;
-	}
-
-	vi_cfg.decode_done_evt = VDEC_ASYNCMSG_DECODE_DONE;
-	vi_cfg.reuse_frame_evt = VDEC_ASYNCMSG_REUSE_FRAME;
-	memcpy(&vi_cfg.cfg, &vdec_cfg_sps.cfg, sizeof(struct vdec_config));
-
-	header = kmalloc(vdec_cfg_sps.seq.len, GFP_KERNEL);
-	if (!header) {
-		pr_err("%s: kmalloc failed\n", __func__);
-		return -ENOMEM;
-	}
-
-	ret = copy_from_user(header,
-			     ((struct vdec_init *)argp)->sps_cfg.seq.header,
-			     vdec_cfg_sps.seq.len);
-
-	if (ret) {
-		pr_err("%s: copy_from_user failed\n", __func__);
-		kfree(header);
-		return ret;
-	}
-
-	TRACE("vi_cfg: handle=%p fourcc=0x%x w=%d h=%d order=%d notify_en=%d "
-	      "vc1_rb=%d h264_sd=%d h264_nls=%d pp_flag=%d fruc_en=%d\n",
-	      vd->vdec_handle, vi_cfg.cfg.fourcc, vi_cfg.cfg.width,
-	      vi_cfg.cfg.height, vi_cfg.cfg.order, vi_cfg.cfg.notify_enable,
-	      vi_cfg.cfg.vc1_rowbase, vi_cfg.cfg.h264_startcode_detect,
-	      vi_cfg.cfg.h264_nal_len_size, vi_cfg.cfg.postproc_flag,
-	      vi_cfg.cfg.fruc_enable);
-	ret = dal_call_f13(vd->vdec_handle, VDEC_DALRPC_INITIALIZE,
-			   &vi_cfg, sizeof(vi_cfg),
-			   header, vdec_cfg_sps.seq.len,
-			   &vdec_buf_req, sizeof(vdec_buf_req));
-
-	kfree(header);
-
-	if (ret)
-		pr_err("%s: remote function failed (%d)\n", __func__, ret);
-	else
-		ret = copy_to_user(((struct vdec_init *)argp)->buf_req,
-				   &vdec_buf_req, sizeof(vdec_buf_req));
-
-	vd->close_decode = 0;
-	return ret;
-}
-
-static int vdec_setbuffers(struct vdec_data *vd, void *argp)
-{
-	struct vdec_buffer vmem;
-	struct vdec_mem_list *l;
-	unsigned long vstart;
-	unsigned long flags;
-	struct {
-		uint32_t size;
-		struct vdec_buf_info buf;
-	} rpc;
-	uint32_t res;
-
-	int ret = 0;
-
-	vd->mem_initialized = 0;
-
-	ret = copy_from_user(&vmem, argp, sizeof(vmem));
-	if (ret) {
-		pr_err("%s: copy_from_user failed\n", __func__);
-		return ret;
-	}
-
-	l = kzalloc(sizeof(struct vdec_mem_list), GFP_KERNEL);
-	if (!l) {
-		pr_err("%s: kzalloc failed!\n", __func__);
-		return -ENOMEM;
-	}
-
-	l->mem.id = vmem.pmem_id;
-	l->mem.buf_type = vmem.buf.buf_type;
-
-	ret = get_pmem_file(l->mem.id, &l->mem.phys_addr, &vstart,
-			    &l->mem.len, &l->mem.file);
-	if (ret) {
-		pr_err("%s: get_pmem_fd failed\n", __func__);
-		goto err_get_pmem_file;
-	}
-
-	TRACE("pmem_id=%d (phys=0x%08lx len=0x%lx) buftype=%d num_buf=%d "
-	      "islast=%d src_id=%d offset=0x%08x size=0x%x\n",
-	      vmem.pmem_id, l->mem.phys_addr, l->mem.len,
-	      vmem.buf.buf_type, vmem.buf.num_buf, vmem.buf.islast,
-	      vmem.buf.region.src_id, vmem.buf.region.offset,
-	      vmem.buf.region.size);
-
-	/* input buffers */
-	if ((vmem.buf.region.offset + vmem.buf.region.size) > l->mem.len) {
-		pr_err("%s: invalid input buffer offset!\n", __func__);
-		ret = -EINVAL;
-		goto err_bad_offset;
-
-	}
-	vmem.buf.region.offset += l->mem.phys_addr;
-
-	rpc.size = sizeof(vmem.buf);
-	memcpy(&rpc.buf, &vmem.buf, sizeof(struct vdec_buf_info));
-
-
-	ret = dal_call(vd->vdec_handle, VDEC_DALRPC_SETBUFFERS, 5,
-		       &rpc, sizeof(rpc), &res, sizeof(res));
-
-	if (ret < 4) {
-		pr_err("%s: remote function failed (%d)\n", __func__, ret);
-		ret = -EIO;
-		goto err_dal_call;
-	}
-
-	spin_lock_irqsave(&vd->vdec_mem_list_lock, flags);
-	list_add(&l->list, &vd->vdec_mem_list_head);
-	spin_unlock_irqrestore(&vd->vdec_mem_list_lock, flags);
-
-	vd->mem_initialized = 1;
-	return ret;
-
-err_dal_call:
-err_bad_offset:
-	put_pmem_file(l->mem.file);
-err_get_pmem_file:
-	kfree(l);
-	return ret;
-}
-
-static int vdec_queue(struct vdec_data *vd, void *argp)
-{
-	struct {
-		uint32_t size;
-		struct vdec_input_buf_info buf_info;
-		uint32_t osize;
-	} rpc;
-	struct vdec_mem_list *l;
-	struct {
-		uint32_t result;
-		uint32_t size;
-		struct vdec_queue_status status;
-	} rpc_res;
-
-	u32 pmem_id;
-	int ret = 0;
-
-	if (!vd->mem_initialized) {
-		pr_err("%s: memory is not being initialized!\n", __func__);
-		return -EPERM;
-	}
-
-	ret = copy_from_user(&rpc.buf_info,
-			     &((struct vdec_input_buf *)argp)->buffer,
-			     sizeof(rpc.buf_info));
-	if (ret) {
-		pr_err("%s: copy_from_user failed\n", __func__);
-		return ret;
-	}
-
-	ret = copy_from_user(&pmem_id,
-			     &((struct vdec_input_buf *)argp)->pmem_id,
-			     sizeof(u32));
-	if (ret) {
-		pr_err("%s: copy_from_user failed\n", __func__);
-		return ret;
-	}
-
-	l = vdec_get_mem_from_list(vd, pmem_id, VDEC_BUFFER_TYPE_INPUT);
-
-	if (NULL == l) {
-		pr_err("%s: not able to find the buffer from list\n", __func__);
-		return -EPERM;
-	}
-
-	if ((rpc.buf_info.size + rpc.buf_info.offset) >= l->mem.len) {
-		pr_err("%s: invalid queue buffer offset!\n", __func__);
-		return -EINVAL;
-	}
-
-	rpc.buf_info.offset += l->mem.phys_addr;
-	rpc.size = sizeof(struct vdec_input_buf_info);
-	rpc.osize = sizeof(struct vdec_queue_status);
-
-	ret = dal_call(vd->vdec_handle, VDEC_DALRPC_QUEUE, 8,
-		       &rpc, sizeof(rpc), &rpc_res, sizeof(rpc_res));
-	if (ret < 4) {
-		pr_err("%s: remote function failed (%d)\n", __func__, ret);
-		ret = -EIO;
-	}
-	return ret;
-}
-
-static int vdec_reuse_framebuffer(struct vdec_data *vd, void *argp)
-{
-	u32 buf_id;
-	int ret = 0;
-
-	ret = copy_from_user(&buf_id, argp, sizeof(buf_id));
-	if (ret) {
-		pr_err("%s: copy_from_user failed\n", __func__);
-		return ret;
-	}
-
-	ret = dal_call_f0(vd->vdec_handle, VDEC_DALRPC_REUSEFRAMEBUFFER,
-			  buf_id);
-	if (ret)
-		pr_err("%s: remote function failed (%d)\n", __func__, ret);
-
-	return ret;
-}
-
-static int vdec_flush(struct vdec_data *vd, void *argp)
-{
-	u32 flush_type;
-	int ret = 0;
-
-	ret = copy_from_user(&flush_type, argp, sizeof(flush_type));
-	if (ret) {
-		pr_err("%s: copy_from_user failed\n", __func__);
-		return ret;
-	}
-
-	TRACE("flush_type=%d\n", flush_type);
-	ret = dal_call_f0(vd->vdec_handle, VDEC_DALRPC_FLUSH, flush_type);
-	if (ret) {
-		pr_err("%s: remote function failed (%d)\n", __func__, ret);
-		return ret;
-	}
-
-	return ret;
-}
-
-static int vdec_close(struct vdec_data *vd, void *argp)
-{
-	struct vdec_mem_list *l;
-	int ret = 0;
-
-	pr_info("q6vdec_close()\n");
-	vd->close_decode = 1;
-	wake_up(&vd->vdec_msg_evt);
-	ret = dal_call_f0(vd->vdec_handle, DAL_OP_CLOSE, 0);
-	if (ret)
-		pr_err("%s: failed to close daldevice (%d)\n", __func__, ret);
-
-	if (vd->mem_initialized) {
-		list_for_each_entry(l, &vd->vdec_mem_list_head, list)
-		    put_pmem_file(l->mem.file);
-	}
-
-	return ret;
-}
-static int vdec_getdecattributes(struct vdec_data *vd, void *argp)
-{
-	struct {
-		uint32_t status;
-		uint32_t size;
-		struct vdec_dec_attributes dec_attr;
-	} rpc;
-	uint32_t inp;
-	int ret = 0;
-	inp = sizeof(struct vdec_dec_attributes);
-
-	ret = dal_call(vd->vdec_handle, VDEC_DALRPC_GETDECATTRIBUTES, 9,
-		       &inp, sizeof(inp), &rpc, sizeof(rpc));
-	if (ret < 4 || rpc.size != sizeof(struct vdec_dec_attributes)) {
-		pr_err("%s: remote function failed (%d)\n", __func__, ret);
-		ret = -EIO;
-	} else
-		ret =
-		    copy_to_user(((struct vdec_dec_attributes *)argp),
-				 &rpc.dec_attr, sizeof(rpc.dec_attr));
-	return ret;
-}
-
-static int vdec_freebuffers(struct vdec_data *vd, void *argp)
-{
-	struct vdec_buffer vmem;
-	struct vdec_mem_list *l;
-	struct {
-		uint32_t size;
-		struct vdec_buf_info buf;
-	} rpc;
-	uint32_t res;
-
-	int ret = 0;
-
-	if (!vd->mem_initialized) {
-		pr_err("%s: memory is not being initialized!\n", __func__);
-		return -EPERM;
-	}
-
-	ret = copy_from_user(&vmem, argp, sizeof(vmem));
-	if (ret) {
-		pr_err("%s: copy_from_user failed\n", __func__);
-		return ret;
-	}
-
-	l = vdec_get_mem_from_list(vd, vmem.pmem_id, vmem.buf.buf_type);
-
-	if (NULL == l) {
-		pr_err("%s: not able to find the buffer from list\n", __func__);
-		return -EPERM;
-	}
-
-	/* input buffers */
-	if ((vmem.buf.region.offset + vmem.buf.region.size) > l->mem.len) {
-		pr_err("%s: invalid input buffer offset!\n", __func__);
-		return -EINVAL;
-
-	}
-	vmem.buf.region.offset += l->mem.phys_addr;
-
-	rpc.size = sizeof(vmem.buf);
-	memcpy(&rpc.buf, &vmem.buf, sizeof(struct vdec_buf_info));
-
-	ret = dal_call(vd->vdec_handle, VDEC_DALRPC_FREEBUFFERS, 5,
-		       &rpc, sizeof(rpc), &res, sizeof(res));
-	if (ret < 4) {
-		pr_err("%s: remote function failed (%d)\n", __func__, ret);
-	}
-
-	return ret;
-}
-static long vdec_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct vdec_data *vd = file->private_data;
-	void __user *argp = (void __user *)arg;
-	int ret = 0;
-
-	if (!vd->running)
-		return -EPERM;
-
-	switch (cmd) {
-	case VDEC_IOCTL_INITIALIZE:
-		ret = vdec_initialize(vd, argp);
-		break;
-
-	case VDEC_IOCTL_SETBUFFERS:
-		ret = vdec_setbuffers(vd, argp);
-		break;
-
-	case VDEC_IOCTL_QUEUE:
-		TRACE("VDEC_IOCTL_QUEUE (pid=%d tid=%d)\n",
-		      current->group_leader->pid, current->pid);
-		ret = vdec_queue(vd, argp);
-		break;
-
-	case VDEC_IOCTL_REUSEFRAMEBUFFER:
-		TRACE("VDEC_IOCTL_REUSEFRAMEBUFFER (pid=%d tid=%d)\n",
-		      current->group_leader->pid, current->pid);
-		ret = vdec_reuse_framebuffer(vd, argp);
-		break;
-
-	case VDEC_IOCTL_FLUSH:
-		ret = vdec_flush(vd, argp);
-		break;
-
-	case VDEC_IOCTL_EOS:
-		TRACE("VDEC_IOCTL_EOS (pid=%d tid=%d)\n",
-		      current->group_leader->pid, current->pid);
-		ret = dal_call_f0(vd->vdec_handle, VDEC_DALRPC_SIGEOFSTREAM, 0);
-		if (ret)
-			pr_err("%s: remote function failed (%d)\n",
-			       __func__, ret);
-		break;
-
-	case VDEC_IOCTL_GETMSG:
-		TRACE("VDEC_IOCTL_GETMSG (pid=%d tid=%d)\n",
-		      current->group_leader->pid, current->pid);
-		wait_event_interruptible(vd->vdec_msg_evt,
-					 vdec_get_msg(vd, argp));
-
-		if (vd->close_decode)
-			ret = -EINTR;
-		break;
-
-	case VDEC_IOCTL_CLOSE:
-		ret = vdec_close(vd, argp);
-		break;
-
-	case VDEC_IOCTL_GETDECATTRIBUTES:
-		TRACE("VDEC_IOCTL_GETDECATTRIBUTES (pid=%d tid=%d)\n",
-		      current->group_leader->pid, current->pid);
-		ret = vdec_getdecattributes(vd, argp);
-
-		if (ret)
-			pr_err("%s: remote function failed (%d)\n",
-			       __func__, ret);
-		break;
-
-	case VDEC_IOCTL_FREEBUFFERS:
-		TRACE("VDEC_IOCTL_FREEBUFFERS (pid=%d tid=%d)\n",
-		      current->group_leader->pid, current->pid);
-		ret = vdec_freebuffers(vd, argp);
-
-		if (ret)
-			pr_err("%s: remote function failed (%d)\n",
-			       __func__, ret);
-		break;
-
-	default:
-		pr_err("%s: invalid ioctl!\n", __func__);
-		ret = -EINVAL;
-		break;
-	}
-
-	TRACE("ioctl done (pid=%d tid=%d)\n",
-	      current->group_leader->pid, current->pid);
-
-	return ret;
-}
-
-static void vdec_dcdone_handler(struct vdec_data *vd, void *frame,
-				uint32_t frame_size)
-{
-	struct vdec_msg msg;
-	struct vdec_mem_list *l;
-	unsigned long flags;
-	int found = 0;
-
-	if (frame_size != sizeof(struct vdec_frame_info)) {
-		pr_warning("%s: msg size mismatch %d != %d\n", __func__,
-			   frame_size, sizeof(struct vdec_frame_info));
-		return;
-	}
-
-	memcpy(&msg.vfr_info, (struct vdec_frame_info *)frame,
-	       sizeof(struct vdec_frame_info));
-
-	if (msg.vfr_info.status == VDEC_FRAME_DECODE_OK) {
-		spin_lock_irqsave(&vd->vdec_mem_list_lock, flags);
-		list_for_each_entry(l, &vd->vdec_mem_list_head, list) {
-			if ((l->mem.buf_type == VDEC_BUFFER_TYPE_OUTPUT) &&
-			    (msg.vfr_info.offset >= l->mem.phys_addr) &&
-			    (msg.vfr_info.offset <
-			     (l->mem.phys_addr + l->mem.len))) {
-				found = 1;
-				msg.vfr_info.offset -= l->mem.phys_addr;
-				msg.vfr_info.data2 = l->mem.id;
-				break;
-			}
-		}
-		spin_unlock_irqrestore(&vd->vdec_mem_list_lock, flags);
-	}
-
-	if (found || (msg.vfr_info.status != VDEC_FRAME_DECODE_OK)) {
-		msg.id = VDEC_MSG_FRAMEDONE;
-		vdec_put_msg(vd, &msg);
-	} else {
-		pr_err("%s: invalid phys addr = 0x%x\n",
-		       __func__, msg.vfr_info.offset);
-	}
-
-}
-
-static void vdec_reuseibuf_handler(struct vdec_data *vd, void *bufstat,
-				   uint32_t bufstat_size)
-{
-	struct vdec_buffer_status *vdec_bufstat;
-	struct vdec_msg msg;
-
-	/* TODO: how do we signal the client? If they are waiting on a
-	 * message in an ioctl, they may block forever */
-	if (bufstat_size != sizeof(struct vdec_buffer_status)) {
-		pr_warning("%s: msg size mismatch %d != %d\n", __func__,
-			   bufstat_size, sizeof(struct vdec_buffer_status));
-		return;
-	}
-	vdec_bufstat = (struct vdec_buffer_status *)bufstat;
-	msg.id = VDEC_MSG_REUSEINPUTBUFFER;
-	msg.buf_id = vdec_bufstat->data;
-	vdec_put_msg(vd, &msg);
-}
-
-static void callback(void *data, int len, void *cookie)
-{
-	struct vdec_data *vd = (struct vdec_data *)cookie;
-	uint32_t *tmp = (uint32_t *) data;
-
-	if (!vd->mem_initialized) {
-		pr_err("%s:memory not initialize but callback called!\n",
-		       __func__);
-		return;
-	}
-
-	TRACE("vdec_async: tmp=0x%08x 0x%08x 0x%08x\n", tmp[0], tmp[1], tmp[2]);
-	switch (tmp[0]) {
-	case VDEC_ASYNCMSG_DECODE_DONE:
-		vdec_dcdone_handler(vd, &tmp[3], tmp[2]);
-		break;
-	case VDEC_ASYNCMSG_REUSE_FRAME:
-		vdec_reuseibuf_handler(vd, &tmp[3], tmp[2]);
-		break;
-	default:
-		pr_err("%s: Unknown async message from DSP id=0x%08x sz=%u\n",
-		       __func__, tmp[0], tmp[2]);
-	}
-}
-static int vdec_open(struct inode *inode, struct file *file)
-{
-	int ret;
-	int i;
-	struct vdec_msg_list *l;
-	struct vdec_data *vd;
-
-	pr_info("q6vdec_open()\n");
-	mutex_lock(&vdec_ref_lock);
-	if (ref_cnt > 0) {
-		pr_err("%s: Instance alredy running\n", __func__);
-		mutex_unlock(&vdec_ref_lock);
-		return -ENOMEM;
-	}
-	ref_cnt++;
-	mutex_unlock(&vdec_ref_lock);
-	vd = kmalloc(sizeof(struct vdec_data), GFP_KERNEL);
-	if (!vd) {
-		pr_err("%s: kmalloc failed\n", __func__);
-		ret = -ENOMEM;
-		goto vdec_open_err_handle_vd;
-	}
-	file->private_data = vd;
-
-	vd->mem_initialized = 0;
-	INIT_LIST_HEAD(&vd->vdec_msg_list_head);
-	INIT_LIST_HEAD(&vd->vdec_msg_list_free);
-	INIT_LIST_HEAD(&vd->vdec_mem_list_head);
-	init_waitqueue_head(&vd->vdec_msg_evt);
-
-	spin_lock_init(&vd->vdec_list_lock);
-	spin_lock_init(&vd->vdec_mem_list_lock);
-	for (i = 0; i < VDEC_MSG_MAX; i++) {
-		l = kzalloc(sizeof(struct vdec_msg_list), GFP_KERNEL);
-		if (!l) {
-			pr_err("%s: kzalloc failed!\n", __func__);
-			ret = -ENOMEM;
-			goto vdec_open_err_handle_list;
-		}
-		list_add(&l->list, &vd->vdec_msg_list_free);
-	}
-
-	vd->vdec_handle = dal_attach(DALDEVICEID_VDEC_DEVICE,
-				     DALDEVICEID_VDEC_PORTNAME,
-				     callback, vd);
-
-	if (!vd->vdec_handle) {
-		pr_err("%s: failed to attach \n", __func__);
-		ret = -EIO;
-		goto vdec_open_err_handle_list;
-	}
-
-	vd->running = 1;
-	prevent_sleep();
-	return 0;
-
-vdec_open_err_handle_list:
-	{
-		struct vdec_msg_list *l, *n;
-		list_for_each_entry_safe(l, n, &vd->vdec_msg_list_free, list) {
-			list_del(&l->list);
-			kfree(l);
-		}
-	}
-vdec_open_err_handle_vd:
-	kfree(vd);
-	return ret;
-}
-
-static int vdec_release(struct inode *inode, struct file *file)
-{
-	int ret;
-	struct vdec_msg_list *l, *n;
-	struct vdec_mem_list *m, *k;
-	struct vdec_data *vd = file->private_data;
-
-	vd->running = 0;
-	wake_up_all(&vd->vdec_msg_evt);
-
-	if (!vd->close_decode)
-		vdec_close(vd, NULL);
-
-	ret = dal_detach(vd->vdec_handle);
-	if (ret)
-		printk(KERN_INFO "%s: failed to detach (%d)\n", __func__, ret);
-
-	list_for_each_entry_safe(l, n, &vd->vdec_msg_list_free, list) {
-		list_del(&l->list);
-		kfree(l);
-	}
-
-	list_for_each_entry_safe(l, n, &vd->vdec_msg_list_head, list) {
-		list_del(&l->list);
-		kfree(l);
-	}
-
-	list_for_each_entry_safe(m, k, &vd->vdec_mem_list_head, list) {
-		list_del(&m->list);
-		kfree(m);
-	}
-	mutex_lock(&vdec_ref_lock);
-	BUG_ON(ref_cnt <= 0);
-	ref_cnt--;
-	mutex_unlock(&vdec_ref_lock);
-	kfree(vd);
-	allow_sleep();
-	return 0;
-}
-
-static const struct file_operations vdec_fops = {
-	.owner = THIS_MODULE,
-	.open = vdec_open,
-	.release = vdec_release,
-	.unlocked_ioctl = vdec_ioctl,
-};
-
-static int __init vdec_init(void)
-{
-	struct device *class_dev;
-	int rc = 0;
-
-	wake_lock_init(&idlelock, WAKE_LOCK_IDLE, "vdec_idle");
-	wake_lock_init(&wakelock, WAKE_LOCK_SUSPEND, "vdec_suspend");
-
-	rc = alloc_chrdev_region(&vdec_device_no, 0, 1, "vdec");
-	if (rc < 0) {
-		pr_err("%s: alloc_chrdev_region failed %d\n", __func__, rc);
-		return rc;
-	}
-
-	driver_class = class_create(THIS_MODULE, "vdec");
-	if (IS_ERR(driver_class)) {
-		rc = -ENOMEM;
-		pr_err("%s: class_create failed %d\n", __func__, rc);
-		goto vdec_init_err_unregister_chrdev_region;
-	}
-	class_dev = device_create(driver_class, NULL,
-				  vdec_device_no, NULL, "vdec");
-	if (!class_dev) {
-		pr_err("%s: class_device_create failed %d\n", __func__, rc);
-		rc = -ENOMEM;
-		goto vdec_init_err_class_destroy;
-	}
-
-	cdev_init(&vdec_cdev, &vdec_fops);
-	vdec_cdev.owner = THIS_MODULE;
-	rc = cdev_add(&vdec_cdev, MKDEV(MAJOR(vdec_device_no), 0), 1);
-
-	if (rc < 0) {
-		pr_err("%s: cdev_add failed %d\n", __func__, rc);
-		goto vdec_init_err_class_device_destroy;
-	}
-
-	return 0;
-
-vdec_init_err_class_device_destroy:
-	device_destroy(driver_class, vdec_device_no);
-vdec_init_err_class_destroy:
-	class_destroy(driver_class);
-vdec_init_err_unregister_chrdev_region:
-	unregister_chrdev_region(vdec_device_no, 1);
-	return rc;
-}
-
-static void __exit vdec_exit(void)
-{
-	device_destroy(driver_class, vdec_device_no);
-	class_destroy(driver_class);
-	unregister_chrdev_region(vdec_device_no, 1);
-}
-
-MODULE_DESCRIPTION("video decoder driver for QSD platform");
-MODULE_VERSION("2.00");
-
-module_init(vdec_init);
-module_exit(vdec_exit);
diff --git a/arch/arm/mach-msm/qdsp6/msm_q6venc.c b/arch/arm/mach-msm/qdsp6/msm_q6venc.c
deleted file mode 100644
index 4f2db90..0000000
--- a/arch/arm/mach-msm/qdsp6/msm_q6venc.c
+++ /dev/null
@@ -1,637 +0,0 @@
-/*
- * Copyright (c) 2008-2009, Code Aurora Forum. All rights reserved.
- * Copyright (c) 2009, Google Inc.
- *
- * Original authors: Code Aurora Forum
- * Major cleanup: Dima Zavin <dima@android.com>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Code Aurora Forum nor
- *       the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-//#define DEBUG 1
-
-#include <linux/device.h>
-#include <linux/file.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/list.h>
-#include <linux/miscdevice.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/sched.h>
-#include <linux/spinlock.h>
-#include <linux/uaccess.h>
-#include <linux/android_pmem.h>
-#include <linux/msm_q6venc.h>
-
-#include <asm/cacheflush.h>
-
-#include "dal.h"
-
-#define DALDEVICEID_VENC_DEVICE		0x0200002D
-#define DALDEVICEID_VENC_PORTNAME	"DSP_DAL_AQ_VID"
-
-enum {
-	VENC_DALRPC_INITIALIZE = DAL_OP_FIRST_DEVICE_API,
-	VENC_DALRPC_SET_CB_CHANNEL,
-	VENC_DALRPC_ENCODE,
-	VENC_DALRPC_INTRA_REFRESH,
-	VENC_DALRPC_RC_CONFIG,
-	VENC_DALRPC_ENCODE_CONFIG,
-	VENC_DALRPC_STOP,
-};
-
-struct callback_event_data {
-	u32				data_notify_event;
-	u32				enc_cb_handle;
-	u32				empty_input_buffer_event;
-};
-
-struct buf_info {
-	unsigned long			paddr;
-	unsigned long			vaddr;
-	struct file			*file;
-	struct venc_buf			venc_buf;
-};
-
-#define VENC_MAX_BUF_NUM		15
-#define RLC_MAX_BUF_NUM			2
-#define BITS_PER_PIXEL			12
-#define PIXELS_PER_MACROBLOCK		16
-
-#define VENC_CB_EVENT_ID		0xd0e4c0de
-
-struct q6venc_dev {
-	struct dal_client		*venc;
-	struct callback_event_data	cb_ev_data;
-	bool				stop_encode;
-	struct buf_info			rlc_bufs[RLC_MAX_BUF_NUM];
-	unsigned int			rlc_buf_index;
-	unsigned int			rlc_buf_len;
-	unsigned int                    enc_buf_size;
-	struct buf_info			enc_bufs[VENC_MAX_BUF_NUM];
-	unsigned int			num_enc_bufs;
-	wait_queue_head_t		encode_wq;
-
-	/* protects all state in q6venc_dev except for cb stuff below */
-	struct mutex			lock;
-
-	/* protects encode_done and done_frame inside the callback */
-	spinlock_t			done_lock;
-	struct frame_type		done_frame;
-	bool				encode_done;
-};
-
-static int get_buf_info(struct buf_info *buf_info, struct venc_buf *venc_buf)
-{
-	unsigned long len;
-	unsigned long vaddr;
-	unsigned long paddr;
-	struct file *file;
-	int ret;
-
-	ret = get_pmem_file(venc_buf->fd, &paddr, &vaddr, &len, &file);
-	if (ret) {
-		pr_err("%s: get_pmem_file failed for fd=%d offset=%ld\n",
-		       __func__, venc_buf->fd, venc_buf->offset);
-		return ret;
-	} else if (venc_buf->offset >= len) {
-		/* XXX: we really should check venc_buf->size too, but userspace
-		 * sometimes leaves this uninitialized (in encode ioctl) */
-		pr_err("%s: invalid offset/size (%ld + %ld > %ld) for fd=%d\n",
-		       __func__, venc_buf->offset, venc_buf->size, len,
-		       venc_buf->fd);
-		put_pmem_file(file);
-		return -EINVAL;
-	}
-
-	buf_info->file = file;
-	buf_info->paddr = paddr + venc_buf->offset;
-	buf_info->vaddr = vaddr;
-	memcpy(&buf_info->venc_buf, venc_buf, sizeof(struct venc_buf));
-	return 0;
-}
-
-static void put_buf_info(struct buf_info *buf_info)
-{
-	if (!buf_info || !buf_info->file)
-		return;
-	put_pmem_file(buf_info->file);
-	buf_info->file = NULL;
-}
-
-static void q6venc_callback(void *context, void *data, uint32_t len)
-{
-	struct q6venc_dev *q6venc = context;
-	struct q6_frame_type *q6frame = data;
-	struct buf_info *rlc_buf;
-	unsigned long flags;
-	int i;
-
-	pr_debug("%s \n", __func__);
-
-	spin_lock_irqsave(&q6venc->done_lock, flags);
-	q6venc->encode_done = true;
-	for (i = 0; i < RLC_MAX_BUF_NUM; ++i) {
-		rlc_buf = &q6venc->rlc_bufs[i];
-		if (rlc_buf->paddr == q6frame->frame_addr)
-			goto frame_found;
-	}
-
-	pr_err("%s: got incorrect phy address 0x%08x from q6 \n", __func__,
-	       q6frame->frame_addr);
-	q6venc->done_frame.q6_frame_type.frame_len = 0;
-	wake_up_interruptible(&q6venc->encode_wq);
-	goto done;
-
-frame_found:
-	memcpy(&q6venc->done_frame.frame_addr, &rlc_buf->venc_buf,
-	       sizeof(struct venc_buf));
-	memcpy(&q6venc->done_frame.q6_frame_type, q6frame,
-	       sizeof(struct q6_frame_type));
-
-	dmac_inv_range((const void *)q6venc->rlc_bufs[i].vaddr,
-		       (const void *)(q6venc->rlc_bufs[i].vaddr +
-				      q6venc->rlc_buf_len));
-
-	wake_up_interruptible(&q6venc->encode_wq);
-
-done:
-	spin_unlock_irqrestore(&q6venc->done_lock, flags);
-}
-
-static void callback(void *data, int len, void *cookie)
-{
-	struct q6venc_dev *ve = (struct q6venc_dev *)cookie;
-	uint32_t *tmp = (uint32_t *) data;
-
-	if (tmp[0] == VENC_CB_EVENT_ID)
-		q6venc_callback(ve, &tmp[3], tmp[2]);
-	else
-		pr_err("%s: Unknown callback received for %p\n", __func__, ve);
-}
-
-static int q6venc_open(struct inode *inode, struct file *file)
-{
-	struct q6venc_dev *q6venc;
-	int err;
-
-	q6venc = kzalloc(sizeof(struct q6venc_dev), GFP_KERNEL);
-	if (!q6venc) {
-		pr_err("%s: Unable to allocate memory for q6venc_dev\n",
-		       __func__);
-		return -ENOMEM;
-	}
-
-	file->private_data = q6venc;
-
-	init_waitqueue_head(&q6venc->encode_wq);
-	mutex_init(&q6venc->lock);
-	spin_lock_init(&q6venc->done_lock);
-
-	q6venc->venc = dal_attach(DALDEVICEID_VENC_DEVICE,
-				  DALDEVICEID_VENC_PORTNAME,
-				  callback, q6venc);
-	if (!q6venc->venc) {
-		pr_err("%s: dal_attach failed\n", __func__);
-		err = -EIO;
-		goto err_dal_attach;
-	}
-
-	q6venc->cb_ev_data.enc_cb_handle = VENC_CB_EVENT_ID;
-	err = dal_call_f5(q6venc->venc, VENC_DALRPC_SET_CB_CHANNEL,
-			  &q6venc->cb_ev_data, sizeof(q6venc->cb_ev_data));
-	if (err) {
-		pr_err("%s: set_cb_channgel failed\n", __func__);
-		goto err_dal_call_set_cb;
-	}
-
-	pr_info("%s() handle=%p enc_cb=%08x\n", __func__, q6venc->venc,
-		q6venc->cb_ev_data.enc_cb_handle);
-
-	return 0;
-
-err_dal_call_set_cb:
-	dal_detach(q6venc->venc);
-err_dal_attach:
-	file->private_data = NULL;
-	mutex_destroy(&q6venc->lock);
-	kfree(q6venc);
-	return err;
-}
-
-static int q6venc_release(struct inode *inode, struct file *file)
-{
-	struct q6venc_dev *q6venc;
-	int id, err;
-
-	q6venc = file->private_data;
-	file->private_data = NULL;
-
-	pr_info("q6venc_close() handle=%p\n", q6venc->venc);
-	for (id = 0; id < q6venc->num_enc_bufs; id++)
-		put_buf_info(&q6venc->enc_bufs[id]);
-	put_buf_info(&q6venc->rlc_bufs[0]);
-	put_buf_info(&q6venc->rlc_bufs[1]);
-
-	if(!q6venc->stop_encode)
-	{
-		err = dal_call_f0(q6venc->venc, VENC_DALRPC_STOP, 1);
-		if (err)
-			pr_err("%s: dal_rpc STOP call failed\n", __func__);
-		q6venc->stop_encode = true;
-	}
-
-	dal_detach(q6venc->venc);
-	mutex_destroy(&q6venc->lock);
-	kfree(q6venc);
-	return 0;
-}
-
-static int q6_config_encode(struct q6venc_dev *q6venc, uint32_t type,
-			    struct init_config *init_config)
-{
-	struct q6_init_config *q6_init_config = &init_config->q6_init_config;
-	int ret;
-	int i;
-
-	mutex_lock(&q6venc->lock);
-
-	if (q6venc->num_enc_bufs != 0) {
-		pr_err("%s: multiple sessions not supported\n", __func__);
-		ret = -EBUSY;
-		goto err_busy;
-	}
-
-	ret = get_buf_info(&q6venc->enc_bufs[0], &init_config->ref_frame_buf1);
-	if (ret) {
-		pr_err("%s: can't get ref_frame_buf1\n", __func__);
-		goto err_get_ref_frame_buf1;
-	}
-
-	ret = get_buf_info(&q6venc->enc_bufs[1], &init_config->ref_frame_buf2);
-	if (ret) {
-		pr_err("%s: can't get ref_frame_buf2\n", __func__);
-		goto err_get_ref_frame_buf2;
-	}
-
-	ret = get_buf_info(&q6venc->rlc_bufs[0], &init_config->rlc_buf1);
-	if (ret) {
-		pr_err("%s: can't get rlc_buf1\n", __func__);
-		goto err_get_rlc_buf1;
-	}
-
-	ret = get_buf_info(&q6venc->rlc_bufs[1], &init_config->rlc_buf2);
-	if (ret) {
-		pr_err("%s: can't get rlc_buf2\n", __func__);
-		goto err_get_rlc_buf2;
-	}
-	q6venc->rlc_buf_len = 2 * q6_init_config->rlc_buf_length;
-	q6venc->num_enc_bufs = 2;
-
-	q6venc->enc_buf_size =
-		(q6_init_config->enc_frame_width_inmb * PIXELS_PER_MACROBLOCK) *
-		(q6_init_config->enc_frame_height_inmb * PIXELS_PER_MACROBLOCK) *
-		BITS_PER_PIXEL / 8;
-
-	q6_init_config->ref_frame_buf1_phy = q6venc->enc_bufs[0].paddr;
-	q6_init_config->ref_frame_buf2_phy = q6venc->enc_bufs[1].paddr;
-	q6_init_config->rlc_buf1_phy = q6venc->rlc_bufs[0].paddr;
-	q6_init_config->rlc_buf2_phy = q6venc->rlc_bufs[1].paddr;
-
-	// The DSP may use the rlc_bufs during initialization,
-	for (i=0; i<RLC_MAX_BUF_NUM; i++)
-	{
-		dmac_inv_range((const void *)q6venc->rlc_bufs[i].vaddr,
-			(const void *)(q6venc->rlc_bufs[i].vaddr +
-				q6venc->rlc_buf_len));
-	}
-
-	ret = dal_call_f5(q6venc->venc, type, q6_init_config,
-			  sizeof(struct q6_init_config));
-	if (ret) {
-		pr_err("%s: rpc failed \n", __func__);
-		goto err_dal_rpc_init;
-	}
-	mutex_unlock(&q6venc->lock);
-	return 0;
-
-err_dal_rpc_init:
-	q6venc->num_enc_bufs = 0;
-	put_pmem_file(q6venc->rlc_bufs[1].file);
-err_get_rlc_buf2:
-	put_pmem_file(q6venc->rlc_bufs[0].file);
-err_get_rlc_buf1:
-	put_pmem_file(q6venc->enc_bufs[1].file);
-err_get_ref_frame_buf2:
-	put_pmem_file(q6venc->enc_bufs[0].file);
-err_get_ref_frame_buf1:
-err_busy:
-	mutex_unlock(&q6venc->lock);
-	return ret;
-}
-
-static int q6_encode(struct q6venc_dev *q6venc, struct encode_param *enc_param)
-{
-	struct q6_encode_param *q6_param = &enc_param->q6_encode_param;
-	struct file *file;
-	struct buf_info *buf;
-	int i;
-	int ret;
-	int rlc_buf_index;
-
-	pr_debug("y_addr fd=%d offset=0x%08lx uv_offset=0x%08lx\n",
-		 enc_param->y_addr.fd, enc_param->y_addr.offset,
-		 enc_param->uv_offset);
-
-	file = fget(enc_param->y_addr.fd);
-	if (!file) {
-		pr_err("%s: invalid encode buffer fd %d\n", __func__,
-		       enc_param->y_addr.fd);
-		return -EBADF;
-	}
-
-	mutex_lock(&q6venc->lock);
-
-	for (i = 0; i < q6venc->num_enc_bufs; i++) {
-		buf = &q6venc->enc_bufs[i];
-		if (buf->file == file
-		    && buf->venc_buf.offset == enc_param->y_addr.offset)
-			break;
-	}
-
-	if (i == q6venc->num_enc_bufs) {
-		if (q6venc->num_enc_bufs == VENC_MAX_BUF_NUM) {
-			pr_err("%s: too many input buffers\n", __func__);
-			ret = -ENOMEM;
-			goto done;
-		}
-
-		buf = &q6venc->enc_bufs[q6venc->num_enc_bufs];
-		ret = get_buf_info(buf, &enc_param->y_addr);
-		if (ret) {
-			pr_err("%s: can't get encode buffer\n", __func__);
-			ret = -EINVAL;
-			goto done;
-		}
-
-		if (!IS_ALIGNED(buf->paddr, PAGE_SIZE)) {
-			pr_err("%s: input buffer not 4k aligned\n", __func__);
-			put_buf_info(buf);
-			ret = -EINVAL;
-			goto done;
-		}
-		q6venc->num_enc_bufs++;
-	}
-
-	/* We must invalidate the buffer that the DSP will write to
-	* to ensure that a dirty cache line doesn't get flushed on
-	* top of the data that the DSP is writing.
-	* Unfortunately, we have to predict which rlc_buf index the
-	* DSP is going to write to.  We assume it will write to buf
-	* 0 the first time we call q6_encode, and alternate afterwards
-	* */
-	rlc_buf_index = q6venc->rlc_buf_index;
-	dmac_inv_range((const void *)q6venc->rlc_bufs[rlc_buf_index].vaddr,
-		       (const void *)(q6venc->rlc_bufs[rlc_buf_index].vaddr +
-				      q6venc->rlc_buf_len));
-	q6venc->rlc_buf_index = (q6venc->rlc_buf_index + 1) % RLC_MAX_BUF_NUM;
-
-	q6_param->luma_addr = buf->paddr;
-	q6_param->chroma_addr = q6_param->luma_addr + enc_param->uv_offset;
-	pr_debug("luma_addr=0x%08x chroma_addr=0x%08x\n", q6_param->luma_addr,
-		 q6_param->chroma_addr);
-
-	/* Ideally, each ioctl that passed in a data buffer would include the size
-	* of the input buffer, so we can properly flush the cache on it.  Since
-	* userspace does not fill in the size fields, we have to assume the size
-	* based on the encoder configuration for now.
-	*/
-	flush_pmem_file(buf->file, enc_param->y_addr.offset,
-		q6venc->enc_buf_size);
-
-	ret = dal_call_f5(q6venc->venc, VENC_DALRPC_ENCODE, q6_param,
-			  sizeof(struct q6_encode_param));
-	if (ret) {
-		pr_err("%s: encode rpc failed\n", __func__);
-		goto done;
-	}
-
-	ret = 0;
-
-done:
-	mutex_unlock(&q6venc->lock);
-	fput(file);
-	return ret;
-}
-
-static int q6venc_ioctl(struct inode *inode, struct file *file,
-			unsigned cmd, unsigned long arg)
-{
-	struct q6venc_dev *q6venc = file->private_data;
-	struct init_config config;
-	struct encode_param encode_param;
-	struct intra_refresh intra_refresh;
-	struct rc_config rc_config;
-	struct frame_type frame_done;
-	unsigned int id;
-	unsigned long flags;
-	int err = 0;
-
-	if (!q6venc) {
-		pr_err("%s: file has no private data\n", __func__);
-		return -ENODEV;
-	}
-
-	pr_debug("%s\n", __func__);
-
-	switch (cmd) {
-	case VENC_IOCTL_INITIALIZE:
-		pr_debug("%s: VENC_IOCTL_INITIALIZE\n", __func__);
-		if (copy_from_user(&config, (void __user *)arg, sizeof(config)))
-			return -EFAULT;
-		err = q6_config_encode(q6venc, VENC_DALRPC_INITIALIZE, &config);
-		break;
-
-	case VENC_IOCTL_ENCODE_CONFIG:
-		pr_debug("%s: VENC_IOCTL_ENCODE_CONFIG\n", __func__);
-		if (copy_from_user(&config, (void __user *)arg, sizeof(config)))
-			return -EFAULT;
-
-		err = q6_config_encode(q6venc, VENC_DALRPC_ENCODE_CONFIG,
-				       &config);
-		break;
-
-	case VENC_IOCTL_ENCODE:
-		pr_debug("%s: VENC_IOCTL_ENCODE\n", __func__);
-		if (copy_from_user(&encode_param, (void __user *)arg,
-				   sizeof(encode_param)))
-			return -EFAULT;
-		err = q6_encode(q6venc, &encode_param);
-		break;
-
-	case VENC_IOCTL_INTRA_REFRESH:
-		pr_debug("%s: VENC_IOCTL_INTRA_REFRESH\n", __func__);
-		if (copy_from_user(&intra_refresh, (void __user *)arg,
-				   sizeof(intra_refresh)))
-			return -EFAULT;
-
-		mutex_lock(&q6venc->lock);
-		err = dal_call_f5(q6venc->venc, VENC_DALRPC_INTRA_REFRESH,
-				  &intra_refresh, sizeof(struct intra_refresh));
-		mutex_unlock(&q6venc->lock);
-		if (err)
-			pr_err("%s: intra_refresh rpc failed\n", __func__);
-		break;
-
-	case VENC_IOCTL_RC_CONFIG:
-		pr_debug("%s: VENC_IOCTL_RC_CONFIG\n", __func__);
-		if (copy_from_user(&rc_config, (void __user *)arg,
-				   sizeof(rc_config)))
-			return -EFAULT;
-
-		mutex_lock(&q6venc->lock);
-		err = dal_call_f5(q6venc->venc, VENC_DALRPC_RC_CONFIG,
-				  &rc_config, sizeof(rc_config));
-		mutex_unlock(&q6venc->lock);
-		if (err)
-			pr_err("%s: dal_call_f5 failed\n", __func__);
-		break;
-
-	case VENC_IOCTL_STOP:
-		pr_debug("%s: VENC_IOCTL_STOP\n", __func__);
-
-		mutex_lock(&q6venc->lock);
-		err = dal_call_f0(q6venc->venc, VENC_DALRPC_STOP, 1);
-		if (err)
-			pr_err("%s: dal_rpc STOP call failed\n", __func__);
-
-		/* XXX: if the dal call fails we still want to continue to free
-		 * the buffers. Is this correct? */
-		for (id = 0; id < q6venc->num_enc_bufs; id++)
-			put_buf_info(&q6venc->enc_bufs[id]);
-		put_buf_info(&q6venc->rlc_bufs[0]);
-		put_buf_info(&q6venc->rlc_bufs[1]);
-		q6venc->num_enc_bufs = 0;
-		q6venc->stop_encode = true;
-		mutex_unlock(&q6venc->lock);
-		break;
-
-	case VENC_IOCTL_WAIT_FOR_ENCODE:
-		pr_debug("%s: waiting for encode done event \n", __func__);
-		err = wait_event_interruptible(q6venc->encode_wq,
-				(q6venc->encode_done || q6venc->stop_encode));
-		if (err < 0) {
-			err = -ERESTARTSYS;
-			break;
-		}
-
-		mutex_lock(&q6venc->lock);
-		if (q6venc->stop_encode) {
-			q6venc->stop_encode = false;
-			mutex_unlock(&q6venc->lock);
-			pr_debug("%s: Received Stop encode event \n", __func__);
-			err = -EINTR;
-			break;
-		}
-
-		spin_lock_irqsave(&q6venc->done_lock, flags);
-		if (!q6venc->encode_done) {
-			spin_unlock_irqrestore(&q6venc->done_lock, flags);
-			pr_err("%s: encoding not stopped, and is not done.\n",
-			       __func__);
-			err = -EIO;
-			break;
-		}
-
-		memcpy(&frame_done, &q6venc->done_frame,
-		       sizeof(struct frame_type));
-		q6venc->encode_done = false;
-		spin_unlock_irqrestore(&q6venc->done_lock, flags);
-		mutex_unlock(&q6venc->lock);
-
-		if (frame_done.q6_frame_type.frame_len == 0) {
-			pr_debug("%s: got incorrect address from q6\n",
-				 __func__);
-			err = -EIO;
-			break;
-		}
-
-		pr_debug("%s: done encoding \n", __func__);
-		if (copy_to_user((void __user *)arg, &frame_done,
-				 sizeof(struct frame_type)))
-			err = -EFAULT;
-		break;
-
-	case VENC_IOCTL_STOP_ENCODE:
-		pr_debug("%s: Stop  encode event   \n", __func__);
-		mutex_lock(&q6venc->lock);
-		q6venc->stop_encode = true;
-		wake_up_interruptible(&q6venc->encode_wq);
-		mutex_unlock(&q6venc->lock);
-		break;
-
-	default:
-		err = -ENOTTY;
-		break;
-	}
-
-	return err;
-}
-
-static const struct file_operations q6venc_dev_fops = {
-	.owner		= THIS_MODULE,
-	.open		= q6venc_open,
-	.release	= q6venc_release,
-	.ioctl		= q6venc_ioctl,
-};
-
-static struct miscdevice q6venc_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "q6venc",
-	.fops	= &q6venc_dev_fops,
-};
-
-static int __init q6venc_init(void)
-{
-	int rc = 0;
-
-	rc = misc_register(&q6venc_misc);
-	if (rc)
-		pr_err("%s: Unable to register q6venc misc device\n", __func__);
-	return rc;
-}
-
-static void __exit q6venc_exit(void)
-{
-	misc_deregister(&q6venc_misc);
-}
-
-MODULE_DESCRIPTION("video encoder driver for QSD platform");
-MODULE_VERSION("2.0");
-
-module_init(q6venc_init);
-module_exit(q6venc_exit);
diff --git a/arch/arm/mach-msm/qdsp6/pcm_in.c b/arch/arm/mach-msm/qdsp6/pcm_in.c
deleted file mode 100644
index de2ce56..0000000
--- a/arch/arm/mach-msm/qdsp6/pcm_in.c
+++ /dev/null
@@ -1,205 +0,0 @@
-/* arch/arm/mach-msm/qdsp6/pcm_in.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/miscdevice.h>
-#include <linux/mutex.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/uaccess.h>
-
-#include <linux/msm_audio.h>
-
-#include <mach/msm_qdsp6_audio.h>
-
-#define BUFSZ (4096)
-#define DMASZ (BUFSZ * 2)
-
-static DEFINE_MUTEX(pcm_in_lock);
-static uint32_t sample_rate = 8000;
-static uint32_t channel_count = 1;
-static int pcm_in_opened = 0;
-
-void audio_client_dump(struct audio_client *ac);
-
-static long q6_in_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	int rc = 0;
-
-	switch (cmd) {
-	case AUDIO_SET_VOLUME:
-		break;
-	case AUDIO_GET_STATS: {
-		struct msm_audio_stats stats;
-		memset(&stats, 0, sizeof(stats));
-		if (copy_to_user((void*) arg, &stats, sizeof(stats)))
-			return -EFAULT;
-		return 0;
-	}
-	case AUDIO_START: {
-		uint32_t acdb_id;
-		rc = 0;
-
-		if (arg == 0) {
-			acdb_id = 0;
-		} else if (copy_from_user(&acdb_id, (void*) arg, sizeof(acdb_id))) {
-			rc = -EFAULT;
-			break;
-		}
-
-		mutex_lock(&pcm_in_lock);
-		if (file->private_data) {
-			rc = -EBUSY;
-		} else {
-			file->private_data = q6audio_open_pcm(
-				BUFSZ, sample_rate, channel_count, AUDIO_FLAG_READ, acdb_id);
-			if (!file->private_data)
-				rc = -ENOMEM;
-		}
-		mutex_unlock(&pcm_in_lock);
-		break;
-	}
-	case AUDIO_STOP:
-		break;
-	case AUDIO_FLUSH:
-		break;
-	case AUDIO_SET_CONFIG: {
-		struct msm_audio_config config;
-		if (copy_from_user(&config, (void*) arg, sizeof(config))) {
-			rc = -EFAULT;
-			break;
-		}
-		sample_rate = config.sample_rate;
-		channel_count = config.channel_count;
-		break;
-	}
-	case AUDIO_GET_CONFIG: {
-		struct msm_audio_config config;
-		config.buffer_size = BUFSZ;
-		config.buffer_count = 2;
-		config.sample_rate = sample_rate;
-		config.channel_count = channel_count;
-		config.unused[0] = 0;
-		config.unused[1] = 0;
-		config.unused[2] = 0;
-		if (copy_to_user((void*) arg, &config, sizeof(config))) {
-			rc = -EFAULT;
-		}
-		break;
-	}
-	default:
-		rc = -EINVAL;
-	}
-	return rc;
-}
-
-static int q6_in_open(struct inode *inode, struct file *file)
-{
-	int rc;
-
-	pr_info("pcm_in: open\n");
-	mutex_lock(&pcm_in_lock);
-	if (pcm_in_opened) {
-		pr_err("pcm_in: busy\n");
-		rc = -EBUSY;
-	} else {
-		pcm_in_opened = 1;
-		rc = 0;
-	}
-	mutex_unlock(&pcm_in_lock);
-	return rc;
-}
-
-static ssize_t q6_in_read(struct file *file, char __user *buf,
-			  size_t count, loff_t *pos)
-{
-	struct audio_client *ac;
-	struct audio_buffer *ab;
-	const char __user *start = buf;
-	int xfer;
-	int res;
-
-	mutex_lock(&pcm_in_lock);
-	ac = file->private_data;
-	if (!ac) {
-		res = -ENODEV;
-		goto fail;
-	}
-	while (count > 0) {
-		ab = ac->buf + ac->cpu_buf;
-
-		if (ab->used)
-			if (!wait_event_timeout(ac->wait, (ab->used == 0), 5*HZ)) {
-				audio_client_dump(ac);
-				pr_err("pcm_read: timeout. dsp dead?\n");
-				BUG();
-			}
-
-		xfer = count;
-		if (xfer > ab->size)
-			xfer = ab->size;
-
-		if (copy_to_user(buf, ab->data, xfer)) {
-			res = -EFAULT;
-			goto fail;
-		}
-
-		buf += xfer;
-		count -= xfer;
-
-		ab->used = 1;
-		q6audio_read(ac, ab);
-		ac->cpu_buf ^= 1;
-	}
-fail:
-	res = buf - start;
-	mutex_unlock(&pcm_in_lock);
-
-	return res;
-}
-
-static int q6_in_release(struct inode *inode, struct file *file)
-{
-	int rc = 0;
-	mutex_lock(&pcm_in_lock);
-	if (file->private_data)
-		rc = q6audio_close(file->private_data);
-	pcm_in_opened = 0;
-	mutex_unlock(&pcm_in_lock);
-	pr_info("pcm_in: release\n");
-	return rc;
-}
-
-static struct file_operations q6_in_fops = {
-	.owner		= THIS_MODULE,
-	.open		= q6_in_open,
-	.read		= q6_in_read,
-	.release	= q6_in_release,
-	.unlocked_ioctl	= q6_in_ioctl,
-};
-
-struct miscdevice q6_in_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_pcm_in",
-	.fops	= &q6_in_fops,
-};
-
-static int __init q6_in_init(void) {
-	return misc_register(&q6_in_misc);
-}
-
-device_initcall(q6_in_init);
diff --git a/arch/arm/mach-msm/qdsp6/pcm_out.c b/arch/arm/mach-msm/qdsp6/pcm_out.c
deleted file mode 100644
index 8987cbe..0000000
--- a/arch/arm/mach-msm/qdsp6/pcm_out.c
+++ /dev/null
@@ -1,228 +0,0 @@
-/* arch/arm/mach-msm/qdsp6/pcm_out.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Author: Brian Swetland <swetland@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/miscdevice.h>
-#include <linux/mutex.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/uaccess.h>
-
-#include <linux/msm_audio.h>
-
-#include <mach/msm_qdsp6_audio.h>
-#include "dal_audio.h"
-
-void audio_client_dump(struct audio_client *ac);
-
-#define BUFSZ (3072)
-#define DMASZ (BUFSZ * 2)
-
-struct pcm {
-	struct mutex lock;
-	struct audio_client *ac;
-	uint32_t sample_rate;
-	uint32_t channel_count;
-};
-
-static long pcm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct pcm *pcm = file->private_data;
-	struct cad_audio_eq_cfg eq_cfg;
-	int rc = 0;
-
-	if (cmd == AUDIO_GET_STATS) {
-		struct msm_audio_stats stats;
-		memset(&stats, 0, sizeof(stats));
-		if (copy_to_user((void*) arg, &stats, sizeof(stats)))
-			return -EFAULT;
-		return 0;
-	}
-
-	mutex_lock(&pcm->lock);
-	switch (cmd) {
-	case AUDIO_SET_VOLUME: {
-		int vol;
-		if (copy_from_user(&vol, (void*) arg, sizeof(vol))) {
-			rc = -EFAULT;
-			break;
-		}
-		rc = q6audio_set_stream_volume(pcm->ac, vol);
-		break;
-	}
-	case AUDIO_SET_EQ: {
-		if (copy_from_user(&eq_cfg, (void *)arg, sizeof(struct cad_audio_eq_cfg))) {
-			rc = -EFAULT;
-			break;
-		}
-		rc = q6audio_set_stream_eq(pcm->ac, &eq_cfg);
-		break;
-	}
-	case AUDIO_START: {
-		uint32_t acdb_id;
-		if (arg == 0) {
-			acdb_id = 0;
-		} else if (copy_from_user(&acdb_id, (void*) arg, sizeof(acdb_id))) {
-			pr_info("pcm_out: copy acdb_id from user failed\n");
-			rc = -EFAULT;
-			break;
-		}
-		if (pcm->ac) {
-			rc = -EBUSY;
-		} else {
-			pcm->ac = q6audio_open_pcm(BUFSZ, pcm->sample_rate,
-						   pcm->channel_count,
-						   AUDIO_FLAG_WRITE, acdb_id);
-			if (!pcm->ac)
-				rc = -ENOMEM;
-		}
-		break;
-	}
-	case AUDIO_STOP:
-		break;
-	case AUDIO_FLUSH:
-		break;
-	case AUDIO_SET_CONFIG: {
-		struct msm_audio_config config;
-		if (pcm->ac) {
-			rc = -EBUSY;
-			break;
-		}
-		if (copy_from_user(&config, (void*) arg, sizeof(config))) {
-			rc = -EFAULT;
-			break;
-		}
-		if (config.channel_count < 1 || config.channel_count > 2) {
-			rc = -EINVAL;
-			break;
-		}
-		pcm->sample_rate = config.sample_rate;
-		pcm->channel_count = config.channel_count;
-		break;
-	}
-	case AUDIO_GET_CONFIG: {
-		struct msm_audio_config config;
-		config.buffer_size = BUFSZ;
-		config.buffer_count = 2;
-		config.sample_rate = pcm->sample_rate;
-		config.channel_count = pcm->channel_count;
-		config.unused[0] = 0;
-		config.unused[1] = 0;
-		config.unused[2] = 0;
-		if (copy_to_user((void*) arg, &config, sizeof(config))) {
-			rc = -EFAULT;
-		}
-		break;
-	}
-	default:
-		rc = -EINVAL;
-	}
-		mutex_unlock(&pcm->lock);
-	return rc;
-}
-
-static int pcm_open(struct inode *inode, struct file *file)
-{
-	struct pcm *pcm;
-
-	pr_info("pcm_out: open\n");
-	pcm = kzalloc(sizeof(struct pcm), GFP_KERNEL);
-
-	if (!pcm)
-		return -ENOMEM;
-
-	mutex_init(&pcm->lock);
-	pcm->channel_count = 2;
-	pcm->sample_rate = 44100;
-
-	file->private_data = pcm;
-	return 0;
-}
-
-static ssize_t pcm_write(struct file *file, const char __user *buf,
-			   size_t count, loff_t *pos)
-{
-	struct pcm *pcm = file->private_data;
-	struct audio_client *ac;
-	struct audio_buffer *ab;
-	const char __user *start = buf;
-	int xfer;
-
-	if (!pcm->ac)
-		pcm_ioctl(file, AUDIO_START, 0);
-
-	ac = pcm->ac;
-	if (!ac)
-		return -ENODEV;
-
-	while (count > 0) {
-		ab = ac->buf + ac->cpu_buf;
-
-		if (ab->used)
-			if (!wait_event_timeout(ac->wait, (ab->used == 0), 5*HZ)) {
-				audio_client_dump(ac);
-				pr_err("pcm_write: timeout. dsp dead?\n");
-				BUG();
-			}
-
-		xfer = count;
-		if (xfer > ab->size)
-			xfer = ab->size;
-
-		if (copy_from_user(ab->data, buf, xfer)) 
-			return -EFAULT;
-
-		buf += xfer;
-		count -= xfer;
-
-		ab->used = xfer;
-		q6audio_write(ac, ab);
-		ac->cpu_buf ^= 1;
-	}
-
-	return buf - start;
-}
-
-static int pcm_release(struct inode *inode, struct file *file)
-{
-	struct pcm *pcm = file->private_data;
-	if (pcm->ac)
-		q6audio_close(pcm->ac);
-	kfree(pcm);
-	pr_info("pcm_out: release\n");
-	return 0;
-}
-
-static struct file_operations pcm_fops = {
-	.owner		= THIS_MODULE,
-	.open		= pcm_open,
-	.write		= pcm_write,
-	.release	= pcm_release,
-	.unlocked_ioctl	= pcm_ioctl,
-};
-
-struct miscdevice pcm_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_pcm_out",
-	.fops	= &pcm_fops,
-};
-
-static int __init pcm_init(void) {
-	return misc_register(&pcm_misc);
-}
-
-device_initcall(pcm_init);
diff --git a/arch/arm/mach-msm/qdsp6/q6audio.c b/arch/arm/mach-msm/qdsp6/q6audio.c
deleted file mode 100644
index 485d615..0000000
--- a/arch/arm/mach-msm/qdsp6/q6audio.c
+++ /dev/null
@@ -1,2003 +0,0 @@
-/* arch/arm/mach-msm/qdsp6/q6audio.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Author: Brian Swetland <swetland@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/mutex.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/dma-mapping.h>
-#include <linux/clk.h>
-
-#include <linux/delay.h>
-#include <linux/wakelock.h>
-#include <linux/firmware.h>
-#include <linux/miscdevice.h>
-
-#include "dal.h"
-#include "dal_audio.h"
-#include "dal_audio_format.h"
-#include "dal_acdb.h"
-#include "dal_adie.h"
-#include <mach/msm_qdsp6_audio.h>
-#include <linux/msm_audio.h>
-#include <mach/htc_acoustic_qsd.h>
-#include <mach/msm_audio_qcp.h>
-
-#include <linux/gpio.h>
-
-#include "q6audio_devices.h"
-
-#if 0
-#define TRACE(x...) pr_info("Q6: "x)
-#else
-#define TRACE(x...) do{}while(0)
-#endif
-
-#if 1
-#define AUDIO_INFO(x...) pr_info("Audio: "x)
-#else
-#define AUDIO_INFO(x...) do{}while(0)
-#endif
-
-static struct q6_hw_info q6_audio_hw[Q6_HW_COUNT] = {
-	[Q6_HW_HANDSET] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_HEADSET] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_SPEAKER] = {
-		.min_gain = -1500,
-		.max_gain = 0,
-	},
-	[Q6_HW_TTY] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_BT_SCO] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-	[Q6_HW_BT_A2DP] = {
-		.min_gain = -2000,
-		.max_gain = 0,
-	},
-};
-
-static struct wake_lock wakelock;
-static struct wake_lock idlelock;
-static int idlecount;
-static DEFINE_MUTEX(idlecount_lock);
-
-void audio_prevent_sleep(void)
-{
-	mutex_lock(&idlecount_lock);
-	if (++idlecount == 1) {
-		wake_lock(&wakelock);
-		wake_lock(&idlelock);
-	}
-	mutex_unlock(&idlecount_lock);
-}
-
-void audio_allow_sleep(void)
-{
-	mutex_lock(&idlecount_lock);
-	if (--idlecount == 0) {
-		wake_unlock(&idlelock);
-		wake_unlock(&wakelock);
-	}
-	mutex_unlock(&idlecount_lock);
-}
-
-static struct clk *icodec_rx_clk;
-static struct clk *icodec_tx_clk;
-static struct clk *ecodec_clk;
-static struct clk *sdac_clk;
-
-static struct q6audio_analog_ops default_analog_ops;
-static struct q6audio_analog_ops *analog_ops = &default_analog_ops;
-static uint32_t tx_clk_freq = 8000;
-static int tx_mute_status = 0;
-static int rx_vol_level = 100;
-static char acdb_file[64] = "default.acdb";
-static uint32_t tx_acdb = 0;
-static uint32_t rx_acdb = 0;
-static int acdb_use_rpc = 0;
-
-void q6audio_register_analog_ops(struct q6audio_analog_ops *ops)
-{
-	analog_ops = ops;
-}
-
-void q6audio_set_acdb_file(char* filename)
-{
-	if (filename) {
-		pr_info("audio: set acdb file as %s\n", filename);
-		strncpy(acdb_file, filename, sizeof(acdb_file)-1);
-	}
-}
-
-static struct q6_device_info *q6_lookup_device(uint32_t device_id)
-{
-	struct q6_device_info *di = q6_audio_devices;
-	for (;;) {
-		if (di->id == device_id)
-			return di;
-		if (di->id == 0) {
-			pr_err("q6_lookup_device: bogus id 0x%08x\n",
-			       device_id);
-			return di;
-		}
-		di++;
-	}
-}
-
-static uint32_t q6_device_to_codec(uint32_t device_id)
-{
-	struct q6_device_info *di = q6_lookup_device(device_id);
-	return di->codec;
-}
-
-static uint32_t q6_device_to_dir(uint32_t device_id)
-{
-	struct q6_device_info *di = q6_lookup_device(device_id);
-	return di->dir;
-}
-
-static uint32_t q6_device_to_cad_id(uint32_t device_id)
-{
-	struct q6_device_info *di = q6_lookup_device(device_id);
-	return di->cad_id;
-}
-
-static uint32_t q6_device_to_path(uint32_t device_id)
-{
-	struct q6_device_info *di = q6_lookup_device(device_id);
-	return di->path;
-}
-
-static uint32_t q6_device_to_rate(uint32_t device_id)
-{
-	struct q6_device_info *di = q6_lookup_device(device_id);
-	return di->rate;
-}
-
-int q6_device_volume(uint32_t device_id, int level)
-{
-	struct q6_device_info *di = q6_lookup_device(device_id);
-	if (analog_ops->get_rx_vol)
-		return analog_ops->get_rx_vol(di->hw, level);
-	else {
-		struct q6_hw_info *hw;
-		hw = &q6_audio_hw[di->hw];
-		return hw->min_gain + ((hw->max_gain - hw->min_gain) * level) / 100;
-	}
-}
-
-static inline int adie_open(struct dal_client *client) 
-{
-	return dal_call_f0(client, DAL_OP_OPEN, 0);
-}
-
-static inline int adie_close(struct dal_client *client) 
-{
-	return dal_call_f0(client, DAL_OP_CLOSE, 0);
-}
-
-static inline int adie_set_path(struct dal_client *client,
-				uint32_t id, uint32_t path_type)
-{
-	return dal_call_f1(client, ADIE_OP_SET_PATH, id, path_type);
-}
-
-static inline int adie_set_path_freq_plan(struct dal_client *client,
-                                         uint32_t path_type, uint32_t plan)
-{
-	return dal_call_f1(client, ADIE_OP_SET_PATH_FREQUENCY_PLAN,
-			   path_type, plan);
-}
-
-static inline int adie_proceed_to_stage(struct dal_client *client,
-					uint32_t path_type, uint32_t stage)
-{
-	return dal_call_f1(client, ADIE_OP_PROCEED_TO_STAGE,
-			   path_type, stage);
-}
-
-static inline int adie_mute_path(struct dal_client *client,
-				 uint32_t path_type, uint32_t mute_state)
-{
-	return dal_call_f1(client, ADIE_OP_MUTE_PATH, path_type, mute_state);
-}
-
-static int adie_refcount;
-
-static struct dal_client *adie;
-static struct dal_client *adsp;
-static struct dal_client *acdb;
-
-static int adie_enable(void)
-{
-	adie_refcount++;
-	if (adie_refcount == 1)
-		adie_open(adie);
-	return 0;
-}
-
-static int adie_disable(void)
-{
-	adie_refcount--;
-	if (adie_refcount == 0)
-		adie_close(adie);
-	return 0;
-}
-
-/* 4k DMA scratch page used for exchanging acdb device config tables
- * and stream format descriptions with the DSP.
- */
-static void *audio_data;
-static dma_addr_t audio_phys;
-
-#define SESSION_MIN 0
-#define SESSION_MAX 64
-
-static DEFINE_MUTEX(session_lock);
-static DEFINE_MUTEX(audio_lock);
-
-static struct audio_client *session[SESSION_MAX];
-
-static int session_alloc(struct audio_client *ac)
-{
-	int n;
-
-	mutex_lock(&session_lock);
-	for (n = SESSION_MIN; n < SESSION_MAX; n++) {
-		if (!session[n]) {
-			session[n] = ac;
-			mutex_unlock(&session_lock);
-			return n;
-		}
-	}
-	mutex_unlock(&session_lock);
-	return -ENOMEM;
-}
-
-static void session_free(int n, struct audio_client *ac)
-{
-	mutex_lock(&session_lock);
-	if (session[n] == ac)
-		session[n] = 0;
-	mutex_unlock(&session_lock);
-}
-
-static void audio_client_free(struct audio_client *ac)
-{
-	session_free(ac->session, ac);
-
-	if (ac->buf[0].data)
-		dma_free_coherent(NULL, ac->buf[0].size,
-				  ac->buf[0].data, ac->buf[0].phys);
-	if (ac->buf[1].data)
-		dma_free_coherent(NULL, ac->buf[1].size,
-				  ac->buf[1].data, ac->buf[1].phys);
-	kfree(ac);
-}
-
-static struct audio_client *audio_client_alloc(unsigned bufsz)
-{
-	struct audio_client *ac;
-	int n;
-
-	ac = kzalloc(sizeof(*ac), GFP_KERNEL);
-	if (!ac)
-		return 0;
-
-	n = session_alloc(ac);
-	if (n < 0)
-		goto fail_session;
-	ac->session = n;
-
-	if (bufsz > 0) {
-		ac->buf[0].data = dma_alloc_coherent(NULL, bufsz,
-						&ac->buf[0].phys, GFP_KERNEL);
-		if (!ac->buf[0].data)
-			goto fail;
-		ac->buf[1].data = dma_alloc_coherent(NULL, bufsz,
-						&ac->buf[1].phys, GFP_KERNEL);
-		if (!ac->buf[1].data)
-			goto fail;
-
-		ac->buf[0].size = bufsz;
-		ac->buf[1].size = bufsz;
-	}
-
-	init_waitqueue_head(&ac->wait);
-	ac->client = adsp;
-
-	return ac;
-
-fail:
-	session_free(n, ac);
-fail_session:
-	audio_client_free(ac);
-	return 0;
-}
-
-void audio_client_dump(struct audio_client *ac)
-{
-	dal_trace_dump(ac->client);
-}
-
-static int audio_ioctl(struct audio_client *ac, void *ptr, uint32_t len)
-{
-	struct adsp_command_hdr *hdr = ptr;
-	uint32_t tmp;
-	int r;
-
-	hdr->size = len - sizeof(u32);
-	hdr->dst = AUDIO_ADDR(ac->session, 0, AUDIO_DOMAIN_DSP);
-	hdr->src = AUDIO_ADDR(ac->session, 0, AUDIO_DOMAIN_MODEM);
-	hdr->context = ac->session;
-	ac->cb_status = -EBUSY;
-	r = dal_call(ac->client, AUDIO_OP_CONTROL, 5, ptr, len, &tmp, sizeof(tmp));
-	if (r != 4)
-		return -EIO;
-	if (!wait_event_timeout(ac->wait, (ac->cb_status != -EBUSY), 5*HZ)) {
-		dal_trace_dump(ac->client);
-		pr_err("audio_ioctl: timeout. dsp dead?\n");
-		BUG();
-	}
-	return ac->cb_status;
-}
-
-static int audio_command(struct audio_client *ac, uint32_t cmd)
-{
-	struct adsp_command_hdr rpc;
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.opcode = cmd;
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-static int audio_open_control(struct audio_client *ac)
-{
-	struct adsp_open_command rpc;
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_OPEN_DEVICE;
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-static int audio_out_open(struct audio_client *ac, uint32_t bufsz,
-			  uint32_t rate, uint32_t channels)
-{
-	struct adsp_open_command rpc;
-
-	memset(&rpc, 0, sizeof(rpc));
-
-	rpc.format.standard.format = ADSP_AUDIO_FORMAT_PCM;
-	rpc.format.standard.channels = channels;
-	rpc.format.standard.bits_per_sample = 16;
-	rpc.format.standard.sampling_rate = rate;
-	rpc.format.standard.is_signed = 1;
-	rpc.format.standard.is_interleaved = 1;
-
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_OPEN_WRITE;
-	rpc.device = ADSP_AUDIO_DEVICE_ID_DEFAULT;
-	rpc.stream_context = ADSP_AUDIO_DEVICE_CONTEXT_PLAYBACK;
-	rpc.buf_max_size = bufsz;
-
-	AUDIO_INFO("open out %p\n", ac);
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-static int audio_in_open(struct audio_client *ac, uint32_t bufsz,
-			 uint32_t rate, uint32_t channels)
-{
-	struct adsp_open_command rpc;
-
-	memset(&rpc, 0, sizeof(rpc));
-
-	rpc.format.standard.format = ADSP_AUDIO_FORMAT_PCM;
-	rpc.format.standard.channels = channels;
-	rpc.format.standard.bits_per_sample = 16;
-	rpc.format.standard.sampling_rate = rate;
-	rpc.format.standard.is_signed = 1;
-	rpc.format.standard.is_interleaved = 1;
-
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_OPEN_READ;
-	rpc.device = ADSP_AUDIO_DEVICE_ID_DEFAULT;
-	rpc.stream_context = ADSP_AUDIO_DEVICE_CONTEXT_RECORD;
-	rpc.buf_max_size = bufsz;
-
-	AUDIO_INFO("%p: open in\n", ac);
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-static int audio_mp3_open(struct audio_client *ac, uint32_t bufsz,
-			  uint32_t rate, uint32_t channels)
-{
-	struct adsp_open_command rpc;
-
-	memset(&rpc, 0, sizeof(rpc));
-
-	rpc.format.standard.format = ADSP_AUDIO_FORMAT_MP3;
-	rpc.format.standard.channels = channels;
-	rpc.format.standard.bits_per_sample = 16;
-	rpc.format.standard.sampling_rate = rate;
-	rpc.format.standard.is_signed = 1;
-	rpc.format.standard.is_interleaved = 0;
-
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_OPEN_WRITE;
-	rpc.device = ADSP_AUDIO_DEVICE_ID_DEFAULT;
-	rpc.stream_context = ADSP_AUDIO_DEVICE_CONTEXT_PLAYBACK;
-	rpc.buf_max_size = bufsz;
-
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-static int audio_aac_open(struct audio_client *ac, uint32_t bufsz,
-			 void *data)
-{
-	struct aac_format *af = data;
-	struct adsp_open_command rpc;
-	uint32_t *aac_type;
-	int idx = sizeof(uint32_t);
-	struct adsp_audio_binary_format *fmt = &(rpc.format.binary);
-
-	memset(&rpc, 0, sizeof(rpc));
-
-	fmt->format = ADSP_AUDIO_FORMAT_MPEG4_AAC;
-	aac_type = (uint32_t *)(fmt->data);
-	switch (af->block_formats) {
-	case 0xffff:
-		if (ac->flags & AUDIO_FLAG_WRITE)
-			*aac_type = ADSP_AUDIO_AAC_ADTS;
-		else
-			*aac_type = ADSP_AUDIO_AAC_MPEG4_ADTS;
-		break;
-	case 0:
-		if (ac->flags & AUDIO_FLAG_WRITE)
-			*aac_type = ADSP_AUDIO_AAC_ADIF;
-		else
-			*aac_type = ADSP_AUDIO_AAC_RAW;
-		break;
-	case 1:
-		*aac_type = ADSP_AUDIO_AAC_RAW;
-		break;
-	case 2:
-		*aac_type = ADSP_AUDIO_AAC_LOAS;
-		break;
-	case 3:
-		*aac_type = ADSP_AUDIO_AAC_FRAMED_RAW;
-		break;
-	case 4:
-		*aac_type = ADSP_AUDIO_AAC_RAW;
-		break;
-	default:
-		pr_err("unsupported AAC type %d\n", af->block_formats);
-		return -EINVAL;
-	}
-
-	AUDIO_INFO("aac_open: type %x, obj %d, idx %d\n",
-	      *aac_type, af->audio_object_type, idx);
-	fmt->data[idx++] = (u8)(((af->audio_object_type & 0x1F) << 3) |
-				((af->sample_rate >> 1) & 0x7));
-	fmt->data[idx] = (u8)(((af->sample_rate & 0x1) << 7) |
-				((af->channel_config & 0x7) << 3));
-
-	switch (af->audio_object_type) {
-	case AAC_OBJECT_ER_LC:
-	case AAC_OBJECT_ER_LTP:
-	case AAC_OBJECT_ER_LD:
-		/* extension flag */
-		fmt->data[idx++] |= 0x1;
-		fmt->data[idx] = (u8)(
-			((af->aac_section_data_resilience_flag & 0x1) << 7) |
-			((af->aac_scalefactor_data_resilience_flag & 0x1) << 6) |
-			((af->aac_spectral_data_resilience_flag	& 0x1) << 5) |
-			((af->ep_config & 0x3) << 2));
-		break;
-
-	case AAC_OBJECT_ER_SCALABLE:
-		fmt->data[idx++] |= 0x1;
-		/* extension flag */
-		fmt->data[idx++] = (u8)(
-			((af->aac_section_data_resilience_flag & 0x1) << 4) |
-			((af->aac_scalefactor_data_resilience_flag & 0x1) << 3) |
-			((af->aac_spectral_data_resilience_flag	& 0x1) << 2) |
-			((af->ep_config >> 1) & 0x1));
-		fmt->data[idx] = (u8)((af->ep_config & 0x1)
-			<< 7);
-		break;
-
-	case AAC_OBJECT_BSAC:
-		fmt->data[++idx] = (u8)((af->ep_config & 0x3)
-			<< 6);
-		break;
-
-	default:
-		pr_err("dbg unknown object type \n");
-		break;
-	}
-	fmt->num_bytes = idx + 1;
-
-	TRACE("aac_open: format %x%x %x%x%x%x %x%x, \n",
-	      fmt->data[0], fmt->data[1], fmt->data[2], fmt->data[3],
-	      fmt->data[4], fmt->data[5], fmt->data[6], fmt->data[7]);
-
-	rpc.device = ADSP_AUDIO_DEVICE_ID_DEFAULT;
-	rpc.config.aac.bit_rate = af->bit_rate;
-	if (ac->flags & AUDIO_FLAG_WRITE) {
-		rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_OPEN_WRITE;
-		rpc.stream_context = ADSP_AUDIO_DEVICE_CONTEXT_PLAYBACK;
-	} else {
-		rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_OPEN_READ;
-		rpc.stream_context = ADSP_AUDIO_DEVICE_CONTEXT_RECORD;
-	}
-
-	if ((af->sbr_on_flag == 0) && (af->sbr_ps_on_flag == 0)) {
-		rpc.config.aac.encoder_mode =
-			ADSP_AUDIO_ENC_AAC_LC_ONLY_MODE;
-	} else if ((af->sbr_on_flag == 1) && (af->sbr_ps_on_flag == 0)) {
-		rpc.config.aac.encoder_mode =
-			ADSP_AUDIO_ENC_AAC_PLUS_MODE;
-	} else if ((af->sbr_on_flag == 1) && (af->sbr_ps_on_flag == 1)) {
-		rpc.config.aac.encoder_mode =
-			ADSP_AUDIO_ENC_ENHANCED_AAC_PLUS_MODE;
-	} else {
-		pr_err("unsupported SBR flag\n");
-		return -EINVAL;
-	}
-	rpc.buf_max_size = bufsz; /* XXX ??? */
-	rpc.hdr.response_type = 0;
-
-	TRACE("aac_open: opcode %x, stream_context 0x%x, "
-	      "mode %d, bytes %d, bbuffer size %d\n",
-	      rpc.hdr.opcode, rpc.stream_context,
-	      rpc.config.aac.encoder_mode, fmt->num_bytes, bufsz);
-
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-static int audio_qcelp_open(struct audio_client *ac, uint32_t bufsz,
-			 void *data)
-{
-	struct msm_audio_qcelp_config *qf = data;
-	struct adsp_open_command rpc;
-	struct adsp_audio_standard_format *fmt = &(rpc.format.standard);
-
-	memset(&rpc, 0, sizeof(rpc));
-
-	fmt->format = ADSP_AUDIO_FORMAT_V13K_FS;
-	fmt->sampling_rate = 8000;
-	fmt->channels = 1;
-	fmt->bits_per_sample = 16;
-	fmt->is_signed = 1;
-	fmt->is_interleaved = 0;
-
-	rpc.device = ADSP_AUDIO_DEVICE_ID_DEFAULT;
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_OPEN_READ;
-	rpc.stream_context = ADSP_AUDIO_DEVICE_CONTEXT_RECORD;
-	rpc.config.qcelp13k.min_rate = (uint16_t) qf->min_bit_rate;
-	rpc.config.qcelp13k.max_rate = (uint16_t) qf->max_bit_rate;
-	rpc.buf_max_size = bufsz; /* XXX ??? */
-
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-static int audio_close(struct audio_client *ac)
-{
-	AUDIO_INFO("%p: close\n", ac);
-	audio_command(ac, ADSP_AUDIO_IOCTL_CMD_STREAM_STOP);
-	audio_command(ac, ADSP_AUDIO_IOCTL_CMD_CLOSE);
-	return 0;
-}
-
-static int audio_set_table(struct audio_client *ac,
-			   uint32_t device_id, int size)
-{
-	struct adsp_set_dev_cfg_table_command rpc;
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_SET_DEVICE_CONFIG_TABLE;
-	if (q6_device_to_dir(device_id) == Q6_TX)
-		rpc.hdr.data = tx_clk_freq;
-	rpc.device_id = device_id;
-	rpc.phys_addr = audio_phys;
-	rpc.phys_size = size;
-	rpc.phys_used = size;
-
-	TRACE("control: set table %x\n", device_id);
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-int q6audio_read(struct audio_client *ac, struct audio_buffer *ab)
-{
-	struct adsp_buffer_command rpc;
-	uint32_t res;
-	int r;
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.size = sizeof(rpc) - sizeof(u32);
-	rpc.hdr.dst = AUDIO_ADDR(ac->session, 0, AUDIO_DOMAIN_DSP);
-	rpc.hdr.src = AUDIO_ADDR(ac->session, 0, AUDIO_DOMAIN_MODEM);
-	rpc.hdr.context = ac->session;
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_DATA_TX;
-	rpc.buffer.addr = ab->phys;
-	rpc.buffer.max_size = ab->size;
-	rpc.buffer.actual_size = ab->used;
-
-	TRACE("%p: read\n", ac);
-	r = dal_call(ac->client, AUDIO_OP_DATA, 5, &rpc, sizeof(rpc),
-		     &res, sizeof(res));
-	return 0;
-}
-
-int q6audio_write(struct audio_client *ac, struct audio_buffer *ab)
-{
-	struct adsp_buffer_command rpc;
-	uint32_t res;
-	int r;
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.size = sizeof(rpc) - sizeof(u32);
-	rpc.hdr.dst = AUDIO_ADDR(ac->session, 0, AUDIO_DOMAIN_DSP);
-	rpc.hdr.src = AUDIO_ADDR(ac->session, 0, AUDIO_DOMAIN_MODEM);
-	rpc.hdr.context = ac->session;
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_DATA_RX;
-	rpc.buffer.addr = ab->phys;
-	rpc.buffer.max_size = ab->size;
-	rpc.buffer.actual_size = ab->used;
-
-	TRACE("%p: write\n", ac);
-	r = dal_call(ac->client, AUDIO_OP_DATA, 5, &rpc, sizeof(rpc),
-		     &res, sizeof(res));
-	return 0;
-}
-
-static int audio_rx_volume(struct audio_client *ac, uint32_t dev_id, int32_t volume)
-{
-	struct adsp_set_dev_volume_command rpc;
-
-	AUDIO_INFO("%s: dev_id 0x%08x, volume = %d\n",
-		   __func__, dev_id , volume);
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_VOL;
-	rpc.device_id = dev_id;
-	rpc.path = ADSP_PATH_RX;
-	rpc.volume = volume;
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-static int audio_rx_mute(struct audio_client *ac, uint32_t dev_id, int mute)
-{
-	struct adsp_set_dev_mute_command rpc;
-
-	AUDIO_INFO("%s: dev_id 0x%08x, mute %d\n",
-		   __func__, dev_id , mute);
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_MUTE;
-	rpc.device_id = dev_id;
-	rpc.path = ADSP_PATH_RX;
-	rpc.mute = !!mute;
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-/*
-static int audio_tx_volume(struct audio_client *ac, uint32_t dev_id, int32_t volume)
-{
-	struct adsp_set_dev_volume_command rpc;
-
-	AUDIO_INFO("%s: dev_id 0x%08x, volume %d\n",
-		   __func__, dev_id , volume);
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_VOL;
-	rpc.device_id = dev_id;
-	rpc.path = ADSP_PATH_TX;
-	rpc.volume = volume;
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-*/
-
-static int audio_tx_mute(struct audio_client *ac, uint32_t dev_id, int mute)
-{
-	struct adsp_set_dev_mute_command rpc;
-
-	AUDIO_INFO("%s: dev_id 0x%08x, mute %d\n",
-		   __func__, dev_id , mute);
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_SET_DEVICE_MUTE;
-	rpc.device_id = dev_id;
-	rpc.path = ADSP_PATH_TX;
-	rpc.mute = !!mute;
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-static int audio_stream_volume(struct audio_client *ac, int volume)
-{
-	struct adsp_set_volume_command rpc;
-	int rc;
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_SET_STREAM_VOL;
-	rpc.volume = volume;
-	rc = audio_ioctl(ac, &rpc, sizeof(rpc));
-	return rc;
-}
-
-static int audio_stream_mute(struct audio_client *ac, int mute)
-{
-	struct adsp_set_mute_command rpc;
-	int rc;
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_SET_STREAM_MUTE;
-	rpc.mute = mute;
-	rc = audio_ioctl(ac, &rpc, sizeof(rpc));
-	return rc;
-}
-
-static int audio_stream_eq(struct audio_client *ac, struct cad_audio_eq_cfg *eq_cfg)
-{
-	struct adsp_audio_set_equalizer_command rpc;
-	int rc;
-	uint32_t i = 0;
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_SET_SESSION_EQ_CONFIG;
-	rpc.enable = eq_cfg->enable;
-	rpc.num_bands = eq_cfg->num_bands;
-	for (i = 0; i < rpc.num_bands; i++)
-	{
-		rpc.eq_bands[i].band_idx = eq_cfg->eq_bands[i].band_idx;
-		rpc.eq_bands[i].filter_type = eq_cfg->eq_bands[i].filter_type;
-		rpc.eq_bands[i].center_freq_hz = eq_cfg->eq_bands[i].center_freq_hz;
-		rpc.eq_bands[i].filter_gain = eq_cfg->eq_bands[i].filter_gain;
-		rpc.eq_bands[i].q_factor = eq_cfg->eq_bands[i].q_factor;
-#if 1
-		pr_info(">>>>>> band_idx       = %d\n", rpc.eq_bands[i].band_idx);
-		pr_info(">>>>>> filter_type    = %d\n", rpc.eq_bands[i].filter_type);
-		pr_info(">>>>>> center_freq_hz = %d\n", rpc.eq_bands[i].center_freq_hz);
-		pr_info(">>>>>> filter_gain    = %d\n", rpc.eq_bands[i].filter_gain);
-		pr_info(">>>>>> q_factor       = %d\n\n", rpc.eq_bands[i].q_factor);
-#endif
-	}
-	rc = audio_ioctl(ac, &rpc, sizeof(rpc));
-	return rc;
-}
-
-static void callback(void *data, int len, void *cookie)
-{
-	struct adsp_event_hdr *e = data;
-	struct audio_client *ac;
-	/* struct adsp_buffer_event *abe = data; */
-
-	TRACE("audio callback: context %d, event 0x%x, status %d\n",
-	      e->context, e->event_id, e->status);
-
-	if (e->context >= SESSION_MAX) {
-		pr_err("audio callback: bogus session %d\n",
-		       e->context);
-		return;
-	}
-	ac = session[e->context];
-	if (!ac) {
-		pr_err("audio callback: unknown session %d\n",
-		       e->context);
-		return;
-	}
-
-	if (e->event_id == ADSP_AUDIO_IOCTL_CMD_STREAM_EOS) {
-		TRACE("%p: CB stream eos\n", ac);
-		if (e->status)
-			pr_err("playback status %d\n", e->status);
-		if (ac->cb_status == -EBUSY) {
-			ac->cb_status = e->status;
-			wake_up(&ac->wait);
-		}
-		return;
-	}
-
-	if (e->event_id == ADSP_AUDIO_EVT_STATUS_BUF_DONE) {
-		TRACE("%p: CB done (%d)\n", ac, e->status);
-		TRACE("%p: actual_size %d, buffer_size %d\n",
-		      ac, abe->buffer.actual_size, ac->buf[ac->dsp_buf].size);
-
-		if (e->status)
-			pr_err("buffer status %d\n", e->status);
-		ac->buf[ac->dsp_buf].used = 0;
-		ac->dsp_buf ^= 1;
-		wake_up(&ac->wait);
-		return;
-	}
-
-	TRACE("%p: CB %08x status %d\n", ac, e->event_id, e->status);
-	if (e->status)
-		pr_warning("audio_cb: s=%d e=%08x status=%d\n",
-			   e->context, e->event_id, e->status);
-	if (ac->cb_status == -EBUSY) {
-		ac->cb_status = e->status;
-		wake_up(&ac->wait);
-	}
-}
-
-static void audio_init(struct dal_client *client)
-{
-	u32 tmp[3];
-
-	tmp[0] = 2 * sizeof(u32);
-	tmp[1] = 1;
-	tmp[2] = 0;
-	dal_call(client, AUDIO_OP_INIT, 5, tmp, sizeof(tmp),
-		 tmp, sizeof(u32));
-}
-
-static struct audio_client *ac_control;
-
-struct audio_config_data {
-	uint32_t device_id;
-	uint32_t sample_rate;
-	uint32_t offset;
-	uint32_t length;
-};
-
-struct audio_config_database {
-	uint8_t magic[8];
-	uint32_t entry_count;
-	uint32_t unused;
-	struct audio_config_data entry[0];
-};
-
-void *acdb_data;
-const struct firmware *acdb_fw;
-extern struct miscdevice q6_control_device;
-
-static int acdb_init(char *filename)
-{
-	const struct audio_config_database *db;
-	const struct firmware *fw;
-	int n;
-
-	pr_info("acdb: load '%s'\n", filename);
-	if (request_firmware(&fw, filename, q6_control_device.this_device) < 0) {
-		pr_err("acdb: load 'default.acdb' failed...\n");
-		return -ENODEV;
-	}
-	db = (void*) fw->data;
-
-	if (fw->size < sizeof(struct audio_config_database)) {
-		pr_err("acdb: undersized database\n");
-		goto fail;
-	}
-	if (strcmp(db->magic, "ACDB1.0")) {
-		pr_err("acdb: invalid magic\n");
-		goto fail;
-	}
-	if (db->entry_count > 1024) {
-		pr_err("acdb: too many entries\n");
-		goto fail;
-	}
-	if (fw->size < (sizeof(struct audio_config_database) +
-			db->entry_count * sizeof(struct audio_config_data))) {
-		pr_err("acdb: undersized TOC\n");
-		goto fail;
-	}
-	for (n = 0; n < db->entry_count; n++) {
-		if (db->entry[n].length > 4096) {
-			pr_err("acdb: entry %d too large (%d)\n",
-			       n, db->entry[n].length);
-			goto fail;
-		}
-		if ((db->entry[n].offset + db->entry[n].length) > fw->size) {
-			pr_err("acdb: entry %d outside of data\n", n);
-			goto fail;
-		}
-	}
-	if (acdb_data)
-		release_firmware(acdb_fw);
-	acdb_data = (void*) fw->data;
-	acdb_fw = fw;
-	return 0;
-fail:
-	release_firmware(fw);
-	return -ENODEV;
-}
-
-static int q6audio_init(void)
-{
-	struct audio_client *ac = 0;
-	int res;
-
-	mutex_lock(&audio_lock);
-	if (ac_control) {
-		res = 0;
-		goto done;
-	}
-
-	pr_info("audio: init: codecs\n");
-	icodec_rx_clk = clk_get(0, "icodec_rx_clk");
-	icodec_tx_clk = clk_get(0, "icodec_tx_clk");
-	ecodec_clk = clk_get(0, "ecodec_clk");
-	sdac_clk = clk_get(0, "sdac_clk");
-	audio_data = dma_alloc_coherent(NULL, 4096, &audio_phys, GFP_KERNEL);
-
-	adsp = dal_attach(AUDIO_DAL_DEVICE, AUDIO_DAL_PORT,
-			  callback, 0);
-	if (!adsp) {
-		pr_err("audio_init: cannot attach to adsp\n");
-		res = -ENODEV;
-		goto done;
-	}
-	pr_info("audio: init: INIT\n");
-	audio_init(adsp);
-	dal_trace(adsp);
-
-	ac = audio_client_alloc(0);
-	if (!ac) {
-		pr_err("audio_init: cannot allocate client\n");
-		res = -ENOMEM;
-		goto done;
-	}
-
-	pr_info("audio: init: OPEN control\n");
-	if (audio_open_control(ac)) {
-		pr_err("audio_init: cannot open control channel\n");
-		res = -ENODEV;
-		goto done;
-	}
-
-	pr_info("audio: init: attach ACDB\n");
-	acdb = dal_attach(ACDB_DAL_DEVICE, ACDB_DAL_PORT, 0, 0);
-	if (!acdb) {
-		pr_err("audio_init: cannot attach to acdb channel\n");
-		res = -ENODEV;
-		goto done;
-	}
-
-	pr_info("audio: init: attach ADIE\n");
-	adie = dal_attach(ADIE_DAL_DEVICE, ADIE_DAL_PORT, 0, 0);
-	if (!adie) {
-		pr_err("audio_init: cannot attach to adie\n");
-		res = -ENODEV;
-		goto done;
-	}
-	if (analog_ops->init)
-		analog_ops->init();
-
-	if (!acdb_data && !acdb_use_rpc) {
-		if (acdb_init(acdb_file)) {
-			pr_info("use RPC to query ACDB.\n");
-			acdb_use_rpc = 1;
-		}
-	}
-
-	res = 0;
-	ac_control = ac;
-
-	wake_lock_init(&idlelock, WAKE_LOCK_IDLE, "audio_pcm_idle");
-	wake_lock_init(&wakelock, WAKE_LOCK_SUSPEND, "audio_pcm_suspend");
-done:
-	if ((res < 0) && ac)
-		audio_client_free(ac);
-	mutex_unlock(&audio_lock);
-
-	return res;
-}
-
-static int acdb_get_config_table(uint32_t device_id, uint32_t sample_rate)
-{
-	if (q6audio_init())
-		return 0;
-
-	if (acdb_use_rpc) {
-		struct acdb_cmd_device_table rpc;
-		struct acdb_result res;
-		int r;
-
-		memset(audio_data, 0, 4096);
-		memset(&rpc, 0, sizeof(rpc));
-
-		rpc.size = sizeof(rpc) - (2 * sizeof(uint32_t));
-		rpc.command_id = ACDB_GET_DEVICE_TABLE;
-		rpc.device_id = device_id;
-		rpc.sample_rate_id = sample_rate;
-		rpc.total_bytes = 4096;
-		rpc.unmapped_buf = audio_phys;
-		rpc.res_size = sizeof(res) - (2 * sizeof(uint32_t));
-
-		r = dal_call(acdb, ACDB_OP_IOCTL, 8, &rpc, sizeof(rpc),
-			     &res, sizeof(res));
-
-		if ((r == sizeof(res)) && (res.dal_status == 0)) {
-			pr_info("acdb: %d bytes for device %d, rate %d.\n",
-				res.used_bytes, device_id, sample_rate);
-			return res.used_bytes;
-		}
-		return 0;
-	} else {
-		struct audio_config_database *db;
-		int n;
-
-		db = acdb_data;
-		for (n = 0; n < db->entry_count; n++) {
-			if (db->entry[n].device_id != device_id)
-				continue;
-			if (db->entry[n].sample_rate != sample_rate)
-				continue;
-			break;
-		}
-
-		if (n == db->entry_count) {
-			pr_err("acdb: no entry for device %d, rate %d.\n",
-			       device_id, sample_rate);
-			return 0;
-		}
-
-		pr_info("acdb: %d bytes for device %d, rate %d.\n",
-			db->entry[n].length, device_id, sample_rate);
-
-		memcpy(audio_data, acdb_data + db->entry[n].offset, db->entry[n].length);
-		return db->entry[n].length;
-	}
-}
-
-static uint32_t audio_rx_path_id = ADIE_PATH_HANDSET_RX;
-static uint32_t audio_rx_device_id = ADSP_AUDIO_DEVICE_ID_HANDSET_SPKR;
-static uint32_t audio_rx_device_group = -1;
-static uint32_t audio_tx_path_id = ADIE_PATH_HANDSET_TX;
-static uint32_t audio_tx_device_id = ADSP_AUDIO_DEVICE_ID_HANDSET_MIC;
-static uint32_t audio_tx_device_group = -1;
-
-static int qdsp6_devchg_notify(struct audio_client *ac,
-			       uint32_t dev_type, uint32_t dev_id)
-{
-	struct adsp_device_switch_command rpc;
-
-	if (dev_type != ADSP_AUDIO_RX_DEVICE &&
-	    dev_type != ADSP_AUDIO_TX_DEVICE)
-		return -EINVAL;
-
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.hdr.opcode = ADSP_AUDIO_IOCTL_CMD_DEVICE_SWITCH_PREPARE;
-	if (dev_type == ADSP_AUDIO_RX_DEVICE) {
-		rpc.old_device = audio_rx_device_id;
-		rpc.new_device = dev_id;
-	} else {
-		rpc.old_device = audio_tx_device_id;
-		rpc.new_device = dev_id;
-	}
-	rpc.device_class = 0;
-	rpc.device_type = dev_type;
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-static int qdsp6_standby(struct audio_client *ac)
-{
-	return audio_command(ac, ADSP_AUDIO_IOCTL_CMD_DEVICE_SWITCH_STANDBY);
-}
-
-static int qdsp6_start(struct audio_client *ac)
-{
-	return audio_command(ac, ADSP_AUDIO_IOCTL_CMD_DEVICE_SWITCH_COMMIT);
-}
-
-static void audio_rx_analog_enable(int en)
-{
-	switch (audio_rx_device_id) {
-	case ADSP_AUDIO_DEVICE_ID_HEADSET_SPKR_MONO:
-	case ADSP_AUDIO_DEVICE_ID_HEADSET_SPKR_STEREO:
-	case ADSP_AUDIO_DEVICE_ID_TTY_HEADSET_SPKR:
-		if (analog_ops->headset_enable)
-			analog_ops->headset_enable(en);
-		break;
-	case ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO_W_MONO_HEADSET:
-	case ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO_W_STEREO_HEADSET:
-	case ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO_W_MONO_HEADSET:
-	case ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO_W_STEREO_HEADSET:
-		if (analog_ops->headset_enable)
-			analog_ops->headset_enable(en);
-		if (analog_ops->speaker_enable)
-			analog_ops->speaker_enable(en);
-		break;
-	case ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO:
-	case ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO:
-		if (analog_ops->speaker_enable)
-			analog_ops->speaker_enable(en);
-		break;
-	case ADSP_AUDIO_DEVICE_ID_BT_SCO_SPKR:
-		if (analog_ops->bt_sco_enable)
-			analog_ops->bt_sco_enable(en);
-		break;
-	case ADSP_AUDIO_DEVICE_ID_HANDSET_SPKR:
-		if (analog_ops->receiver_enable)
-			analog_ops->receiver_enable(en);
-		break;
-	case ADSP_AUDIO_DEVICE_ID_I2S_SPKR:
-		if (analog_ops->i2s_enable)
-			analog_ops->i2s_enable(en);
-		break;
-	}
-}
-
-static void audio_tx_analog_enable(int en)
-{
-	switch (audio_tx_device_id) {
-	case ADSP_AUDIO_DEVICE_ID_HANDSET_MIC:
-	case ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MIC:
-		if (analog_ops->int_mic_enable)
-			analog_ops->int_mic_enable(en);
-		break;
-	case ADSP_AUDIO_DEVICE_ID_HEADSET_MIC:
-	case ADSP_AUDIO_DEVICE_ID_TTY_HEADSET_MIC:
-		if (analog_ops->ext_mic_enable)
-			analog_ops->ext_mic_enable(en);
-		break;
-	case ADSP_AUDIO_DEVICE_ID_BT_SCO_MIC:
-		if (analog_ops->bt_sco_enable)
-			analog_ops->bt_sco_enable(en);
-		break;
-	}
-}
-
-static int audio_update_acdb(uint32_t adev, uint32_t acdb_id)
-{
-	uint32_t sample_rate;
-	int sz = -1;
-
-	sample_rate = q6_device_to_rate(adev);
-
-	if (q6_device_to_dir(adev) == Q6_RX)
-		rx_acdb = acdb_id;
-	else
-		tx_acdb = acdb_id;
-
-	if (acdb_id != 0)
-		sz = acdb_get_config_table(acdb_id, sample_rate);
-
-	if (sz <= 0) {
-		acdb_id = q6_device_to_cad_id(adev);
-		sz = acdb_get_config_table(acdb_id, sample_rate);
-	}
-
-	if (sz > 0)
-		audio_set_table(ac_control, adev, sz);
-	return 0;
-}
-
-static void _audio_rx_path_enable(int reconf, uint32_t acdb_id)
-{
-	adie_enable();
-	adie_set_path(adie, audio_rx_path_id, ADIE_PATH_RX);
-	adie_set_path_freq_plan(adie, ADIE_PATH_RX, 48000);
-
-	adie_proceed_to_stage(adie, ADIE_PATH_RX, ADIE_STAGE_DIGITAL_READY);
-	adie_proceed_to_stage(adie, ADIE_PATH_RX, ADIE_STAGE_DIGITAL_ANALOG_READY);
-
-	audio_update_acdb(audio_rx_device_id, acdb_id);
-	if (!reconf)
-		qdsp6_devchg_notify(ac_control, ADSP_AUDIO_RX_DEVICE, audio_rx_device_id);
-	qdsp6_standby(ac_control);
-	qdsp6_start(ac_control);
-
-	audio_rx_analog_enable(1);
-}
-
-static void _audio_tx_path_enable(int reconf, uint32_t acdb_id)
-{
-	audio_tx_analog_enable(1);
-
-	adie_enable();
-	adie_set_path(adie, audio_tx_path_id, ADIE_PATH_TX);
-
-	if (tx_clk_freq > 8000)
-		adie_set_path_freq_plan(adie, ADIE_PATH_TX, 48000);
-	else
-		adie_set_path_freq_plan(adie, ADIE_PATH_TX, 8000);
-
-	adie_proceed_to_stage(adie, ADIE_PATH_TX, ADIE_STAGE_DIGITAL_READY);
-	adie_proceed_to_stage(adie, ADIE_PATH_TX, ADIE_STAGE_DIGITAL_ANALOG_READY);
-
-	audio_update_acdb(audio_tx_device_id, acdb_id);
-
-	if (!reconf)
-		qdsp6_devchg_notify(ac_control, ADSP_AUDIO_TX_DEVICE, audio_tx_device_id);
-	qdsp6_standby(ac_control);
-	qdsp6_start(ac_control);
-
-	audio_tx_mute(ac_control, audio_tx_device_id, tx_mute_status);
-}
-
-static void _audio_rx_path_disable(void)
-{
-	audio_rx_analog_enable(0);
-
-	adie_proceed_to_stage(adie, ADIE_PATH_RX, ADIE_STAGE_ANALOG_OFF);
-	adie_proceed_to_stage(adie, ADIE_PATH_RX, ADIE_STAGE_DIGITAL_OFF);
-	adie_disable();
-}
-
-static void _audio_tx_path_disable(void)
-{
-	audio_tx_analog_enable(0);
-
-	adie_proceed_to_stage(adie, ADIE_PATH_TX, ADIE_STAGE_ANALOG_OFF);
-	adie_proceed_to_stage(adie, ADIE_PATH_TX, ADIE_STAGE_DIGITAL_OFF);
-	adie_disable();
-}
-
-static int icodec_rx_clk_refcount;
-static int icodec_tx_clk_refcount;
-static int ecodec_clk_refcount;
-static int sdac_clk_refcount;
-
-static void _audio_rx_clk_enable(void)
-{
-	uint32_t device_group = q6_device_to_codec(audio_rx_device_id);
-	AUDIO_INFO("%s: device 0x%08x, group %d\n",
-		   __func__, audio_rx_device_id, device_group);
-	switch(device_group) {
-	case Q6_ICODEC_RX:
-		icodec_rx_clk_refcount++;
-		AUDIO_INFO("%s: icodec_rx_clk_refcount = %d\n",
-			   __func__, icodec_rx_clk_refcount);
-		if (icodec_rx_clk_refcount == 1) {
-			clk_set_rate(icodec_rx_clk, 12288000);
-			clk_enable(icodec_rx_clk);
-			AUDIO_INFO("%s: icodec_rx_clk enabled\n", __func__);
-		}
-		break;
-	case Q6_ECODEC_RX:
-		ecodec_clk_refcount++;
-		AUDIO_INFO("%s: ecodec_clk_refcount = %d\n",
-			   __func__, ecodec_clk_refcount);
-		if (ecodec_clk_refcount == 1) {
-			clk_set_rate(ecodec_clk, 2048000);
-			clk_enable(ecodec_clk);
-			AUDIO_INFO("%s: ecodec_clk enabled\n", __func__);
-		}
-		break;
-	case Q6_SDAC_RX:
-		sdac_clk_refcount++;
-		AUDIO_INFO("%s: sdac_clk_refcount = %d\n",
-			   __func__, sdac_clk_refcount);
-		if (sdac_clk_refcount == 1) {
-			clk_set_rate(sdac_clk, 12288000);
-			clk_enable(sdac_clk);
-			AUDIO_INFO("%s: sdac_clk enabled\n", __func__);
-		}
-		break;
-	default:
-		return;
-	}
-	audio_rx_device_group = device_group;
-}
-
-static void _audio_tx_clk_enable(void)
-{
-	uint32_t device_group = q6_device_to_codec(audio_tx_device_id);
-	AUDIO_INFO("%s: device 0x%08x, group %d\n",
-		   __func__, audio_tx_device_id, device_group);
-	switch (device_group) {
-	case Q6_ICODEC_TX:
-		icodec_tx_clk_refcount++;
-		AUDIO_INFO("%s: icodec_tx_clk_refcount = %d\n",
-			   __func__, icodec_tx_clk_refcount);
-		if (icodec_tx_clk_refcount == 1) {
-			clk_set_rate(icodec_tx_clk, tx_clk_freq * 256);
-			clk_enable(icodec_tx_clk);
-			AUDIO_INFO("%s: icodec_tx_clk enabled\n", __func__);
-		}
-		break;
-	case Q6_ECODEC_TX:
-		ecodec_clk_refcount++;
-		AUDIO_INFO("%s: ecodec_clk_refcount = %d\n",
-			   __func__, ecodec_clk_refcount);
-		if (ecodec_clk_refcount == 1) {
-			clk_set_rate(ecodec_clk, 2048000);
-			clk_enable(ecodec_clk);
-			AUDIO_INFO("%s: ecodec_clk enabled\n", __func__);
-		}
-		break;
-	case Q6_SDAC_TX:
-		/* TODO: In QCT BSP, clk rate was set to 20480000 */
-		sdac_clk_refcount++;
-		AUDIO_INFO("%s: sdac_clk_refcount = %d\n",
-			   __func__, sdac_clk_refcount);
-		if (sdac_clk_refcount == 1) {
-			clk_set_rate(sdac_clk, 12288000);
-			clk_enable(sdac_clk);
-			AUDIO_INFO("%s: sdac_clk enabled\n", __func__);
-		}
-		break;
-	default:
-		return;
-	}
-	audio_tx_device_group = device_group;
-}
-
-static void _audio_rx_clk_disable(void)
-{
-	AUDIO_INFO("%s: group %d\n", __func__, audio_rx_device_group);
-	switch (audio_rx_device_group) {
-	case Q6_ICODEC_RX:
-		icodec_rx_clk_refcount--;
-		AUDIO_INFO("%s: icodec_rx_clk_refcount = %d\n",
-			   __func__, icodec_rx_clk_refcount);
-		if (icodec_rx_clk_refcount == 0) {
-			clk_disable(icodec_rx_clk);
-			audio_rx_device_group = -1;
-			AUDIO_INFO("%s: icodec_rx_clk disabled\n", __func__);
-		}
-		break;
-	case Q6_ECODEC_RX:
-		ecodec_clk_refcount--;
-		AUDIO_INFO("%s: ecodec_clk_refcount = %d\n",
-			   __func__, ecodec_clk_refcount);
-		if (ecodec_clk_refcount == 0) {
-			clk_disable(ecodec_clk);
-			audio_rx_device_group = -1;
-			AUDIO_INFO("%s: ecodec_clk disabled\n", __func__);
-		}
-		break;
-	case Q6_SDAC_RX:
-		sdac_clk_refcount--;
-		AUDIO_INFO("%s: sdac_clk_refcount = %d\n",
-			   __func__, sdac_clk_refcount);
-		if (sdac_clk_refcount == 0) {
-			clk_disable(sdac_clk);
-			audio_rx_device_group = -1;
-			AUDIO_INFO("%s: sdac_clk disabled\n", __func__);
-		}
-		break;
-	default:
-		pr_err("audiolib: invalid rx device group %d\n",
-			audio_rx_device_group);
-		break;
-	}
-}
-
-static void _audio_tx_clk_disable(void)
-{
-	AUDIO_INFO("%s: group %d\n", __func__, audio_tx_device_group);
-	switch (audio_tx_device_group) {
-	case Q6_ICODEC_TX:
-		icodec_tx_clk_refcount--;
-		AUDIO_INFO("%s: icodec_tx_clk_refcount = %d\n",
-			   __func__, icodec_tx_clk_refcount);
-		if (icodec_tx_clk_refcount == 0) {
-			clk_disable(icodec_tx_clk);
-			audio_tx_device_group = -1;
-			AUDIO_INFO("%s: icodec_tx_clk disabled\n", __func__);
-		}
-		break;
-	case Q6_ECODEC_TX:
-		ecodec_clk_refcount--;
-		AUDIO_INFO("%s: ecodec_clk_refcount = %d\n",
-			   __func__, ecodec_clk_refcount);
-		if (ecodec_clk_refcount == 0) {
-			clk_disable(ecodec_clk);
-			audio_tx_device_group = -1;
-			AUDIO_INFO("%s: ecodec_clk disabled\n", __func__);
-		}
-		break;
-	case Q6_SDAC_TX:
-		sdac_clk_refcount--;
-		AUDIO_INFO("%s: sdac_clk_refcount = %d\n",
-			   __func__, sdac_clk_refcount);
-		if (sdac_clk_refcount == 0) {
-			clk_disable(sdac_clk);
-			audio_tx_device_group = -1;
-			AUDIO_INFO("%s: sdac_clk disabled\n", __func__);
-		}
-		break;
-	default:
-		pr_err("audiolib: invalid tx device group %d\n",
-			audio_tx_device_group);
-		break;
-	}
-}
-
-static void _audio_rx_clk_reinit(uint32_t rx_device)
-{
-	uint32_t device_group = q6_device_to_codec(rx_device);
-
-	if (device_group != audio_rx_device_group)
-		_audio_rx_clk_disable();
-
-	audio_rx_device_id = rx_device;
-	audio_rx_path_id = q6_device_to_path(rx_device);
-
-	if (device_group != audio_rx_device_group)
-		_audio_rx_clk_enable();
-
-}
-
-static void _audio_tx_clk_reinit(uint32_t tx_device)
-{
-	uint32_t device_group = q6_device_to_codec(tx_device);
-
-	if (device_group != audio_tx_device_group)
-		_audio_tx_clk_disable();
-
-	audio_tx_device_id = tx_device;
-	audio_tx_path_id = q6_device_to_path(tx_device);
-
-	if (device_group != audio_tx_device_group)
-		_audio_tx_clk_enable();
-}
-
-static DEFINE_MUTEX(audio_path_lock);
-static int audio_rx_path_refcount;
-static int audio_tx_path_refcount;
-
-static int audio_rx_path_enable(int en, uint32_t acdb_id)
-{
-	mutex_lock(&audio_path_lock);
-	if (en) {
-		audio_rx_path_refcount++;
-		if (audio_rx_path_refcount == 1) {
-			_audio_rx_clk_enable();
-			_audio_rx_path_enable(0, acdb_id);
-		}
-	} else {
-		audio_rx_path_refcount--;
-		if (audio_rx_path_refcount == 0) {
-			_audio_rx_path_disable();
-			_audio_rx_clk_disable();
-		}
-	}
-	mutex_unlock(&audio_path_lock);
-	return 0;
-}
-
-static int audio_tx_path_enable(int en, uint32_t acdb_id)
-{
-	mutex_lock(&audio_path_lock);
-	if (en) {
-		audio_tx_path_refcount++;
-		if (audio_tx_path_refcount == 1) {
-			_audio_tx_clk_enable();
-			_audio_tx_path_enable(0, acdb_id);
-		}
-	} else {
-		audio_tx_path_refcount--;
-		if (audio_tx_path_refcount == 0) {
-			_audio_tx_path_disable();
-			_audio_tx_clk_disable();
-		}
-	}
-	mutex_unlock(&audio_path_lock);
-	return 0;
-}
-
-int q6audio_reinit_acdb(char* filename) {
-	int res;
-
-	if (q6audio_init())
-		return 0;
-
-	mutex_lock(&audio_path_lock);
-	if (strlen(filename) < 0) {
-		res = -EINVAL;
-		goto done;
-	}
-	res = acdb_init(filename);
-	if (!res)
-		strcpy(acdb_file, filename);
-done:
-	mutex_unlock(&audio_path_lock);
-	return res;
-
-}
-
-int q6audio_update_acdb(uint32_t id_src, uint32_t id_dst)
-{
-	int res;
-
-	if (q6audio_init())
-		return 0;
-
-	mutex_lock(&audio_path_lock);
-	res = audio_update_acdb(id_dst, id_src);
-	if (res)
-		goto done;
-
-	if (q6_device_to_dir(id_dst) == Q6_RX)
-		qdsp6_devchg_notify(ac_control, ADSP_AUDIO_RX_DEVICE, id_dst);
-	else
-		qdsp6_devchg_notify(ac_control, ADSP_AUDIO_TX_DEVICE, id_dst);
-	qdsp6_standby(ac_control);
-	qdsp6_start(ac_control);
-done:
-	mutex_unlock(&audio_path_lock);
-	return res;
-}
-
-int q6audio_set_tx_mute(int mute)
-{
-	uint32_t adev;
-	int rc;
-
-	if (q6audio_init())
-		return 0;
-
-	mutex_lock(&audio_path_lock);
-
-	if (mute == tx_mute_status) {
-		mutex_unlock(&audio_path_lock);
-		return 0;
-	}
-
-	adev = audio_tx_device_id;
-	rc = audio_tx_mute(ac_control, adev, mute);
-	tx_mute_status = mute;
-	mutex_unlock(&audio_path_lock);
-	return 0;
-}
-
-int q6audio_set_stream_volume(struct audio_client *ac, int vol)
-{
-	if (vol > 1200 || vol < -4000) {
-		pr_err("unsupported volume level %d\n", vol);
-		return -EINVAL;
-	}
-	mutex_lock(&audio_path_lock);
-	audio_stream_mute(ac, 0);
-	audio_stream_volume(ac, vol);
-	mutex_unlock(&audio_path_lock);
-	return 0;
-}
-
-int q6audio_set_stream_eq(struct audio_client *ac, struct cad_audio_eq_cfg *eq_cfg)
-{
-	mutex_lock(&audio_path_lock);
-	audio_stream_eq(ac, eq_cfg);
-	mutex_unlock(&audio_path_lock);
-	return 0;
-}
-
-int q6audio_set_rx_volume(int level)
-{
-	uint32_t adev;
-	int vol;
-
-	if (q6audio_init())
-		return 0;
-
-	if (level < 0 || level > 100)
-		return -EINVAL;
-
-	mutex_lock(&audio_path_lock);
-	adev = ADSP_AUDIO_DEVICE_ID_VOICE;
-	vol = q6_device_volume(audio_rx_device_id, level);
-	audio_rx_mute(ac_control, adev, 0);
-	audio_rx_volume(ac_control, adev, vol);
-	rx_vol_level = level;
-	mutex_unlock(&audio_path_lock);
-	return 0;
-}
-
-int q6audio_set_rx_mute(int mute)
-{
-	uint32_t adev;
-
-	if (q6audio_init())
-		return 0;
-
-	if (mute < 0 || mute > 1)
-		return -EINVAL;
-
-	mutex_lock(&audio_path_lock);
-	AUDIO_INFO("%s: set mute status %d\n", __func__, mute);
-	adev = ADSP_AUDIO_DEVICE_ID_VOICE;
-	audio_rx_mute(ac_control, adev, mute);
-	mutex_unlock(&audio_path_lock);
-	return 0;
-}
-
-static void do_rx_routing(uint32_t device_id, uint32_t acdb_id)
-{
-	if (device_id == audio_rx_device_id) {
-		if (acdb_id != rx_acdb) {
-			audio_update_acdb(device_id, acdb_id);
-			qdsp6_devchg_notify(ac_control, ADSP_AUDIO_RX_DEVICE, device_id);
-			qdsp6_standby(ac_control);
-			qdsp6_start(ac_control);
-		}
-		return;
-	}
-
-	if (audio_rx_path_refcount > 0) {
-		qdsp6_devchg_notify(ac_control, ADSP_AUDIO_RX_DEVICE, device_id);
-		_audio_rx_path_disable();
-		_audio_rx_clk_reinit(device_id);
-		_audio_rx_path_enable(1, acdb_id);
-	} else {
-		audio_rx_device_id = device_id;
-		audio_rx_path_id = q6_device_to_path(device_id);
-	}
-}
-
-static void do_tx_routing(uint32_t device_id, uint32_t acdb_id)
-{
-	if (device_id == audio_tx_device_id) {
-		if (acdb_id != tx_acdb) {
-			audio_update_acdb(device_id, acdb_id);
-			qdsp6_devchg_notify(ac_control, ADSP_AUDIO_TX_DEVICE, device_id);
-			qdsp6_standby(ac_control);
-			qdsp6_start(ac_control);
-		}
-		return;
-	}
-
-	if (audio_tx_path_refcount > 0) {
-		qdsp6_devchg_notify(ac_control, ADSP_AUDIO_TX_DEVICE, device_id);
-		_audio_tx_path_disable();
-		_audio_tx_clk_reinit(device_id);
-		_audio_tx_path_enable(1, acdb_id);
-	} else {
-		audio_tx_device_id = device_id;
-		audio_tx_path_id = q6_device_to_path(device_id);
-	}
-}
-
-int q6audio_do_routing(uint32_t device_id, uint32_t acdb_id)
-{
-	if (q6audio_init())
-		return 0;
-
-	mutex_lock(&audio_path_lock);
-
-	switch(q6_device_to_dir(device_id)) {
-	case Q6_RX:
-		do_rx_routing(device_id, acdb_id);
-		break;
-	case Q6_TX:
-		do_tx_routing(device_id, acdb_id);
-		break;
-	}
-
-	mutex_unlock(&audio_path_lock);
-	return 0;
-}
-
-int q6audio_set_route(const char *name)
-{
-	uint32_t route;
-	if (!strcmp(name, "speaker")) {
-		route = ADIE_PATH_SPEAKER_STEREO_RX;
-	} else if (!strcmp(name, "headphones")) {
-		route = ADIE_PATH_HEADSET_STEREO_RX;
-	} else if (!strcmp(name, "handset")) {
-		route = ADIE_PATH_HANDSET_RX;
-	} else {
-		return -EINVAL;
-	}
-
-	mutex_lock(&audio_path_lock);
-	if (route == audio_rx_path_id)
-		goto done;
-
-	audio_rx_path_id = route;
-
-	if (audio_rx_path_refcount > 0) {
-		_audio_rx_path_disable();
-		_audio_rx_path_enable(1, 0);
-	}
-	if (audio_tx_path_refcount > 0) {
-		_audio_tx_path_disable();
-		_audio_tx_path_enable(1, 0);
-	}
-done:
-	mutex_unlock(&audio_path_lock);
-	return 0;
-}
-
-struct audio_client *q6audio_open_pcm(uint32_t bufsz, uint32_t rate,
-				      uint32_t channels, uint32_t flags, uint32_t acdb_id)
-{
-	int rc, retry = 5;
-	struct audio_client *ac;
-
-	if (q6audio_init())
-		return 0;
-
-	ac = audio_client_alloc(bufsz);
-	if (!ac)
-		return 0;
-
-	ac->flags = flags;
-
-	mutex_lock(&audio_path_lock);
-
-	if (ac->flags & AUDIO_FLAG_WRITE) {
-		audio_rx_path_refcount++;
-		if (audio_rx_path_refcount == 1) {
-			_audio_rx_clk_enable();
-			audio_update_acdb(audio_rx_device_id, acdb_id);
-			qdsp6_devchg_notify(ac_control, ADSP_AUDIO_RX_DEVICE, audio_rx_device_id);
-			qdsp6_standby(ac_control);
-			qdsp6_start(ac_control);
-		}
-	} else {
-		/* TODO: consider concurrency with voice call */
-		tx_clk_freq = rate;
-		audio_tx_path_refcount++;
-		if (audio_tx_path_refcount == 1) {
-			_audio_tx_clk_enable();
-			_audio_tx_path_enable(0, acdb_id);
-		}
-	}
-
-	for (retry = 5;;retry--) {
-		if (ac->flags & AUDIO_FLAG_WRITE)
-			rc = audio_out_open(ac, bufsz, rate, channels);
-		else
-			rc = audio_in_open(ac, bufsz, rate, channels);
-		if (rc == 0)
-			break;
-		if (retry == 0)
-			BUG();
-		pr_err("q6audio: open pcm error %d, retrying\n", rc);
-		msleep(1);
-	}
-
-	if (ac->flags & AUDIO_FLAG_WRITE) {
-		if (audio_rx_path_refcount == 1) {
-			adie_enable();
-			adie_set_path(adie, audio_rx_path_id, ADIE_PATH_RX);
-			adie_set_path_freq_plan(adie, ADIE_PATH_RX, 48000);
-
-			adie_proceed_to_stage(adie, ADIE_PATH_RX, ADIE_STAGE_DIGITAL_READY);
-			adie_proceed_to_stage(adie, ADIE_PATH_RX, ADIE_STAGE_DIGITAL_ANALOG_READY);
-
-			audio_rx_analog_enable(1);
-		}
-	}
-
-	mutex_unlock(&audio_path_lock);
-
-	for (retry = 5;;retry--) {
-		rc = audio_command(ac, ADSP_AUDIO_IOCTL_CMD_SESSION_START);
-		if (rc == 0)
-			break;
-		if (retry == 0)
-			BUG();
-		pr_err("q6audio: stream start error %d, retrying\n", rc);
-	}
-
-	if (!(ac->flags & AUDIO_FLAG_WRITE)) {
-		ac->buf[0].used = 1;
-		ac->buf[1].used = 1;
-		q6audio_read(ac, &ac->buf[0]);
-		q6audio_read(ac, &ac->buf[1]);
-	}
-
-	audio_prevent_sleep();
-	return ac;
-}
-
-int q6audio_close(struct audio_client *ac)
-{
-	audio_close(ac);
-	if (ac->flags & AUDIO_FLAG_WRITE)
-		audio_rx_path_enable(0, 0);
-	else
-		audio_tx_path_enable(0, 0);
-
-	audio_client_free(ac);
-	audio_allow_sleep();
-	return 0;
-}
-
-struct audio_client *q6voice_open(uint32_t flags, uint32_t acdb_id)
-{
-	struct audio_client *ac;
-
-	if (q6audio_init())
-		return 0;
-
-	ac = audio_client_alloc(0);
-	if (!ac)
-		return 0;
-
-	ac->flags = flags;
-	if (ac->flags & AUDIO_FLAG_WRITE) {
-		audio_rx_path_enable(1, acdb_id);
-		audio_rx_mute(ac_control, ADSP_AUDIO_DEVICE_ID_VOICE, 0);
-	} else {
-		tx_clk_freq = 8000;
-		audio_tx_path_enable(1, acdb_id);
-	}
-
-	return ac;
-}
-
-int q6voice_close(struct audio_client *ac)
-{
-	if (ac->flags & AUDIO_FLAG_WRITE) {
-		audio_rx_mute(ac_control, ADSP_AUDIO_DEVICE_ID_VOICE, 1);
-		audio_rx_path_enable(0, 0);
-	} else
-		audio_tx_path_enable(0, 0);
-
-	audio_client_free(ac);
-	return 0;
-}
-
-struct audio_client *q6audio_open_mp3(uint32_t bufsz, uint32_t rate,
-				      uint32_t channels, uint32_t acdb_id)
-{
-	struct audio_client *ac;
-
-	printk("q6audio_open_mp3()\n");
-
-	if (q6audio_init())
-		return 0;
-
-	ac = audio_client_alloc(bufsz);
-	if (!ac)
-		return 0;
-
-	ac->flags = AUDIO_FLAG_WRITE;
-	audio_rx_path_enable(1, acdb_id);
-
-	audio_mp3_open(ac, bufsz, rate, channels);
-	audio_command(ac, ADSP_AUDIO_IOCTL_CMD_SESSION_START);
-
-	return ac;
-}
-
-int q6audio_mp3_close(struct audio_client *ac)
-{
-	audio_close(ac);
-	audio_rx_path_enable(0, 0);
-	audio_client_free(ac);
-	return 0;
-}
-
-int q6audio_async(struct audio_client *ac)
-{
-	struct adsp_command_hdr rpc;
-	memset(&rpc, 0, sizeof(rpc));
-	rpc.opcode = ADSP_AUDIO_IOCTL_CMD_STREAM_EOS;
-	rpc.response_type = ADSP_AUDIO_RESPONSE_ASYNC;
-	return audio_ioctl(ac, &rpc, sizeof(rpc));
-}
-
-struct audio_client *q6audio_open_aac(uint32_t bufsz, uint32_t rate,
-				      uint32_t flags, void *data, uint32_t acdb_id)
-{
-	struct audio_client *ac;
-
-	TRACE("q6audio_open_aac flags=%d rate=%d\n", flags, rate);
-
-	if (q6audio_init())
-		return 0;
-
-	ac = audio_client_alloc(bufsz);
-	if (!ac)
-		return 0;
-
-	ac->flags = flags;
-	if (ac->flags & AUDIO_FLAG_WRITE)
-		audio_rx_path_enable(1, acdb_id);
-	else {
-		/* TODO: consider concourrency with voice call */
-		tx_clk_freq = rate;
-		audio_tx_path_enable(1, acdb_id);
-	}
-
-	audio_aac_open(ac, bufsz, data);
-	audio_command(ac, ADSP_AUDIO_IOCTL_CMD_SESSION_START);
-
-	if (!(ac->flags & AUDIO_FLAG_WRITE)) {
-		ac->buf[0].used = 1;
-		ac->buf[1].used = 1;
-		q6audio_read(ac, &ac->buf[0]);
-		q6audio_read(ac, &ac->buf[1]);
-	}
-	audio_prevent_sleep();
-	return ac;
-}
-
-int q6audio_aac_close(struct audio_client *ac)
-{
-	audio_close(ac);
-	if (ac->flags & AUDIO_FLAG_WRITE)
-		audio_rx_path_enable(0, 0);
-	else
-		audio_tx_path_enable(0, 0);
-
-	audio_client_free(ac);
-	audio_allow_sleep();
-	return 0;
-}
-
-struct audio_client *q6fm_open(void)
-{
-	struct audio_client *ac;
-
-	printk("q6fm_open()\n");
-
-	if (q6audio_init())
-		return 0;
-
-	if (audio_rx_device_id != ADSP_AUDIO_DEVICE_ID_HEADSET_SPKR_STEREO &&
-	    audio_rx_device_id != ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO)
-		return 0;
-
-	ac = audio_client_alloc(0);
-	if (!ac)
-		return 0;
-
-	ac->flags = AUDIO_FLAG_WRITE;
-	audio_rx_path_enable(1, 0);
-	enable_aux_loopback(1);
-
-	return ac;
-}
-
-int q6fm_close(struct audio_client *ac)
-{
-	audio_rx_path_enable(0, 0);
-	enable_aux_loopback(0);
-	audio_client_free(ac);
-	return 0;
-}
-
-struct audio_client *q6audio_open_qcelp(uint32_t bufsz, uint32_t rate,
-				      void *data, uint32_t acdb_id)
-{
-	struct audio_client *ac;
-
-	if (q6audio_init())
-		return 0;
-
-	ac = audio_client_alloc(bufsz);
-	if (!ac)
-		return 0;
-
-	ac->flags = AUDIO_FLAG_READ;
-	tx_clk_freq = rate;
-	audio_tx_path_enable(1, acdb_id);
-
-	audio_qcelp_open(ac, bufsz, data);
-	audio_command(ac, ADSP_AUDIO_IOCTL_CMD_SESSION_START);
-
-	ac->buf[0].used = 1;
-	ac->buf[1].used = 1;
-	q6audio_read(ac, &ac->buf[0]);
-	q6audio_read(ac, &ac->buf[1]);
-
-	audio_prevent_sleep();
-	return ac;
-}
-
-int q6audio_qcelp_close(struct audio_client *ac)
-{
-	audio_close(ac);
-	audio_tx_path_enable(0, 0);
-	audio_client_free(ac);
-	audio_allow_sleep();
-	return 0;
-}
-
diff --git a/arch/arm/mach-msm/qdsp6/q6audio_devices.h b/arch/arm/mach-msm/qdsp6/q6audio_devices.h
deleted file mode 100644
index d4d30b5..0000000
--- a/arch/arm/mach-msm/qdsp6/q6audio_devices.h
+++ /dev/null
@@ -1,265 +0,0 @@
-/* arch/arm/mach-msm/qdsp6/q6audio_devices.h
- *
- * Copyright (C) 2009 Google, Inc.
- * Author: Brian Swetland <swetland@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-struct q6_device_info {
-	uint32_t id;
-	uint32_t cad_id;
-	uint32_t path;
-	uint32_t rate;
-	uint8_t dir;
-	uint8_t codec;
-	uint8_t hw;
-};
-
-#define Q6_ICODEC_RX		0
-#define Q6_ICODEC_TX		1
-#define Q6_ECODEC_RX		2
-#define Q6_ECODEC_TX		3
-#define Q6_SDAC_RX		6
-#define Q6_SDAC_TX		7
-#define Q6_CODEC_NONE		255
-
-#define Q6_TX		1
-#define Q6_RX		2
-#define Q6_TX_RX	3
-
-#define CAD_HW_DEVICE_ID_HANDSET_MIC		0x01
-#define CAD_HW_DEVICE_ID_HANDSET_SPKR		0x02
-#define CAD_HW_DEVICE_ID_HEADSET_MIC		0x03
-#define CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO	0x04
-#define CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO	0x05
-#define CAD_HW_DEVICE_ID_SPKR_PHONE_MIC		0x06
-#define CAD_HW_DEVICE_ID_SPKR_PHONE_MONO	0x07
-#define CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO	0x08
-#define CAD_HW_DEVICE_ID_BT_SCO_MIC		0x09
-#define CAD_HW_DEVICE_ID_BT_SCO_SPKR		0x0A
-#define CAD_HW_DEVICE_ID_BT_A2DP_SPKR		0x0B
-#define CAD_HW_DEVICE_ID_TTY_HEADSET_MIC	0x0C
-#define CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR	0x0D
-
-#define CAD_HW_DEVICE_ID_DEFAULT_TX		0x0E
-#define CAD_HW_DEVICE_ID_DEFAULT_RX		0x0F
-
-/* Logical Device to indicate A2DP routing */
-#define CAD_HW_DEVICE_ID_BT_A2DP_TX             0x10
-#define CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_MONO_RX		0x11
-#define CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_STEREO_RX	0x12
-#define CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX	0x13
-#define CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_STEREO_RX	0x14
-
-#define CAD_HW_DEVICE_ID_VOICE			0x15
-
-#define CAD_HW_DEVICE_ID_I2S_RX                 0x20
-#define CAD_HW_DEVICE_ID_I2S_TX                 0x21
-
-/* AUXPGA */
-#define CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO_LB 0x22
-#define CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO_LB   0x23
-#define CAD_HW_DEVICE_ID_SPEAKER_SPKR_STEREO_LB 0x24
-#define CAD_HW_DEVICE_ID_SPEAKER_SPKR_MONO_LB   0x25
-
-#define CAD_HW_DEVICE_ID_NULL_RX		0x2A
-
-#define CAD_HW_DEVICE_ID_MAX_NUM                0x2F
-
-#define CAD_HW_DEVICE_ID_INVALID                0xFF
-
-#define CAD_RX_DEVICE  0x00
-#define CAD_TX_DEVICE  0x01
-
-static struct q6_device_info q6_audio_devices[] = {
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_HANDSET_SPKR,
-		.cad_id	= CAD_HW_DEVICE_ID_HANDSET_SPKR,
-		.path	= ADIE_PATH_HANDSET_RX,
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ICODEC_RX,
-		.hw	= Q6_HW_HANDSET,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_HEADSET_SPKR_MONO,
-		.cad_id	= CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO,
-		.path	= ADIE_PATH_HEADSET_MONO_RX,
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ICODEC_RX,
-		.hw	= Q6_HW_HEADSET,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_HEADSET_SPKR_STEREO,
-		.cad_id	= CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO,
-		.path	= ADIE_PATH_HEADSET_STEREO_RX,
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ICODEC_RX,
-		.hw	= Q6_HW_HEADSET,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO,
-		.cad_id	= CAD_HW_DEVICE_ID_SPKR_PHONE_MONO,
-		.path	= ADIE_PATH_SPEAKER_RX,
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ICODEC_RX,
-		.hw	= Q6_HW_SPEAKER,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO,
-		.cad_id	= CAD_HW_DEVICE_ID_SPKR_PHONE_STEREO,
-		.path	= ADIE_PATH_SPEAKER_STEREO_RX,
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ICODEC_RX,
-		.hw	= Q6_HW_SPEAKER,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO_W_MONO_HEADSET,
-		.cad_id	= CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_MONO_RX,
-		.path	= ADIE_PATH_SPKR_MONO_HDPH_MONO_RX,
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ICODEC_RX,
-		.hw	= Q6_HW_SPEAKER,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MONO_W_STEREO_HEADSET,
-		.cad_id	= CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX,
-		.path	= ADIE_PATH_SPKR_MONO_HDPH_STEREO_RX,
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ICODEC_RX,
-		.hw	= Q6_HW_SPEAKER,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO_W_MONO_HEADSET,
-		.cad_id	= CAD_HW_DEVICE_ID_HEADSET_MONO_PLUS_SPKR_STEREO_RX,
-		.path	= ADIE_PATH_SPKR_STEREO_HDPH_MONO_RX,
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ICODEC_RX,
-		.hw	= Q6_HW_SPEAKER,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_STEREO_W_STEREO_HEADSET,
-		.cad_id	= CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_STEREO_RX,
-		.path	= ADIE_PATH_SPKR_STEREO_HDPH_STEREO_RX,
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ICODEC_RX,
-		.hw	= Q6_HW_SPEAKER,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_TTY_HEADSET_SPKR,
-		.cad_id	= CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR,
-		.path	= ADIE_PATH_TTY_HEADSET_RX,
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ICODEC_RX,
-		.hw	= Q6_HW_TTY,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_HANDSET_MIC,
-		.cad_id	= CAD_HW_DEVICE_ID_HANDSET_MIC,
-		.path	= ADIE_PATH_HANDSET_TX,
-		.rate   = 8000,
-		.dir	= Q6_TX,
-		.codec	= Q6_ICODEC_TX,
-		.hw	= Q6_HW_HANDSET,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_HEADSET_MIC,
-		.cad_id	= CAD_HW_DEVICE_ID_HEADSET_MIC,
-		.path	= ADIE_PATH_HEADSET_MONO_TX,
-		.rate   = 8000,
-		.dir	= Q6_TX,
-		.codec	= Q6_ICODEC_TX,
-		.hw	= Q6_HW_HEADSET,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_SPKR_PHONE_MIC,
-		.cad_id	= CAD_HW_DEVICE_ID_SPKR_PHONE_MIC,
-		.path	= ADIE_PATH_SPEAKER_TX,
-		.rate   = 8000,
-		.dir	= Q6_TX,
-		.codec	= Q6_ICODEC_TX,
-		.hw	= Q6_HW_SPEAKER,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_TTY_HEADSET_MIC,
-		.cad_id	= CAD_HW_DEVICE_ID_TTY_HEADSET_MIC,
-		.path	= ADIE_PATH_TTY_HEADSET_TX,
-		.rate   = 8000,
-		.dir	= Q6_TX,
-		.codec	= Q6_ICODEC_TX,
-		.hw	= Q6_HW_HEADSET,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_BT_SCO_SPKR,
-		.cad_id	= CAD_HW_DEVICE_ID_BT_SCO_SPKR,
-		.path	= 0, /* XXX */
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ECODEC_RX,
-		.hw	= Q6_HW_BT_SCO,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_BT_A2DP_SPKR,
-		.cad_id	= CAD_HW_DEVICE_ID_BT_A2DP_SPKR,
-		.path	= 0, /* XXX */
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_ECODEC_RX,
-		.hw	= Q6_HW_BT_A2DP,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_BT_SCO_MIC,
-		.cad_id	= CAD_HW_DEVICE_ID_BT_SCO_MIC,
-		.path	= 0, /* XXX */
-		.rate   = 8000,
-		.dir	= Q6_TX,
-		.codec	= Q6_ECODEC_TX,
-		.hw	= Q6_HW_BT_SCO,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_I2S_SPKR,
-		.cad_id	= CAD_HW_DEVICE_ID_I2S_RX,
-		.path	= 0, /* XXX */
-		.rate   = 48000,
-		.dir	= Q6_RX,
-		.codec	= Q6_SDAC_RX,
-		.hw	= Q6_HW_SPEAKER,
-	},
-	{
-		.id	= ADSP_AUDIO_DEVICE_ID_I2S_MIC,
-		.cad_id	= CAD_HW_DEVICE_ID_I2S_TX,
-		.path	= 0, /* XXX */
-		.rate   = 16000,
-		.dir	= Q6_TX,
-		.codec	= Q6_SDAC_TX,
-		.hw	= Q6_HW_SPEAKER,
-	},
-	{
-		.id	= 0,
-		.cad_id	= 0,
-		.path	= 0,
-		.rate   = 8000,
-		.dir	= 0,
-		.codec	= Q6_CODEC_NONE,
-		.hw	= 0,
-	},
-};
-
diff --git a/arch/arm/mach-msm/qdsp6/qcelp_in.c b/arch/arm/mach-msm/qdsp6/qcelp_in.c
deleted file mode 100644
index e584318..0000000
--- a/arch/arm/mach-msm/qdsp6/qcelp_in.c
+++ /dev/null
@@ -1,212 +0,0 @@
-/* arch/arm/mach-msm/qdsp6/qcelp_in.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Copyright (C) 2009 HTC Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
-*/
-
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/miscdevice.h>
-#include <linux/mutex.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/uaccess.h>
-#include <linux/msm_audio.h>
-#include <mach/msm_qdsp6_audio.h>
-#include <mach/msm_audio_qcp.h>
-
-#define BUFSZ (734)
-#define DMASZ (BUFSZ * 2)
-
-#if 0
-#define TRACE(x...) pr_info("Q6: "x)
-#else
-#define TRACE(x...) do{}while(0)
-#endif
-
-static DEFINE_MUTEX(qcelp_in_lock);
-static int qcelp_in_opened = 0;
-static struct msm_audio_qcelp_config *qf;
-
-void audio_client_dump(struct audio_client *ac);
-
-static long qcelp_in_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	int rc = 0;
-
-	switch (cmd) {
-	case AUDIO_SET_VOLUME:
-		break;
-	case AUDIO_GET_STATS: {
-		struct msm_audio_stats stats;
-		memset(&stats, 0, sizeof(stats));
-		if (copy_to_user((void*) arg, &stats, sizeof(stats)))
-			return -EFAULT;
-		return 0;
-	}
-	case AUDIO_START: {
-		uint32_t acdb_id;
-		rc = 0;
-
-		if (arg == 0) {
-			acdb_id = 0;
-		} else if (copy_from_user(&acdb_id, (void*) arg, sizeof(acdb_id))) {
-			rc = -EFAULT;
-			break;
-		}
-
-		mutex_lock(&qcelp_in_lock);
-		if (file->private_data) {
-			rc = -EBUSY;
-		} else {
-			file->private_data = q6audio_open_qcelp(
-				BUFSZ, 8000, qf, acdb_id);
-			if (!file->private_data)
-				rc = -ENOMEM;
-		}
-		mutex_unlock(&qcelp_in_lock);
-		break;
-	}
-	case AUDIO_STOP:
-		break;
-	case AUDIO_FLUSH:
-		break;
-	case AUDIO_GET_CONFIG:
-		if (copy_to_user((void *)arg, qf,
-				sizeof(struct msm_audio_qcelp_config)))
-			return -EFAULT;
-		break;
-	case AUDIO_SET_CONFIG:
-		if (copy_from_user(qf, (void *)arg,
-				sizeof(struct msm_audio_qcelp_config)))
-			return -EFAULT;
-		if (qf->min_bit_rate > 4 || qf->min_bit_rate < 1) {
-			pr_err("invalid min bitrate\n");
-			return -EINVAL;
-		}
-		if (qf->max_bit_rate > 4 || qf->max_bit_rate < 1) {
-			pr_err("invalid max bitrate\n");
-			return -EINVAL;
-		}
-		if (qf->cdma_rate > CDMA_RATE_ERASURE ||
-			qf->cdma_rate < CDMA_RATE_BLANK) {
-			pr_err("invalid qcelp cdma rate\n");
-			return -EINVAL;
-		}
-		break;
-	default:
-		rc = -EINVAL;
-	}
-	return rc;
-}
-
-static int qcelp_in_open(struct inode *inode, struct file *file)
-{
-	int rc;
-
-	pr_info("qcelp_in: open\n");
-	 mutex_lock(&qcelp_in_lock);
-	 if (qcelp_in_opened) {
-		pr_err("qcelp_in: busy\n");
-		rc = -EBUSY;
-	 } else {
-		qf = kzalloc(sizeof(*qf), GFP_KERNEL);
-		memset(qf, 0, sizeof(struct msm_audio_qcelp_config));
-		qf->channels = 1;
-		qf->cdma_rate = 0x04; /* CDMA_RATE_FULL */
-		qf->min_bit_rate = 1;
-		qf->max_bit_rate = 4;
-		qcelp_in_opened = 1;
-		rc = 0;
-	 }
-	 mutex_unlock(&qcelp_in_lock);
-	 return rc;
-}
-
-static ssize_t qcelp_in_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
-{
-	 struct audio_client *ac;
-	 struct audio_buffer *ab;
-	 const char __user *start = buf;
-	 int xfer, res = 0;
-
-	 mutex_lock(&qcelp_in_lock);
-	 ac = file->private_data;
-	 if (!ac) {
-		res = -ENODEV;
-		pr_err("qcelp_in_read ac NULL\n");
-		goto fail;
-	 }
-	 while (count > 0) {
-		ab = ac->buf + ac->cpu_buf;
-		TRACE("qcelp_in_read wait count=%d ab=%d ac->buf=%d cpu_buf=%d ac->buf[1]=%d\n",
-		      count, ab, ac->buf, ac->cpu_buf, &(ac->buf[1]));
-		if (ab->used)
-			wait_event(ac->wait, (ab->used == 0));
-		TRACE(" qcelp_in_read event arrive ab->size=%d\n", ab->size);
-		xfer = count;
-		if (xfer > ab->size)
-			xfer = ab->size;
-
-		if (copy_to_user(buf, ab->data, xfer)) {
-			res = -EFAULT;
-			pr_err("Tomdbg copy to user failed \n");
-			goto fail;
-		}
-		TRACE("qcelp_in read buf = %d,xfer = %d,cnt = %d\n", buf, xfer, count);
-
-		buf += xfer;
-		count -= xfer;
-
-		ab->used = 1;
-		q6audio_read(ac, ab);
-		ac->cpu_buf ^= 1;
-	 }
-fail:
-	 res = buf - start;
-	 mutex_unlock(&qcelp_in_lock);
-	 return res;
-}
-
-static int qcelp_in_release(struct inode *inode, struct file *file)
-{
-	 int rc = 0;
-	 pr_info("qcelp_in: release\n");
-	 mutex_lock(&qcelp_in_lock);
-	 if (file->private_data)
-		rc = q6audio_close(file->private_data);
-	 kfree(qf);
-	 qcelp_in_opened = 0;
-	 mutex_unlock(&qcelp_in_lock);
-	 return rc;
-}
-
-static struct file_operations qcelp_in_fops = {
-	.owner	  = THIS_MODULE,
-	.open	  = qcelp_in_open,
-	.read	  = qcelp_in_read,
-	.release  = qcelp_in_release,
-	.unlocked_ioctl	= qcelp_in_ioctl,
-};
-
-struct miscdevice qcelp_in_misc = {
-	 .minor = MISC_DYNAMIC_MINOR,
-	 .name = "msm_qcelp_in",
-	 .fops = &qcelp_in_fops,
-};
-
-static int __init qcelp_in_init(void) {
-	 return misc_register(&qcelp_in_misc);
-}
-
-device_initcall(qcelp_in_init);
diff --git a/arch/arm/mach-msm/qdsp6/routing.c b/arch/arm/mach-msm/qdsp6/routing.c
deleted file mode 100644
index a851896..0000000
--- a/arch/arm/mach-msm/qdsp6/routing.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/* arch/arm/mach-msm/qdsp6/routing.c
- *
- * Copyright (C) 2009 Google, Inc.
- * Author: Brian Swetland <swetland@google.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/miscdevice.h>
-#include <linux/uaccess.h>
-
-extern int q6audio_set_route(const char *name);
-
-static int q6_open(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static ssize_t q6_write(struct file *file, const char __user *buf,
-			size_t count, loff_t *pos)
-{
-	char cmd[32];
-
-	if (count >= sizeof(cmd))
-		return -EINVAL;
-	if (copy_from_user(cmd, buf, count))
-		return -EFAULT;
-	cmd[count] = 0;
-
-	if ((count > 1) && (cmd[count-1] == '\n'))
-		cmd[count-1] = 0;
-
-	q6audio_set_route(cmd);
-
-	return count;
-}
-
-static int q6_release(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static struct file_operations q6_fops = {
-	.owner		= THIS_MODULE,
-	.open		= q6_open,
-	.write		= q6_write,
-	.release	= q6_release,
-};
-
-static struct miscdevice q6_misc = {
-	.minor	= MISC_DYNAMIC_MINOR,
-	.name	= "msm_audio_route",
-	.fops	= &q6_fops,
-};
-
-
-static int __init q6_init(void) {
-	return misc_register(&q6_misc);
-}
-
-device_initcall(q6_init);
-- 
1.5.4.3

